# 1 "CG_stdexec.hpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 463 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "CG_stdexec.hpp" 2
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 1 3
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/requires_hosted.h" 1 3
# 31 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/requires_hosted.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++config.h" 1 3
# 306 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++config.h" 3
namespace std {
typedef long unsigned int size_t;
typedef long int ptrdiff_t;

typedef decltype(nullptr) nullptr_t;

#pragma GCC visibility push(default)

extern "C++" __attribute__((__noreturn__, __always_inline__)) inline void
__terminate() noexcept {
  void terminate() noexcept __attribute__((__noreturn__));
  terminate();
}
#pragma GCC visibility pop
} // namespace std
# 339 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++config.h" 3
namespace std {
inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {}
} // namespace std
namespace __gnu_cxx {
inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {}
} // namespace __gnu_cxx
# 532 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++config.h" 3
namespace std {
#pragma GCC visibility push(default)

constexpr inline bool __is_constant_evaluated() noexcept {

  return __builtin_is_constant_evaluated();
}
#pragma GCC visibility pop
} // namespace std
# 679 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++config.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/os_defines.h" 1 3
# 39 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 394 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 395 "/usr/include/features.h" 2 3 4
# 480 "/usr/include/features.h" 3 4
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 481 "/usr/include/features.h" 2 3 4
# 502 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 576 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 577 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 578 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 503 "/usr/include/features.h" 2 3 4
# 526 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 527 "/usr/include/features.h" 2 3 4
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/os_defines.h" 2 3
# 680 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++config.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h" 1 3
# 683 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++config.h" 2 3
# 882 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++config.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/pstl_config.h" 1 3
# 883 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++config.h" 2 3
# 32 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/requires_hosted.h" 2 3
# 39 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 1 3
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ios" 1 3
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ios" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/iosfwd" 1 3
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/iosfwd" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stringfwd.h" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stringfwd.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memoryfwd.h" 1 3
# 47 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memoryfwd.h" 3

namespace std __attribute__((__visibility__("default"))) {
# 64 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memoryfwd.h" 3
  template <typename> class allocator;

  template <> class allocator<void>;

  template <typename, typename> struct uses_allocator;

  template <typename> struct allocator_traits;

} // namespace std
# 41 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stringfwd.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 52 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stringfwd.h" 3
  template <class _CharT> struct char_traits;

  template <> struct char_traits<char>;

  template <> struct char_traits<wchar_t>;

  template <> struct char_traits<char8_t>;

  template <> struct char_traits<char16_t>;
  template <> struct char_traits<char32_t>;

  namespace __cxx11 {

  template <typename _CharT, typename _Traits = char_traits<_CharT>,
            typename _Alloc = allocator<_CharT>>
  class basic_string;

  }

  typedef basic_string<char> string;

  typedef basic_string<wchar_t> wstring;

  typedef basic_string<char8_t> u8string;

  typedef basic_string<char16_t> u16string;

  typedef basic_string<char32_t> u32string;

} // namespace std
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/iosfwd" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/postypes.h" 1 3
# 39 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/postypes.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cwchar" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cwchar" 3

# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 119 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 31 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 18 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 3 4
typedef long unsigned int size_t;
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 87 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_wchar_t.h" 1 3 4
# 88 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4

# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3 4
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 36 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 1 3 4
# 55 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stdarg___gnuc_va_list.h" 1 3 4
# 12 "/usr/lib/llvm-18/lib/clang/18/include/__stdarg___gnuc_va_list.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 56 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 2 3 4
# 39 "/usr/include/wchar.h" 2 3 4

typedef __gnuc_va_list va_list;

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 52 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 53 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 1 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct {
  int __count;
  union {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 2 3 4

typedef __mbstate_t mbstate_t;
# 54 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4

struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 55 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4

struct _IO_FILE;

typedef struct _IO_FILE FILE;
# 58 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct {

  struct __locale_data *__locales[13];

  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;

  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 61 "/usr/include/wchar.h" 2 3 4
# 90 "/usr/include/wchar.h" 3 4
extern "C" {

struct tm;

extern wchar_t *wcscpy(wchar_t *__restrict __dest,
                       const wchar_t *__restrict __src) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern wchar_t *wcsncpy(wchar_t *__restrict __dest,
                        const wchar_t *__restrict __src,
                        size_t __n) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern size_t wcslcpy(wchar_t *__restrict __dest,
                      const wchar_t *__restrict __src,
                      size_t __n) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern size_t wcslcat(wchar_t *__restrict __dest,
                      const wchar_t *__restrict __src,
                      size_t __n) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern wchar_t *wcscat(wchar_t *__restrict __dest,
                       const wchar_t *__restrict __src) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern wchar_t *wcsncat(wchar_t *__restrict __dest,
                        const wchar_t *__restrict __src,
                        size_t __n) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int wcscmp(const wchar_t *__s1, const wchar_t *__s2) noexcept(true)
    __attribute__((__pure__)) __attribute__((__nonnull__(1, 2)));

extern int wcsncmp(const wchar_t *__s1, const wchar_t *__s2,
                   size_t __n) noexcept(true) __attribute__((__pure__))
__attribute__((__nonnull__(1, 2)));

extern int wcscasecmp(const wchar_t *__s1, const wchar_t *__s2) noexcept(true);

extern int wcsncasecmp(const wchar_t *__s1, const wchar_t *__s2,
                       size_t __n) noexcept(true);

extern int wcscasecmp_l(const wchar_t *__s1, const wchar_t *__s2,
                        locale_t __loc) noexcept(true);

extern int wcsncasecmp_l(const wchar_t *__s1, const wchar_t *__s2, size_t __n,
                         locale_t __loc) noexcept(true);

extern int wcscoll(const wchar_t *__s1, const wchar_t *__s2) noexcept(true);

extern size_t wcsxfrm(wchar_t *__restrict __s1, const wchar_t *__restrict __s2,
                      size_t __n) noexcept(true);

extern int wcscoll_l(const wchar_t *__s1, const wchar_t *__s2,
                     locale_t __loc) noexcept(true);

extern size_t wcsxfrm_l(wchar_t *__s1, const wchar_t *__s2, size_t __n,
                        locale_t __loc) noexcept(true);

extern wchar_t *wcsdup(const wchar_t *__s) noexcept(true)
    __attribute__((__malloc__));
# 189 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschr(const wchar_t *__wcs, wchar_t __wc) noexcept(true)
    __attribute__((__pure__));
# 199 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr(const wchar_t *__wcs, wchar_t __wc) noexcept(true)
    __attribute__((__pure__));

extern wchar_t *wcschrnul(const wchar_t *__s, wchar_t __wc) noexcept(true)
    __attribute__((__pure__));

extern size_t wcscspn(const wchar_t *__wcs,
                      const wchar_t *__reject) noexcept(true)
    __attribute__((__pure__));

extern size_t wcsspn(const wchar_t *__wcs,
                     const wchar_t *__accept) noexcept(true)
    __attribute__((__pure__));
# 226 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk(const wchar_t *__wcs,
                        const wchar_t *__accept) noexcept(true)
    __attribute__((__pure__));
# 237 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr(const wchar_t *__haystack,
                       const wchar_t *__needle) noexcept(true)
    __attribute__((__pure__));

extern wchar_t *wcstok(wchar_t *__restrict __s,
                       const wchar_t *__restrict __delim,
                       wchar_t **__restrict __ptr) noexcept(true);

extern size_t wcslen(const wchar_t *__s) noexcept(true)
    __attribute__((__pure__));
# 258 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs(const wchar_t *__haystack,
                       const wchar_t *__needle) noexcept(true)
    __attribute__((__pure__));

extern size_t wcsnlen(const wchar_t *__s, size_t __maxlen) noexcept(true)
    __attribute__((__pure__));
# 278 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr(const wchar_t *__s, wchar_t __c,
                        size_t __n) noexcept(true) __attribute__((__pure__));

extern int wmemcmp(const wchar_t *__s1, const wchar_t *__s2,
                   size_t __n) noexcept(true) __attribute__((__pure__));

extern wchar_t *wmemcpy(wchar_t *__restrict __s1,
                        const wchar_t *__restrict __s2,
                        size_t __n) noexcept(true);

extern wchar_t *wmemmove(wchar_t *__s1, const wchar_t *__s2,
                         size_t __n) noexcept(true);

extern wchar_t *wmemset(wchar_t *__s, wchar_t __c, size_t __n) noexcept(true);

extern wchar_t *wmempcpy(wchar_t *__restrict __s1,
                         const wchar_t *__restrict __s2,
                         size_t __n) noexcept(true);

extern wint_t btowc(int __c) noexcept(true);

extern int wctob(wint_t __c) noexcept(true);

extern int mbsinit(const mbstate_t *__ps) noexcept(true)
    __attribute__((__pure__));

extern size_t mbrtowc(wchar_t *__restrict __pwc, const char *__restrict __s,
                      size_t __n, mbstate_t *__restrict __p) noexcept(true);

extern size_t wcrtomb(char *__restrict __s, wchar_t __wc,
                      mbstate_t *__restrict __ps) noexcept(true);

extern size_t __mbrlen(const char *__restrict __s, size_t __n,
                       mbstate_t *__restrict __ps) noexcept(true);
extern size_t mbrlen(const char *__restrict __s, size_t __n,
                     mbstate_t *__restrict __ps) noexcept(true);
# 362 "/usr/include/wchar.h" 3 4
extern size_t mbsrtowcs(wchar_t *__restrict __dst,
                        const char **__restrict __src, size_t __len,
                        mbstate_t *__restrict __ps) noexcept(true);

extern size_t wcsrtombs(char *__restrict __dst,
                        const wchar_t **__restrict __src, size_t __len,
                        mbstate_t *__restrict __ps) noexcept(true);

extern size_t mbsnrtowcs(wchar_t *__restrict __dst,
                         const char **__restrict __src, size_t __nmc,
                         size_t __len,
                         mbstate_t *__restrict __ps) noexcept(true);

extern size_t wcsnrtombs(char *__restrict __dst,
                         const wchar_t **__restrict __src, size_t __nwc,
                         size_t __len,
                         mbstate_t *__restrict __ps) noexcept(true);

extern int wcwidth(wchar_t __c) noexcept(true);

extern int wcswidth(const wchar_t *__s, size_t __n) noexcept(true);

extern double wcstod(const wchar_t *__restrict __nptr,
                     wchar_t **__restrict __endptr) noexcept(true);

extern float wcstof(const wchar_t *__restrict __nptr,
                    wchar_t **__restrict __endptr) noexcept(true);
extern long double wcstold(const wchar_t *__restrict __nptr,
                           wchar_t **__restrict __endptr) noexcept(true);
# 422 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32(const wchar_t *__restrict __nptr,
                         wchar_t **__restrict __endptr) noexcept(true);

extern _Float64 wcstof64(const wchar_t *__restrict __nptr,
                         wchar_t **__restrict __endptr) noexcept(true);
# 437 "/usr/include/wchar.h" 3 4
extern _Float32x wcstof32x(const wchar_t *__restrict __nptr,
                           wchar_t **__restrict __endptr) noexcept(true);

extern _Float64x wcstof64x(const wchar_t *__restrict __nptr,
                           wchar_t **__restrict __endptr) noexcept(true);
# 455 "/usr/include/wchar.h" 3 4
extern long int wcstol(const wchar_t *__restrict __nptr,
                       wchar_t **__restrict __endptr,
                       int __base) noexcept(true);

extern unsigned long int wcstoul(const wchar_t *__restrict __nptr,
                                 wchar_t **__restrict __endptr,
                                 int __base) noexcept(true);

__extension__ extern long long int wcstoll(const wchar_t *__restrict __nptr,
                                           wchar_t **__restrict __endptr,
                                           int __base) noexcept(true);

__extension__ extern unsigned long long int
wcstoull(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr,
         int __base) noexcept(true);

__extension__ extern long long int wcstoq(const wchar_t *__restrict __nptr,
                                          wchar_t **__restrict __endptr,
                                          int __base) noexcept(true);

__extension__ extern unsigned long long int
wcstouq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr,
        int __base) noexcept(true);

extern long int wcstol(const wchar_t *__restrict __nptr,
                       wchar_t **__restrict __endptr,
                       int __base) noexcept(true) __asm__(""
                                                          "__isoc23_wcstol");

extern unsigned long int
wcstoul(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr,
        int __base) noexcept(true) __asm__(""
                                           "__isoc23_wcstoul");

__extension__ extern long long int
wcstoll(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr,
        int __base) noexcept(true) __asm__(""
                                           "__isoc23_wcstoll");

__extension__ extern unsigned long long int
wcstoull(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr,
         int __base) noexcept(true) __asm__(""
                                            "__isoc23_wcstoull");

__extension__ extern long long int
wcstoq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr,
       int __base) noexcept(true) __asm__(""
                                          "__isoc23_wcstoll");

__extension__ extern unsigned long long int
wcstouq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr,
        int __base) noexcept(true) __asm__(""
                                           "__isoc23_wcstoull");
# 561 "/usr/include/wchar.h" 3 4
extern long int wcstol_l(const wchar_t *__restrict __nptr,
                         wchar_t **__restrict __endptr, int __base,
                         locale_t __loc) noexcept(true);

extern unsigned long int wcstoul_l(const wchar_t *__restrict __nptr,
                                   wchar_t **__restrict __endptr, int __base,
                                   locale_t __loc) noexcept(true);

__extension__ extern long long int wcstoll_l(const wchar_t *__restrict __nptr,
                                             wchar_t **__restrict __endptr,
                                             int __base,
                                             locale_t __loc) noexcept(true);

__extension__ extern unsigned long long int
wcstoull_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr,
           int __base, locale_t __loc) noexcept(true);

extern long int
wcstol_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr,
         int __base,
         locale_t __loc) noexcept(true) __asm__(""
                                                "__isoc23_wcstol_l");

extern unsigned long int
wcstoul_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr,
          int __base,
          locale_t __loc) noexcept(true) __asm__(""
                                                 "__isoc23_wcstoul_l");

__extension__ extern long long int
wcstoll_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr,
          int __base,
          locale_t __loc) noexcept(true) __asm__(""
                                                 "__isoc23_wcstoll_l");

__extension__ extern unsigned long long int
wcstoull_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr,
           int __base,
           locale_t __loc) noexcept(true) __asm__(""
                                                  "__isoc23_wcstoull_l");
# 630 "/usr/include/wchar.h" 3 4
extern double wcstod_l(const wchar_t *__restrict __nptr,
                       wchar_t **__restrict __endptr,
                       locale_t __loc) noexcept(true);

extern float wcstof_l(const wchar_t *__restrict __nptr,
                      wchar_t **__restrict __endptr,
                      locale_t __loc) noexcept(true);

extern long double wcstold_l(const wchar_t *__restrict __nptr,
                             wchar_t **__restrict __endptr,
                             locale_t __loc) noexcept(true);
# 649 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32_l(const wchar_t *__restrict __nptr,
                           wchar_t **__restrict __endptr,
                           locale_t __loc) noexcept(true);

extern _Float64 wcstof64_l(const wchar_t *__restrict __nptr,
                           wchar_t **__restrict __endptr,
                           locale_t __loc) noexcept(true);
# 667 "/usr/include/wchar.h" 3 4
extern _Float32x wcstof32x_l(const wchar_t *__restrict __nptr,
                             wchar_t **__restrict __endptr,
                             locale_t __loc) noexcept(true);

extern _Float64x wcstof64x_l(const wchar_t *__restrict __nptr,
                             wchar_t **__restrict __endptr,
                             locale_t __loc) noexcept(true);
# 689 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy(wchar_t *__restrict __dest,
                       const wchar_t *__restrict __src) noexcept(true);

extern wchar_t *wcpncpy(wchar_t *__restrict __dest,
                        const wchar_t *__restrict __src,
                        size_t __n) noexcept(true);
# 718 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream(wchar_t **__bufloc,
                               size_t *__sizeloc) noexcept(true)
    __attribute__((__malloc__));

extern int fwide(__FILE *__fp, int __mode) noexcept(true);

extern int fwprintf(__FILE *__restrict __stream,
                    const wchar_t *__restrict __format, ...);

extern int wprintf(const wchar_t *__restrict __format, ...);

extern int swprintf(wchar_t *__restrict __s, size_t __n,
                    const wchar_t *__restrict __format, ...) noexcept(true);

extern int vfwprintf(__FILE *__restrict __s, const wchar_t *__restrict __format,
                     __gnuc_va_list __arg);

extern int vwprintf(const wchar_t *__restrict __format, __gnuc_va_list __arg);

extern int vswprintf(wchar_t *__restrict __s, size_t __n,
                     const wchar_t *__restrict __format,
                     __gnuc_va_list __arg) noexcept(true);

extern int fwscanf(__FILE *__restrict __stream,
                   const wchar_t *__restrict __format, ...);

extern int wscanf(const wchar_t *__restrict __format, ...);

extern int swscanf(const wchar_t *__restrict __s,
                   const wchar_t *__restrict __format, ...) noexcept(true);
# 795 "/usr/include/wchar.h" 3 4
extern int fwscanf(__FILE *__restrict __stream,
                   const wchar_t *__restrict __format,
                   ...) __asm__(""
                                "__isoc23_fwscanf")

    ;
extern int wscanf(const wchar_t *__restrict __format,
                  ...) __asm__(""
                               "__isoc23_wscanf")

    ;
extern int swscanf(const wchar_t *__restrict __s,
                   const wchar_t *__restrict __format,
                   ...) noexcept(true) __asm__(""
                                               "__isoc23_swscanf")

    ;
# 851 "/usr/include/wchar.h" 3 4
extern int vfwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format,
                    __gnuc_va_list __arg);

extern int vwscanf(const wchar_t *__restrict __format, __gnuc_va_list __arg);

extern int vswscanf(const wchar_t *__restrict __s,
                    const wchar_t *__restrict __format,
                    __gnuc_va_list __arg) noexcept(true);
# 875 "/usr/include/wchar.h" 3 4
extern int vfwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format,
                    __gnuc_va_list __arg) __asm__(""
                                                  "__isoc23_vfwscanf")

    ;
extern int vwscanf(const wchar_t *__restrict __format,
                   __gnuc_va_list __arg) __asm__(""
                                                 "__isoc23_vwscanf")

    ;
extern int
vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format,
         __gnuc_va_list __arg) noexcept(true) __asm__(""
                                                      "__isoc23_vswscanf")

    ;
# 935 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc(__FILE *__stream);
extern wint_t getwc(__FILE *__stream);

extern wint_t getwchar(void);

extern wint_t fputwc(wchar_t __wc, __FILE *__stream);
extern wint_t putwc(wchar_t __wc, __FILE *__stream);

extern wint_t putwchar(wchar_t __wc);

extern wchar_t *fgetws(wchar_t *__restrict __ws, int __n,
                       __FILE *__restrict __stream);

extern int fputws(const wchar_t *__restrict __ws, __FILE *__restrict __stream);

extern wint_t ungetwc(wint_t __wc, __FILE *__stream);
# 990 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked(__FILE *__stream);
extern wint_t getwchar_unlocked(void);

extern wint_t fgetwc_unlocked(__FILE *__stream);

extern wint_t fputwc_unlocked(wchar_t __wc, __FILE *__stream);
# 1016 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked(wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked(wchar_t __wc);
# 1026 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked(wchar_t *__restrict __ws, int __n,
                                __FILE *__restrict __stream);

extern int fputws_unlocked(const wchar_t *__restrict __ws,
                           __FILE *__restrict __stream);

extern size_t wcsftime(wchar_t *__restrict __s, size_t __maxsize,
                       const wchar_t *__restrict __format,
                       const struct tm *__restrict __tp) noexcept(true);

extern size_t wcsftime_l(wchar_t *__restrict __s, size_t __maxsize,
                         const wchar_t *__restrict __format,
                         const struct tm *__restrict __tp,
                         locale_t __loc) noexcept(true);
# 1073 "/usr/include/wchar.h" 3 4
}
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cwchar" 2 3
# 62 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cwchar" 3
namespace std {
using ::mbstate_t;
}
# 135 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cwchar" 3
extern "C++" {
namespace std __attribute__((__visibility__("default"))) {

  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;

  using ::vswprintf;

  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemchr;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;

  inline wchar_t *wcschr(wchar_t * __p, wchar_t __c) {
    return wcschr(const_cast<const wchar_t *>(__p), __c);
  }

  inline wchar_t *wcspbrk(wchar_t * __s1, const wchar_t *__s2) {
    return wcspbrk(const_cast<const wchar_t *>(__s1), __s2);
  }

  inline wchar_t *wcsrchr(wchar_t * __p, wchar_t __c) {
    return wcsrchr(const_cast<const wchar_t *>(__p), __c);
  }

  inline wchar_t *wcsstr(wchar_t * __s1, const wchar_t *__s2) {
    return wcsstr(const_cast<const wchar_t *>(__s1), __s2);
  }

  inline wchar_t *wmemchr(wchar_t * __p, wchar_t __c, size_t __n) {
    return wmemchr(const_cast<const wchar_t *>(__p), __c, __n);
  }

} // namespace std
}

namespace __gnu_cxx {

using ::wcstold;
# 260 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cwchar" 3
using ::wcstoll;
using ::wcstoull;

} // namespace __gnu_cxx

namespace std {
using ::__gnu_cxx::wcstold;
using ::__gnu_cxx::wcstoll;
using ::__gnu_cxx::wcstoull;
} // namespace std
# 280 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cwchar" 3
namespace std {

using std::wcstof;

using std::vfwscanf;

using std::vswscanf;

using std::vwscanf;

using std::wcstold;
using std::wcstoll;
using std::wcstoull;

} // namespace std
# 41 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/postypes.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 62 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/postypes.h" 3
  typedef long int streamoff;

  typedef ptrdiff_t streamsize;
# 81 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/postypes.h" 3
  template <typename _StateT> class fpos {
  private:
    streamoff _M_off;
    _StateT _M_state;

  public:
    fpos() : _M_off(0), _M_state() {}
# 103 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/postypes.h" 3
    fpos(streamoff __off) : _M_off(__off), _M_state() {}

    fpos(const fpos &) = default;
    fpos &operator=(const fpos &) = default;
    ~fpos() = default;

    operator streamoff() const { return _M_off; }

    void state(_StateT __st) { _M_state = __st; }

    _StateT state() const { return _M_state; }

    fpos &operator+=(streamoff __off) {
      _M_off += __off;
      return *this;
    }

    fpos &operator-=(streamoff __off) {
      _M_off -= __off;
      return *this;
    }

    fpos operator+(streamoff __off) const {
      fpos __pos(*this);
      __pos += __off;
      return __pos;
    }

    fpos operator-(streamoff __off) const {
      fpos __pos(*this);
      __pos -= __off;
      return __pos;
    }

    streamoff operator-(const fpos &__other) const {
      return _M_off - __other._M_off;
    }
  };

  template <typename _StateT>
  inline bool operator==(const fpos<_StateT> &__lhs,
                         const fpos<_StateT> &__rhs) {
    return streamoff(__lhs) == streamoff(__rhs);
  }

  template <typename _StateT>
  inline bool operator!=(const fpos<_StateT> &__lhs,
                         const fpos<_StateT> &__rhs) {
    return streamoff(__lhs) != streamoff(__rhs);
  }

  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;

  typedef fpos<mbstate_t> u8streampos;

  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;

} // namespace std
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/iosfwd" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 76 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/iosfwd" 3
  class ios_base;

  template <typename _CharT, typename _Traits = char_traits<_CharT>>
  class basic_ios;

  template <typename _CharT, typename _Traits = char_traits<_CharT>>
  class basic_streambuf;

  template <typename _CharT, typename _Traits = char_traits<_CharT>>
  class basic_istream;

  template <typename _CharT, typename _Traits = char_traits<_CharT>>
  class basic_ostream;

  template <typename _CharT, typename _Traits = char_traits<_CharT>>
  class basic_iostream;

  namespace __cxx11 {

  template <typename _CharT, typename _Traits = char_traits<_CharT>,
            typename _Alloc = allocator<_CharT>>
  class basic_stringbuf;

  template <typename _CharT, typename _Traits = char_traits<_CharT>,
            typename _Alloc = allocator<_CharT>>
  class basic_istringstream;

  template <typename _CharT, typename _Traits = char_traits<_CharT>,
            typename _Alloc = allocator<_CharT>>
  class basic_ostringstream;

  template <typename _CharT, typename _Traits = char_traits<_CharT>,
            typename _Alloc = allocator<_CharT>>
  class basic_stringstream;

  } // namespace __cxx11

  template <typename _CharT, typename _Traits = char_traits<_CharT>>
  class basic_filebuf;

  template <typename _CharT, typename _Traits = char_traits<_CharT>>
  class basic_ifstream;

  template <typename _CharT, typename _Traits = char_traits<_CharT>>
  class basic_ofstream;

  template <typename _CharT, typename _Traits = char_traits<_CharT>>
  class basic_fstream;

  template <typename _CharT, typename _Traits = char_traits<_CharT>>
  class istreambuf_iterator;

  template <typename _CharT, typename _Traits = char_traits<_CharT>>
  class ostreambuf_iterator;

  typedef basic_ios<char> ios;

  typedef basic_streambuf<char> streambuf;

  typedef basic_istream<char> istream;

  typedef basic_ostream<char> ostream;

  typedef basic_iostream<char> iostream;

  typedef basic_stringbuf<char> stringbuf;

  typedef basic_istringstream<char> istringstream;

  typedef basic_ostringstream<char> ostringstream;

  typedef basic_stringstream<char> stringstream;

  typedef basic_filebuf<char> filebuf;

  typedef basic_ifstream<char> ifstream;

  typedef basic_ofstream<char> ofstream;

  typedef basic_fstream<char> fstream;

  typedef basic_ios<wchar_t> wios;

  typedef basic_streambuf<wchar_t> wstreambuf;

  typedef basic_istream<wchar_t> wistream;

  typedef basic_ostream<wchar_t> wostream;

  typedef basic_iostream<wchar_t> wiostream;

  typedef basic_stringbuf<wchar_t> wstringbuf;

  typedef basic_istringstream<wchar_t> wistringstream;

  typedef basic_ostringstream<wchar_t> wostringstream;

  typedef basic_stringstream<wchar_t> wstringstream;

  typedef basic_filebuf<wchar_t> wfilebuf;

  typedef basic_ifstream<wchar_t> wifstream;

  typedef basic_ofstream<wchar_t> wofstream;

  typedef basic_fstream<wchar_t> wfstream;

  template <typename _CharT, typename _Traits = char_traits<_CharT>,
            typename _Allocator = allocator<_CharT>>
  class basic_syncbuf;
  template <typename _CharT, typename _Traits = char_traits<_CharT>,
            typename _Allocator = allocator<_CharT>>
  class basic_osyncstream;

  using syncbuf = basic_syncbuf<char>;
  using osyncstream = basic_osyncstream<char>;

  using wsyncbuf = basic_syncbuf<wchar_t>;
  using wosyncstream = basic_osyncstream<wchar_t>;
# 256 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/iosfwd" 3
} // namespace std
# 41 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ios" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/exception" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/exception" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception.h" 1 3
# 35 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception.h" 3

extern "C++" {

namespace std __attribute__((__visibility__("default"))) {
# 59 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception.h" 3
  class exception {
  public:
    exception() noexcept {}
    virtual ~exception() noexcept;

    exception(const exception &) = default;
    exception &operator=(const exception &) = default;
    exception(exception &&) = default;
    exception &operator=(exception &&) = default;

    virtual const char *what() const noexcept;
  };

} // namespace std
}
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/exception" 2 3

extern "C++" {

namespace std __attribute__((__visibility__("default"))) {
# 51 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/exception" 3
  class bad_exception : public exception {
  public:
    bad_exception() noexcept {}

    virtual ~bad_exception() noexcept;

    virtual const char *what() const noexcept;
  };

  typedef void (*terminate_handler)();

  terminate_handler set_terminate(terminate_handler) noexcept;

  terminate_handler get_terminate() noexcept;

  void terminate() noexcept __attribute__((__noreturn__));

  typedef void (*__attribute__((__deprecated__)) unexpected_handler)();

  __attribute__((__deprecated__)) unexpected_handler set_unexpected(
      unexpected_handler) noexcept;

  __attribute__((__deprecated__)) unexpected_handler get_unexpected() noexcept;

  __attribute__((__deprecated__)) void unexpected()
      __attribute__((__noreturn__));
# 121 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/exception" 3
  __attribute__((__deprecated__("use '"
                                "std::uncaught_exceptions()"
                                "' instead"))) bool
  uncaught_exception() noexcept __attribute__((__pure__));

  int uncaught_exceptions() noexcept __attribute__((__pure__));

} // namespace std

namespace __gnu_cxx __attribute__((__visibility__("default"))) {
# 156 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/exception" 3
  void __verbose_terminate_handler();

} // namespace __gnu_cxx
}

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception_ptr.h" 1 3
# 35 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception_ptr.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception_defines.h" 1 3
# 36 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception_ptr.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/cxxabi_init_exception.h" 1 3
# 35 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)

# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3
# 72 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_ptrdiff_t.h" 1 3
# 18 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_ptrdiff_t.h" 3
typedef long int ptrdiff_t;
# 73 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3

# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3
# 18 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3
# 87 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_wchar_t.h" 1 3
# 88 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3

# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3

# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_nullptr_t.h" 1 3
# 98 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3
# 107 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_max_align_t.h" 1 3
# 19 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 108 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3

# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_offsetof.h" 1 3
# 113 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3
# 39 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/cxxabi_init_exception.h" 2 3
# 50 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/cxxabi_init_exception.h" 3
namespace std {
class type_info;
}

namespace __cxxabiv1 {
struct __cxa_refcounted_exception;

extern "C" {

void *__cxa_allocate_exception(size_t) noexcept;

void __cxa_free_exception(void *) noexcept;

__cxa_refcounted_exception *
__cxa_init_primary_exception(void *__object, std::type_info *__tinfo,
                             void (*__dest)(void *)) noexcept;
}
} // namespace __cxxabiv1

#pragma GCC visibility pop
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception_ptr.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/typeinfo" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/typeinfo" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hash_bytes.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hash_bytes.h" 3

namespace std {

size_t _Hash_bytes(const void *__ptr, size_t __len, size_t __seed);

size_t _Fnv_hash_bytes(const void *__ptr, size_t __len, size_t __seed);

} // namespace std
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/typeinfo" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1 {
class __class_type_info;
}
# 84 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/typeinfo" 3
namespace std {

class type_info {
public:
  virtual ~type_info();

  const char *name() const noexcept {
    return __name[0] == '*' ? __name + 1 : __name;
  }

  bool before(const type_info &__arg) const noexcept;

  bool operator==(const type_info &__arg) const noexcept;

  size_t hash_code() const noexcept {

    return _Hash_bytes(name(), __builtin_strlen(name()),
                       static_cast<size_t>(0xc70f6907UL));
  }

  virtual bool __is_pointer_p() const;

  virtual bool __is_function_p() const;

  virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
                          unsigned __outer) const;

  virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
                           void **__obj_ptr) const;

protected:
  const char *__name;

  explicit type_info(const char *__n) : __name(__n) {}

private:
  type_info &operator=(const type_info &) = delete;
  type_info(const type_info &) = delete;
# 167 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/typeinfo" 3
};

inline bool type_info::before(const type_info &__arg) const noexcept {

  if (__name[0] != '*' || __arg.__name[0] != '*')
    return __builtin_strcmp(__name, __arg.__name) < 0;
# 187 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/typeinfo" 3
  return __name < __arg.__name;
}

inline bool type_info::operator==(const type_info &__arg) const noexcept {
  if (std::__is_constant_evaluated())
    return this == &__arg;

  if (__name == __arg.__name)
    return true;

  return __name[0] != '*' && __builtin_strcmp(__name, __arg.name()) == 0;
}
# 220 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/typeinfo" 3
class bad_cast : public exception {
public:
  bad_cast() noexcept {}

  virtual ~bad_cast() noexcept;

  virtual const char *what() const noexcept;
};

class bad_typeid : public exception {
public:
  bad_typeid() noexcept {}

  virtual ~bad_typeid() noexcept;

  virtual const char *what() const noexcept;
};
} // namespace std
}

#pragma GCC visibility pop
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception_ptr.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/new" 1 3
# 39 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/new" 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std {

class bad_alloc : public exception {
public:
  bad_alloc() throw() {}

  bad_alloc(const bad_alloc &) = default;
  bad_alloc &operator=(const bad_alloc &) = default;

  virtual ~bad_alloc() throw();

  virtual const char *what() const throw();
};

class bad_array_new_length : public bad_alloc {
public:
  bad_array_new_length() throw() {}

  virtual ~bad_array_new_length() throw();

  virtual const char *what() const throw();
};

enum class align_val_t : size_t {};

struct nothrow_t {

  explicit nothrow_t() = default;
};

extern const nothrow_t nothrow;

typedef void (*new_handler)();

new_handler set_new_handler(new_handler) throw();

new_handler get_new_handler() noexcept;

} // namespace std
# 126 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/new" 3
[[__nodiscard__]] void *operator new(std::size_t)
    __attribute__((__externally_visible__));
[[__nodiscard__]] void *operator new[](std::size_t)
    __attribute__((__externally_visible__));
void operator delete(void *) noexcept __attribute__((__externally_visible__));
void operator delete[](void *) noexcept __attribute__((__externally_visible__));

[[__nodiscard__]] void *operator new(std::size_t,
                                     const std::nothrow_t &) noexcept
    __attribute__((__externally_visible__, __alloc_size__(1), __malloc__));
[[__nodiscard__]] void *operator new[](std::size_t,
                                       const std::nothrow_t &) noexcept
    __attribute__((__externally_visible__, __alloc_size__(1), __malloc__));
void operator delete(void *, const std::nothrow_t &) noexcept
    __attribute__((__externally_visible__));
void operator delete[](void *, const std::nothrow_t &) noexcept
    __attribute__((__externally_visible__));

[[__nodiscard__]] void *operator new(std::size_t, std::align_val_t)
    __attribute__((__externally_visible__, __alloc_size__(1), __malloc__));
[[__nodiscard__]] void *operator new(std::size_t, std::align_val_t,
                                     const std::nothrow_t &) noexcept
    __attribute__((__externally_visible__, __alloc_size__(1), __malloc__));
void operator delete(void *, std::align_val_t) noexcept
    __attribute__((__externally_visible__));
void operator delete(void *, std::align_val_t, const std::nothrow_t &) noexcept
    __attribute__((__externally_visible__));
[[__nodiscard__]] void *operator new[](std::size_t, std::align_val_t)
    __attribute__((__externally_visible__, __alloc_size__(1), __malloc__));
[[__nodiscard__]] void *operator new[](std::size_t, std::align_val_t,
                                       const std::nothrow_t &) noexcept
    __attribute__((__externally_visible__, __alloc_size__(1), __malloc__));
void operator delete[](void *, std::align_val_t) noexcept
    __attribute__((__externally_visible__));
void operator delete[](void *, std::align_val_t,
                       const std::nothrow_t &) noexcept
    __attribute__((__externally_visible__));
# 174 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/new" 3
[[__nodiscard__]] inline void *operator new(std::size_t, void *__p) noexcept {
  return __p;
}
[[__nodiscard__]] inline void *operator new[](std::size_t, void *__p) noexcept {
  return __p;
}

inline void operator delete(void *, void *) noexcept {}
inline void operator delete[](void *, void *) noexcept {}
}

namespace std {

template <typename _Tp>
[[nodiscard]] constexpr _Tp *launder(_Tp *__p) noexcept {
  return __builtin_launder(__p);
}

template <typename _Ret, typename... _Args, bool _NE>
void launder(_Ret (*)(_Args...) noexcept(_NE)) = delete;
template <typename _Ret, typename... _Args, bool _NE>
void launder(_Ret (*)(_Args......) noexcept(_NE)) = delete;

void launder(void *) = delete;
void launder(const void *) = delete;
void launder(volatile void *) = delete;
void launder(const volatile void *) = delete;

} // namespace std

namespace std {

struct destroying_delete_t {
  explicit destroying_delete_t() = default;
};

inline constexpr destroying_delete_t destroying_delete{};
} // namespace std

#pragma GCC visibility pop
# 39 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception_ptr.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/move.h" 1 3
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/move.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _Tp> class reference_wrapper;
# 61 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Tp, _Tp __v> struct integral_constant {
    static constexpr _Tp value = __v;
    typedef _Tp value_type;
    typedef integral_constant<_Tp, __v> type;
    constexpr operator value_type() const noexcept { return value; }

    constexpr value_type operator()() const noexcept { return value; }
  };

  using true_type = integral_constant<bool, true>;

  using false_type = integral_constant<bool, false>;

  template <bool __v> using __bool_constant = integral_constant<bool, __v>;

  template <bool __v> using bool_constant = integral_constant<bool, __v>;

  template <bool, typename _Tp = void> struct enable_if {};

  template <typename _Tp> struct enable_if<true, _Tp> {
    typedef _Tp type;
  };

  template <bool _Cond, typename _Tp = void>
  using __enable_if_t = typename enable_if<_Cond, _Tp>::type;

  template <bool> struct __conditional {
    template <typename _Tp, typename> using type = _Tp;
  };

  template <> struct __conditional<false> {
    template <typename, typename _Up> using type = _Up;
  };

  template <bool _Cond, typename _If, typename _Else>
  using __conditional_t =
      typename __conditional<_Cond>::template type<_If, _Else>;

  template <typename _Type> struct __type_identity {
    using type = _Type;
  };

  template <typename _Tp>
  using __type_identity_t = typename __type_identity<_Tp>::type;

  namespace __detail {

  template <typename _Tp, typename...> using __first_t = _Tp;

  template <typename... _Bn>
  auto
  __or_fn(int) -> __first_t<false_type, __enable_if_t<!bool(_Bn::value)>...>;

  template <typename... _Bn> auto __or_fn(...) -> true_type;

  template <typename... _Bn>
  auto
  __and_fn(int) -> __first_t<true_type, __enable_if_t<bool(_Bn::value)>...>;

  template <typename... _Bn> auto __and_fn(...) -> false_type;
  } // namespace __detail

  template <typename... _Bn>
  struct __or_ : decltype(__detail::__or_fn<_Bn...>(0)) {};

  template <typename... _Bn>
  struct __and_ : decltype(__detail::__and_fn<_Bn...>(0)) {};

  template <typename _Pp> struct __not_ : __bool_constant<!bool(_Pp::value)> {};

  template <typename... _Bn>
  inline constexpr bool __or_v = __or_<_Bn...>::value;
  template <typename... _Bn>
  inline constexpr bool __and_v = __and_<_Bn...>::value;

  namespace __detail {
  template <typename, typename _B1, typename... _Bn> struct __disjunction_impl {
    using type = _B1;
  };

  template <typename _B1, typename _B2, typename... _Bn>
  struct __disjunction_impl<__enable_if_t<!bool(_B1::value)>, _B1, _B2,
                            _Bn...> {
    using type = typename __disjunction_impl<void, _B2, _Bn...>::type;
  };

  template <typename, typename _B1, typename... _Bn> struct __conjunction_impl {
    using type = _B1;
  };

  template <typename _B1, typename _B2, typename... _Bn>
  struct __conjunction_impl<__enable_if_t<bool(_B1::value)>, _B1, _B2, _Bn...> {
    using type = typename __conjunction_impl<void, _B2, _Bn...>::type;
  };
  } // namespace __detail

  template <typename... _Bn>
  struct conjunction : __detail::__conjunction_impl<void, _Bn...>::type {};

  template <> struct conjunction<> : true_type {};

  template <typename... _Bn>
  struct disjunction : __detail::__disjunction_impl<void, _Bn...>::type {};

  template <> struct disjunction<> : false_type {};

  template <typename _Pp> struct negation : __not_<_Pp>::type {};

  template <typename... _Bn>
  inline constexpr bool conjunction_v = conjunction<_Bn...>::value;

  template <typename... _Bn>
  inline constexpr bool disjunction_v = disjunction<_Bn...>::value;

  template <typename _Pp>
  inline constexpr bool negation_v = negation<_Pp>::value;

  template <typename> struct is_reference;
  template <typename> struct is_function;
  template <typename> struct is_void;
  template <typename> struct remove_cv;
  template <typename> struct is_const;

  template <typename> struct __is_array_unknown_bounds;

  template <typename _Tp, size_t = sizeof(_Tp)>
  constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>) {
    return {};
  }

  template <typename _TypeIdentity,
            typename _NestedType = typename _TypeIdentity::type>
  constexpr typename __or_<is_reference<_NestedType>, is_function<_NestedType>,
                           is_void<_NestedType>,
                           __is_array_unknown_bounds<_NestedType>>::type
  __is_complete_or_unbounded(_TypeIdentity) {
    return {};
  }

  template <typename _Tp> using __remove_cv_t = typename remove_cv<_Tp>::type;

  template <typename _Tp> struct is_void : public false_type {};

  template <> struct is_void<void> : public true_type {};

  template <> struct is_void<const void> : public true_type {};

  template <> struct is_void<volatile void> : public true_type {};

  template <> struct is_void<const volatile void> : public true_type {};

  template <typename> struct __is_integral_helper : public false_type {};

  template <> struct __is_integral_helper<bool> : public true_type {};

  template <> struct __is_integral_helper<char> : public true_type {};

  template <> struct __is_integral_helper<signed char> : public true_type {};

  template <> struct __is_integral_helper<unsigned char> : public true_type {};

  template <> struct __is_integral_helper<wchar_t> : public true_type {};

  template <> struct __is_integral_helper<char8_t> : public true_type {};

  template <> struct __is_integral_helper<char16_t> : public true_type {};

  template <> struct __is_integral_helper<char32_t> : public true_type {};

  template <> struct __is_integral_helper<short> : public true_type {};

  template <> struct __is_integral_helper<unsigned short> : public true_type {};

  template <> struct __is_integral_helper<int> : public true_type {};

  template <> struct __is_integral_helper<unsigned int> : public true_type {};

  template <> struct __is_integral_helper<long> : public true_type {};

  template <> struct __is_integral_helper<unsigned long> : public true_type {};

  template <> struct __is_integral_helper<long long> : public true_type {};

  template <>
  struct __is_integral_helper<unsigned long long> : public true_type {};
# 440 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Tp>
  struct is_integral : public __is_integral_helper<__remove_cv_t<_Tp>>::type {};

  template <typename> struct __is_floating_point_helper : public false_type {};

  template <> struct __is_floating_point_helper<float> : public true_type {};

  template <> struct __is_floating_point_helper<double> : public true_type {};

  template <>
  struct __is_floating_point_helper<long double> : public true_type {};
# 500 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Tp>
  struct is_floating_point
      : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type {};

  template <typename> struct is_array : public false_type {};

  template <typename _Tp, std::size_t _Size>
  struct is_array<_Tp[_Size]> : public true_type {};

  template <typename _Tp> struct is_array<_Tp[]> : public true_type {};

  template <typename> struct __is_pointer_helper : public false_type {};

  template <typename _Tp>
  struct __is_pointer_helper<_Tp *> : public true_type {};

  template <typename _Tp>
  struct is_pointer : public __is_pointer_helper<__remove_cv_t<_Tp>>::type {};

  template <typename> struct is_lvalue_reference : public false_type {};

  template <typename _Tp>
  struct is_lvalue_reference<_Tp &> : public true_type {};

  template <typename> struct is_rvalue_reference : public false_type {};

  template <typename _Tp>
  struct is_rvalue_reference<_Tp &&> : public true_type {};

  template <typename>
  struct __is_member_object_pointer_helper : public false_type {};

  template <typename _Tp, typename _Cp>
  struct __is_member_object_pointer_helper<_Tp _Cp::*>
      : public __not_<is_function<_Tp>>::type {};

  template <typename _Tp>
  struct is_member_object_pointer
      : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type {};

  template <typename>
  struct __is_member_function_pointer_helper : public false_type {};

  template <typename _Tp, typename _Cp>
  struct __is_member_function_pointer_helper<_Tp _Cp::*>
      : public is_function<_Tp>::type {};

  template <typename _Tp>
  struct is_member_function_pointer
      : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type {};

  template <typename _Tp>
  struct is_enum : public integral_constant<bool, __is_enum(_Tp)> {};

  template <typename _Tp>
  struct is_union : public integral_constant<bool, __is_union(_Tp)> {};

  template <typename _Tp>
  struct is_class : public integral_constant<bool, __is_class(_Tp)> {};

  template <typename _Tp>
  struct is_function : public __bool_constant<!is_const<const _Tp>::value> {};

  template <typename _Tp> struct is_function<_Tp &> : public false_type {};

  template <typename _Tp> struct is_function<_Tp &&> : public false_type {};

  template <typename _Tp> struct is_null_pointer : public false_type {};

  template <> struct is_null_pointer<std::nullptr_t> : public true_type {};

  template <>
  struct is_null_pointer<const std::nullptr_t> : public true_type {};

  template <>
  struct is_null_pointer<volatile std::nullptr_t> : public true_type {};

  template <>
  struct is_null_pointer<const volatile std::nullptr_t> : public true_type {};

  template <typename _Tp> struct __is_nullptr_t : public is_null_pointer<_Tp> {
  } __attribute__((__deprecated__("use '"
                                  "std::is_null_pointer"
                                  "' instead")));

  template <typename _Tp> struct is_reference : public false_type {};

  template <typename _Tp> struct is_reference<_Tp &> : public true_type {};

  template <typename _Tp> struct is_reference<_Tp &&> : public true_type {};

  template <typename _Tp>
  struct is_arithmetic
      : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type {};

  template <typename _Tp>
  struct is_fundamental : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
                                       is_null_pointer<_Tp>>::type {};

  template <typename _Tp>
  struct is_object
      : public __not_<
            __or_<is_function<_Tp>, is_reference<_Tp>, is_void<_Tp>>>::type {};

  template <typename> struct is_member_pointer;

  template <typename _Tp>
  struct is_scalar
      : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                     is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type {};

  template <typename _Tp>
  struct is_compound : public __not_<is_fundamental<_Tp>>::type {};

  template <typename _Tp>
  struct __is_member_pointer_helper : public false_type {};

  template <typename _Tp, typename _Cp>
  struct __is_member_pointer_helper<_Tp _Cp::*> : public true_type {};

  template <typename _Tp>
  struct is_member_pointer
      : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type {};

  template <typename, typename> struct is_same;

  template <typename _Tp, typename... _Types>
  using __is_one_of = __or_<is_same<_Tp, _Types>...>;

  __extension__ template <typename _Tp>
  using __is_signed_integer =
      __is_one_of<__remove_cv_t<_Tp>, signed char, signed short, signed int,
                  signed long, signed long long
# 733 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
                  >;

  __extension__ template <typename _Tp>
  using __is_unsigned_integer =
      __is_one_of<__remove_cv_t<_Tp>, unsigned char, unsigned short,
                  unsigned int, unsigned long, unsigned long long
# 753 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
                  >;

  template <typename _Tp>
  using __is_standard_integer =
      __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;

  template <typename...> using __void_t = void;

  template <typename> struct is_const : public false_type {};

  template <typename _Tp> struct is_const<_Tp const> : public true_type {};

  template <typename> struct is_volatile : public false_type {};

  template <typename _Tp>
  struct is_volatile<_Tp volatile> : public true_type {};

  template <typename _Tp>
  struct is_trivial : public integral_constant<bool, __is_trivial(_Tp)> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_trivially_copyable
      : public integral_constant<bool, __is_trivially_copyable(_Tp)> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_standard_layout
      : public integral_constant<bool, __is_standard_layout(_Tp)> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct __attribute__((__deprecated__("use '"
                                       "is_standard_layout && is_trivial"
                                       "' instead"))) is_pod
      : public integral_constant<bool, __is_pod(_Tp)> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct [[__deprecated__]] is_literal_type
      : public integral_constant<bool, __is_literal_type(_Tp)> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_empty : public integral_constant<bool, __is_empty(_Tp)> {};

  template <typename _Tp>
  struct is_polymorphic
      : public integral_constant<bool, __is_polymorphic(_Tp)> {};

  template <typename _Tp>
  struct is_final : public integral_constant<bool, __is_final(_Tp)> {};

  template <typename _Tp>
  struct is_abstract : public integral_constant<bool, __is_abstract(_Tp)> {};

  template <typename _Tp, bool = is_arithmetic<_Tp>::value>
  struct __is_signed_helper : public false_type {};

  template <typename _Tp>
  struct __is_signed_helper<_Tp, true>
      : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};

  template <typename _Tp>
  struct is_signed : public __is_signed_helper<_Tp>::type {};

  template <typename _Tp>
  struct is_unsigned
      : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type {};

  template <typename _Tp, typename _Up = _Tp &&> _Up __declval(int);

  template <typename _Tp> _Tp __declval(long);

  template <typename _Tp>
  auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template <typename> struct remove_all_extents;

  template <typename _Tp> struct __is_array_known_bounds : public false_type {};

  template <typename _Tp, size_t _Size>
  struct __is_array_known_bounds<_Tp[_Size]> : public true_type {};

  template <typename _Tp>
  struct __is_array_unknown_bounds : public false_type {};

  template <typename _Tp>
  struct __is_array_unknown_bounds<_Tp[]> : public true_type {};
# 936 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  struct __do_is_destructible_impl {
    template <typename _Tp, typename = decltype(declval<_Tp &>().~_Tp())>
    static true_type __test(int);

    template <typename> static false_type __test(...);
  };

  template <typename _Tp>
  struct __is_destructible_impl : public __do_is_destructible_impl {
    typedef decltype(__test<_Tp>(0)) type;
  };

  template <typename _Tp,
            bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>,
                         is_function<_Tp>>::value,
            bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
  struct __is_destructible_safe;

  template <typename _Tp>
  struct __is_destructible_safe<_Tp, false, false>
      : public __is_destructible_impl<
            typename remove_all_extents<_Tp>::type>::type {};

  template <typename _Tp>
  struct __is_destructible_safe<_Tp, true, false> : public false_type {};

  template <typename _Tp>
  struct __is_destructible_safe<_Tp, false, true> : public true_type {};

  template <typename _Tp>
  struct is_destructible : public __is_destructible_safe<_Tp>::type {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  struct __do_is_nt_destructible_impl {
    template <typename _Tp>
    static __bool_constant<noexcept(declval<_Tp &>().~_Tp())> __test(int);

    template <typename> static false_type __test(...);
  };

  template <typename _Tp>
  struct __is_nt_destructible_impl : public __do_is_nt_destructible_impl {
    typedef decltype(__test<_Tp>(0)) type;
  };

  template <typename _Tp,
            bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>,
                         is_function<_Tp>>::value,
            bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
  struct __is_nt_destructible_safe;

  template <typename _Tp>
  struct __is_nt_destructible_safe<_Tp, false, false>
      : public __is_nt_destructible_impl<
            typename remove_all_extents<_Tp>::type>::type {};

  template <typename _Tp>
  struct __is_nt_destructible_safe<_Tp, true, false> : public false_type {};

  template <typename _Tp>
  struct __is_nt_destructible_safe<_Tp, false, true> : public true_type {};

  template <typename _Tp>
  struct is_nothrow_destructible : public __is_nt_destructible_safe<_Tp>::type {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp, typename... _Args>
  using __is_constructible_impl =
      __bool_constant<__is_constructible(_Tp, _Args...)>;

  template <typename _Tp, typename... _Args>
  struct is_constructible : public __is_constructible_impl<_Tp, _Args...> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_default_constructible : public __is_constructible_impl<_Tp> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp, typename = void>
  struct __add_lvalue_reference_helper {
    using type = _Tp;
  };

  template <typename _Tp>
  struct __add_lvalue_reference_helper<_Tp, __void_t<_Tp &>> {
    using type = _Tp &;
  };

  template <typename _Tp>
  using __add_lval_ref_t = typename __add_lvalue_reference_helper<_Tp>::type;

  template <typename _Tp>
  struct is_copy_constructible
      : public __is_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp, typename = void>
  struct __add_rvalue_reference_helper {
    using type = _Tp;
  };

  template <typename _Tp>
  struct __add_rvalue_reference_helper<_Tp, __void_t<_Tp &&>> {
    using type = _Tp &&;
  };

  template <typename _Tp>
  using __add_rval_ref_t = typename __add_rvalue_reference_helper<_Tp>::type;

  template <typename _Tp>
  struct is_move_constructible
      : public __is_constructible_impl<_Tp, __add_rval_ref_t<_Tp>> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp, typename... _Args>
  using __is_nothrow_constructible_impl =
      __bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;

  template <typename _Tp, typename... _Args>
  struct is_nothrow_constructible
      : public __is_nothrow_constructible_impl<_Tp, _Args...> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_nothrow_default_constructible
      : public __is_nothrow_constructible_impl<_Tp> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_nothrow_copy_constructible
      : public __is_nothrow_constructible_impl<_Tp,
                                               __add_lval_ref_t<const _Tp>> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_nothrow_move_constructible
      : public __is_nothrow_constructible_impl<_Tp, __add_rval_ref_t<_Tp>> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp, typename _Up>
  using __is_assignable_impl = __bool_constant<__is_assignable(_Tp, _Up)>;

  template <typename _Tp, typename _Up>
  struct is_assignable : public __is_assignable_impl<_Tp, _Up> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_copy_assignable
      : public __is_assignable_impl<__add_lval_ref_t<_Tp>,
                                    __add_lval_ref_t<const _Tp>> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_move_assignable
      : public __is_assignable_impl<__add_lval_ref_t<_Tp>,
                                    __add_rval_ref_t<_Tp>> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp, typename _Up>
  using __is_nothrow_assignable_impl =
      __bool_constant<__is_nothrow_assignable(_Tp, _Up)>;

  template <typename _Tp, typename _Up>
  struct is_nothrow_assignable : public __is_nothrow_assignable_impl<_Tp, _Up> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_nothrow_copy_assignable
      : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>,
                                            __add_lval_ref_t<const _Tp>> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_nothrow_move_assignable
      : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>,
                                            __add_rval_ref_t<_Tp>> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp, typename... _Args>
  using __is_trivially_constructible_impl =
      __bool_constant<__is_trivially_constructible(_Tp, _Args...)>;

  template <typename _Tp, typename... _Args>
  struct is_trivially_constructible
      : public __is_trivially_constructible_impl<_Tp, _Args...> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_trivially_default_constructible
      : public __is_trivially_constructible_impl<_Tp> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  struct __do_is_implicitly_default_constructible_impl {
    template <typename _Tp> static void __helper(const _Tp &);

    template <typename _Tp>
    static true_type __test(const _Tp &,
                            decltype(__helper<const _Tp &>({})) * = 0);

    static false_type __test(...);
  };

  template <typename _Tp>
  struct __is_implicitly_default_constructible_impl
      : public __do_is_implicitly_default_constructible_impl {
    typedef decltype(__test(declval<_Tp>())) type;
  };

  template <typename _Tp>
  struct __is_implicitly_default_constructible_safe
      : public __is_implicitly_default_constructible_impl<_Tp>::type {};

  template <typename _Tp>
  struct __is_implicitly_default_constructible
      : public __and_<__is_constructible_impl<_Tp>,
                      __is_implicitly_default_constructible_safe<_Tp>>::type {};

  template <typename _Tp>
  struct is_trivially_copy_constructible
      : public __is_trivially_constructible_impl<_Tp,
                                                 __add_lval_ref_t<const _Tp>> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_trivially_move_constructible
      : public __is_trivially_constructible_impl<_Tp, __add_rval_ref_t<_Tp>> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp, typename _Up>
  using __is_trivially_assignable_impl =
      __bool_constant<__is_trivially_assignable(_Tp, _Up)>;

  template <typename _Tp, typename _Up>
  struct is_trivially_assignable
      : public __is_trivially_assignable_impl<_Tp, _Up> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_trivially_copy_assignable
      : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>,
                                              __add_lval_ref_t<const _Tp>> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_trivially_move_assignable
      : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>,
                                              __add_rval_ref_t<_Tp>> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_trivially_destructible
      : public __and_<__is_destructible_safe<_Tp>,
                      __bool_constant<__has_trivial_destructor(_Tp)>>::type {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct has_virtual_destructor
      : public integral_constant<bool, __has_virtual_destructor(_Tp)> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct alignment_of : public integral_constant<std::size_t, alignof(_Tp)> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename> struct rank : public integral_constant<std::size_t, 0> {};

  template <typename _Tp, std::size_t _Size>
  struct rank<_Tp[_Size]>
      : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {};

  template <typename _Tp>
  struct rank<_Tp[]>
      : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {};

  template <typename, unsigned _Uint = 0>
  struct extent : public integral_constant<size_t, 0> {};

  template <typename _Tp, size_t _Size>
  struct extent<_Tp[_Size], 0> : public integral_constant<size_t, _Size> {};

  template <typename _Tp, unsigned _Uint, size_t _Size>
  struct extent<_Tp[_Size], _Uint> : public extent<_Tp, _Uint - 1>::type {};

  template <typename _Tp>
  struct extent<_Tp[], 0> : public integral_constant<size_t, 0> {};

  template <typename _Tp, unsigned _Uint>
  struct extent<_Tp[], _Uint> : public extent<_Tp, _Uint - 1>::type {};

  template <typename _Tp, typename _Up>
  struct is_same

      : public integral_constant<bool, __is_same(_Tp, _Up)>

  {};
# 1409 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Base, typename _Derived>
  struct is_base_of
      : public integral_constant<bool, __is_base_of(_Base, _Derived)> {};

  template <typename _From, typename _To>
  struct is_convertible : public __bool_constant<__is_convertible(_From, _To)> {
  };
# 1458 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _ToElementType, typename _FromElementType>
  using __is_array_convertible =
      is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;
# 1477 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _From, typename _To,
            bool =
                __or_<is_void<_From>, is_function<_To>, is_array<_To>>::value>
  struct __is_nt_convertible_helper : is_void<_To> {};

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template <typename _From, typename _To>
  class __is_nt_convertible_helper<_From, _To, false> {
    template <typename _To1> static void __test_aux(_To1) noexcept;

    template <typename _From1, typename _To1>
    static __bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))>
    __test(int);

    template <typename, typename> static false_type __test(...);

  public:
    using type = decltype(__test<_From, _To>(0));
  };
#pragma GCC diagnostic pop

  template <typename _From, typename _To>
  struct is_nothrow_convertible
      : public __is_nt_convertible_helper<_From, _To>::type {};

  template <typename _From, typename _To>
  inline constexpr bool is_nothrow_convertible_v =
      is_nothrow_convertible<_From, _To>::value;

  template <typename _Tp> struct remove_const {
    typedef _Tp type;
  };

  template <typename _Tp> struct remove_const<_Tp const> {
    typedef _Tp type;
  };

  template <typename _Tp> struct remove_volatile {
    typedef _Tp type;
  };

  template <typename _Tp> struct remove_volatile<_Tp volatile> {
    typedef _Tp type;
  };

  template <typename _Tp> struct remove_cv {
    using type = __remove_cv(_Tp);
  };
# 1563 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Tp> struct add_const {
    using type = _Tp const;
  };

  template <typename _Tp> struct add_volatile {
    using type = _Tp volatile;
  };

  template <typename _Tp> struct add_cv {
    using type = _Tp const volatile;
  };

  template <typename _Tp>
  using remove_const_t = typename remove_const<_Tp>::type;

  template <typename _Tp>
  using remove_volatile_t = typename remove_volatile<_Tp>::type;

  template <typename _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;

  template <typename _Tp> using add_const_t = typename add_const<_Tp>::type;

  template <typename _Tp>
  using add_volatile_t = typename add_volatile<_Tp>::type;

  template <typename _Tp> using add_cv_t = typename add_cv<_Tp>::type;
# 1614 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Tp> struct remove_reference {
    using type = _Tp;
  };

  template <typename _Tp> struct remove_reference<_Tp &> {
    using type = _Tp;
  };

  template <typename _Tp> struct remove_reference<_Tp &&> {
    using type = _Tp;
  };

  template <typename _Tp> struct add_lvalue_reference {
    using type = __add_lval_ref_t<_Tp>;
  };

  template <typename _Tp> struct add_rvalue_reference {
    using type = __add_rval_ref_t<_Tp>;
  };

  template <typename _Tp>
  using remove_reference_t = typename remove_reference<_Tp>::type;

  template <typename _Tp>
  using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;

  template <typename _Tp>
  using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;

  template <typename _Unqualified, bool _IsConst, bool _IsVol>
  struct __cv_selector;

  template <typename _Unqualified>
  struct __cv_selector<_Unqualified, false, false> {
    typedef _Unqualified __type;
  };

  template <typename _Unqualified>
  struct __cv_selector<_Unqualified, false, true> {
    typedef volatile _Unqualified __type;
  };

  template <typename _Unqualified>
  struct __cv_selector<_Unqualified, true, false> {
    typedef const _Unqualified __type;
  };

  template <typename _Unqualified>
  struct __cv_selector<_Unqualified, true, true> {
    typedef const volatile _Unqualified __type;
  };

  template <typename _Qualified, typename _Unqualified,
            bool _IsConst = is_const<_Qualified>::value,
            bool _IsVol = is_volatile<_Qualified>::value>
  class __match_cv_qualifiers {
    typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

  public:
    typedef typename __match::__type __type;
  };

  template <typename _Tp> struct __make_unsigned { typedef _Tp __type; };

  template <> struct __make_unsigned<char> { typedef unsigned char __type; };

  template <> struct __make_unsigned<signed char> {
    typedef unsigned char __type;
  };

  template <> struct __make_unsigned<short> { typedef unsigned short __type; };

  template <> struct __make_unsigned<int> { typedef unsigned int __type; };

  template <> struct __make_unsigned<long> { typedef unsigned long __type; };

  template <> struct __make_unsigned<long long> {
    typedef unsigned long long __type;
  };
# 1741 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Tp, bool _IsInt = is_integral<_Tp>::value,
            bool _IsEnum = is_enum<_Tp>::value>
  class __make_unsigned_selector;

  template <typename _Tp> class __make_unsigned_selector<_Tp, true, false> {
    using __unsigned_type =
        typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

  public:
    using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
  };

  class __make_unsigned_selector_base {
  protected:
    template <typename...> struct _List {};

    template <typename _Tp, typename... _Up>
    struct _List<_Tp, _Up...> : _List<_Up...> {
      static constexpr size_t __size = sizeof(_Tp);
    };

    template <size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
    struct __select;

    template <size_t _Sz, typename _Uint, typename... _UInts>
    struct __select<_Sz, _List<_Uint, _UInts...>, true> {
      using __type = _Uint;
    };

    template <size_t _Sz, typename _Uint, typename... _UInts>
    struct __select<_Sz, _List<_Uint, _UInts...>, false>
        : __select<_Sz, _List<_UInts...>> {};
  };

  template <typename _Tp>
  class __make_unsigned_selector<_Tp, false, true>
      : __make_unsigned_selector_base {

    using _UInts = _List<unsigned char, unsigned short, unsigned int,
                         unsigned long, unsigned long long>;

    using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

  public:
    using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
  };

  template <> struct __make_unsigned<wchar_t> {
    using __type =
        typename __make_unsigned_selector<wchar_t, false, true>::__type;
  };

  template <> struct __make_unsigned<char8_t> {
    using __type =
        typename __make_unsigned_selector<char8_t, false, true>::__type;
  };

  template <> struct __make_unsigned<char16_t> {
    using __type =
        typename __make_unsigned_selector<char16_t, false, true>::__type;
  };

  template <> struct __make_unsigned<char32_t> {
    using __type =
        typename __make_unsigned_selector<char32_t, false, true>::__type;
  };

  template <typename _Tp> struct make_unsigned {
    typedef typename __make_unsigned_selector<_Tp>::__type type;
  };

  template <> struct make_unsigned<bool>;
  template <> struct make_unsigned<bool const>;
  template <> struct make_unsigned<bool volatile>;
  template <> struct make_unsigned<bool const volatile>;

  template <typename _Tp> struct __make_signed { typedef _Tp __type; };

  template <> struct __make_signed<char> { typedef signed char __type; };

  template <> struct __make_signed<unsigned char> {
    typedef signed char __type;
  };

  template <> struct __make_signed<unsigned short> {
    typedef signed short __type;
  };

  template <> struct __make_signed<unsigned int> { typedef signed int __type; };

  template <> struct __make_signed<unsigned long> {
    typedef signed long __type;
  };

  template <> struct __make_signed<unsigned long long> {
    typedef signed long long __type;
  };
# 1901 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Tp, bool _IsInt = is_integral<_Tp>::value,
            bool _IsEnum = is_enum<_Tp>::value>
  class __make_signed_selector;

  template <typename _Tp> class __make_signed_selector<_Tp, true, false> {
    using __signed_type = typename __make_signed<__remove_cv_t<_Tp>>::__type;

  public:
    using __type = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
  };

  template <typename _Tp> class __make_signed_selector<_Tp, false, true> {
    typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

  public:
    typedef typename __make_signed_selector<__unsigned_type>::__type __type;
  };

  template <> struct __make_signed<wchar_t> {
    using __type =
        typename __make_signed_selector<wchar_t, false, true>::__type;
  };

  template <> struct __make_signed<char8_t> {
    using __type =
        typename __make_signed_selector<char8_t, false, true>::__type;
  };

  template <> struct __make_signed<char16_t> {
    using __type =
        typename __make_signed_selector<char16_t, false, true>::__type;
  };

  template <> struct __make_signed<char32_t> {
    using __type =
        typename __make_signed_selector<char32_t, false, true>::__type;
  };

  template <typename _Tp> struct make_signed {
    typedef typename __make_signed_selector<_Tp>::__type type;
  };

  template <> struct make_signed<bool>;
  template <> struct make_signed<bool const>;
  template <> struct make_signed<bool volatile>;
  template <> struct make_signed<bool const volatile>;

  template <typename _Tp> using make_signed_t = typename make_signed<_Tp>::type;

  template <typename _Tp>
  using make_unsigned_t = typename make_unsigned<_Tp>::type;

  template <typename _Tp> struct remove_extent {
    typedef _Tp type;
  };

  template <typename _Tp, std::size_t _Size> struct remove_extent<_Tp[_Size]> {
    typedef _Tp type;
  };

  template <typename _Tp> struct remove_extent<_Tp[]> {
    typedef _Tp type;
  };

  template <typename _Tp> struct remove_all_extents {
    typedef _Tp type;
  };

  template <typename _Tp, std::size_t _Size>
  struct remove_all_extents<_Tp[_Size]> {
    typedef typename remove_all_extents<_Tp>::type type;
  };

  template <typename _Tp> struct remove_all_extents<_Tp[]> {
    typedef typename remove_all_extents<_Tp>::type type;
  };

  template <typename _Tp>
  using remove_extent_t = typename remove_extent<_Tp>::type;

  template <typename _Tp>
  using remove_all_extents_t = typename remove_all_extents<_Tp>::type;

  template <typename _Tp, typename> struct __remove_pointer_helper {
    typedef _Tp type;
  };

  template <typename _Tp, typename _Up>
  struct __remove_pointer_helper<_Tp, _Up *> {
    typedef _Up type;
  };

  template <typename _Tp>
  struct remove_pointer
      : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>> {};

  template <typename _Tp, typename = void> struct __add_pointer_helper {
    using type = _Tp;
  };

  template <typename _Tp> struct __add_pointer_helper<_Tp, __void_t<_Tp *>> {
    using type = _Tp *;
  };

  template <typename _Tp>
  struct add_pointer : public __add_pointer_helper<_Tp> {};

  template <typename _Tp> struct add_pointer<_Tp &> {
    using type = _Tp *;
  };

  template <typename _Tp> struct add_pointer<_Tp &&> {
    using type = _Tp *;
  };

  template <typename _Tp>
  using remove_pointer_t = typename remove_pointer<_Tp>::type;

  template <typename _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;

  template <std::size_t _Len> struct __aligned_storage_msa {
    union __type {
      unsigned char __data[_Len];
      struct __attribute__((__aligned__)) {
      } __align;
    };
  };
# 2095 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <std::size_t _Len, std::size_t _Align = __alignof__(
                                  typename __aligned_storage_msa<_Len>::__type)>
  struct

      aligned_storage {
    union type {
      unsigned char __data[_Len];
      struct __attribute__((__aligned__((_Align)))) {
      } __align;
    };
  };

  template <typename... _Types> struct __strictest_alignment {
    static const size_t _S_alignment = 0;
    static const size_t _S_size = 0;
  };

  template <typename _Tp, typename... _Types>
  struct __strictest_alignment<_Tp, _Types...> {
    static const size_t
        _S_alignment = alignof(_Tp) >
                               __strictest_alignment<_Types...>::_S_alignment
                           ? alignof(_Tp)
                           : __strictest_alignment<_Types...>::_S_alignment;
    static const size_t
        _S_size = sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
                      ? sizeof(_Tp)
                      : __strictest_alignment<_Types...>::_S_size;
  };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 2141 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <size_t _Len, typename... _Types>
  struct

      aligned_union {
  private:
    static_assert(sizeof...(_Types) != 0, "At least one type is required");

    using __strictest = __strictest_alignment<_Types...>;
    static const size_t _S_len =
        _Len > __strictest::_S_size ? _Len : __strictest::_S_size;

  public:
    static const size_t alignment_value = __strictest::_S_alignment;

    typedef typename aligned_storage<_S_len, alignment_value>::type type;
  };

  template <size_t _Len, typename... _Types>
  const size_t aligned_union<_Len, _Types...>::alignment_value;
#pragma GCC diagnostic pop

  template <typename _Up>
  struct __decay_selector : __conditional_t<is_const<const _Up>::value,
                                            remove_cv<_Up>, add_pointer<_Up>> {
  };

  template <typename _Up, size_t _Nm> struct __decay_selector<_Up[_Nm]> {
    using type = _Up *;
  };

  template <typename _Up> struct __decay_selector<_Up[]> {
    using type = _Up *;
  };

  template <typename _Tp> struct decay {
    using type = typename __decay_selector<_Tp>::type;
  };

  template <typename _Tp> struct decay<_Tp &> {
    using type = typename __decay_selector<_Tp>::type;
  };

  template <typename _Tp> struct decay<_Tp &&> {
    using type = typename __decay_selector<_Tp>::type;
  };

  template <typename _Tp> struct __strip_reference_wrapper {
    typedef _Tp __type;
  };

  template <typename _Tp>
  struct __strip_reference_wrapper<reference_wrapper<_Tp>> {
    typedef _Tp &__type;
  };

  template <typename _Tp> using __decay_t = typename decay<_Tp>::type;

  template <typename _Tp>
  using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;

  template <typename... _Cond>
  using _Require = __enable_if_t<__and_<_Cond...>::value>;

  template <typename _Tp>
  using __remove_cvref_t =
      typename remove_cv<typename remove_reference<_Tp>::type>::type;

  template <bool _Cond, typename _Iftrue, typename _Iffalse>
  struct conditional {
    typedef _Iftrue type;
  };

  template <typename _Iftrue, typename _Iffalse>
  struct conditional<false, _Iftrue, _Iffalse> {
    typedef _Iffalse type;
  };

  template <typename... _Tp> struct common_type;
# 2256 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Tp> struct __success_type {
    typedef _Tp type;
  };

  struct __failure_type {};

  struct __do_common_type_impl {
    template <typename _Tp, typename _Up>
    using __cond_t = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());

    template <typename _Tp, typename _Up>
    static __success_type<__decay_t<__cond_t<_Tp, _Up>>> _S_test(int);

    template <typename _Tp, typename _Up>
    static __success_type<__remove_cvref_t<__cond_t<const _Tp &, const _Up &>>>
    _S_test_2(int);

    template <typename, typename> static __failure_type _S_test_2(...);

    template <typename _Tp, typename _Up>
    static decltype(_S_test_2<_Tp, _Up>(0)) _S_test(...);
  };

  template <> struct common_type<> {};

  template <typename _Tp0>
  struct common_type<_Tp0> : public common_type<_Tp0, _Tp0> {};

  template <typename _Tp1, typename _Tp2, typename _Dp1 = __decay_t<_Tp1>,
            typename _Dp2 = __decay_t<_Tp2>>
  struct __common_type_impl {

    using type = common_type<_Dp1, _Dp2>;
  };

  template <typename _Tp1, typename _Tp2>
  struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
      : private __do_common_type_impl {

    using type = decltype(_S_test<_Tp1, _Tp2>(0));
  };

  template <typename _Tp1, typename _Tp2>
  struct common_type<_Tp1, _Tp2> : public __common_type_impl<_Tp1, _Tp2>::type {
  };

  template <typename...> struct __common_type_pack {};

  template <typename, typename, typename = void> struct __common_type_fold;

  template <typename _Tp1, typename _Tp2, typename... _Rp>
  struct common_type<_Tp1, _Tp2, _Rp...>
      : public __common_type_fold<common_type<_Tp1, _Tp2>,
                                  __common_type_pack<_Rp...>> {};

  template <typename _CTp, typename... _Rp>
  struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
                            __void_t<typename _CTp::type>>
      : public common_type<typename _CTp::type, _Rp...> {};

  template <typename _CTp, typename _Rp>
  struct __common_type_fold<_CTp, _Rp, void> {};

  template <typename _Tp, bool = is_enum<_Tp>::value>
  struct __underlying_type_impl {
    using type = __underlying_type(_Tp);
  };

  template <typename _Tp> struct __underlying_type_impl<_Tp, false> {};

  template <typename _Tp>
  struct underlying_type : public __underlying_type_impl<_Tp> {};

  template <typename _Tp> struct __declval_protector {
    static const bool __stop = false;
  };

  template <typename _Tp>
  auto declval() noexcept -> decltype(__declval<_Tp>(0)) {
    static_assert(__declval_protector<_Tp>::__stop,
                  "declval() must not be used!");
    return __declval<_Tp>(0);
  }

  template <typename _Signature> struct result_of;

  struct __invoke_memfun_ref {};
  struct __invoke_memfun_deref {};
  struct __invoke_memobj_ref {};
  struct __invoke_memobj_deref {};
  struct __invoke_other {};

  template <typename _Tp, typename _Tag>
  struct __result_of_success : __success_type<_Tp> {
    using __invoke_type = _Tag;
  };

  struct __result_of_memfun_ref_impl {
    template <typename _Fp, typename _Tp1, typename... _Args>
    static __result_of_success<
        decltype((std::declval<_Tp1>().*
                  std::declval<_Fp>())(std::declval<_Args>()...)),
        __invoke_memfun_ref>
    _S_test(int);

    template <typename...> static __failure_type _S_test(...);
  };

  template <typename _MemPtr, typename _Arg, typename... _Args>
  struct __result_of_memfun_ref : private __result_of_memfun_ref_impl {
    typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
  };

  struct __result_of_memfun_deref_impl {
    template <typename _Fp, typename _Tp1, typename... _Args>
    static __result_of_success<
        decltype(((*std::declval<_Tp1>()).*
                  std::declval<_Fp>())(std::declval<_Args>()...)),
        __invoke_memfun_deref>
    _S_test(int);

    template <typename...> static __failure_type _S_test(...);
  };

  template <typename _MemPtr, typename _Arg, typename... _Args>
  struct __result_of_memfun_deref : private __result_of_memfun_deref_impl {
    typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
  };

  struct __result_of_memobj_ref_impl {
    template <typename _Fp, typename _Tp1>
    static __result_of_success<decltype(std::declval<_Tp1>().*
                                        std::declval<_Fp>()),
                               __invoke_memobj_ref>
    _S_test(int);

    template <typename, typename> static __failure_type _S_test(...);
  };

  template <typename _MemPtr, typename _Arg>
  struct __result_of_memobj_ref : private __result_of_memobj_ref_impl {
    typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
  };

  struct __result_of_memobj_deref_impl {
    template <typename _Fp, typename _Tp1>
    static __result_of_success<decltype((*std::declval<_Tp1>()).*
                                        std::declval<_Fp>()),
                               __invoke_memobj_deref>
    _S_test(int);

    template <typename, typename> static __failure_type _S_test(...);
  };

  template <typename _MemPtr, typename _Arg>
  struct __result_of_memobj_deref : private __result_of_memobj_deref_impl {
    typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
  };

  template <typename _MemPtr, typename _Arg> struct __result_of_memobj;

  template <typename _Res, typename _Class, typename _Arg>
  struct __result_of_memobj<_Res _Class::*, _Arg> {
    typedef __remove_cvref_t<_Arg> _Argval;
    typedef _Res _Class::*_MemPtr;
    typedef typename __conditional_t<
        __or_<is_same<_Argval, _Class>, is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>>::type type;
  };

  template <typename _MemPtr, typename _Arg, typename... _Args>
  struct __result_of_memfun;

  template <typename _Res, typename _Class, typename _Arg, typename... _Args>
  struct __result_of_memfun<_Res _Class::*, _Arg, _Args...> {
    typedef typename remove_reference<_Arg>::type _Argval;
    typedef _Res _Class::*_MemPtr;
    typedef typename __conditional_t<
        is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>>::type type;
  };

  template <typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
  struct __inv_unwrap {
    using type = _Tp;
  };

  template <typename _Tp, typename _Up>
  struct __inv_unwrap<_Tp, reference_wrapper<_Up>> {
    using type = _Up &;
  };

  template <bool, bool, typename _Functor, typename... _ArgTypes>
  struct __result_of_impl {
    typedef __failure_type type;
  };

  template <typename _MemPtr, typename _Arg>
  struct __result_of_impl<true, false, _MemPtr, _Arg>
      : public __result_of_memobj<__decay_t<_MemPtr>,
                                  typename __inv_unwrap<_Arg>::type> {};

  template <typename _MemPtr, typename _Arg, typename... _Args>
  struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
      : public __result_of_memfun<__decay_t<_MemPtr>,
                                  typename __inv_unwrap<_Arg>::type, _Args...> {
  };

  struct __result_of_other_impl {
    template <typename _Fn, typename... _Args>
    static __result_of_success<
        decltype(std::declval<_Fn>()(std::declval<_Args>()...)), __invoke_other>
    _S_test(int);

    template <typename...> static __failure_type _S_test(...);
  };

  template <typename _Functor, typename... _ArgTypes>
  struct __result_of_impl<false, false, _Functor, _ArgTypes...>
      : private __result_of_other_impl {
    typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
  };

  template <typename _Functor, typename... _ArgTypes>
  struct __invoke_result
      : public __result_of_impl<
            is_member_object_pointer<
                typename remove_reference<_Functor>::type>::value,
            is_member_function_pointer<
                typename remove_reference<_Functor>::type>::value,
            _Functor, _ArgTypes...>::type {};

  template <typename _Functor, typename... _ArgTypes>
  struct result_of<_Functor(_ArgTypes...)>
      : public __invoke_result<_Functor, _ArgTypes...> {
  } __attribute__((__deprecated__("use '"
                                  "std::invoke_result"
                                  "' instead")));

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

  template <size_t _Len, size_t _Align = __alignof__(
                             typename __aligned_storage_msa<_Len>::__type)>
  using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
  using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
#pragma GCC diagnostic pop

  template <typename _Tp> using decay_t = typename decay<_Tp>::type;

  template <bool _Cond, typename _Tp = void>
  using enable_if_t = typename enable_if<_Cond, _Tp>::type;

  template <bool _Cond, typename _Iftrue, typename _Iffalse>
  using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;

  template <typename... _Tp>
  using common_type_t = typename common_type<_Tp...>::type;

  template <typename _Tp>
  using underlying_type_t = typename underlying_type<_Tp>::type;

  template <typename _Tp> using result_of_t = typename result_of<_Tp>::type;

  template <typename...> using void_t = void;
# 2642 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Def, template <typename...> class _Op, typename... _Args>
  struct __detected_or {
    using type = _Def;
    using __is_detected = false_type;
  };

  template <typename _Def, template <typename...> class _Op, typename... _Args>
    requires requires { typename _Op<_Args...>; }
  struct __detected_or<_Def, _Op, _Args...> {
    using type = _Op<_Args...>;
    using __is_detected = true_type;
  };
# 2682 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Default, template <typename...> class _Op,
            typename... _Args>
  using __detected_or_t = typename __detected_or<_Default, _Op, _Args...>::type;
# 2701 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Tp> struct __is_swappable;

  template <typename _Tp> struct __is_nothrow_swappable;

  template <typename> struct __is_tuple_like_impl : false_type {};

  template <typename _Tp>
  struct __is_tuple_like
      : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type {};

  template <typename _Tp>
  constexpr inline _Require<__not_<__is_tuple_like<_Tp>>,
                            is_move_constructible<_Tp>, is_move_assignable<_Tp>>
  swap(_Tp &, _Tp &) noexcept(__and_<is_nothrow_move_constructible<_Tp>,
                                     is_nothrow_move_assignable<_Tp>>::value);

  template <typename _Tp, size_t _Nm>
  constexpr inline __enable_if_t<__is_swappable<_Tp>::value> swap(
      _Tp(&__a)[_Nm],
      _Tp(&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
  using std::swap;

  struct __do_is_swappable_impl {
    template <typename _Tp, typename = decltype(swap(std::declval<_Tp &>(),
                                                     std::declval<_Tp &>()))>
    static true_type __test(int);

    template <typename> static false_type __test(...);
  };

  struct __do_is_nothrow_swappable_impl {
    template <typename _Tp>
    static __bool_constant<noexcept(swap(std::declval<_Tp &>(),
                                         std::declval<_Tp &>()))>
    __test(int);

    template <typename> static false_type __test(...);
  };

  } // namespace __swappable_details

  template <typename _Tp>
  struct __is_swappable_impl
      : public __swappable_details::__do_is_swappable_impl {
    typedef decltype(__test<_Tp>(0)) type;
  };

  template <typename _Tp>
  struct __is_nothrow_swappable_impl
      : public __swappable_details::__do_is_nothrow_swappable_impl {
    typedef decltype(__test<_Tp>(0)) type;
  };

  template <typename _Tp>
  struct __is_swappable : public __is_swappable_impl<_Tp>::type {};

  template <typename _Tp>
  struct __is_nothrow_swappable
      : public __is_nothrow_swappable_impl<_Tp>::type {};

  template <typename _Tp>
  struct is_swappable : public __is_swappable_impl<_Tp>::type {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  struct is_nothrow_swappable : public __is_nothrow_swappable_impl<_Tp>::type {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  inline constexpr bool is_swappable_v = is_swappable<_Tp>::value;

  template <typename _Tp>
  inline constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;

  namespace __swappable_with_details {
  using std::swap;

  struct __do_is_swappable_with_impl {
    template <
        typename _Tp, typename _Up,
        typename = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
        typename = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
    static true_type __test(int);

    template <typename, typename> static false_type __test(...);
  };

  struct __do_is_nothrow_swappable_with_impl {
    template <typename _Tp, typename _Up>
    static __bool_constant<
        noexcept(swap(std::declval<_Tp>(), std::declval<_Up>())) &&
        noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))>
    __test(int);

    template <typename, typename> static false_type __test(...);
  };

  } // namespace __swappable_with_details

  template <typename _Tp, typename _Up>
  struct __is_swappable_with_impl
      : public __swappable_with_details::__do_is_swappable_with_impl {
    typedef decltype(__test<_Tp, _Up>(0)) type;
  };

  template <typename _Tp>
  struct __is_swappable_with_impl<_Tp &, _Tp &>
      : public __swappable_details::__do_is_swappable_impl {
    typedef decltype(__test<_Tp &>(0)) type;
  };

  template <typename _Tp, typename _Up>
  struct __is_nothrow_swappable_with_impl
      : public __swappable_with_details::__do_is_nothrow_swappable_with_impl {
    typedef decltype(__test<_Tp, _Up>(0)) type;
  };

  template <typename _Tp>
  struct __is_nothrow_swappable_with_impl<_Tp &, _Tp &>
      : public __swappable_details::__do_is_nothrow_swappable_impl {
    typedef decltype(__test<_Tp &>(0)) type;
  };

  template <typename _Tp, typename _Up>
  struct is_swappable_with : public __is_swappable_with_impl<_Tp, _Up>::type {
    static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                  "first template argument must be a complete class or an "
                  "unbounded array");
    static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
                  "second template argument must be a complete class or an "
                  "unbounded array");
  };

  template <typename _Tp, typename _Up>
  struct is_nothrow_swappable_with
      : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type {
    static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
                  "first template argument must be a complete class or an "
                  "unbounded array");
    static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
                  "second template argument must be a complete class or an "
                  "unbounded array");
  };

  template <typename _Tp, typename _Up>
  inline constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;

  template <typename _Tp, typename _Up>
  inline constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;
# 2924 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Result, typename _Ret, bool = is_void<_Ret>::value,
            typename = void>
  struct __is_invocable_impl : false_type {
    using __nothrow_conv = false_type;
  };

  template <typename _Result, typename _Ret>
  struct __is_invocable_impl<_Result, _Ret, true,
                             __void_t<typename _Result::type>> : true_type {
    using __nothrow_conv = true_type;
  };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

  template <typename _Result, typename _Ret>
  struct __is_invocable_impl<_Result, _Ret, false,
                             __void_t<typename _Result::type>> {
  private:
    using _Res_t = typename _Result::type;

    static _Res_t _S_get() noexcept;

    template <typename _Tp>
    static void _S_conv(__type_identity_t<_Tp>) noexcept;

    template <typename _Tp, bool _Nothrow = noexcept(_S_conv<_Tp>(_S_get())),
              typename = decltype(_S_conv<_Tp>(_S_get())),

              bool _Dangle = false

              >
    static __bool_constant<_Nothrow && !_Dangle> _S_test(int);

    template <typename _Tp, bool = false> static false_type _S_test(...);

  public:
    using type = decltype(_S_test<_Ret, true>(1));

    using __nothrow_conv = decltype(_S_test<_Ret>(1));
  };
#pragma GCC diagnostic pop

  template <typename _Fn, typename... _ArgTypes>
  struct __is_invocable
      : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type {};

  template <typename _Fn, typename _Tp, typename... _Args>
  constexpr bool __call_is_nt(__invoke_memfun_ref) {
    using _Up = typename __inv_unwrap<_Tp>::type;
    return noexcept(
        (std::declval<_Up>().*std::declval<_Fn>())(std::declval<_Args>()...));
  }

  template <typename _Fn, typename _Tp, typename... _Args>
  constexpr bool __call_is_nt(__invoke_memfun_deref) {
    return noexcept(((*std::declval<_Tp>()).*
                     std::declval<_Fn>())(std::declval<_Args>()...));
  }

  template <typename _Fn, typename _Tp>
  constexpr bool __call_is_nt(__invoke_memobj_ref) {
    using _Up = typename __inv_unwrap<_Tp>::type;
    return noexcept(std::declval<_Up>().*std::declval<_Fn>());
  }

  template <typename _Fn, typename _Tp>
  constexpr bool __call_is_nt(__invoke_memobj_deref) {
    return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
  }

  template <typename _Fn, typename... _Args>
  constexpr bool __call_is_nt(__invoke_other) {
    return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
  }

  template <typename _Result, typename _Fn, typename... _Args>
  struct __call_is_nothrow : __bool_constant<std::__call_is_nt<_Fn, _Args...>(
                                 typename _Result::__invoke_type{})> {};

  template <typename _Fn, typename... _Args>
  using __call_is_nothrow_ =
      __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;

  template <typename _Fn, typename... _Args>
  struct __is_nothrow_invocable
      : __and_<__is_invocable<_Fn, _Args...>,
               __call_is_nothrow_<_Fn, _Args...>>::type {};

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  struct __nonesuchbase {};
  struct __nonesuch : private __nonesuchbase {
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const &) = delete;
    void operator=(__nonesuch const &) = delete;
  };
#pragma GCC diagnostic pop

  template <typename _Functor, typename... _ArgTypes>
  struct invoke_result : public __invoke_result<_Functor, _ArgTypes...> {
    static_assert(std::__is_complete_or_unbounded(__type_identity<_Functor>{}),
                  "_Functor must be a complete class or an unbounded array");
    static_assert(
        (std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...),
        "each argument type must be a complete class or an unbounded array");
  };

  template <typename _Fn, typename... _Args>
  using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;

  template <typename _Fn, typename... _ArgTypes>
  struct is_invocable
      : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type {
    static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
                  "_Fn must be a complete class or an unbounded array");
    static_assert(
        (std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...),
        "each argument type must be a complete class or an unbounded array");
  };

  template <typename _Ret, typename _Fn, typename... _ArgTypes>
  struct is_invocable_r
      : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type {
    static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
                  "_Fn must be a complete class or an unbounded array");
    static_assert(
        (std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...),
        "each argument type must be a complete class or an unbounded array");
    static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
                  "_Ret must be a complete class or an unbounded array");
  };

  template <typename _Fn, typename... _ArgTypes>
  struct is_nothrow_invocable
      : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,
               __call_is_nothrow_<_Fn, _ArgTypes...>>::type {
    static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
                  "_Fn must be a complete class or an unbounded array");
    static_assert(
        (std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...),
        "each argument type must be a complete class or an unbounded array");
  };

  template <typename _Result, typename _Ret>
  using __is_nt_invocable_impl =
      typename __is_invocable_impl<_Result, _Ret>::__nothrow_conv;

  template <typename _Ret, typename _Fn, typename... _ArgTypes>
  struct is_nothrow_invocable_r
      : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,
               __call_is_nothrow_<_Fn, _ArgTypes...>>::type {
    static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
                  "_Fn must be a complete class or an unbounded array");
    static_assert(
        (std::__is_complete_or_unbounded(__type_identity<_ArgTypes>{}) && ...),
        "each argument type must be a complete class or an unbounded array");
    static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
                  "_Ret must be a complete class or an unbounded array");
  };
# 3155 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Tp> inline constexpr bool is_void_v = is_void<_Tp>::value;
  template <typename _Tp>
  inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
  template <typename _Tp>
  inline constexpr bool is_integral_v = is_integral<_Tp>::value;
  template <typename _Tp>
  inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;

  template <typename _Tp> inline constexpr bool is_array_v = false;
  template <typename _Tp> inline constexpr bool is_array_v<_Tp[]> = true;
  template <typename _Tp, size_t _Num>
  inline constexpr bool is_array_v<_Tp[_Num]> = true;

  template <typename _Tp>
  inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;
  template <typename _Tp> inline constexpr bool is_lvalue_reference_v = false;
  template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v<_Tp &> = true;
  template <typename _Tp> inline constexpr bool is_rvalue_reference_v = false;
  template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v<_Tp &&> = true;
  template <typename _Tp>
  inline constexpr bool is_member_object_pointer_v =
      is_member_object_pointer<_Tp>::value;
  template <typename _Tp>
  inline constexpr bool is_member_function_pointer_v =
      is_member_function_pointer<_Tp>::value;
  template <typename _Tp> inline constexpr bool is_enum_v = __is_enum(_Tp);
  template <typename _Tp> inline constexpr bool is_union_v = __is_union(_Tp);
  template <typename _Tp> inline constexpr bool is_class_v = __is_class(_Tp);
  template <typename _Tp>
  inline constexpr bool is_function_v = is_function<_Tp>::value;
  template <typename _Tp> inline constexpr bool is_reference_v = false;
  template <typename _Tp> inline constexpr bool is_reference_v<_Tp &> = true;
  template <typename _Tp> inline constexpr bool is_reference_v<_Tp &&> = true;
  template <typename _Tp>
  inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
  template <typename _Tp>
  inline constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;
  template <typename _Tp>
  inline constexpr bool is_object_v = is_object<_Tp>::value;
  template <typename _Tp>
  inline constexpr bool is_scalar_v = is_scalar<_Tp>::value;
  template <typename _Tp>
  inline constexpr bool is_compound_v = is_compound<_Tp>::value;
  template <typename _Tp>
  inline constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;
  template <typename _Tp> inline constexpr bool is_const_v = false;
  template <typename _Tp> inline constexpr bool is_const_v<const _Tp> = true;
  template <typename _Tp> inline constexpr bool is_volatile_v = false;
  template <typename _Tp>
  inline constexpr bool is_volatile_v<volatile _Tp> = true;

  template <typename _Tp>
  inline constexpr bool is_trivial_v = __is_trivial(_Tp);
  template <typename _Tp>
  inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Tp);
  template <typename _Tp>
  inline constexpr bool is_standard_layout_v = __is_standard_layout(_Tp);
  template <typename _Tp>
  __attribute__((__deprecated__("use '"
                                "is_standard_layout_v && is_trivial_v"
                                "' instead"))) inline constexpr bool is_pod_v =
      __is_pod(_Tp);
  template <typename _Tp>
  [[__deprecated__]]
  inline constexpr bool is_literal_type_v = __is_literal_type(_Tp);
  template <typename _Tp> inline constexpr bool is_empty_v = __is_empty(_Tp);
  template <typename _Tp>
  inline constexpr bool is_polymorphic_v = __is_polymorphic(_Tp);
  template <typename _Tp>
  inline constexpr bool is_abstract_v = __is_abstract(_Tp);
  template <typename _Tp> inline constexpr bool is_final_v = __is_final(_Tp);

  template <typename _Tp>
  inline constexpr bool is_signed_v = is_signed<_Tp>::value;
  template <typename _Tp>
  inline constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;

  template <typename _Tp, typename... _Args>
  inline constexpr bool is_constructible_v = __is_constructible(_Tp, _Args...);
  template <typename _Tp>
  inline constexpr bool is_default_constructible_v = __is_constructible(_Tp);
  template <typename _Tp>
  inline constexpr bool is_copy_constructible_v =
      __is_constructible(_Tp, __add_lval_ref_t<const _Tp>);
  template <typename _Tp>
  inline constexpr bool is_move_constructible_v =
      __is_constructible(_Tp, __add_rval_ref_t<_Tp>);

  template <typename _Tp, typename _Up>
  inline constexpr bool is_assignable_v = __is_assignable(_Tp, _Up);
  template <typename _Tp>
  inline constexpr bool is_copy_assignable_v =
      __is_assignable(__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>);
  template <typename _Tp>
  inline constexpr bool is_move_assignable_v =
      __is_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);

  template <typename _Tp>
  inline constexpr bool is_destructible_v = is_destructible<_Tp>::value;

  template <typename _Tp, typename... _Args>
  inline constexpr bool is_trivially_constructible_v =
      __is_trivially_constructible(_Tp, _Args...);
  template <typename _Tp>
  inline constexpr bool is_trivially_default_constructible_v =
      __is_trivially_constructible(_Tp);
  template <typename _Tp>
  inline constexpr bool is_trivially_copy_constructible_v =
      __is_trivially_constructible(_Tp, __add_lval_ref_t<const _Tp>);
  template <typename _Tp>
  inline constexpr bool is_trivially_move_constructible_v =
      __is_trivially_constructible(_Tp, __add_rval_ref_t<_Tp>);

  template <typename _Tp, typename _Up>
  inline constexpr bool is_trivially_assignable_v =
      __is_trivially_assignable(_Tp, _Up);
  template <typename _Tp>
  inline constexpr bool is_trivially_copy_assignable_v =
      __is_trivially_assignable(__add_lval_ref_t<_Tp>,
                                __add_lval_ref_t<const _Tp>);
  template <typename _Tp>
  inline constexpr bool is_trivially_move_assignable_v =
      __is_trivially_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);
  template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v =
      is_trivially_destructible<_Tp>::value;
  template <typename _Tp, typename... _Args>
  inline constexpr bool is_nothrow_constructible_v =
      __is_nothrow_constructible(_Tp, _Args...);
  template <typename _Tp>
  inline constexpr bool is_nothrow_default_constructible_v =
      __is_nothrow_constructible(_Tp);
  template <typename _Tp>
  inline constexpr bool is_nothrow_copy_constructible_v =
      __is_nothrow_constructible(_Tp, __add_lval_ref_t<const _Tp>);
  template <typename _Tp>
  inline constexpr bool is_nothrow_move_constructible_v =
      __is_nothrow_constructible(_Tp, __add_rval_ref_t<_Tp>);

  template <typename _Tp, typename _Up>
  inline constexpr bool is_nothrow_assignable_v =
      __is_nothrow_assignable(_Tp, _Up);
  template <typename _Tp>
  inline constexpr bool is_nothrow_copy_assignable_v = __is_nothrow_assignable(
      __add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>);
  template <typename _Tp>
  inline constexpr bool is_nothrow_move_assignable_v =
      __is_nothrow_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);

  template <typename _Tp>
  inline constexpr bool is_nothrow_destructible_v =
      is_nothrow_destructible<_Tp>::value;

  template <typename _Tp>
  inline constexpr bool has_virtual_destructor_v =
      __has_virtual_destructor(_Tp);

  template <typename _Tp>
  inline constexpr size_t alignment_of_v = alignment_of<_Tp>::value;

  template <typename _Tp> inline constexpr size_t rank_v = 0;
  template <typename _Tp, size_t _Size>
  inline constexpr size_t rank_v<_Tp[_Size]> = 1 + rank_v<_Tp>;
  template <typename _Tp>
  inline constexpr size_t rank_v<_Tp[]> = 1 + rank_v<_Tp>;

  template <typename _Tp, unsigned _Idx = 0>
  inline constexpr size_t extent_v = 0;
  template <typename _Tp, size_t _Size>
  inline constexpr size_t extent_v<_Tp[_Size], 0> = _Size;
  template <typename _Tp, unsigned _Idx, size_t _Size>
  inline constexpr size_t extent_v<_Tp[_Size], _Idx> = extent_v<_Tp, _Idx - 1>;
  template <typename _Tp> inline constexpr size_t extent_v<_Tp[], 0> = 0;
  template <typename _Tp, unsigned _Idx>
  inline constexpr size_t extent_v<_Tp[], _Idx> = extent_v<_Tp, _Idx - 1>;

  template <typename _Tp, typename _Up>
  inline constexpr bool is_same_v = __is_same(_Tp, _Up);

  template <typename _Base, typename _Derived>
  inline constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

  template <typename _From, typename _To>
  inline constexpr bool is_convertible_v = __is_convertible(_From, _To);

  template <typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
  template <typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_v =
      is_nothrow_invocable<_Fn, _Args...>::value;
  template <typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_r_v =
      is_invocable_r<_Ret, _Fn, _Args...>::value;
  template <typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_r_v =
      is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;

  template <typename _Tp>
  struct has_unique_object_representations
      : bool_constant<__has_unique_object_representations(
            remove_cv_t<remove_all_extents_t<_Tp>>)> {
    static_assert(
        std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
        "template argument must be a complete class or an unbounded array");
  };

  template <typename _Tp>
  inline constexpr bool has_unique_object_representations_v =
      has_unique_object_representations<_Tp>::value;

  template <typename _Tp>
  struct is_aggregate : bool_constant<__is_aggregate(remove_cv_t<_Tp>)> {};

  template <typename _Tp>
  inline constexpr bool is_aggregate_v = __is_aggregate(remove_cv_t<_Tp>);
# 3429 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Tp> struct remove_cvref {
    using type = __remove_cvref(_Tp);
  };
# 3446 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Tp>
  using remove_cvref_t = typename remove_cvref<_Tp>::type;

  template <typename _Tp> struct type_identity {
    using type = _Tp;
  };

  template <typename _Tp>
  using type_identity_t = typename type_identity<_Tp>::type;
# 3468 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  template <typename _Tp> struct unwrap_reference {
    using type = _Tp;
  };

  template <typename _Tp> struct unwrap_reference<reference_wrapper<_Tp>> {
    using type = _Tp &;
  };

  template <typename _Tp>
  using unwrap_reference_t = typename unwrap_reference<_Tp>::type;

  template <typename _Tp> struct unwrap_ref_decay {
    using type = unwrap_reference_t<decay_t<_Tp>>;
  };

  template <typename _Tp>
  using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;

  template <typename _Tp> inline constexpr bool is_bounded_array_v = false;

  template <typename _Tp, size_t _Size>
  inline constexpr bool is_bounded_array_v<_Tp[_Size]> = true;

  template <typename _Tp> inline constexpr bool is_unbounded_array_v = false;

  template <typename _Tp>
  inline constexpr bool is_unbounded_array_v<_Tp[]> = true;

  template <typename _Tp>
  struct is_bounded_array : public bool_constant<is_bounded_array_v<_Tp>> {};

  template <typename _Tp>
  struct is_unbounded_array : public bool_constant<is_unbounded_array_v<_Tp>> {
  };
# 3648 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/type_traits" 3
  constexpr inline bool is_constant_evaluated() noexcept {

    return __builtin_is_constant_evaluated();
  }

  template <typename _From, typename _To>
  using __copy_cv = typename __match_cv_qualifiers<_From, _To>::__type;

  template <typename _Xp, typename _Yp>
  using __cond_res =
      decltype(false ? declval<_Xp (&)()>()() : declval<_Yp (&)()>()());

  template <typename _Ap, typename _Bp, typename = void>
  struct __common_ref_impl {};

  template <typename _Ap, typename _Bp>
  using __common_ref = typename __common_ref_impl<_Ap, _Bp>::type;

  template <typename _Xp, typename _Yp>
  using __condres_cvref =
      __cond_res<__copy_cv<_Xp, _Yp> &, __copy_cv<_Yp, _Xp> &>;

  template <typename _Xp, typename _Yp>
  struct __common_ref_impl<_Xp &, _Yp &, __void_t<__condres_cvref<_Xp, _Yp>>>
      : enable_if<is_reference_v<__condres_cvref<_Xp, _Yp>>,
                  __condres_cvref<_Xp, _Yp>> {};

  template <typename _Xp, typename _Yp>
  using __common_ref_C = remove_reference_t<__common_ref<_Xp &, _Yp &>> &&;

  template <typename _Xp, typename _Yp>
  struct __common_ref_impl<
      _Xp &&, _Yp &&,
      _Require<is_convertible<_Xp &&, __common_ref_C<_Xp, _Yp>>,
               is_convertible<_Yp &&, __common_ref_C<_Xp, _Yp>>>> {
    using type = __common_ref_C<_Xp, _Yp>;
  };

  template <typename _Xp, typename _Yp>
  using __common_ref_D = __common_ref<const _Xp &, _Yp &>;

  template <typename _Xp, typename _Yp>
  struct __common_ref_impl<
      _Xp &&, _Yp &,
      _Require<is_convertible<_Xp &&, __common_ref_D<_Xp, _Yp>>>> {
    using type = __common_ref_D<_Xp, _Yp>;
  };

  template <typename _Xp, typename _Yp>
  struct __common_ref_impl<_Xp &, _Yp &&> : __common_ref_impl<_Yp &&, _Xp &> {};

  template <typename _Tp, typename _Up, template <typename> class _TQual,
            template <typename> class _UQual>
  struct basic_common_reference {};

  template <typename _Tp> struct __xref {
    template <typename _Up> using __type = __copy_cv<_Tp, _Up>;
  };

  template <typename _Tp> struct __xref<_Tp &> {
    template <typename _Up> using __type = __copy_cv<_Tp, _Up> &;
  };

  template <typename _Tp> struct __xref<_Tp &&> {
    template <typename _Up> using __type = __copy_cv<_Tp, _Up> &&;
  };

  template <typename _Tp1, typename _Tp2>
  using __basic_common_ref = typename basic_common_reference<
      remove_cvref_t<_Tp1>, remove_cvref_t<_Tp2>, __xref<_Tp1>::template __type,
      __xref<_Tp2>::template __type>::type;

  template <typename... _Tp> struct common_reference;

  template <typename... _Tp>
  using common_reference_t = typename common_reference<_Tp...>::type;

  template <> struct common_reference<> {};

  template <typename _Tp0> struct common_reference<_Tp0> {
    using type = _Tp0;
  };

  template <typename _Tp1, typename _Tp2, int _Bullet = 1, typename = void>
  struct __common_reference_impl
      : __common_reference_impl<_Tp1, _Tp2, _Bullet + 1> {};

  template <typename _Tp1, typename _Tp2>
  struct common_reference<_Tp1, _Tp2> : __common_reference_impl<_Tp1, _Tp2> {};

  template <typename _Tp1, typename _Tp2>
  struct __common_reference_impl<_Tp1 &, _Tp2 &, 1,
                                 void_t<__common_ref<_Tp1 &, _Tp2 &>>> {
    using type = __common_ref<_Tp1 &, _Tp2 &>;
  };

  template <typename _Tp1, typename _Tp2>
  struct __common_reference_impl<_Tp1 &&, _Tp2 &&, 1,
                                 void_t<__common_ref<_Tp1 &&, _Tp2 &&>>> {
    using type = __common_ref<_Tp1 &&, _Tp2 &&>;
  };

  template <typename _Tp1, typename _Tp2>
  struct __common_reference_impl<_Tp1 &, _Tp2 &&, 1,
                                 void_t<__common_ref<_Tp1 &, _Tp2 &&>>> {
    using type = __common_ref<_Tp1 &, _Tp2 &&>;
  };

  template <typename _Tp1, typename _Tp2>
  struct __common_reference_impl<_Tp1 &&, _Tp2 &, 1,
                                 void_t<__common_ref<_Tp1 &&, _Tp2 &>>> {
    using type = __common_ref<_Tp1 &&, _Tp2 &>;
  };

  template <typename _Tp1, typename _Tp2>
  struct __common_reference_impl<_Tp1, _Tp2, 2,
                                 void_t<__basic_common_ref<_Tp1, _Tp2>>> {
    using type = __basic_common_ref<_Tp1, _Tp2>;
  };

  template <typename _Tp1, typename _Tp2>
  struct __common_reference_impl<_Tp1, _Tp2, 3,
                                 void_t<__cond_res<_Tp1, _Tp2>>> {
    using type = __cond_res<_Tp1, _Tp2>;
  };

  template <typename _Tp1, typename _Tp2>
  struct __common_reference_impl<_Tp1, _Tp2, 4,
                                 void_t<common_type_t<_Tp1, _Tp2>>> {
    using type = common_type_t<_Tp1, _Tp2>;
  };

  template <typename _Tp1, typename _Tp2>
  struct __common_reference_impl<_Tp1, _Tp2, 5, void> {};

  template <typename _Tp1, typename _Tp2, typename... _Rest>
  struct common_reference<_Tp1, _Tp2, _Rest...>
      : __common_type_fold<common_reference<_Tp1, _Tp2>,
                           __common_type_pack<_Rest...>> {};

  template <typename _Tp1, typename _Tp2, typename... _Rest>
  struct __common_type_fold<common_reference<_Tp1, _Tp2>,
                            __common_type_pack<_Rest...>,
                            void_t<common_reference_t<_Tp1, _Tp2>>>
      : public common_reference<common_reference_t<_Tp1, _Tp2>, _Rest...> {};

} // namespace std
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/move.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _Tp>
  inline constexpr _Tp *__addressof(_Tp & __r) noexcept {
    return __builtin_addressof(__r);
  }
# 67 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/move.h" 3
  template <typename _Tp>
  [[__nodiscard__]]
  constexpr _Tp &&forward(typename std::remove_reference<_Tp>::type &
                          __t) noexcept {
    return static_cast<_Tp &&>(__t);
  }

  template <typename _Tp>
  [[__nodiscard__]]
  constexpr _Tp &&forward(typename std::remove_reference<_Tp>::type &&
                          __t) noexcept {
    static_assert(
        !std::is_lvalue_reference<_Tp>::value,
        "std::forward must not be used to convert an rvalue to an lvalue");
    return static_cast<_Tp &&>(__t);
  }

  template <typename _Tp>
  [[__nodiscard__]]
  constexpr
      typename std::remove_reference<_Tp>::type &&move(_Tp && __t) noexcept {
    return static_cast<typename std::remove_reference<_Tp>::type &&>(__t);
  }

  template <typename _Tp>
  struct __move_if_noexcept_cond
      : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                      is_copy_constructible<_Tp>>::type {};
# 114 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/move.h" 3
  template <typename _Tp>
  [[__nodiscard__]]
  constexpr __conditional_t<__move_if_noexcept_cond<_Tp>::value, const _Tp &,
                            _Tp &&> move_if_noexcept(_Tp & __x) noexcept {
    return std::move(__x);
  }
# 135 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/move.h" 3
  template <typename _Tp>
  [[__nodiscard__]]
  inline constexpr _Tp *addressof(_Tp & __r) noexcept {
    return std::__addressof(__r);
  }

  template <typename _Tp> const _Tp *addressof(const _Tp &&) = delete;

  template <typename _Tp, typename _Up = _Tp>
  constexpr inline _Tp __exchange(_Tp & __obj, _Up && __new_val) {
    _Tp __old_val = std::move(__obj);
    __obj = std::forward<_Up>(__new_val);
    return __old_val;
  }
# 179 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/move.h" 3
  template <typename _Tp>
  constexpr inline

      typename enable_if<
          __and_<__not_<__is_tuple_like<_Tp>>, is_move_constructible<_Tp>,
                 is_move_assignable<_Tp>>::value>::type

      swap(_Tp & __a,
           _Tp & __b) noexcept(__and_<is_nothrow_move_constructible<_Tp>,
                                      is_nothrow_move_assignable<_Tp>>::value)

  {

    _Tp __tmp = std::move(__a);
    __a = std::move(__b);
    __b = std::move(__tmp);
  }

  template <typename _Tp, size_t _Nm>
  constexpr inline

      typename enable_if<__is_swappable<_Tp>::value>::type

      swap(_Tp(&__a)[_Nm],
           _Tp(&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value) {
    for (size_t __n = 0; __n < _Nm; ++__n)
      swap(__a[__n], __b[__n]);
  }

} // namespace std
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception_ptr.h" 2 3

extern "C++" {

namespace std __attribute__((__visibility__("default"))) {
  class type_info;

  namespace __exception_ptr {
  class exception_ptr;
  }

  using __exception_ptr::exception_ptr;
# 75 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception_ptr.h" 3
  exception_ptr current_exception() noexcept;

  template <typename _Ex> exception_ptr make_exception_ptr(_Ex) noexcept;

  void rethrow_exception(exception_ptr) __attribute__((__noreturn__));

  namespace __exception_ptr {
  using std::rethrow_exception;
# 97 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception_ptr.h" 3
  class exception_ptr {
    void *_M_exception_object;

    explicit exception_ptr(void *__e) noexcept;

    void _M_addref() noexcept;
    void _M_release() noexcept;

    void *_M_get() const noexcept __attribute__((__pure__));

    friend exception_ptr std::current_exception() noexcept;
    friend void std::rethrow_exception(exception_ptr);
    template <typename _Ex>
    friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

  public:
    exception_ptr() noexcept;

    exception_ptr(const exception_ptr &) noexcept;

    exception_ptr(nullptr_t) noexcept : _M_exception_object(nullptr) {}

    exception_ptr(exception_ptr &&__o) noexcept
        : _M_exception_object(__o._M_exception_object) {
      __o._M_exception_object = nullptr;
    }
# 135 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception_ptr.h" 3
    exception_ptr &operator=(const exception_ptr &) noexcept;

    exception_ptr &operator=(exception_ptr &&__o) noexcept {
      exception_ptr(static_cast<exception_ptr &&>(__o)).swap(*this);
      return *this;
    }

    ~exception_ptr() noexcept;

    void swap(exception_ptr &) noexcept;
# 162 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception_ptr.h" 3
    explicit operator bool() const noexcept { return _M_exception_object; }

    friend bool operator==(const exception_ptr &,
                           const exception_ptr &) noexcept = default;
# 182 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception_ptr.h" 3
    const class std::type_info *__cxa_exception_type() const noexcept
        __attribute__((__pure__));
  };

  inline exception_ptr::exception_ptr() noexcept : _M_exception_object(0) {}

  inline exception_ptr::exception_ptr(const exception_ptr &__other) noexcept
      : _M_exception_object(__other._M_exception_object) {
    if (_M_exception_object)
      _M_addref();
  }

  inline exception_ptr::~exception_ptr() noexcept {
    if (_M_exception_object)
      _M_release();
  }

  inline exception_ptr &
  exception_ptr::operator=(const exception_ptr &__other) noexcept {
    exception_ptr(__other).swap(*this);
    return *this;
  }

  inline void exception_ptr::swap(exception_ptr &__other) noexcept {
    void *__tmp = _M_exception_object;
    _M_exception_object = __other._M_exception_object;
    __other._M_exception_object = __tmp;
  }

  inline void swap(exception_ptr &__lhs, exception_ptr &__rhs) {
    __lhs.swap(__rhs);
  }

  template <typename _Ex>

  inline void __dest_thunk(void *__x) {
    static_cast<_Ex *>(__x)->~_Ex();
  }

  } // namespace __exception_ptr

  using __exception_ptr::swap;

  template <typename _Ex> exception_ptr make_exception_ptr(_Ex __ex) noexcept {

    using _Ex2 = typename decay<_Ex>::type;
    void *__e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
    (void)__cxxabiv1::__cxa_init_primary_exception(
        __e, const_cast<std::type_info *>(&typeid(_Ex)),
        __exception_ptr::__dest_thunk<_Ex2>);
    try {
      ::new (__e) _Ex2(__ex);
      return exception_ptr(__e);
    } catch (...) {
      __cxxabiv1::__cxa_free_exception(__e);
      return current_exception();
    }
# 277 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception_ptr.h" 3
  }
# 291 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/exception_ptr.h" 3
} // namespace std
}
# 165 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/exception" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/nested_exception.h" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/nested_exception.h" 3
extern "C++" {

namespace std __attribute__((__visibility__("default"))) {
# 59 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/nested_exception.h" 3
  class nested_exception {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) {}

    nested_exception(const nested_exception &) noexcept = default;

    nested_exception &operator=(const nested_exception &) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void rethrow_nested() const {
      if (_M_ptr)
        rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr nested_ptr() const noexcept { return _M_ptr; }
  };

  template <typename _Except>
  struct _Nested_exception : public _Except, public nested_exception {
    explicit _Nested_exception(const _Except &__ex) : _Except(__ex) {}

    explicit _Nested_exception(_Except &&__ex)
        : _Except(static_cast<_Except &&>(__ex)) {}
  };
# 145 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/nested_exception.h" 3
  template <typename _Tp>
  [[noreturn]]
  inline void throw_with_nested(_Tp && __t) {
    using _Up = typename decay<_Tp>::type;
    using _CopyConstructible =
        __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
    static_assert(_CopyConstructible::value,
                  "throw_with_nested argument must be CopyConstructible");

    if constexpr (is_class_v<_Up>)
      if constexpr (!is_final_v<_Up>)
        if constexpr (!is_base_of_v<nested_exception, _Up>)
          throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    throw std::forward<_Tp>(__t);
  }
# 203 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/nested_exception.h" 3
  template <typename _Ex>

  inline void rethrow_if_nested(const _Ex &__ex) {
    const _Ex *__ptr = __builtin_addressof(__ex);
# 223 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/nested_exception.h" 3
    if constexpr (!is_polymorphic_v<_Ex>)
      return;
    else if constexpr (is_base_of_v<nested_exception, _Ex> &&
                       !is_convertible_v<_Ex *, nested_exception *>)
      return;

    else if (auto __ne_ptr = dynamic_cast<const nested_exception *>(__ptr))
      __ne_ptr->rethrow_nested();
  }

} // namespace std
}
# 166 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/exception" 2 3
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ios" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/char_traits.h" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/char_traits.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cwchar" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cwchar" 3
# 47 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/char_traits.h" 2 3
# 56 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/char_traits.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/compare" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/compare" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/concepts" 1 3
# 36 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/concepts" 3
# 46 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/concepts" 3
namespace std __attribute__((__visibility__("default"))) {

  namespace __detail {
  template <typename _Tp, typename _Up>
  concept __same_as = std::is_same_v<_Tp, _Up>;
  }

  template <typename _Tp, typename _Up>
  concept same_as =
      __detail::__same_as<_Tp, _Up> && __detail::__same_as<_Up, _Tp>;

  template <typename _Derived, typename _Base>
  concept derived_from =
      __is_base_of(_Base, _Derived) &&
      is_convertible_v<const volatile _Derived *, const volatile _Base *>;

  template <typename _From, typename _To>
  concept convertible_to = is_convertible_v<_From, _To> && requires {
    static_cast<_To>(std::declval<_From>());
  };

  template <typename _Tp, typename _Up>
  concept common_reference_with =
      same_as<common_reference_t<_Tp, _Up>, common_reference_t<_Up, _Tp>> &&
      convertible_to<_Tp, common_reference_t<_Tp, _Up>> &&
      convertible_to<_Up, common_reference_t<_Tp, _Up>>;

  template <typename _Tp, typename _Up>
  concept common_with =
      same_as<common_type_t<_Tp, _Up>, common_type_t<_Up, _Tp>> &&
      requires {
        static_cast<common_type_t<_Tp, _Up>>(std::declval<_Tp>());
        static_cast<common_type_t<_Tp, _Up>>(std::declval<_Up>());
      } &&
      common_reference_with<add_lvalue_reference_t<const _Tp>,
                            add_lvalue_reference_t<const _Up>> &&
      common_reference_with<
          add_lvalue_reference_t<common_type_t<_Tp, _Up>>,
          common_reference_t<add_lvalue_reference_t<const _Tp>,
                             add_lvalue_reference_t<const _Up>>>;

  template <typename _Tp>
  concept integral = is_integral_v<_Tp>;

  template <typename _Tp>
  concept signed_integral = integral<_Tp> && is_signed_v<_Tp>;

  template <typename _Tp>
  concept unsigned_integral = integral<_Tp> && !signed_integral<_Tp>;

  template <typename _Tp>
  concept floating_point = is_floating_point_v<_Tp>;

  namespace __detail {
  template <typename _Tp> using __cref = const remove_reference_t<_Tp> &;

  template <typename _Tp>
  concept __class_or_enum =
      is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;

  template <typename _Tp> constexpr bool __destructible_impl = false;
  template <typename _Tp>
    requires requires(_Tp &__t) {
      { __t.~_Tp() } noexcept;
    }
  constexpr bool __destructible_impl<_Tp> = true;

  template <typename _Tp>
  constexpr bool __destructible = __destructible_impl<_Tp>;
  template <typename _Tp> constexpr bool __destructible<_Tp &> = true;
  template <typename _Tp> constexpr bool __destructible<_Tp &&> = true;
  template <typename _Tp, size_t _Nm>
  constexpr bool __destructible<_Tp[_Nm]> = __destructible<_Tp>;

  } // namespace __detail

  template <typename _Lhs, typename _Rhs>
  concept assignable_from =
      is_lvalue_reference_v<_Lhs> &&
      common_reference_with<__detail::__cref<_Lhs>, __detail::__cref<_Rhs>> &&
      requires(_Lhs __lhs, _Rhs &&__rhs) {
        { __lhs = static_cast<_Rhs &&>(__rhs) } -> same_as<_Lhs>;
      };

  template <typename _Tp>
  concept destructible = __detail::__destructible<_Tp>;

  template <typename _Tp, typename... _Args>
  concept constructible_from =
      destructible<_Tp> && is_constructible_v<_Tp, _Args...>;

  template <typename _Tp>
  concept default_initializable = constructible_from<_Tp> && requires {
    _Tp{};
    (void)::new _Tp;
  };

  template <typename _Tp>
  concept move_constructible =
      constructible_from<_Tp, _Tp> && convertible_to<_Tp, _Tp>;

  template <typename _Tp>
  concept copy_constructible =
      move_constructible<_Tp> && constructible_from<_Tp, _Tp &> &&
      convertible_to<_Tp &, _Tp> && constructible_from<_Tp, const _Tp &> &&
      convertible_to<const _Tp &, _Tp> && constructible_from<_Tp, const _Tp> &&
      convertible_to<const _Tp, _Tp>;

  namespace ranges {
  namespace __cust_swap {
  template <typename _Tp> void swap(_Tp &, _Tp &) = delete;

  template <typename _Tp, typename _Up>
  concept __adl_swap =
      (__detail::__class_or_enum<remove_reference_t<_Tp>> ||
       __detail::__class_or_enum<remove_reference_t<_Up>>) &&
      requires(_Tp &&__t, _Up &&__u) {
        swap(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u));
      };

  struct _Swap {
  private:
    template <typename _Tp, typename _Up> static constexpr bool _S_noexcept() {
      if constexpr (__adl_swap<_Tp, _Up>)
        return noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()));
      else
        return is_nothrow_move_constructible_v<remove_reference_t<_Tp>> &&
               is_nothrow_move_assignable_v<remove_reference_t<_Tp>>;
    }

  public:
    template <typename _Tp, typename _Up>
      requires __adl_swap<_Tp, _Up> ||
               (same_as<_Tp, _Up> && is_lvalue_reference_v<_Tp> &&
                move_constructible<remove_reference_t<_Tp>> &&
                assignable_from<_Tp, remove_reference_t<_Tp>>)
    constexpr void operator()(_Tp &&__t, _Up &&__u) const
        noexcept(_S_noexcept<_Tp, _Up>()) {
      if constexpr (__adl_swap<_Tp, _Up>)
        swap(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u));
      else {
        auto __tmp = static_cast<remove_reference_t<_Tp> &&>(__t);
        __t = static_cast<remove_reference_t<_Tp> &&>(__u);
        __u = static_cast<remove_reference_t<_Tp> &&>(__tmp);
      }
    }

    template <typename _Tp, typename _Up, size_t _Num>
      requires requires(const _Swap &__swap, _Tp &__e1, _Up &__e2) {
        __swap(__e1, __e2);
      }
    constexpr void operator()(_Tp (&__e1)[_Num], _Up (&__e2)[_Num]) const
        noexcept(noexcept(std::declval<const _Swap &>()(*__e1, *__e2))) {
      for (size_t __n = 0; __n < _Num; ++__n)
        (*this)(__e1[__n], __e2[__n]);
    }
  };
  } // namespace __cust_swap

  inline namespace __cust {
  inline constexpr __cust_swap::_Swap swap{};
  }
  } // namespace ranges

  template <typename _Tp>
  concept swappable = requires(_Tp &__a, _Tp &__b) { ranges::swap(__a, __b); };

  template <typename _Tp, typename _Up>
  concept swappable_with =
      common_reference_with<_Tp, _Up> && requires(_Tp &&__t, _Up &&__u) {
        ranges::swap(static_cast<_Tp &&>(__t), static_cast<_Tp &&>(__t));
        ranges::swap(static_cast<_Up &&>(__u), static_cast<_Up &&>(__u));
        ranges::swap(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u));
        ranges::swap(static_cast<_Up &&>(__u), static_cast<_Tp &&>(__t));
      };

  template <typename _Tp>
  concept movable = is_object_v<_Tp> && move_constructible<_Tp> &&
                    assignable_from<_Tp &, _Tp> && swappable<_Tp>;

  template <typename _Tp>
  concept copyable =
      copy_constructible<_Tp> && movable<_Tp> &&
      assignable_from<_Tp &, _Tp &> && assignable_from<_Tp &, const _Tp &> &&
      assignable_from<_Tp &, const _Tp>;

  template <typename _Tp>
  concept semiregular = copyable<_Tp> && default_initializable<_Tp>;

  namespace __detail {
  template <typename _Tp>
  concept __boolean_testable_impl = convertible_to<_Tp, bool>;

  template <typename _Tp>
  concept __boolean_testable =
      __boolean_testable_impl<_Tp> && requires(_Tp &&__t) {
        { !static_cast<_Tp &&>(__t) } -> __boolean_testable_impl;
      };
  } // namespace __detail

  namespace __detail {
  template <typename _Tp, typename _Up>
  concept __weakly_eq_cmp_with =
      requires(__detail::__cref<_Tp> __t, __detail::__cref<_Up> __u) {
        { __t == __u } -> __boolean_testable;
        { __t != __u } -> __boolean_testable;
        { __u == __t } -> __boolean_testable;
        { __u != __t } -> __boolean_testable;
      };
  } // namespace __detail

  template <typename _Tp>
  concept equality_comparable = __detail::__weakly_eq_cmp_with<_Tp, _Tp>;

  template <typename _Tp, typename _Up>
  concept equality_comparable_with =
      equality_comparable<_Tp> && equality_comparable<_Up> &&
      common_reference_with<__detail::__cref<_Tp>, __detail::__cref<_Up>> &&
      equality_comparable<
          common_reference_t<__detail::__cref<_Tp>, __detail::__cref<_Up>>> &&
      __detail::__weakly_eq_cmp_with<_Tp, _Up>;

  namespace __detail {
  template <typename _Tp, typename _Up>
  concept __partially_ordered_with = requires(
      const remove_reference_t<_Tp> &__t, const remove_reference_t<_Up> &__u) {
    { __t < __u } -> __boolean_testable;
    { __t > __u } -> __boolean_testable;
    { __t <= __u } -> __boolean_testable;
    { __t >= __u } -> __boolean_testable;
    { __u < __t } -> __boolean_testable;
    { __u > __t } -> __boolean_testable;
    { __u <= __t } -> __boolean_testable;
    { __u >= __t } -> __boolean_testable;
  };
  } // namespace __detail

  template <typename _Tp>
  concept totally_ordered =
      equality_comparable<_Tp> && __detail::__partially_ordered_with<_Tp, _Tp>;

  template <typename _Tp, typename _Up>
  concept totally_ordered_with =
      totally_ordered<_Tp> && totally_ordered<_Up> &&
      equality_comparable_with<_Tp, _Up> &&
      totally_ordered<
          common_reference_t<__detail::__cref<_Tp>, __detail::__cref<_Up>>> &&
      __detail::__partially_ordered_with<_Tp, _Up>;

  template <typename _Tp>
  concept regular = semiregular<_Tp> && equality_comparable<_Tp>;

  template <typename _Fn, typename... _Args>
  concept invocable = is_invocable_v<_Fn, _Args...>;

  template <typename _Fn, typename... _Args>
  concept regular_invocable = invocable<_Fn, _Args...>;

  template <typename _Fn, typename... _Args>
  concept predicate =
      regular_invocable<_Fn, _Args...> &&
      __detail::__boolean_testable<invoke_result_t<_Fn, _Args...>>;

  template <typename _Rel, typename _Tp, typename _Up>
  concept relation = predicate<_Rel, _Tp, _Tp> && predicate<_Rel, _Up, _Up> &&
                     predicate<_Rel, _Tp, _Up> && predicate<_Rel, _Up, _Tp>;

  template <typename _Rel, typename _Tp, typename _Up>
  concept equivalence_relation = relation<_Rel, _Tp, _Up>;

  template <typename _Rel, typename _Tp, typename _Up>
  concept strict_weak_order = relation<_Rel, _Tp, _Up>;

} // namespace std
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/compare" 2 3

namespace std __attribute__((__visibility__("default"))) {

  namespace __cmp_cat {
  using type = signed char;

  enum class _Ord : type { equivalent = 0, less = -1, greater = 1 };

  enum class _Ncmp : type { _Unordered = 2 };

  struct __unspec {
    consteval __unspec(__unspec *) noexcept {}
  };
  } // namespace __cmp_cat

  class partial_ordering {

    __cmp_cat::type _M_value;

    constexpr explicit partial_ordering(__cmp_cat::_Ord __v) noexcept
        : _M_value(__cmp_cat::type(__v)) {}

    constexpr explicit partial_ordering(__cmp_cat::_Ncmp __v) noexcept
        : _M_value(__cmp_cat::type(__v)) {}

    friend class weak_ordering;
    friend class strong_ordering;

  public:
    static const partial_ordering less;
    static const partial_ordering equivalent;
    static const partial_ordering greater;
    static const partial_ordering unordered;

    [[nodiscard]]
    friend constexpr bool operator==(partial_ordering __v,
                                     __cmp_cat::__unspec) noexcept {
      return __v._M_value == 0;
    }

    [[nodiscard]]
    friend constexpr bool operator==(partial_ordering,
                                     partial_ordering) noexcept = default;

    [[nodiscard]]
    friend constexpr bool operator<(partial_ordering __v,
                                    __cmp_cat::__unspec) noexcept {
      return __v._M_value == -1;
    }

    [[nodiscard]]
    friend constexpr bool operator>(partial_ordering __v,
                                    __cmp_cat::__unspec) noexcept {
      return __v._M_value == 1;
    }

    [[nodiscard]]
    friend constexpr bool operator<=(partial_ordering __v,
                                     __cmp_cat::__unspec) noexcept {
      return __v._M_value <= 0;
    }

    [[nodiscard]]
    friend constexpr bool operator>=(partial_ordering __v,
                                     __cmp_cat::__unspec) noexcept {
      return __cmp_cat::type(__v._M_value & 1) == __v._M_value;
    }

    [[nodiscard]]
    friend constexpr bool operator<(__cmp_cat::__unspec,
                                    partial_ordering __v) noexcept {
      return __v._M_value == 1;
    }

    [[nodiscard]]
    friend constexpr bool operator>(__cmp_cat::__unspec,
                                    partial_ordering __v) noexcept {
      return __v._M_value == -1;
    }

    [[nodiscard]]
    friend constexpr bool operator<=(__cmp_cat::__unspec,
                                     partial_ordering __v) noexcept {
      return __cmp_cat::type(__v._M_value & 1) == __v._M_value;
    }

    [[nodiscard]]
    friend constexpr bool operator>=(__cmp_cat::__unspec,
                                     partial_ordering __v) noexcept {
      return 0 >= __v._M_value;
    }

    [[nodiscard]]
    friend constexpr partial_ordering
    operator<=>(partial_ordering __v, __cmp_cat::__unspec) noexcept {
      return __v;
    }

    [[nodiscard]]
    friend constexpr partial_ordering
    operator<=>(__cmp_cat::__unspec, partial_ordering __v) noexcept {
      if (__v._M_value & 1)
        return partial_ordering(__cmp_cat::_Ord(-__v._M_value));
      else
        return __v;
    }
  };

  inline constexpr partial_ordering partial_ordering::less(
      __cmp_cat::_Ord::less);

  inline constexpr partial_ordering partial_ordering::equivalent(
      __cmp_cat::_Ord::equivalent);

  inline constexpr partial_ordering partial_ordering::greater(
      __cmp_cat::_Ord::greater);

  inline constexpr partial_ordering partial_ordering::unordered(
      __cmp_cat::_Ncmp::_Unordered);

  class weak_ordering {
    __cmp_cat::type _M_value;

    constexpr explicit weak_ordering(__cmp_cat::_Ord __v) noexcept
        : _M_value(__cmp_cat::type(__v)) {}

    friend class strong_ordering;

  public:
    static const weak_ordering less;
    static const weak_ordering equivalent;
    static const weak_ordering greater;

    [[nodiscard]]
    constexpr operator partial_ordering() const noexcept {
      return partial_ordering(__cmp_cat::_Ord(_M_value));
    }

    [[nodiscard]]
    friend constexpr bool operator==(weak_ordering __v,
                                     __cmp_cat::__unspec) noexcept {
      return __v._M_value == 0;
    }

    [[nodiscard]]
    friend constexpr bool operator==(weak_ordering,
                                     weak_ordering) noexcept = default;

    [[nodiscard]]
    friend constexpr bool operator<(weak_ordering __v,
                                    __cmp_cat::__unspec) noexcept {
      return __v._M_value < 0;
    }

    [[nodiscard]]
    friend constexpr bool operator>(weak_ordering __v,
                                    __cmp_cat::__unspec) noexcept {
      return __v._M_value > 0;
    }

    [[nodiscard]]
    friend constexpr bool operator<=(weak_ordering __v,
                                     __cmp_cat::__unspec) noexcept {
      return __v._M_value <= 0;
    }

    [[nodiscard]]
    friend constexpr bool operator>=(weak_ordering __v,
                                     __cmp_cat::__unspec) noexcept {
      return __v._M_value >= 0;
    }

    [[nodiscard]]
    friend constexpr bool operator<(__cmp_cat::__unspec,
                                    weak_ordering __v) noexcept {
      return 0 < __v._M_value;
    }

    [[nodiscard]]
    friend constexpr bool operator>(__cmp_cat::__unspec,
                                    weak_ordering __v) noexcept {
      return 0 > __v._M_value;
    }

    [[nodiscard]]
    friend constexpr bool operator<=(__cmp_cat::__unspec,
                                     weak_ordering __v) noexcept {
      return 0 <= __v._M_value;
    }

    [[nodiscard]]
    friend constexpr bool operator>=(__cmp_cat::__unspec,
                                     weak_ordering __v) noexcept {
      return 0 >= __v._M_value;
    }

    [[nodiscard]]
    friend constexpr weak_ordering operator<=>(weak_ordering __v,
                                               __cmp_cat::__unspec) noexcept {
      return __v;
    }

    [[nodiscard]]
    friend constexpr weak_ordering operator<=>(__cmp_cat::__unspec,
                                               weak_ordering __v) noexcept {
      return weak_ordering(__cmp_cat::_Ord(-__v._M_value));
    }
  };

  inline constexpr weak_ordering weak_ordering::less(__cmp_cat::_Ord::less);

  inline constexpr weak_ordering weak_ordering::equivalent(
      __cmp_cat::_Ord::equivalent);

  inline constexpr weak_ordering weak_ordering::greater(
      __cmp_cat::_Ord::greater);

  class strong_ordering {
    __cmp_cat::type _M_value;

    constexpr explicit strong_ordering(__cmp_cat::_Ord __v) noexcept
        : _M_value(__cmp_cat::type(__v)) {}

  public:
    static const strong_ordering less;
    static const strong_ordering equal;
    static const strong_ordering equivalent;
    static const strong_ordering greater;

    [[nodiscard]]
    constexpr operator partial_ordering() const noexcept {
      return partial_ordering(__cmp_cat::_Ord(_M_value));
    }

    [[nodiscard]]
    constexpr operator weak_ordering() const noexcept {
      return weak_ordering(__cmp_cat::_Ord(_M_value));
    }

    [[nodiscard]]
    friend constexpr bool operator==(strong_ordering __v,
                                     __cmp_cat::__unspec) noexcept {
      return __v._M_value == 0;
    }

    [[nodiscard]]
    friend constexpr bool operator==(strong_ordering,
                                     strong_ordering) noexcept = default;

    [[nodiscard]]
    friend constexpr bool operator<(strong_ordering __v,
                                    __cmp_cat::__unspec) noexcept {
      return __v._M_value < 0;
    }

    [[nodiscard]]
    friend constexpr bool operator>(strong_ordering __v,
                                    __cmp_cat::__unspec) noexcept {
      return __v._M_value > 0;
    }

    [[nodiscard]]
    friend constexpr bool operator<=(strong_ordering __v,
                                     __cmp_cat::__unspec) noexcept {
      return __v._M_value <= 0;
    }

    [[nodiscard]]
    friend constexpr bool operator>=(strong_ordering __v,
                                     __cmp_cat::__unspec) noexcept {
      return __v._M_value >= 0;
    }

    [[nodiscard]]
    friend constexpr bool operator<(__cmp_cat::__unspec,
                                    strong_ordering __v) noexcept {
      return 0 < __v._M_value;
    }

    [[nodiscard]]
    friend constexpr bool operator>(__cmp_cat::__unspec,
                                    strong_ordering __v) noexcept {
      return 0 > __v._M_value;
    }

    [[nodiscard]]
    friend constexpr bool operator<=(__cmp_cat::__unspec,
                                     strong_ordering __v) noexcept {
      return 0 <= __v._M_value;
    }

    [[nodiscard]]
    friend constexpr bool operator>=(__cmp_cat::__unspec,
                                     strong_ordering __v) noexcept {
      return 0 >= __v._M_value;
    }

    [[nodiscard]]
    friend constexpr strong_ordering operator<=>(strong_ordering __v,
                                                 __cmp_cat::__unspec) noexcept {
      return __v;
    }

    [[nodiscard]]
    friend constexpr strong_ordering operator<=>(__cmp_cat::__unspec,
                                                 strong_ordering __v) noexcept {
      return strong_ordering(__cmp_cat::_Ord(-__v._M_value));
    }
  };

  inline constexpr strong_ordering strong_ordering::less(__cmp_cat::_Ord::less);

  inline constexpr strong_ordering strong_ordering::equal(
      __cmp_cat::_Ord::equivalent);

  inline constexpr strong_ordering strong_ordering::equivalent(
      __cmp_cat::_Ord::equivalent);

  inline constexpr strong_ordering strong_ordering::greater(
      __cmp_cat::_Ord::greater);

  [[nodiscard]]
  constexpr bool is_eq(partial_ordering __cmp) noexcept {
    return __cmp == 0;
  }

  [[nodiscard]]
  constexpr bool is_neq(partial_ordering __cmp) noexcept {
    return __cmp != 0;
  }

  [[nodiscard]]
  constexpr bool is_lt(partial_ordering __cmp) noexcept {
    return __cmp < 0;
  }

  [[nodiscard]]
  constexpr bool is_lteq(partial_ordering __cmp) noexcept {
    return __cmp <= 0;
  }

  [[nodiscard]]
  constexpr bool is_gt(partial_ordering __cmp) noexcept {
    return __cmp > 0;
  }

  [[nodiscard]]
  constexpr bool is_gteq(partial_ordering __cmp) noexcept {
    return __cmp >= 0;
  }

  namespace __detail {
  template <typename _Tp> inline constexpr unsigned __cmp_cat_id = 1;
  template <> inline constexpr unsigned __cmp_cat_id<partial_ordering> = 2;
  template <> inline constexpr unsigned __cmp_cat_id<weak_ordering> = 4;
  template <> inline constexpr unsigned __cmp_cat_id<strong_ordering> = 8;

  template <typename... _Ts> constexpr auto __common_cmp_cat() {
    constexpr unsigned __cats = (__cmp_cat_id<_Ts> | ...);

    if constexpr (__cats & 1)
      return;

    else if constexpr (bool(__cats & __cmp_cat_id<partial_ordering>))
      return partial_ordering::equivalent;

    else if constexpr (bool(__cats & __cmp_cat_id<weak_ordering>))
      return weak_ordering::equivalent;

    else
      return strong_ordering::equivalent;
  }
  } // namespace __detail

  template <typename... _Ts> struct common_comparison_category {
    using type = decltype(__detail::__common_cmp_cat<_Ts...>());
  };

  template <typename _Tp> struct common_comparison_category<_Tp> {
    using type = void;
  };

  template <> struct common_comparison_category<partial_ordering> {
    using type = partial_ordering;
  };

  template <> struct common_comparison_category<weak_ordering> {
    using type = weak_ordering;
  };

  template <> struct common_comparison_category<strong_ordering> {
    using type = strong_ordering;
  };

  template <> struct common_comparison_category<> {
    using type = strong_ordering;
  };

  template <typename... _Ts>
  using common_comparison_category_t =
      typename common_comparison_category<_Ts...>::type;

  namespace __detail {
  template <typename _Tp, typename _Cat>
  concept __compares_as =
      same_as<common_comparison_category_t<_Tp, _Cat>, _Cat>;
  }

  template <typename _Tp, typename _Cat = partial_ordering>
  concept three_way_comparable = __detail::__weakly_eq_cmp_with<_Tp, _Tp> &&
                                 __detail::__partially_ordered_with<_Tp, _Tp> &&
                                 requires(const remove_reference_t<_Tp> &__a,
                                          const remove_reference_t<_Tp> &__b) {
                                   {
                                     __a <=> __b
                                   } -> __detail::__compares_as<_Cat>;
                                 };

  template <typename _Tp, typename _Up, typename _Cat = partial_ordering>
  concept three_way_comparable_with =
      three_way_comparable<_Tp, _Cat> && three_way_comparable<_Up, _Cat> &&
      common_reference_with<const remove_reference_t<_Tp> &,
                            const remove_reference_t<_Up> &> &&
      three_way_comparable<common_reference_t<const remove_reference_t<_Tp> &,
                                              const remove_reference_t<_Up> &>,
                           _Cat> &&
      __detail::__weakly_eq_cmp_with<_Tp, _Up> &&
      __detail::__partially_ordered_with<_Tp, _Up> &&
      requires(const remove_reference_t<_Tp> &__t,
               const remove_reference_t<_Up> &__u) {
        { __t <=> __u } -> __detail::__compares_as<_Cat>;
        { __u <=> __t } -> __detail::__compares_as<_Cat>;
      };

  namespace __detail {
  template <typename _Tp, typename _Up>
  using __cmp3way_res_t = decltype(std::declval<_Tp>() <=> std::declval<_Up>());

  template <typename _Tp, typename _Up> struct __cmp3way_res_impl {};

  template <typename _Tp, typename _Up>
    requires requires { typename __cmp3way_res_t<__cref<_Tp>, __cref<_Up>>; }
  struct __cmp3way_res_impl<_Tp, _Up> {
    using type = __cmp3way_res_t<__cref<_Tp>, __cref<_Up>>;
  };
  } // namespace __detail

  template <typename _Tp, typename _Up = _Tp>
  struct compare_three_way_result : __detail::__cmp3way_res_impl<_Tp, _Up> {};

  template <typename _Tp, typename _Up = _Tp>
  using compare_three_way_result_t =
      typename __detail::__cmp3way_res_impl<_Tp, _Up>::type;

  namespace __detail {

  template <typename _Tp, typename _Up>
  concept __3way_builtin_ptr_cmp =
      requires(_Tp &&__t, _Up &&__u) {
        static_cast<_Tp &&>(__t) <=> static_cast<_Up &&>(__u);
      } && convertible_to<_Tp, const volatile void *> &&
      convertible_to<_Up, const volatile void *> &&
      !requires(_Tp &&__t, _Up &&__u) {
        operator<=>(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u));
      } && !requires(_Tp &&__t, _Up &&__u) {
        static_cast<_Tp &&>(__t).operator<=>(static_cast<_Up &&>(__u));
      };
  } // namespace __detail

  struct compare_three_way {
    template <typename _Tp, typename _Up>
      requires three_way_comparable_with<_Tp, _Up>
    constexpr auto operator() [[nodiscard]] (_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::declval<_Tp>() <=> std::declval<_Up>())) {
      if constexpr (__detail::__3way_builtin_ptr_cmp<_Tp, _Up>) {
        auto __pt = static_cast<const volatile void *>(__t);
        auto __pu = static_cast<const volatile void *>(__u);
        if (std::__is_constant_evaluated())
          return __pt <=> __pu;
        auto __it = reinterpret_cast<long unsigned int>(__pt);
        auto __iu = reinterpret_cast<long unsigned int>(__pu);
        return __it <=> __iu;
      } else
        return static_cast<_Tp &&>(__t) <=> static_cast<_Up &&>(__u);
    }

    using is_transparent = void;
  };

  namespace __cmp_cust {
  template <floating_point _Tp>
  constexpr weak_ordering __fp_weak_ordering(_Tp __e, _Tp __f) {

    auto __cat = [](_Tp __fp) -> int {
      const int __sign = __builtin_signbit(__fp) ? -1 : 1;
      if (__builtin_isnormal(__fp))
        return (__fp == 0 ? 1 : 3) * __sign;
      if (__builtin_isnan(__fp))
        return 5 * __sign;
      if (int __inf = __builtin_isinf_sign(__fp))
        return 4 * __inf;
      return 2 * __sign;
    };

    auto __po = __e <=> __f;
    if (is_lt(__po))
      return weak_ordering::less;
    else if (is_gt(__po))
      return weak_ordering::greater;
    else if (__po == partial_ordering::equivalent)
      return weak_ordering::equivalent;
    else {

      auto __isnan_sign = [](_Tp __fp) -> int {
        return __builtin_isnan(__fp) ? __builtin_signbit(__fp) ? -1 : 1 : 0;
      };
      auto __ord = __isnan_sign(__e) <=> __isnan_sign(__f);
      if (is_eq(__ord))
        return weak_ordering::equivalent;
      else if (is_lt(__ord))
        return weak_ordering::less;
      else
        return weak_ordering::greater;
    }
  }

  template <typename _Tp, typename _Up>
  concept __adl_strong = requires(_Tp &&__t, _Up &&__u) {
    strong_ordering(
        strong_order(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u)));
  };

  template <typename _Tp, typename _Up>
  concept __adl_weak = requires(_Tp &&__t, _Up &&__u) {
    weak_ordering(
        weak_order(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u)));
  };

  template <typename _Tp, typename _Up>
  concept __adl_partial = requires(_Tp &&__t, _Up &&__u) {
    partial_ordering(
        partial_order(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u)));
  };

  template <typename _Ord, typename _Tp, typename _Up>
  concept __cmp3way = requires(_Tp &&__t, _Up &&__u, compare_three_way __c) {
    _Ord(__c(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u)));
  };

  template <typename _Tp, typename _Up>
  concept __strongly_ordered =
      __adl_strong<_Tp, _Up> || floating_point<remove_reference_t<_Tp>> ||
      __cmp3way<strong_ordering, _Tp, _Up>;

  template <typename _Tp, typename _Up>
  concept __decayed_same_as = same_as<decay_t<_Tp>, decay_t<_Up>>;

  class _Strong_order {
    template <typename _Tp, typename _Up> static constexpr bool _S_noexcept() {
      if constexpr (floating_point<decay_t<_Tp>>)
        return true;
      else if constexpr (__adl_strong<_Tp, _Up>)
        return noexcept(strong_ordering(
            strong_order(std::declval<_Tp>(), std::declval<_Up>())));
      else if constexpr (__cmp3way<strong_ordering, _Tp, _Up>)
        return noexcept(
            compare_three_way()(std::declval<_Tp>(), std::declval<_Up>()));
    }

    friend class _Weak_order;
    friend class _Strong_fallback;

    enum class _Fp_fmt {
      _Binary16,
      _Binary32,
      _Binary64,
      _Binary128,
      _X86_80bit,
      _M68k_80bit,
      _Dbldbl,
      _Bfloat16,
    };
# 691 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/compare" 3
    template <typename _Tp> static consteval _Fp_fmt _S_fp_fmt() noexcept {

      using enum _Fp_fmt;
# 711 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/compare" 3
      if constexpr (__is_same(_Tp, long double))
        return (-16381) == -16381 ? _X86_80bit : _M68k_80bit;
# 723 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/compare" 3
      constexpr int __width = sizeof(_Tp) * 8;

      if constexpr (__width == 16)
        return _Binary16;
      else if constexpr (__width == 32)
        return _Binary32;
      else if constexpr (__width == 64)
        return _Binary64;
      else if constexpr (__width == 128)
        return _Binary128;
    }

    using int64_t = long int;
    using int32_t = int;
    using int16_t = short;
    using uint64_t = long unsigned int;
    using uint16_t = unsigned short;

    template <typename _Tp> struct _Int {

      uint64_t _M_lo;
      _Tp _M_hi;

      constexpr explicit _Int(_Tp __hi, uint64_t __lo) noexcept : _M_hi(__hi) {
        _M_lo = __lo;
      }

      constexpr explicit _Int(uint64_t __lo) noexcept : _M_hi(0) {
        _M_lo = __lo;
      }

      constexpr bool operator==(const _Int &) const = default;
# 773 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/compare" 3
      constexpr _Int &operator^=(const _Int &__rhs) noexcept {
        _M_hi ^= __rhs._M_hi;
        _M_lo ^= __rhs._M_lo;
        return *this;
      }

      constexpr strong_ordering operator<=>(const _Int &__rhs) const noexcept {
        strong_ordering __cmp = _M_hi <=> __rhs._M_hi;
        if (__cmp != strong_ordering::equal)
          return __cmp;
        return _M_lo <=> __rhs._M_lo;
      }
    };

    template <typename _Tp> static constexpr _Tp _S_compl(_Tp __t) noexcept {
      constexpr int __width = sizeof(_Tp) * 8;

      make_unsigned_t<_Tp> __sign = __t >> (__width - 1);

      return __t ^ (__sign >> 1);
    }

    template <typename _Tp>
    static constexpr _Int<_Tp> _S_compl(_Int<_Tp> __t) noexcept {
      constexpr int __width = sizeof(_Tp) * 8;
      make_unsigned_t<_Tp> __sign = __t._M_hi >> (__width - 1);
      __t._M_hi ^= (__sign >> 1);
      uint64_t __sign64 = (_Tp)__sign;
      __t._M_lo ^= __sign64;
      return __t;
    }

    template <typename _Tp>
    constexpr static auto _S_fp_bits(_Tp __val) noexcept {
      if constexpr (sizeof(_Tp) == sizeof(int64_t))
        return __builtin_bit_cast(int64_t, __val);
      else if constexpr (sizeof(_Tp) == sizeof(int32_t))
        return __builtin_bit_cast(int32_t, __val);
      else if constexpr (sizeof(_Tp) == sizeof(int16_t))
        return __builtin_bit_cast(int16_t, __val);
      else {

        using enum _Fp_fmt;

        constexpr auto __fmt = _S_fp_fmt<_Tp>();
        if constexpr (__fmt == _X86_80bit || __fmt == _M68k_80bit) {
          if constexpr (sizeof(_Tp) == 3 * sizeof(int32_t)) {
            auto __ival = __builtin_bit_cast(_Int<int32_t>, __val);
            return _Int<int16_t>(__ival._M_hi, __ival._M_lo);
          } else {
            auto __ival = __builtin_bit_cast(_Int<int64_t>, __val);
            return _Int<int16_t>(__ival._M_hi, __ival._M_lo);
          }
        } else if constexpr (sizeof(_Tp) == 2 * sizeof(int64_t)) {

          return __builtin_bit_cast(__int128, __val);

        } else
          static_assert(sizeof(_Tp) == sizeof(int64_t),
                        "unsupported floating-point type");
      }
    }

    template <typename _Tp>
    static constexpr strong_ordering _S_fp_cmp(_Tp __x, _Tp __y) noexcept {
# 877 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/compare" 3
      auto __ix = _S_fp_bits(__x);
      auto __iy = _S_fp_bits(__y);

      if (__ix == __iy)
        return strong_ordering::equal;

      using enum _Fp_fmt;

      constexpr auto __fmt = _S_fp_fmt<_Tp>();

      if constexpr (__fmt == _Dbldbl) {

        struct _Unpacked {
          double _M_hi;
          int64_t _M_lo;
        };
        auto __x2 = __builtin_bit_cast(_Unpacked, __x);
        auto __y2 = __builtin_bit_cast(_Unpacked, __y);

        auto __cmp = _S_fp_cmp(__x2._M_hi, __y2._M_hi);
        if (__cmp != strong_ordering::equal)
          return __cmp;

        if (__builtin_isnan(__x2._M_hi))
          return strong_ordering::equal;

        if (((__x2._M_lo | __y2._M_lo) & 0x7fffffffffffffffULL) == 0)
          return strong_ordering::equal;

        return _S_compl(__x2._M_lo) <=> _S_compl(__y2._M_lo);
      } else {
        if constexpr (__fmt == _M68k_80bit) {

          constexpr uint16_t __maxexp = 0x7fff;
          if ((__ix._M_hi & __maxexp) == __maxexp)
            __ix._M_lo |= 1ull << 63;
          if ((__iy._M_hi & __maxexp) == __maxexp)
            __iy._M_lo |= 1ull << 63;
        } else {
# 944 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/compare" 3
        }
        return _S_compl(__ix) <=> _S_compl(__iy);
      }
    }

  public:
    template <typename _Tp, __decayed_same_as<_Tp> _Up>
      requires __strongly_ordered<_Tp, _Up>
    constexpr strong_ordering operator()
        [[nodiscard]] (_Tp &&__e, _Up &&__f) const
        noexcept(_S_noexcept<_Tp, _Up>()) {
      if constexpr (floating_point<decay_t<_Tp>>)
        return _S_fp_cmp(__e, __f);
      else if constexpr (__adl_strong<_Tp, _Up>)
        return strong_ordering(
            strong_order(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f)));
      else if constexpr (__cmp3way<strong_ordering, _Tp, _Up>)
        return compare_three_way()(static_cast<_Tp &&>(__e),
                                   static_cast<_Up &&>(__f));
    }
  };

  template <typename _Tp, typename _Up>
  concept __weakly_ordered =
      floating_point<remove_reference_t<_Tp>> || __adl_weak<_Tp, _Up> ||
      __cmp3way<weak_ordering, _Tp, _Up> || __strongly_ordered<_Tp, _Up>;

  class _Weak_order {
    template <typename _Tp, typename _Up> static constexpr bool _S_noexcept() {
      if constexpr (floating_point<decay_t<_Tp>>)
        return true;
      else if constexpr (__adl_weak<_Tp, _Up>)
        return noexcept(weak_ordering(
            weak_order(std::declval<_Tp>(), std::declval<_Up>())));
      else if constexpr (__cmp3way<weak_ordering, _Tp, _Up>)
        return noexcept(
            compare_three_way()(std::declval<_Tp>(), std::declval<_Up>()));
      else if constexpr (__strongly_ordered<_Tp, _Up>)
        return _Strong_order::_S_noexcept<_Tp, _Up>();
    }

    friend class _Partial_order;
    friend class _Weak_fallback;

  public:
    template <typename _Tp, __decayed_same_as<_Tp> _Up>
      requires __weakly_ordered<_Tp, _Up>
    constexpr weak_ordering operator()
        [[nodiscard]] (_Tp &&__e, _Up &&__f) const
        noexcept(_S_noexcept<_Tp, _Up>()) {
      if constexpr (floating_point<decay_t<_Tp>>)
        return __cmp_cust::__fp_weak_ordering(__e, __f);
      else if constexpr (__adl_weak<_Tp, _Up>)
        return weak_ordering(
            weak_order(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f)));
      else if constexpr (__cmp3way<weak_ordering, _Tp, _Up>)
        return compare_three_way()(static_cast<_Tp &&>(__e),
                                   static_cast<_Up &&>(__f));
      else if constexpr (__strongly_ordered<_Tp, _Up>)
        return _Strong_order{}(static_cast<_Tp &&>(__e),
                               static_cast<_Up &&>(__f));
    }
  };

  template <typename _Tp, typename _Up>
  concept __partially_ordered =
      __adl_partial<_Tp, _Up> || __cmp3way<partial_ordering, _Tp, _Up> ||
      __weakly_ordered<_Tp, _Up>;

  class _Partial_order {
    template <typename _Tp, typename _Up> static constexpr bool _S_noexcept() {
      if constexpr (__adl_partial<_Tp, _Up>)
        return noexcept(partial_ordering(
            partial_order(std::declval<_Tp>(), std::declval<_Up>())));
      else if constexpr (__cmp3way<partial_ordering, _Tp, _Up>)
        return noexcept(
            compare_three_way()(std::declval<_Tp>(), std::declval<_Up>()));
      else if constexpr (__weakly_ordered<_Tp, _Up>)
        return _Weak_order::_S_noexcept<_Tp, _Up>();
    }

    friend class _Partial_fallback;

  public:
    template <typename _Tp, __decayed_same_as<_Tp> _Up>
      requires __partially_ordered<_Tp, _Up>
    constexpr partial_ordering operator()
        [[nodiscard]] (_Tp &&__e, _Up &&__f) const
        noexcept(_S_noexcept<_Tp, _Up>()) {
      if constexpr (__adl_partial<_Tp, _Up>)
        return partial_ordering(
            partial_order(static_cast<_Tp &&>(__e), static_cast<_Up &&>(__f)));
      else if constexpr (__cmp3way<partial_ordering, _Tp, _Up>)
        return compare_three_way()(static_cast<_Tp &&>(__e),
                                   static_cast<_Up &&>(__f));
      else if constexpr (__weakly_ordered<_Tp, _Up>)
        return _Weak_order{}(static_cast<_Tp &&>(__e),
                             static_cast<_Up &&>(__f));
    }
  };

  template <typename _Tp, typename _Up>
  concept __op_eq_lt = requires(_Tp &&__t, _Up &&__u) {
    {
      static_cast<_Tp &&>(__t) == static_cast<_Up &&>(__u)
    } -> convertible_to<bool>;
    {
      static_cast<_Tp &&>(__t) < static_cast<_Up &&>(__u)
    } -> convertible_to<bool>;
  };

  class _Strong_fallback {
    template <typename _Tp, typename _Up> static constexpr bool _S_noexcept() {
      if constexpr (__strongly_ordered<_Tp, _Up>)
        return _Strong_order::_S_noexcept<_Tp, _Up>();
      else
        return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>())) &&
               noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
    }

  public:
    template <typename _Tp, __decayed_same_as<_Tp> _Up>
      requires __strongly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>
    constexpr strong_ordering operator()
        [[nodiscard]] (_Tp &&__e, _Up &&__f) const
        noexcept(_S_noexcept<_Tp, _Up>()) {
      if constexpr (__strongly_ordered<_Tp, _Up>)
        return _Strong_order{}(static_cast<_Tp &&>(__e),
                               static_cast<_Up &&>(__f));
      else
        return static_cast<_Tp &&>(__e) == static_cast<_Up &&>(__f)
                   ? strong_ordering::equal
               : static_cast<_Tp &&>(__e) < static_cast<_Up &&>(__f)
                   ? strong_ordering::less
                   : strong_ordering::greater;
    }
  };

  class _Weak_fallback {
    template <typename _Tp, typename _Up> static constexpr bool _S_noexcept() {
      if constexpr (__weakly_ordered<_Tp, _Up>)
        return _Weak_order::_S_noexcept<_Tp, _Up>();
      else
        return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>())) &&
               noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
    }

  public:
    template <typename _Tp, __decayed_same_as<_Tp> _Up>
      requires __weakly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>
    constexpr weak_ordering operator()
        [[nodiscard]] (_Tp &&__e, _Up &&__f) const
        noexcept(_S_noexcept<_Tp, _Up>()) {
      if constexpr (__weakly_ordered<_Tp, _Up>)
        return _Weak_order{}(static_cast<_Tp &&>(__e),
                             static_cast<_Up &&>(__f));
      else
        return static_cast<_Tp &&>(__e) == static_cast<_Up &&>(__f)
                   ? weak_ordering::equivalent
               : static_cast<_Tp &&>(__e) < static_cast<_Up &&>(__f)
                   ? weak_ordering::less
                   : weak_ordering::greater;
    }
  };

  template <typename _Tp, typename _Up>
  concept __op_eq_lt_lt =
      __op_eq_lt<_Tp, _Up> && requires(_Tp &&__t, _Up &&__u) {
        {
          static_cast<_Up &&>(__u) < static_cast<_Tp &&>(__t)
        } -> convertible_to<bool>;
      };

  class _Partial_fallback {
    template <typename _Tp, typename _Up> static constexpr bool _S_noexcept() {
      if constexpr (__partially_ordered<_Tp, _Up>)
        return _Partial_order::_S_noexcept<_Tp, _Up>();
      else
        return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>())) &&
               noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
    }

  public:
    template <typename _Tp, __decayed_same_as<_Tp> _Up>
      requires __partially_ordered<_Tp, _Up> || __op_eq_lt_lt<_Tp, _Up>
    constexpr partial_ordering operator()
        [[nodiscard]] (_Tp &&__e, _Up &&__f) const
        noexcept(_S_noexcept<_Tp, _Up>()) {
      if constexpr (__partially_ordered<_Tp, _Up>)
        return _Partial_order{}(static_cast<_Tp &&>(__e),
                                static_cast<_Up &&>(__f));
      else
        return static_cast<_Tp &&>(__e) == static_cast<_Up &&>(__f)
                   ? partial_ordering::equivalent
               : static_cast<_Tp &&>(__e) < static_cast<_Up &&>(__f)
                   ? partial_ordering::less
               : static_cast<_Up &&>(__f) < static_cast<_Tp &&>(__e)
                   ? partial_ordering::greater
                   : partial_ordering::unordered;
    }
  };
  } // namespace __cmp_cust

  inline namespace __cmp_alg {
  inline constexpr __cmp_cust::_Strong_order strong_order{};

  inline constexpr __cmp_cust::_Weak_order weak_order{};

  inline constexpr __cmp_cust::_Partial_order partial_order{};

  inline constexpr __cmp_cust::_Strong_fallback compare_strong_order_fallback{};

  inline constexpr __cmp_cust::_Weak_fallback compare_weak_order_fallback{};

  inline constexpr __cmp_cust::_Partial_fallback
      compare_partial_order_fallback{};
  } // namespace __cmp_alg

  namespace __detail {

  inline constexpr struct _Synth3way {
    template <typename _Tp, typename _Up>
    static constexpr bool _S_noexcept(const _Tp *__t = nullptr,
                                      const _Up *__u = nullptr) {
      if constexpr (three_way_comparable_with<_Tp, _Up>)
        return noexcept(*__t <=> *__u);
      else
        return noexcept(*__t < *__u) && noexcept(*__u < *__t);
    }

    template <typename _Tp, typename _Up>
    [[nodiscard]]
    constexpr auto operator()(const _Tp &__t, const _Up &__u) const
        noexcept(_S_noexcept<_Tp, _Up>())
      requires requires {
        { __t < __u } -> __boolean_testable;
        { __u < __t } -> __boolean_testable;
      }
    {
      if constexpr (three_way_comparable_with<_Tp, _Up>)
        return __t <=> __u;
      else {
        if (__t < __u)
          return weak_ordering::less;
        else if (__u < __t)
          return weak_ordering::greater;
        else
          return weak_ordering::equivalent;
      }
    }
  } __synth3way = {};

  template <typename _Tp, typename _Up = _Tp>
  using __synth3way_t = decltype(__detail::__synth3way(std::declval<_Tp &>(),
                                                       std::declval<_Up &>()));
  } // namespace __detail

} // namespace std
# 57 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/char_traits.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_construct.h" 1 3
# 61 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_construct.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator_base_types.h" 1 3
# 63 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator_base_types.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/iterator_concepts.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/iterator_concepts.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ptr_traits.h" 1 3
# 46 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ptr_traits.h" 3
namespace __gnu_debug {
struct _Safe_iterator_base;
}

namespace std __attribute__((__visibility__("default"))) {

  class __undefined;

  template <typename _Tp> struct __get_first_arg {
    using type = __undefined;
  };

  template <template <typename, typename...> class _SomeTemplate, typename _Tp,
            typename... _Types>
  struct __get_first_arg<_SomeTemplate<_Tp, _Types...>> {
    using type = _Tp;
  };

  template <typename _Tp, typename _Up> struct __replace_first_arg {};

  template <template <typename, typename...> class _SomeTemplate, typename _Up,
            typename _Tp, typename... _Types>
  struct __replace_first_arg<_SomeTemplate<_Tp, _Types...>, _Up> {
    using type = _SomeTemplate<_Up, _Types...>;
  };

  template <typename _Ptr, typename = void>
  struct __ptr_traits_elem : __get_first_arg<_Ptr> {};

  template <typename _Ptr>
    requires requires { typename _Ptr::element_type; }
  struct __ptr_traits_elem<_Ptr, void> {
    using type = typename _Ptr::element_type;
  };

  template <typename _Ptr>
  using __ptr_traits_elem_t = typename __ptr_traits_elem<_Ptr>::type;

  template <typename _Ptr, typename _Elt, bool = is_void<_Elt>::value>
  struct __ptr_traits_ptr_to {
    using pointer = _Ptr;
    using element_type = _Elt;

    static pointer pointer_to(element_type &__r)

      requires requires {
        { pointer::pointer_to(__r) } -> convertible_to<pointer>;
      }

    {
      return pointer::pointer_to(__r);
    }
  };

  template <typename _Ptr, typename _Elt>
  struct __ptr_traits_ptr_to<_Ptr, _Elt, true> {};

  template <typename _Tp> struct __ptr_traits_ptr_to<_Tp *, _Tp, false> {
    using pointer = _Tp *;
    using element_type = _Tp;

    static constexpr pointer pointer_to(element_type &__r) noexcept {
      return std::addressof(__r);
    }
  };

  template <typename _Ptr, typename _Elt>
  struct __ptr_traits_impl : __ptr_traits_ptr_to<_Ptr, _Elt> {
  private:
    template <typename _Tp> using __diff_t = typename _Tp::difference_type;

    template <typename _Tp, typename _Up>
    using __rebind = __type_identity<typename _Tp::template rebind<_Up>>;

  public:
    using pointer = _Ptr;

    using element_type = _Elt;

    using difference_type = __detected_or_t<ptrdiff_t, __diff_t, _Ptr>;

    template <typename _Up>
    using rebind = typename __detected_or_t<__replace_first_arg<_Ptr, _Up>,
                                            __rebind, _Ptr, _Up>::type;
  };

  template <typename _Ptr> struct __ptr_traits_impl<_Ptr, __undefined> {};

  template <typename _Ptr>
  struct pointer_traits : __ptr_traits_impl<_Ptr, __ptr_traits_elem_t<_Ptr>> {};

  template <typename _Tp>
  struct pointer_traits<_Tp *> : __ptr_traits_ptr_to<_Tp *, _Tp> {

    typedef _Tp *pointer;

    typedef _Tp element_type;

    typedef ptrdiff_t difference_type;

    template <typename _Up> using rebind = _Up *;
  };

  template <typename _Ptr, typename _Tp>
  using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template <typename _Tp> constexpr _Tp *__to_address(_Tp * __ptr) noexcept {
    static_assert(!std::is_function<_Tp>::value, "not a function pointer");
    return __ptr;
  }

  template <typename _Ptr>
  constexpr auto __to_address(const _Ptr &__ptr) noexcept
      -> decltype(std::pointer_traits<_Ptr>::to_address(__ptr)) {
    return std::pointer_traits<_Ptr>::to_address(__ptr);
  }

  template <typename _Ptr, typename... _None>
  constexpr auto __to_address(const _Ptr &__ptr, _None...) noexcept {
    if constexpr (is_base_of_v<__gnu_debug::_Safe_iterator_base, _Ptr>)
      return std::__to_address(__ptr.base().operator->());
    else
      return std::__to_address(__ptr.operator->());
  }
# 248 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ptr_traits.h" 3
  template <typename _Tp> constexpr _Tp *to_address(_Tp * __ptr) noexcept {
    return std::__to_address(__ptr);
  }
# 260 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ptr_traits.h" 3
  template <typename _Ptr>
  constexpr auto to_address(const _Ptr &__ptr) noexcept {
    return std::__to_address(__ptr);
  }

} // namespace std
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/iterator_concepts.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_cmp.h" 1 3
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_cmp.h" 3
namespace std __attribute__((__visibility__("default"))) {

  struct __is_transparent;

  struct identity {
    template <typename _Tp>
    [[nodiscard]]
    constexpr _Tp &&operator()(_Tp &&__t) const noexcept {
      return std::forward<_Tp>(__t);
    }

    using is_transparent = __is_transparent;
  };
# 66 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_cmp.h" 3
  namespace ranges {
  namespace __detail {

  template<typename _Tp, typename _Up>
      concept __less_builtin_ptr_cmp
 = requires (_Tp&& __t, _Up&& __u) { { __t < __u } -> same_as<bool>; }
   && convertible_to<_Tp, const volatile void*>
   && convertible_to<_Up, const volatile void*>
   && (! requires(_Tp&& __t, _Up&& __u)
       { operator<(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }
       && ! requires(_Tp&& __t, _Up&& __u)
       { std::forward<_Tp>(__t).operator<(std::forward<_Up>(__u)); });
  } // namespace __detail

  struct equal_to {
    template <typename _Tp, typename _Up>
      requires equality_comparable_with<_Tp, _Up>
    constexpr bool operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::declval<_Tp>() == std::declval<_Up>())) {
      return std::forward<_Tp>(__t) == std::forward<_Up>(__u);
    }

    using is_transparent = __is_transparent;
  };

  struct not_equal_to {
    template <typename _Tp, typename _Up>
      requires equality_comparable_with<_Tp, _Up>
    constexpr bool operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::declval<_Up>() == std::declval<_Tp>())) {
      return !equal_to{}(std::forward<_Tp>(__t), std::forward<_Up>(__u));
    }

    using is_transparent = __is_transparent;
  };

  struct less {
    template <typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
    constexpr bool operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>())) {
      if constexpr (__detail::__less_builtin_ptr_cmp<_Tp, _Up>) {
        if (std::__is_constant_evaluated())
          return __t < __u;

        auto __x = reinterpret_cast<long unsigned int>(
            static_cast<const volatile void *>(std::forward<_Tp>(__t)));
        auto __y = reinterpret_cast<long unsigned int>(
            static_cast<const volatile void *>(std::forward<_Up>(__u)));
        return __x < __y;
      } else
        return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
    }

    using is_transparent = __is_transparent;
  };

  struct greater {
    template <typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
    constexpr bool operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>())) {
      return less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t));
    }

    using is_transparent = __is_transparent;
  };

  struct greater_equal {
    template <typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
    constexpr bool operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>())) {
      return !less{}(std::forward<_Tp>(__t), std::forward<_Up>(__u));
    }

    using is_transparent = __is_transparent;
  };

  struct less_equal {
    template <typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
    constexpr bool operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>())) {
      return !less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t));
    }

    using is_transparent = __is_transparent;
  };

  } // namespace ranges

} // namespace std
# 39 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/iterator_concepts.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 58 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/iterator_concepts.h" 3
  struct default_sentinel_t {};

  inline constexpr default_sentinel_t default_sentinel{};

  struct input_iterator_tag;
  struct output_iterator_tag;
  struct forward_iterator_tag;
  struct bidirectional_iterator_tag;
  struct random_access_iterator_tag;
  struct contiguous_iterator_tag;

  template <typename _Iterator> struct iterator_traits;

  template <typename _Tp>
    requires is_object_v<_Tp>
  struct iterator_traits<_Tp *>;

  template <typename _Iterator, typename> struct __iterator_traits;

  namespace __detail {
  template <typename _Tp> using __with_ref = _Tp &;

  template <typename _Tp>
  concept __can_reference = requires { typename __with_ref<_Tp>; };

  template <typename _Tp>
  concept __dereferenceable = requires(_Tp &__t) {
    { *__t } -> __can_reference;
  };
  } // namespace __detail

  template <__detail::__dereferenceable _Tp>
  using iter_reference_t = decltype(*std::declval<_Tp &>());

  namespace ranges {
  namespace __cust_imove {
  void iter_move();

  template <typename _Tp>
  concept __adl_imove =
      (std::__detail::__class_or_enum<remove_reference_t<_Tp>>) &&
      requires(_Tp &&__t) { iter_move(static_cast<_Tp &&>(__t)); };

  struct _IMove {
  private:
    template <typename _Tp> struct __result {
      using type = iter_reference_t<_Tp>;
    };

    template <typename _Tp>
      requires __adl_imove<_Tp>
    struct __result<_Tp> {
      using type = decltype(iter_move(std::declval<_Tp>()));
    };

    template <typename _Tp>
      requires(!__adl_imove<_Tp>) &&
              is_lvalue_reference_v<iter_reference_t<_Tp>>
    struct __result<_Tp> {
      using type = remove_reference_t<iter_reference_t<_Tp>> &&;
    };

    template <typename _Tp> static constexpr bool _S_noexcept() {
      if constexpr (__adl_imove<_Tp>)
        return noexcept(iter_move(std::declval<_Tp>()));
      else
        return noexcept(*std::declval<_Tp>());
    }

  public:
    template <std::__detail::__dereferenceable _Tp>
    using __type = typename __result<_Tp>::type;

    template <std::__detail::__dereferenceable _Tp>
    [[nodiscard]]
    constexpr __type<_Tp> operator()(_Tp &&__e) const
        noexcept(_S_noexcept<_Tp>()) {
      if constexpr (__adl_imove<_Tp>)
        return iter_move(static_cast<_Tp &&>(__e));
      else if constexpr (is_lvalue_reference_v<iter_reference_t<_Tp>>)
        return static_cast<__type<_Tp>>(*__e);
      else
        return *__e;
    }
  };
  } // namespace __cust_imove

  inline namespace __cust {
  inline constexpr __cust_imove::_IMove iter_move{};
  }
  } // namespace ranges

  template <__detail::__dereferenceable _Tp>
    requires __detail::__can_reference<
                 ranges::__cust_imove::_IMove::__type<_Tp &>>
  using iter_rvalue_reference_t = ranges::__cust_imove::_IMove::__type<_Tp &>;

  template <typename> struct incrementable_traits {};

  template <typename _Tp>
    requires is_object_v<_Tp>
  struct incrementable_traits<_Tp *> {
    using difference_type = ptrdiff_t;
  };

  template <typename _Iter>
  struct incrementable_traits<const _Iter> : incrementable_traits<_Iter> {};

  template <typename _Tp>
    requires requires { typename _Tp::difference_type; }
  struct incrementable_traits<_Tp> {
    using difference_type = typename _Tp::difference_type;
  };

  template <typename _Tp>
    requires(
        !requires { typename _Tp::difference_type; } &&
        requires(const _Tp &__a, const _Tp &__b) {
          { __a - __b } -> integral;
        })
  struct incrementable_traits<_Tp> {
    using difference_type =
        make_signed_t<decltype(std::declval<_Tp>() - std::declval<_Tp>())>;
  };

  template <> struct incrementable_traits<__int128> {
    using difference_type = __int128;
  };

  template <> struct incrementable_traits<unsigned __int128> {
    using difference_type = __int128;
  };

  namespace __detail {

  template <typename _Iter>
  concept __primary_traits_iter =
      __is_base_of(__iterator_traits<_Iter, void>, iterator_traits<_Iter>);

  template <typename _Iter, typename _Tp> struct __iter_traits_impl {
    using type = iterator_traits<_Iter>;
  };

  template <typename _Iter, typename _Tp>
    requires __primary_traits_iter<_Iter>
  struct __iter_traits_impl<_Iter, _Tp> {
    using type = _Tp;
  };

  template <typename _Iter, typename _Tp = _Iter>
  using __iter_traits = typename __iter_traits_impl<_Iter, _Tp>::type;

  template <typename _Tp>
  using __iter_diff_t =
      typename __iter_traits<_Tp, incrementable_traits<_Tp>>::difference_type;
  } // namespace __detail

  template <typename _Tp>
  using iter_difference_t = __detail::__iter_diff_t<remove_cvref_t<_Tp>>;

  namespace __detail {
  template <typename> struct __cond_value_type {};

  template <typename _Tp>
    requires is_object_v<_Tp>
  struct __cond_value_type<_Tp> {
    using value_type = remove_cv_t<_Tp>;
  };

  template <typename _Tp>
  concept __has_member_value_type = requires { typename _Tp::value_type; };

  template <typename _Tp>
  concept __has_member_element_type = requires { typename _Tp::element_type; };

  } // namespace __detail

  template <typename> struct indirectly_readable_traits {};

  template <typename _Tp>
  struct indirectly_readable_traits<_Tp *> : __detail::__cond_value_type<_Tp> {
  };

  template <typename _Iter>
    requires is_array_v<_Iter>
  struct indirectly_readable_traits<_Iter> {
    using value_type = remove_cv_t<remove_extent_t<_Iter>>;
  };

  template <typename _Iter>
  struct indirectly_readable_traits<const _Iter>
      : indirectly_readable_traits<_Iter> {};

  template <__detail::__has_member_value_type _Tp>
  struct indirectly_readable_traits<_Tp>
      : __detail::__cond_value_type<typename _Tp::value_type> {};

  template <__detail::__has_member_element_type _Tp>
  struct indirectly_readable_traits<_Tp>
      : __detail::__cond_value_type<typename _Tp::element_type> {};

  template <__detail::__has_member_value_type _Tp>
    requires __detail::__has_member_element_type<_Tp> &&
             same_as<remove_cv_t<typename _Tp::element_type>,
                     remove_cv_t<typename _Tp::value_type>>
  struct indirectly_readable_traits<_Tp>
      : __detail::__cond_value_type<typename _Tp::value_type> {};

  template <__detail::__has_member_value_type _Tp>
    requires __detail::__has_member_element_type<_Tp>
  struct indirectly_readable_traits<_Tp> {};

  namespace __detail {
  template <typename _Tp>
  using __iter_value_t =
      typename __iter_traits<_Tp, indirectly_readable_traits<_Tp>>::value_type;
  }

  template <typename _Tp>
  using iter_value_t = __detail::__iter_value_t<remove_cvref_t<_Tp>>;

  namespace __detail {

  template <typename _Iter>
  concept __cpp17_iterator = requires(_Iter __it) {
    { *__it } -> __can_reference;
    { ++__it } -> same_as<_Iter &>;
    { *__it++ } -> __can_reference;
  } && copyable<_Iter>;

  template <typename _Iter>
  concept __cpp17_input_iterator =
      __cpp17_iterator<_Iter> && equality_comparable<_Iter> &&
      requires(_Iter __it) {
        typename incrementable_traits<_Iter>::difference_type;
        typename indirectly_readable_traits<_Iter>::value_type;
        typename common_reference_t<
            iter_reference_t<_Iter> &&,
            typename indirectly_readable_traits<_Iter>::value_type &>;
        typename common_reference_t<
            decltype(*__it++) &&,
            typename indirectly_readable_traits<_Iter>::value_type &>;
        requires signed_integral<
            typename incrementable_traits<_Iter>::difference_type>;
      };

  template <typename _Iter>
  concept __cpp17_fwd_iterator =
      __cpp17_input_iterator<_Iter> && constructible_from<_Iter> &&
      is_lvalue_reference_v<iter_reference_t<_Iter>> &&
      same_as<remove_cvref_t<iter_reference_t<_Iter>>,
              typename indirectly_readable_traits<_Iter>::value_type> &&
      requires(_Iter __it) {
        { __it++ } -> convertible_to<const _Iter &>;
        { *__it++ } -> same_as<iter_reference_t<_Iter>>;
      };

  template <typename _Iter>
  concept __cpp17_bidi_iterator =
      __cpp17_fwd_iterator<_Iter> && requires(_Iter __it) {
        { --__it } -> same_as<_Iter &>;
        { __it-- } -> convertible_to<const _Iter &>;
        { *__it-- } -> same_as<iter_reference_t<_Iter>>;
      };

  template <typename _Iter>
  concept __cpp17_randacc_iterator =
      __cpp17_bidi_iterator<_Iter> && totally_ordered<_Iter> &&
      requires(_Iter __it,
               typename incrementable_traits<_Iter>::difference_type __n) {
        { __it += __n } -> same_as<_Iter &>;
        { __it -= __n } -> same_as<_Iter &>;
        { __it + __n } -> same_as<_Iter>;
        { __n + __it } -> same_as<_Iter>;
        { __it - __n } -> same_as<_Iter>;
        { __it - __it } -> same_as<decltype(__n)>;
        { __it[__n] } -> convertible_to<iter_reference_t<_Iter>>;
      };

  template <typename _Iter>
  concept __iter_with_nested_types = requires {
    typename _Iter::iterator_category;
    typename _Iter::value_type;
    typename _Iter::difference_type;
    typename _Iter::reference;
  };

  template <typename _Iter>
  concept __iter_without_nested_types = !__iter_with_nested_types<_Iter>;

  template <typename _Iter>
  concept __iter_without_category =
      !requires { typename _Iter::iterator_category; };

  } // namespace __detail

  template <typename _Iterator>
    requires __detail::__iter_with_nested_types<_Iterator>
  struct __iterator_traits<_Iterator, void> {
  private:
    template <typename _Iter> struct __ptr {
      using type = void;
    };

    template <typename _Iter>
      requires requires { typename _Iter::pointer; }
    struct __ptr<_Iter> {
      using type = typename _Iter::pointer;
    };

  public:
    using iterator_category = typename _Iterator::iterator_category;
    using value_type = typename _Iterator::value_type;
    using difference_type = typename _Iterator::difference_type;
    using pointer = typename __ptr<_Iterator>::type;
    using reference = typename _Iterator::reference;
  };

  template <typename _Iterator>
    requires __detail::__iter_without_nested_types<_Iterator> &&
             __detail::__cpp17_input_iterator<_Iterator>
  struct __iterator_traits<_Iterator, void> {
  private:
    template <typename _Iter> struct __cat {
      using type = input_iterator_tag;
    };

    template <typename _Iter>
      requires requires { typename _Iter::iterator_category; }
    struct __cat<_Iter> {
      using type = typename _Iter::iterator_category;
    };

    template <typename _Iter>
      requires __detail::__iter_without_category<_Iter> &&
               __detail::__cpp17_randacc_iterator<_Iter>
    struct __cat<_Iter> {
      using type = random_access_iterator_tag;
    };

    template <typename _Iter>
      requires __detail::__iter_without_category<_Iter> &&
               __detail::__cpp17_bidi_iterator<_Iter>
    struct __cat<_Iter> {
      using type = bidirectional_iterator_tag;
    };

    template <typename _Iter>
      requires __detail::__iter_without_category<_Iter> &&
               __detail::__cpp17_fwd_iterator<_Iter>
    struct __cat<_Iter> {
      using type = forward_iterator_tag;
    };

    template <typename _Iter> struct __ptr {
      using type = void;
    };

    template <typename _Iter>
      requires requires { typename _Iter::pointer; }
    struct __ptr<_Iter> {
      using type = typename _Iter::pointer;
    };

    template <typename _Iter>
      requires(
          !requires { typename _Iter::pointer; } &&
          requires(_Iter &__it) { __it.operator->(); })
    struct __ptr<_Iter> {
      using type = decltype(std::declval<_Iter &>().operator->());
    };

    template <typename _Iter> struct __ref {
      using type = iter_reference_t<_Iter>;
    };

    template <typename _Iter>
      requires requires { typename _Iter::reference; }
    struct __ref<_Iter> {
      using type = typename _Iter::reference;
    };

  public:
    using iterator_category = typename __cat<_Iterator>::type;
    using value_type =
        typename indirectly_readable_traits<_Iterator>::value_type;
    using difference_type =
        typename incrementable_traits<_Iterator>::difference_type;
    using pointer = typename __ptr<_Iterator>::type;
    using reference = typename __ref<_Iterator>::type;
  };

  template <typename _Iterator>
    requires __detail::__iter_without_nested_types<_Iterator> &&
             __detail::__cpp17_iterator<_Iterator>
  struct __iterator_traits<_Iterator, void> {
  private:
    template <typename _Iter> struct __diff {
      using type = void;
    };

    template <typename _Iter>
      requires requires {
        typename incrementable_traits<_Iter>::difference_type;
      }
    struct __diff<_Iter> {
      using type = typename incrementable_traits<_Iter>::difference_type;
    };

  public:
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using difference_type = typename __diff<_Iterator>::type;
    using pointer = void;
    using reference = void;
  };

  namespace __detail {
  template <typename _Iter> struct __iter_concept_impl;

  template <typename _Iter>
    requires requires { typename __iter_traits<_Iter>::iterator_concept; }
  struct __iter_concept_impl<_Iter> {
    using type = typename __iter_traits<_Iter>::iterator_concept;
  };

  template <typename _Iter>
    requires(
        !requires { typename __iter_traits<_Iter>::iterator_concept; } &&
        requires { typename __iter_traits<_Iter>::iterator_category; })
  struct __iter_concept_impl<_Iter> {
    using type = typename __iter_traits<_Iter>::iterator_category;
  };

  template <typename _Iter>
    requires(
        !requires { typename __iter_traits<_Iter>::iterator_concept; } &&
        !requires { typename __iter_traits<_Iter>::iterator_category; } &&
        __primary_traits_iter<_Iter>)
  struct __iter_concept_impl<_Iter> {
    using type = random_access_iterator_tag;
  };

  template <typename _Iter> struct __iter_concept_impl {};

  template <typename _Iter>
  using __iter_concept = typename __iter_concept_impl<_Iter>::type;

  template <typename _In>
  concept __indirectly_readable_impl =
      requires {
        typename iter_value_t<_In>;
        typename iter_reference_t<_In>;
        typename iter_rvalue_reference_t<_In>;
        requires same_as<iter_reference_t<const _In>, iter_reference_t<_In>>;
        requires same_as<iter_rvalue_reference_t<const _In>,
                         iter_rvalue_reference_t<_In>>;
      } &&
      common_reference_with<iter_reference_t<_In> &&, iter_value_t<_In> &> &&
      common_reference_with<iter_reference_t<_In> &&,
                            iter_rvalue_reference_t<_In> &&> &&
      common_reference_with<iter_rvalue_reference_t<_In> &&,
                            const iter_value_t<_In> &>;

  } // namespace __detail

  template <typename _In>
  concept indirectly_readable =
      __detail::__indirectly_readable_impl<remove_cvref_t<_In>>;

  template <indirectly_readable _Tp>
  using iter_common_reference_t =
      common_reference_t<iter_reference_t<_Tp>, iter_value_t<_Tp> &>;

  template <typename _Out, typename _Tp>
  concept indirectly_writable = requires(_Out &&__o, _Tp &&__t) {
    *__o = std::forward<_Tp>(__t);
    *std::forward<_Out>(__o) = std::forward<_Tp>(__t);
    const_cast<const iter_reference_t<_Out> &&>(*__o) = std::forward<_Tp>(__t);
    const_cast<const iter_reference_t<_Out> &&>(*std::forward<_Out>(__o)) =
        std::forward<_Tp>(__t);
  };

  namespace ranges::__detail {
  class __max_diff_type;
  class __max_size_type;

  __extension__ template <typename _Tp>
  concept __is_signed_int128

      = same_as<_Tp, __int128>;

  __extension__ template <typename _Tp>
  concept __is_unsigned_int128

      = same_as<_Tp, unsigned __int128>;

  template <typename _Tp>
  concept __cv_bool = same_as<const volatile _Tp, const volatile bool>;

  template <typename _Tp>
  concept __integral_nonbool = integral<_Tp> && !__cv_bool<_Tp>;

  template <typename _Tp>
  concept __is_int128 = __is_signed_int128<_Tp> || __is_unsigned_int128<_Tp>;

  template <typename _Tp>
  concept __is_integer_like =
      __integral_nonbool<_Tp> || __is_int128<_Tp> ||
      same_as<_Tp, __max_diff_type> || same_as<_Tp, __max_size_type>;

  template <typename _Tp>
  concept __is_signed_integer_like =
      signed_integral<_Tp> || __is_signed_int128<_Tp> ||
      same_as<_Tp, __max_diff_type>;

  } // namespace ranges::__detail

  namespace __detail {
  using ranges::__detail::__is_signed_integer_like;
  }

  template <typename _Iter>
  concept weakly_incrementable = movable<_Iter> && requires(_Iter __i) {
    typename iter_difference_t<_Iter>;
    requires __detail::__is_signed_integer_like<iter_difference_t<_Iter>>;
    { ++__i } -> same_as<_Iter &>;
    __i++;
  };

  template <typename _Iter>
  concept incrementable =
      regular<_Iter> && weakly_incrementable<_Iter> && requires(_Iter __i) {
        { __i++ } -> same_as<_Iter>;
      };

  template <typename _Iter>
  concept input_or_output_iterator = requires(_Iter __i) {
    { *__i } -> __detail::__can_reference;
  } && weakly_incrementable<_Iter>;

  template <typename _Sent, typename _Iter>
  concept sentinel_for =
      semiregular<_Sent> && input_or_output_iterator<_Iter> &&
      __detail::__weakly_eq_cmp_with<_Sent, _Iter>;

  template <typename _Sent, typename _Iter>
  inline constexpr bool disable_sized_sentinel_for = false;

  template <typename _Sent, typename _Iter>
  concept sized_sentinel_for =
      sentinel_for<_Sent, _Iter> &&
      !disable_sized_sentinel_for<remove_cv_t<_Sent>, remove_cv_t<_Iter>> &&
      requires(const _Iter &__i, const _Sent &__s) {
        { __s - __i } -> same_as<iter_difference_t<_Iter>>;
        { __i - __s } -> same_as<iter_difference_t<_Iter>>;
      };

  template <typename _Iter>
  concept input_iterator =
      input_or_output_iterator<_Iter> && indirectly_readable<_Iter> &&
      requires { typename __detail::__iter_concept<_Iter>; } &&
      derived_from<__detail::__iter_concept<_Iter>, input_iterator_tag>;

  template <typename _Iter, typename _Tp>
  concept output_iterator =
      input_or_output_iterator<_Iter> && indirectly_writable<_Iter, _Tp> &&
      requires(_Iter __i, _Tp &&__t) { *__i++ = std::forward<_Tp>(__t); };

  template <typename _Iter>
  concept forward_iterator =
      input_iterator<_Iter> &&
      derived_from<__detail::__iter_concept<_Iter>, forward_iterator_tag> &&
      incrementable<_Iter> && sentinel_for<_Iter, _Iter>;

  template <typename _Iter>
  concept bidirectional_iterator = forward_iterator<_Iter> &&
                                   derived_from<__detail::__iter_concept<_Iter>,
                                                bidirectional_iterator_tag> &&
                                   requires(_Iter __i) {
                                     { --__i } -> same_as<_Iter &>;
                                     { __i-- } -> same_as<_Iter>;
                                   };

  template <typename _Iter>
  concept random_access_iterator =
      bidirectional_iterator<_Iter> &&
      derived_from<__detail::__iter_concept<_Iter>,
                   random_access_iterator_tag> &&
      totally_ordered<_Iter> && sized_sentinel_for<_Iter, _Iter> &&
      requires(_Iter __i, const _Iter __j, const iter_difference_t<_Iter> __n) {
        { __i += __n } -> same_as<_Iter &>;
        { __j + __n } -> same_as<_Iter>;
        { __n + __j } -> same_as<_Iter>;
        { __i -= __n } -> same_as<_Iter &>;
        { __j - __n } -> same_as<_Iter>;
        { __j[__n] } -> same_as<iter_reference_t<_Iter>>;
      };

  template <typename _Iter>
  concept contiguous_iterator =
      random_access_iterator<_Iter> &&
      derived_from<__detail::__iter_concept<_Iter>, contiguous_iterator_tag> &&
      is_lvalue_reference_v<iter_reference_t<_Iter>> &&
      same_as<iter_value_t<_Iter>, remove_cvref_t<iter_reference_t<_Iter>>> &&
      requires(const _Iter &__i) {
        {
          std::to_address(__i)
        } -> same_as<add_pointer_t<iter_reference_t<_Iter>>>;
      };

  template <typename _Fn, typename _Iter>
  concept indirectly_unary_invocable =
      indirectly_readable<_Iter> && copy_constructible<_Fn> &&
      invocable<_Fn &, iter_value_t<_Iter> &> &&
      invocable<_Fn &, iter_reference_t<_Iter>> &&
      invocable<_Fn &, iter_common_reference_t<_Iter>> &&
      common_reference_with<invoke_result_t<_Fn &, iter_value_t<_Iter> &>,
                            invoke_result_t<_Fn &, iter_reference_t<_Iter>>>;

  template <typename _Fn, typename _Iter>
  concept indirectly_regular_unary_invocable =
      indirectly_readable<_Iter> && copy_constructible<_Fn> &&
      regular_invocable<_Fn &, iter_value_t<_Iter> &> &&
      regular_invocable<_Fn &, iter_reference_t<_Iter>> &&
      regular_invocable<_Fn &, iter_common_reference_t<_Iter>> &&
      common_reference_with<invoke_result_t<_Fn &, iter_value_t<_Iter> &>,
                            invoke_result_t<_Fn &, iter_reference_t<_Iter>>>;

  template <typename _Fn, typename _Iter>
  concept indirect_unary_predicate =
      indirectly_readable<_Iter> && copy_constructible<_Fn> &&
      predicate<_Fn &, iter_value_t<_Iter> &> &&
      predicate<_Fn &, iter_reference_t<_Iter>> &&
      predicate<_Fn &, iter_common_reference_t<_Iter>>;

  template <typename _Fn, typename _I1, typename _I2>
  concept indirect_binary_predicate =
      indirectly_readable<_I1> && indirectly_readable<_I2> &&
      copy_constructible<_Fn> &&
      predicate<_Fn &, iter_value_t<_I1> &, iter_value_t<_I2> &> &&
      predicate<_Fn &, iter_value_t<_I1> &, iter_reference_t<_I2>> &&
      predicate<_Fn &, iter_reference_t<_I1>, iter_value_t<_I2> &> &&
      predicate<_Fn &, iter_reference_t<_I1>, iter_reference_t<_I2>> &&
      predicate<_Fn &, iter_common_reference_t<_I1>,
                iter_common_reference_t<_I2>>;

  template <typename _Fn, typename _I1, typename _I2 = _I1>
  concept indirect_equivalence_relation =
      indirectly_readable<_I1> && indirectly_readable<_I2> &&
      copy_constructible<_Fn> &&
      equivalence_relation<_Fn &, iter_value_t<_I1> &, iter_value_t<_I2> &> &&
      equivalence_relation<_Fn &, iter_value_t<_I1> &, iter_reference_t<_I2>> &&
      equivalence_relation<_Fn &, iter_reference_t<_I1>, iter_value_t<_I2> &> &&
      equivalence_relation<_Fn &, iter_reference_t<_I1>,
                           iter_reference_t<_I2>> &&
      equivalence_relation<_Fn &, iter_common_reference_t<_I1>,
                           iter_common_reference_t<_I2>>;

  template <typename _Fn, typename _I1, typename _I2 = _I1>
  concept indirect_strict_weak_order =
      indirectly_readable<_I1> && indirectly_readable<_I2> &&
      copy_constructible<_Fn> &&
      strict_weak_order<_Fn &, iter_value_t<_I1> &, iter_value_t<_I2> &> &&
      strict_weak_order<_Fn &, iter_value_t<_I1> &, iter_reference_t<_I2>> &&
      strict_weak_order<_Fn &, iter_reference_t<_I1>, iter_value_t<_I2> &> &&
      strict_weak_order<_Fn &, iter_reference_t<_I1>, iter_reference_t<_I2>> &&
      strict_weak_order<_Fn &, iter_common_reference_t<_I1>,
                        iter_common_reference_t<_I2>>;

  template <typename _Fn, typename... _Is>
    requires(indirectly_readable<_Is> && ...) &&
                invocable<_Fn, iter_reference_t<_Is>...>
  using indirect_result_t = invoke_result_t<_Fn, iter_reference_t<_Is>...>;

  namespace __detail {
  template <typename _Iter, typename _Proj> struct __projected {
    struct __type {
      using value_type = remove_cvref_t<indirect_result_t<_Proj &, _Iter>>;
      indirect_result_t<_Proj &, _Iter> operator*() const;
    };
  };

  template <weakly_incrementable _Iter, typename _Proj>
  struct __projected<_Iter, _Proj> {
    struct __type {
      using value_type = remove_cvref_t<indirect_result_t<_Proj &, _Iter>>;
      using difference_type = iter_difference_t<_Iter>;
      indirect_result_t<_Proj &, _Iter> operator*() const;
    };
  };
  } // namespace __detail

  template <indirectly_readable _Iter,
            indirectly_regular_unary_invocable<_Iter> _Proj>
  using projected = typename __detail::__projected<_Iter, _Proj>::__type;

  template <typename _In, typename _Out>
  concept indirectly_movable =
      indirectly_readable<_In> &&
      indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;

  template <typename _In, typename _Out>
  concept indirectly_movable_storable =
      indirectly_movable<_In, _Out> &&
      indirectly_writable<_Out, iter_value_t<_In>> &&
      movable<iter_value_t<_In>> &&
      constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>> &&
      assignable_from<iter_value_t<_In> &, iter_rvalue_reference_t<_In>>;

  template <typename _In, typename _Out>
  concept indirectly_copyable =
      indirectly_readable<_In> &&
      indirectly_writable<_Out, iter_reference_t<_In>>;

  template <typename _In, typename _Out>
  concept indirectly_copyable_storable =
      indirectly_copyable<_In, _Out> &&
      indirectly_writable<_Out, iter_value_t<_In> &> &&
      indirectly_writable<_Out, const iter_value_t<_In> &> &&
      indirectly_writable<_Out, iter_value_t<_In> &&> &&
      indirectly_writable<_Out, const iter_value_t<_In> &&> &&
      copyable<iter_value_t<_In>> &&
      constructible_from<iter_value_t<_In>, iter_reference_t<_In>> &&
      assignable_from<iter_value_t<_In> &, iter_reference_t<_In>>;

  namespace ranges {
  namespace __cust_iswap {
  template <typename _It1, typename _It2> void iter_swap(_It1, _It2) = delete;

  template <typename _Tp, typename _Up>
  concept __adl_iswap =
      (std::__detail::__class_or_enum<remove_reference_t<_Tp>> ||
       std::__detail::__class_or_enum<remove_reference_t<_Up>>) &&
      requires(_Tp &&__t, _Up &&__u) {
        iter_swap(static_cast<_Tp &&>(__t), static_cast<_Up &&>(__u));
      };

  template <typename _Xp, typename _Yp>
  constexpr iter_value_t<_Xp> __iter_exchange_move(
      _Xp &&__x,
      _Yp &&__y) noexcept(noexcept(iter_value_t<_Xp>(iter_move(__x))) &&
                          noexcept(*__x = iter_move(__y))) {
    iter_value_t<_Xp> __old_value(iter_move(__x));
    *__x = iter_move(__y);
    return __old_value;
  }

  struct _IterSwap {
  private:
    template <typename _Tp, typename _Up> static constexpr bool _S_noexcept() {
      if constexpr (__adl_iswap<_Tp, _Up>)
        return noexcept(iter_swap(std::declval<_Tp>(), std::declval<_Up>()));
      else if constexpr (indirectly_readable<_Tp> && indirectly_readable<_Up> &&
                         swappable_with<iter_reference_t<_Tp>,
                                        iter_reference_t<_Up>>)
        return noexcept(
            ranges::swap(*std::declval<_Tp>(), *std::declval<_Up>()));
      else
        return noexcept(*std::declval<_Tp>() = __iter_exchange_move(
                            std::declval<_Up>(), std::declval<_Tp>()));
    }

  public:
    template <typename _Tp, typename _Up>
      requires __adl_iswap<_Tp, _Up> ||
               (indirectly_readable<remove_reference_t<_Tp>> &&
                indirectly_readable<remove_reference_t<_Up>> &&
                swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>) ||
               (indirectly_movable_storable<_Tp, _Up> &&
                indirectly_movable_storable<_Up, _Tp>)
    constexpr void operator()(_Tp &&__e1, _Up &&__e2) const
        noexcept(_S_noexcept<_Tp, _Up>()) {
      if constexpr (__adl_iswap<_Tp, _Up>)
        iter_swap(static_cast<_Tp &&>(__e1), static_cast<_Up &&>(__e2));
      else if constexpr (indirectly_readable<_Tp> && indirectly_readable<_Up> &&
                         swappable_with<iter_reference_t<_Tp>,
                                        iter_reference_t<_Up>>)
        ranges::swap(*__e1, *__e2);
      else
        *__e1 = __iter_exchange_move(__e2, __e1);
    }
  };
  } // namespace __cust_iswap

  inline namespace __cust {
  inline constexpr __cust_iswap::_IterSwap iter_swap{};
  }

  } // namespace ranges

  template <typename _I1, typename _I2 = _I1>
  concept indirectly_swappable =
      indirectly_readable<_I1> && indirectly_readable<_I2> &&
      requires(const _I1 __i1, const _I2 __i2) {
        ranges::iter_swap(__i1, __i1);
        ranges::iter_swap(__i2, __i2);
        ranges::iter_swap(__i1, __i2);
        ranges::iter_swap(__i2, __i1);
      };

  template <typename _I1, typename _I2, typename _Rel, typename _P1 = identity,
            typename _P2 = identity>
  concept indirectly_comparable =
      indirect_binary_predicate<_Rel, projected<_I1, _P1>, projected<_I2, _P2>>;

  template <typename _Iter>
  concept permutable =
      forward_iterator<_Iter> && indirectly_movable_storable<_Iter, _Iter> &&
      indirectly_swappable<_Iter, _Iter>;

  template <typename _I1, typename _I2, typename _Out,
            typename _Rel = ranges::less, typename _P1 = identity,
            typename _P2 = identity>
  concept mergeable =
      input_iterator<_I1> && input_iterator<_I2> &&
      weakly_incrementable<_Out> && indirectly_copyable<_I1, _Out> &&
      indirectly_copyable<_I2, _Out> &&
      indirect_strict_weak_order<_Rel, projected<_I1, _P1>,
                                 projected<_I2, _P2>>;

  template <typename _Iter, typename _Rel = ranges::less,
            typename _Proj = identity>
  concept sortable = permutable<_Iter> &&
                     indirect_strict_weak_order<_Rel, projected<_Iter, _Proj>>;

  struct unreachable_sentinel_t {
    template <weakly_incrementable _It>
    friend constexpr bool operator==(unreachable_sentinel_t,
                                     const _It &) noexcept {
      return false;
    }
  };

  inline constexpr unreachable_sentinel_t unreachable_sentinel{};

  namespace ranges::__cust_access {
  using std::__detail::__class_or_enum;

  struct _Decay_copy final {
    template <typename _Tp>
    constexpr decay_t<_Tp> operator()(_Tp &&__t) const
        noexcept(is_nothrow_convertible_v<_Tp, decay_t<_Tp>>) {
      return std::forward<_Tp>(__t);
    }
  } inline constexpr __decay_copy{};

  template <typename _Tp>
  concept __member_begin = requires(_Tp &__t) {
    { __decay_copy(__t.begin()) } -> input_or_output_iterator;
  };

  void begin(auto &) = delete;
  void begin(const auto &) = delete;

  template <typename _Tp>
  concept __adl_begin =
      __class_or_enum<remove_reference_t<_Tp>> && requires(_Tp &__t) {
        { __decay_copy(begin(__t)) } -> input_or_output_iterator;
      };

  template <typename _Tp>
    requires is_array_v<_Tp> || __member_begin<_Tp &> || __adl_begin<_Tp &>
  auto __begin(_Tp &__t) {
    if constexpr (is_array_v<_Tp>)
      return __t + 0;
    else if constexpr (__member_begin<_Tp &>)
      return __t.begin();
    else
      return begin(__t);
  }
  } // namespace ranges::__cust_access

  namespace __detail {

  template <typename _Tp>
  using __range_iter_t =
      decltype(ranges::__cust_access::__begin(std::declval<_Tp &>()));

  }

} // namespace std
# 72 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator_base_types.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 93 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag {};

  struct output_iterator_tag {};

  struct forward_iterator_tag : public input_iterator_tag {};

  struct bidirectional_iterator_tag : public forward_iterator_tag {};

  struct random_access_iterator_tag : public bidirectional_iterator_tag {};

  struct contiguous_iterator_tag : public random_access_iterator_tag {};
# 125 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator_base_types.h" 3
  template <typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
            typename _Pointer = _Tp *, typename _Reference = _Tp &>
  struct [[__deprecated__]] iterator {

    typedef _Category iterator_category;

    typedef _Tp value_type;

    typedef _Distance difference_type;

    typedef _Pointer pointer;

    typedef _Reference reference;
  };
# 149 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator_base_types.h" 3
  template <typename _Iterator> struct iterator_traits;

  template <typename _Iterator, typename = __void_t<>>
  struct __iterator_traits {};
# 176 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator_base_types.h" 3
  template <typename _Iterator>
  struct iterator_traits : public __iterator_traits<_Iterator> {};
# 194 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator_base_types.h" 3
  template <typename _Tp>

    requires is_object_v<_Tp>

  struct iterator_traits<_Tp *> {
    using iterator_concept = contiguous_iterator_tag;
    using iterator_category = random_access_iterator_tag;
    using value_type = remove_cv_t<_Tp>;
    using difference_type = ptrdiff_t;
    using pointer = _Tp *;
    using reference = _Tp &;
  };
# 235 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator_base_types.h" 3
  template <typename _Iter>
  __attribute__((__always_inline__)) inline constexpr
      typename iterator_traits<_Iter>::iterator_category
      __iterator_category(const _Iter &) {
    return typename iterator_traits<_Iter>::iterator_category();
  }

  template <typename _Iter>
  using __iter_category_t = typename iterator_traits<_Iter>::iterator_category;

  template <typename _InIter>
  using _RequireInputIter = __enable_if_t<
      is_convertible<__iter_category_t<_InIter>, input_iterator_tag>::value>;

  template <typename _It, typename _Cat = __iter_category_t<_It>>
  struct __is_random_access_iter
      : is_base_of<random_access_iterator_tag, _Cat> {
    typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
    enum { __value = _Base::value };
  };
# 270 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator_base_types.h" 3
} // namespace std
# 62 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_construct.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator_base_funcs.h" 1 3
# 63 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator_base_funcs.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/concept_check.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/concept_check.h" 3
# 65 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator_base_funcs.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/debug/assertions.h" 1 3
# 66 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;

  template <typename _InputIterator>
  inline constexpr typename iterator_traits<_InputIterator>::difference_type
  __distance(_InputIterator __first, _InputIterator __last,
             input_iterator_tag) {

    typename iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last) {
      ++__first;
      ++__n;
    }
    return __n;
  }

  template <typename _RandomAccessIterator>
  __attribute__((__always_inline__)) inline constexpr
      typename iterator_traits<_RandomAccessIterator>::difference_type
      __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
                 random_access_iterator_tag) {

    return __last - __first;
  }

  template <typename _Tp>
  ptrdiff_t __distance(std::_List_iterator<_Tp>, std::_List_iterator<_Tp>,
                       input_iterator_tag);

  template <typename _Tp>
  ptrdiff_t __distance(std::_List_const_iterator<_Tp>,
                       std::_List_const_iterator<_Tp>, input_iterator_tag);

  template <typename _OutputIterator>
  void __distance(_OutputIterator, _OutputIterator, output_iterator_tag) =
      delete;
# 144 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator_base_funcs.h" 3
  template <typename _InputIterator>
  [[__nodiscard__]] __attribute__((__always_inline__)) inline constexpr
      typename iterator_traits<_InputIterator>::difference_type
      distance(_InputIterator __first, _InputIterator __last) {

    return std::__distance(__first, __last, std::__iterator_category(__first));
  }

  template <typename _InputIterator, typename _Distance>
  inline constexpr void __advance(_InputIterator & __i, _Distance __n,
                                  input_iterator_tag) {

    do {
      if (std::__is_constant_evaluated() && !bool(__n >= 0))
        __builtin_unreachable();
    } while (false);
    while (__n--)
      ++__i;
  }

  template <typename _BidirectionalIterator, typename _Distance>
  inline constexpr void __advance(_BidirectionalIterator & __i, _Distance __n,
                                  bidirectional_iterator_tag) {

    if (__n > 0)
      while (__n--)
        ++__i;
    else
      while (__n++)
        --__i;
  }

  template <typename _RandomAccessIterator, typename _Distance>
  inline constexpr void __advance(_RandomAccessIterator & __i, _Distance __n,
                                  random_access_iterator_tag) {

    if (__builtin_constant_p(__n) && __n == 1)
      ++__i;
    else if (__builtin_constant_p(__n) && __n == -1)
      --__i;
    else
      __i += __n;
  }

  template <typename _OutputIterator, typename _Distance>
  void __advance(_OutputIterator &, _Distance, output_iterator_tag) = delete;
# 217 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator_base_funcs.h" 3
  template <typename _InputIterator, typename _Distance>
  __attribute__((__always_inline__)) inline constexpr void advance(
      _InputIterator & __i, _Distance __n) {

    typename iterator_traits<_InputIterator>::difference_type __d = __n;
    std::__advance(__i, __d, std::__iterator_category(__i));
  }

  template <typename _InputIterator>
  [[__nodiscard__]] [[__gnu__::__always_inline__]]
  inline constexpr _InputIterator next(
      _InputIterator __x,
      typename iterator_traits<_InputIterator>::difference_type __n = 1) {

    std::advance(__x, __n);
    return __x;
  }

  template <typename _BidirectionalIterator>
  [[__nodiscard__]] [[__gnu__::__always_inline__]]
  inline constexpr _BidirectionalIterator prev(
      _BidirectionalIterator __x,
      typename iterator_traits<_BidirectionalIterator>::difference_type __n =
          1) {

    std::advance(__x, -__n);
    return __x;
  }

} // namespace std
# 63 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_construct.h" 2 3
# 73 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_construct.h" 3
namespace std __attribute__((__visibility__("default"))) {

  template <typename _Tp> constexpr inline void destroy_at(_Tp * __location) {
    if constexpr (202002L > 201703L && is_array_v<_Tp>) {
      for (auto &__x : *__location)
        std::destroy_at(std::__addressof(__x));
    } else
      __location->~_Tp();
  }

  template <typename _Tp, typename... _Args>
  constexpr auto construct_at(_Tp * __location, _Args && ...__args) noexcept(
      noexcept(::new ((void *)0) _Tp(std::declval<_Args>()...)))
      -> decltype(::new ((void *)0) _Tp(std::declval<_Args>()...)) {
    return ::new ((void *)__location) _Tp(std::forward<_Args>(__args)...);
  }
# 106 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_construct.h" 3
  template <typename _Tp, typename... _Args>
  constexpr inline void _Construct(_Tp * __p, _Args && ...__args) {

    if (std::__is_constant_evaluated()) {

      std::construct_at(__p, std::forward<_Args>(__args)...);
      return;
    }

    ::new ((void *)__p) _Tp(std::forward<_Args>(__args)...);
  }
# 132 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_construct.h" 3
  template <typename _T1> inline void _Construct_novalue(_T1 * __p) {
    ::new ((void *)__p) _T1;
  }

  template <typename _ForwardIterator>
  constexpr void _Destroy(_ForwardIterator __first, _ForwardIterator __last);

  template <typename _Tp> constexpr inline void _Destroy(_Tp * __pointer) {

    std::destroy_at(__pointer);
  }

  template <bool> struct _Destroy_aux {
    template <typename _ForwardIterator>
    static constexpr void __destroy(_ForwardIterator __first,
                                    _ForwardIterator __last) {
      for (; __first != __last; ++__first)
        std::_Destroy(std::__addressof(*__first));
    }
  };

  template <> struct _Destroy_aux<true> {
    template <typename _ForwardIterator>
    static void __destroy(_ForwardIterator, _ForwardIterator) {}
  };

  template <typename _ForwardIterator>
  constexpr inline void _Destroy(_ForwardIterator __first,
                                 _ForwardIterator __last) {
    typedef typename iterator_traits<_ForwardIterator>::value_type _Value_type;

    static_assert(is_destructible<_Value_type>::value,
                  "value type is destructible");

    if (std::__is_constant_evaluated())
      return std::_Destroy_aux<false>::__destroy(__first, __last);

    std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::__destroy(__first,
                                                                        __last);
  }

  template <bool> struct _Destroy_n_aux {
    template <typename _ForwardIterator, typename _Size>
    static constexpr _ForwardIterator __destroy_n(_ForwardIterator __first,
                                                  _Size __count) {
      for (; __count > 0; (void)++__first, --__count)
        std::_Destroy(std::__addressof(*__first));
      return __first;
    }
  };

  template <> struct _Destroy_n_aux<true> {
    template <typename _ForwardIterator, typename _Size>
    static _ForwardIterator __destroy_n(_ForwardIterator __first,
                                        _Size __count) {
      std::advance(__first, __count);
      return __first;
    }
  };

  template <typename _ForwardIterator, typename _Size>
  constexpr inline _ForwardIterator _Destroy_n(_ForwardIterator __first,
                                               _Size __count) {
    typedef typename iterator_traits<_ForwardIterator>::value_type _Value_type;

    static_assert(is_destructible<_Value_type>::value,
                  "value type is destructible");

    if (std::__is_constant_evaluated())
      return std::_Destroy_n_aux<false>::__destroy_n(__first, __count);

    return std::_Destroy_n_aux<__has_trivial_destructor(
        _Value_type)>::__destroy_n(__first, __count);
  }

  template <typename _ForwardIterator>
  constexpr inline void destroy(_ForwardIterator __first,
                                _ForwardIterator __last) {
    std::_Destroy(__first, __last);
  }

  template <typename _ForwardIterator, typename _Size>
  constexpr inline _ForwardIterator destroy_n(_ForwardIterator __first,
                                              _Size __count) {
    return std::_Destroy_n(__first, __count);
  }

} // namespace std
# 58 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/char_traits.h" 2 3

namespace __gnu_cxx __attribute__((__visibility__("default"))) {

#pragma GCC diagnostic push

#pragma GCC diagnostic ignored "-Warray-bounds"
# 83 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/char_traits.h" 3
  template <typename _CharT> struct _Char_types {
    typedef unsigned long int_type;

    typedef std::streampos pos_type;
    typedef std::streamoff off_type;
    typedef std::mbstate_t state_type;
  };
# 110 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/char_traits.h" 3
  template <typename _CharT> struct char_traits {
    typedef _CharT char_type;
    typedef typename _Char_types<_CharT>::int_type int_type;

    typedef typename _Char_types<_CharT>::pos_type pos_type;
    typedef typename _Char_types<_CharT>::off_type off_type;
    typedef typename _Char_types<_CharT>::state_type state_type;

    using comparison_category = std::strong_ordering;

    static constexpr void assign(char_type &__c1, const char_type &__c2) {

      if (std::__is_constant_evaluated())
        std::construct_at(__builtin_addressof(__c1), __c2);
      else

        __c1 = __c2;
    }

    static constexpr bool eq(const char_type &__c1, const char_type &__c2) {
      return __c1 == __c2;
    }

    static constexpr bool lt(const char_type &__c1, const char_type &__c2) {
      return __c1 < __c2;
    }

    static constexpr int compare(const char_type *__s1, const char_type *__s2,
                                 std::size_t __n);

    static constexpr std::size_t length(const char_type *__s);

    static constexpr const char_type *
    find(const char_type *__s, std::size_t __n, const char_type &__a);

    static constexpr char_type *move(char_type *__s1, const char_type *__s2,
                                     std::size_t __n);

    static constexpr char_type *copy(char_type *__s1, const char_type *__s2,
                                     std::size_t __n);

    static constexpr char_type *assign(char_type *__s, std::size_t __n,
                                       char_type __a);

    static constexpr char_type to_char_type(const int_type &__c) {
      return static_cast<char_type>(__c);
    }

    static constexpr int_type to_int_type(const char_type &__c) {
      return static_cast<int_type>(__c);
    }

    static constexpr bool eq_int_type(const int_type &__c1,
                                      const int_type &__c2) {
      return __c1 == __c2;
    }

    static constexpr int_type eof() { return static_cast<int_type>(-1); }

    static constexpr int_type not_eof(const int_type &__c) {
      return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type());
    }
  };

  template <typename _CharT>
  constexpr int char_traits<_CharT>::compare(
      const char_type *__s1, const char_type *__s2, std::size_t __n) {
    for (std::size_t __i = 0; __i < __n; ++__i)
      if (lt(__s1[__i], __s2[__i]))
        return -1;
      else if (lt(__s2[__i], __s1[__i]))
        return 1;
    return 0;
  }

  template <typename _CharT>
  constexpr std::size_t char_traits<_CharT>::length(const char_type *__p) {
    std::size_t __i = 0;
    while (!eq(__p[__i], char_type()))
      ++__i;
    return __i;
  }

  template <typename _CharT>
  constexpr const typename char_traits<_CharT>::char_type *
  char_traits<_CharT>::find(const char_type *__s, std::size_t __n,
                            const char_type &__a) {
    for (std::size_t __i = 0; __i < __n; ++__i)
      if (eq(__s[__i], __a))
        return __s + __i;
    return 0;
  }

  template <typename _CharT>
  constexpr typename char_traits<_CharT>::char_type *char_traits<_CharT>::move(
      char_type * __s1, const char_type *__s2, std::size_t __n) {
    if (__n == 0)
      return __s1;

    if (std::__is_constant_evaluated()) {

      if (__builtin_constant_p(__s2 < __s1) && __s1 > __s2 &&
          __s1 < (__s2 + __n)) {
        do {
          --__n;
          assign(__s1[__n], __s2[__n]);
        } while (__n > 0);
      } else
        copy(__s1, __s2, __n);
      return __s1;
    }

    __builtin_memmove(__s1, __s2, __n * sizeof(char_type));
    return __s1;
  }

  template <typename _CharT>
  constexpr typename char_traits<_CharT>::char_type *char_traits<_CharT>::copy(
      char_type * __s1, const char_type *__s2, std::size_t __n) {
    if (__n == 0)
      return __s1;

    if (std::__is_constant_evaluated()) {
      for (std::size_t __i = 0; __i < __n; ++__i)
        std::construct_at(__s1 + __i, __s2[__i]);
      return __s1;
    }

    __builtin_memcpy(__s1, __s2, __n * sizeof(char_type));
    return __s1;
  }

  template <typename _CharT>
  constexpr typename char_traits<_CharT>::char_type *
  char_traits<_CharT>::assign(char_type * __s, std::size_t __n, char_type __a) {

    if (std::__is_constant_evaluated()) {
      for (std::size_t __i = 0; __i < __n; ++__i)
        std::construct_at(__s + __i, __a);
      return __s;
    }

    if constexpr (sizeof(_CharT) == 1 && __is_trivial(_CharT)) {
      if (__n) {
        unsigned char __c;
        __builtin_memcpy(&__c, __builtin_addressof(__a), 1);
        __builtin_memset(__s, __c, __n);
      }
    } else {
      for (std::size_t __i = 0; __i < __n; ++__i)
        __s[__i] = __a;
    }
    return __s;
  }

} // namespace __gnu_cxx

namespace std __attribute__((__visibility__("default"))) {
# 330 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/char_traits.h" 3
  template <typename _CharT>
  struct char_traits : public __gnu_cxx::char_traits<_CharT> {};

  template <> struct char_traits<char> {
    typedef char char_type;
    typedef int int_type;

    typedef streampos pos_type;
    typedef streamoff off_type;
    typedef mbstate_t state_type;

    using comparison_category = strong_ordering;

    static constexpr void assign(char_type &__c1,
                                 const char_type &__c2) noexcept {

      if (std::__is_constant_evaluated())
        std::construct_at(__builtin_addressof(__c1), __c2);
      else

        __c1 = __c2;
    }

    static constexpr bool eq(const char_type &__c1,
                             const char_type &__c2) noexcept {
      return __c1 == __c2;
    }

    static constexpr bool lt(const char_type &__c1,
                             const char_type &__c2) noexcept {

      return (static_cast<unsigned char>(__c1) <
              static_cast<unsigned char>(__c2));
    }

    static constexpr int compare(const char_type *__s1, const char_type *__s2,
                                 size_t __n) {
      if (__n == 0)
        return 0;

      if (std::__is_constant_evaluated()) {
        for (size_t __i = 0; __i < __n; ++__i)
          if (lt(__s1[__i], __s2[__i]))
            return -1;
          else if (lt(__s2[__i], __s1[__i]))
            return 1;
        return 0;
      }

      return __builtin_memcmp(__s1, __s2, __n);
    }

    static constexpr size_t length(const char_type *__s) {

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::length(__s);

      return __builtin_strlen(__s);
    }

    static constexpr const char_type *find(const char_type *__s, size_t __n,
                                           const char_type &__a) {
      if (__n == 0)
        return 0;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);

      return static_cast<const char_type *>(__builtin_memchr(__s, __a, __n));
    }

    static constexpr char_type *move(char_type *__s1, const char_type *__s2,
                                     size_t __n) {
      if (__n == 0)
        return __s1;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);

      return static_cast<char_type *>(__builtin_memmove(__s1, __s2, __n));
    }

    static constexpr char_type *copy(char_type *__s1, const char_type *__s2,
                                     size_t __n) {
      if (__n == 0)
        return __s1;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);

      return static_cast<char_type *>(__builtin_memcpy(__s1, __s2, __n));
    }

    static constexpr char_type *assign(char_type *__s, size_t __n,
                                       char_type __a) {
      if (__n == 0)
        return __s;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);

      return static_cast<char_type *>(__builtin_memset(__s, __a, __n));
    }

    static constexpr char_type to_char_type(const int_type &__c) noexcept {
      return static_cast<char_type>(__c);
    }

    static constexpr int_type to_int_type(const char_type &__c) noexcept {
      return static_cast<int_type>(static_cast<unsigned char>(__c));
    }

    static constexpr bool eq_int_type(const int_type &__c1,
                                      const int_type &__c2) noexcept {
      return __c1 == __c2;
    }

    static constexpr int_type eof() noexcept {
      return static_cast<int_type>(-1);
    }

    static constexpr int_type not_eof(const int_type &__c) noexcept {
      return (__c == eof()) ? 0 : __c;
    }
  };

  template <> struct char_traits<wchar_t> {
    typedef wchar_t char_type;
    typedef wint_t int_type;

    typedef streamoff off_type;
    typedef wstreampos pos_type;
    typedef mbstate_t state_type;

    using comparison_category = strong_ordering;

    static constexpr void assign(char_type &__c1,
                                 const char_type &__c2) noexcept {

      if (std::__is_constant_evaluated())
        std::construct_at(__builtin_addressof(__c1), __c2);
      else

        __c1 = __c2;
    }

    static constexpr bool eq(const char_type &__c1,
                             const char_type &__c2) noexcept {
      return __c1 == __c2;
    }

    static constexpr bool lt(const char_type &__c1,
                             const char_type &__c2) noexcept {
      return __c1 < __c2;
    }

    static constexpr int compare(const char_type *__s1, const char_type *__s2,
                                 size_t __n) {
      if (__n == 0)
        return 0;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);

      return wmemcmp(__s1, __s2, __n);
    }

    static constexpr size_t length(const char_type *__s) {

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::length(__s);

      return wcslen(__s);
    }

    static constexpr const char_type *find(const char_type *__s, size_t __n,
                                           const char_type &__a) {
      if (__n == 0)
        return 0;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);

      return wmemchr(__s, __a, __n);
    }

    static constexpr char_type *move(char_type *__s1, const char_type *__s2,
                                     size_t __n) {
      if (__n == 0)
        return __s1;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);

      return wmemmove(__s1, __s2, __n);
    }

    static constexpr char_type *copy(char_type *__s1, const char_type *__s2,
                                     size_t __n) {
      if (__n == 0)
        return __s1;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);

      return wmemcpy(__s1, __s2, __n);
    }

    static constexpr char_type *assign(char_type *__s, size_t __n,
                                       char_type __a) {
      if (__n == 0)
        return __s;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);

      return wmemset(__s, __a, __n);
    }

    static constexpr char_type to_char_type(const int_type &__c) noexcept {
      return char_type(__c);
    }

    static constexpr int_type to_int_type(const char_type &__c) noexcept {
      return int_type(__c);
    }

    static constexpr bool eq_int_type(const int_type &__c1,
                                      const int_type &__c2) noexcept {
      return __c1 == __c2;
    }

    static constexpr int_type eof() noexcept {
      return static_cast<int_type>((0xffffffffu));
    }

    static constexpr int_type not_eof(const int_type &__c) noexcept {
      return eq_int_type(__c, eof()) ? 0 : __c;
    }
  };

  template <> struct char_traits<char8_t> {
    typedef char8_t char_type;
    typedef unsigned int int_type;

    typedef u8streampos pos_type;
    typedef streamoff off_type;
    typedef mbstate_t state_type;

    using comparison_category = strong_ordering;

    static constexpr void assign(char_type &__c1,
                                 const char_type &__c2) noexcept {

      if (std::__is_constant_evaluated())
        std::construct_at(__builtin_addressof(__c1), __c2);
      else

        __c1 = __c2;
    }

    static constexpr bool eq(const char_type &__c1,
                             const char_type &__c2) noexcept {
      return __c1 == __c2;
    }

    static constexpr bool lt(const char_type &__c1,
                             const char_type &__c2) noexcept {
      return __c1 < __c2;
    }

    static constexpr int compare(const char_type *__s1, const char_type *__s2,
                                 size_t __n) {
      if (__n == 0)
        return 0;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);

      return __builtin_memcmp(__s1, __s2, __n);
    }

    static constexpr size_t length(const char_type *__s) {

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::length(__s);

      size_t __i = 0;
      while (!eq(__s[__i], char_type()))
        ++__i;
      return __i;
    }

    static constexpr const char_type *find(const char_type *__s, size_t __n,
                                           const char_type &__a) {
      if (__n == 0)
        return 0;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);

      return static_cast<const char_type *>(__builtin_memchr(__s, __a, __n));
    }

    static constexpr char_type *move(char_type *__s1, const char_type *__s2,
                                     size_t __n) {
      if (__n == 0)
        return __s1;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);

      return static_cast<char_type *>(__builtin_memmove(__s1, __s2, __n));
    }

    static constexpr char_type *copy(char_type *__s1, const char_type *__s2,
                                     size_t __n) {
      if (__n == 0)
        return __s1;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);

      return static_cast<char_type *>(__builtin_memcpy(__s1, __s2, __n));
    }

    static constexpr char_type *assign(char_type *__s, size_t __n,
                                       char_type __a) {
      if (__n == 0)
        return __s;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);

      return static_cast<char_type *>(__builtin_memset(__s, __a, __n));
    }

    static constexpr char_type to_char_type(const int_type &__c) noexcept {
      return char_type(__c);
    }

    static constexpr int_type to_int_type(const char_type &__c) noexcept {
      return int_type(__c);
    }

    static constexpr bool eq_int_type(const int_type &__c1,
                                      const int_type &__c2) noexcept {
      return __c1 == __c2;
    }

    static constexpr int_type eof() noexcept {
      return static_cast<int_type>(-1);
    }

    static constexpr int_type not_eof(const int_type &__c) noexcept {
      return eq_int_type(__c, eof()) ? 0 : __c;
    }
  };

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

  template <> struct char_traits<char16_t> {
    typedef char16_t char_type;

    typedef unsigned short int_type;

    typedef streamoff off_type;
    typedef u16streampos pos_type;
    typedef mbstate_t state_type;

    using comparison_category = strong_ordering;

    static constexpr void assign(char_type &__c1,
                                 const char_type &__c2) noexcept {

      if (std::__is_constant_evaluated())
        std::construct_at(__builtin_addressof(__c1), __c2);
      else

        __c1 = __c2;
    }

    static constexpr bool eq(const char_type &__c1,
                             const char_type &__c2) noexcept {
      return __c1 == __c2;
    }

    static constexpr bool lt(const char_type &__c1,
                             const char_type &__c2) noexcept {
      return __c1 < __c2;
    }

    static constexpr int compare(const char_type *__s1, const char_type *__s2,
                                 size_t __n) {
      for (size_t __i = 0; __i < __n; ++__i)
        if (lt(__s1[__i], __s2[__i]))
          return -1;
        else if (lt(__s2[__i], __s1[__i]))
          return 1;
      return 0;
    }

    static constexpr size_t length(const char_type *__s) {
      size_t __i = 0;
      while (!eq(__s[__i], char_type()))
        ++__i;
      return __i;
    }

    static constexpr const char_type *find(const char_type *__s, size_t __n,
                                           const char_type &__a) {
      for (size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

    static constexpr char_type *move(char_type *__s1, const char_type *__s2,
                                     size_t __n) {
      if (__n == 0)
        return __s1;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);

      return (static_cast<char_type *>(
          __builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
    }

    static constexpr char_type *copy(char_type *__s1, const char_type *__s2,
                                     size_t __n) {
      if (__n == 0)
        return __s1;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);

      return (static_cast<char_type *>(
          __builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
    }

    static constexpr char_type *assign(char_type *__s, size_t __n,
                                       char_type __a) {
      for (size_t __i = 0; __i < __n; ++__i)
        assign(__s[__i], __a);
      return __s;
    }

    static constexpr char_type to_char_type(const int_type &__c) noexcept {
      return char_type(__c);
    }

    static constexpr bool eq_int_type(const int_type &__c1,
                                      const int_type &__c2) noexcept {
      return __c1 == __c2;
    }

    static constexpr int_type to_int_type(const char_type &__c) noexcept {
      return __c == eof() ? int_type(0xfffd) : int_type(__c);
    }

    static constexpr int_type eof() noexcept {
      return static_cast<int_type>(-1);
    }

    static constexpr int_type not_eof(const int_type &__c) noexcept {
      return eq_int_type(__c, eof()) ? 0 : __c;
    }
  };

  template <> struct char_traits<char32_t> {
    typedef char32_t char_type;

    typedef unsigned int int_type;

    typedef streamoff off_type;
    typedef u32streampos pos_type;
    typedef mbstate_t state_type;

    using comparison_category = strong_ordering;

    static constexpr void assign(char_type &__c1,
                                 const char_type &__c2) noexcept {

      if (std::__is_constant_evaluated())
        std::construct_at(__builtin_addressof(__c1), __c2);
      else

        __c1 = __c2;
    }

    static constexpr bool eq(const char_type &__c1,
                             const char_type &__c2) noexcept {
      return __c1 == __c2;
    }

    static constexpr bool lt(const char_type &__c1,
                             const char_type &__c2) noexcept {
      return __c1 < __c2;
    }

    static constexpr int compare(const char_type *__s1, const char_type *__s2,
                                 size_t __n) {
      for (size_t __i = 0; __i < __n; ++__i)
        if (lt(__s1[__i], __s2[__i]))
          return -1;
        else if (lt(__s2[__i], __s1[__i]))
          return 1;
      return 0;
    }

    static constexpr size_t length(const char_type *__s) {
      size_t __i = 0;
      while (!eq(__s[__i], char_type()))
        ++__i;
      return __i;
    }

    static constexpr const char_type *find(const char_type *__s, size_t __n,
                                           const char_type &__a) {
      for (size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

    static constexpr char_type *move(char_type *__s1, const char_type *__s2,
                                     size_t __n) {
      if (__n == 0)
        return __s1;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);

      return (static_cast<char_type *>(
          __builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
    }

    static constexpr char_type *copy(char_type *__s1, const char_type *__s2,
                                     size_t __n) {
      if (__n == 0)
        return __s1;

      if (std::__is_constant_evaluated())
        return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);

      return (static_cast<char_type *>(
          __builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
    }

    static constexpr char_type *assign(char_type *__s, size_t __n,
                                       char_type __a) {
      for (size_t __i = 0; __i < __n; ++__i)
        assign(__s[__i], __a);
      return __s;
    }

    static constexpr char_type to_char_type(const int_type &__c) noexcept {
      return char_type(__c);
    }

    static constexpr int_type to_int_type(const char_type &__c) noexcept {
      return int_type(__c);
    }

    static constexpr bool eq_int_type(const int_type &__c1,
                                      const int_type &__c2) noexcept {
      return __c1 == __c2;
    }

    static constexpr int_type eof() noexcept {
      return static_cast<int_type>(-1);
    }

    static constexpr int_type not_eof(const int_type &__c) noexcept {
      return eq_int_type(__c, eof()) ? 0 : __c;
    }
  };

  namespace __detail {
  template <typename _ChTraits>
  constexpr auto __char_traits_cmp_cat(int __cmp) noexcept {
    if constexpr (requires { typename _ChTraits::comparison_category; }) {
      using _Cat = typename _ChTraits::comparison_category;
      static_assert(!is_void_v<common_comparison_category_t<_Cat>>);
      return static_cast<_Cat>(__cmp <=> 0);
    } else
      return static_cast<weak_ordering>(__cmp <=> 0);
  }
  } // namespace __detail

#pragma GCC diagnostic pop

} // namespace std
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ios" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/localefwd.h" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/localefwd.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++locale.h" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++locale.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/clocale" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/clocale" 3

# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 92 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3 4
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4
struct lconv {

  char *decimal_point;
  char *thousands_sep;

  char *grouping;

  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;

  char p_sign_posn;
  char n_sign_posn;

  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;

  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};

extern char *setlocale(int __category, const char *__locale) noexcept(true);

extern struct lconv *localeconv(void) noexcept(true);
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale(int __category_mask, const char *__locale,
                          locale_t __base) noexcept(true);
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale(locale_t __dataset) noexcept(true);

extern void freelocale(locale_t __dataset) noexcept(true);

extern locale_t uselocale(locale_t __dataset) noexcept(true);
}
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/clocale" 2 3

namespace std {
using ::lconv;
using ::localeconv;
using ::setlocale;
} // namespace std
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++locale.h" 2 3

namespace __gnu_cxx __attribute__((__visibility__("default"))) {

  extern "C" __typeof(uselocale) __uselocale;

}

namespace std __attribute__((__visibility__("default"))) {

  typedef __locale_t __c_locale;
# 73 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++locale.h" 3
  inline int __convert_from_v(
      const __c_locale &__cloc __attribute__((__unused__)), char *__out,
      const int __size __attribute__((__unused__)), const char *__fmt, ...) {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 93 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);

    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);

    __builtin_va_end(__args);

    __gnu_cxx::__uselocale(__old);

    return __ret;
  }

} // namespace std
# 41 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/localefwd.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cctype" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cctype" 3

# 1 "/usr/include/ctype.h" 1 3 4
# 26 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4

typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;

typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;

typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;

typedef long int __quad_t;
typedef unsigned long int __u_quad_t;

typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4

typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct {
  int __val[2];
} __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;

typedef int __clockid_t;

typedef void *__timer_t;

typedef long int __blksize_t;

typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;

typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;

typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;

typedef long int __fsword_t;

typedef long int __ssize_t;

typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;

typedef __off64_t __loff_t;
typedef char *__caddr_t;

typedef long int __intptr_t;

typedef unsigned int __socklen_t;

typedef int __sig_atomic_t;
# 27 "/usr/include/ctype.h" 2 3 4

extern "C" {
# 39 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 40 "/usr/include/ctype.h" 2 3 4

enum {
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc(void) noexcept(true)
    __attribute__((__const__));
extern const __int32_t **__ctype_tolower_loc(void) noexcept(true)
    __attribute__((__const__));
extern const __int32_t **__ctype_toupper_loc(void) noexcept(true)
    __attribute__((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum(int) noexcept(true);
extern int isalpha(int) noexcept(true);
extern int iscntrl(int) noexcept(true);
extern int isdigit(int) noexcept(true);
extern int islower(int) noexcept(true);
extern int isgraph(int) noexcept(true);
extern int isprint(int) noexcept(true);
extern int ispunct(int) noexcept(true);
extern int isspace(int) noexcept(true);
extern int isupper(int) noexcept(true);
extern int isxdigit(int) noexcept(true);

extern int tolower(int __c) noexcept(true);

extern int toupper(int __c) noexcept(true);

extern int isblank(int) noexcept(true);

extern int isctype(int __c, int __mask) noexcept(true);

extern int isascii(int __c) noexcept(true);

extern int toascii(int __c) noexcept(true);

extern int _toupper(int) noexcept(true);
extern int _tolower(int) noexcept(true);
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l(int, locale_t) noexcept(true);
extern int isalpha_l(int, locale_t) noexcept(true);
extern int iscntrl_l(int, locale_t) noexcept(true);
extern int isdigit_l(int, locale_t) noexcept(true);
extern int islower_l(int, locale_t) noexcept(true);
extern int isgraph_l(int, locale_t) noexcept(true);
extern int isprint_l(int, locale_t) noexcept(true);
extern int ispunct_l(int, locale_t) noexcept(true);
extern int isspace_l(int, locale_t) noexcept(true);
extern int isupper_l(int, locale_t) noexcept(true);
extern int isxdigit_l(int, locale_t) noexcept(true);

extern int isblank_l(int, locale_t) noexcept(true);

extern int __tolower_l(int __c, locale_t __l) noexcept(true);
extern int tolower_l(int __c, locale_t __l) noexcept(true);

extern int __toupper_l(int __c, locale_t __l) noexcept(true);
extern int toupper_l(int __c, locale_t __l) noexcept(true);
# 327 "/usr/include/ctype.h" 3 4
}
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cctype" 2 3
# 62 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cctype" 3
namespace std {
using ::isalnum;
using ::isalpha;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;
} // namespace std

namespace std {
using ::isblank;
}
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/localefwd.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 55 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/localefwd.h" 3
  class locale;

  template <typename _Facet> bool has_facet(const locale &) throw();

  template <typename _Facet> const _Facet &use_facet(const locale &);

  template <typename _CharT> bool isspace(_CharT, const locale &);

  template <typename _CharT> bool isprint(_CharT, const locale &);

  template <typename _CharT> bool iscntrl(_CharT, const locale &);

  template <typename _CharT> bool isupper(_CharT, const locale &);

  template <typename _CharT> bool islower(_CharT, const locale &);

  template <typename _CharT> bool isalpha(_CharT, const locale &);

  template <typename _CharT> bool isdigit(_CharT, const locale &);

  template <typename _CharT> bool ispunct(_CharT, const locale &);

  template <typename _CharT> bool isxdigit(_CharT, const locale &);

  template <typename _CharT> bool isalnum(_CharT, const locale &);

  template <typename _CharT> bool isgraph(_CharT, const locale &);

  template <typename _CharT> bool isblank(_CharT, const locale &);

  template <typename _CharT> _CharT toupper(_CharT, const locale &);

  template <typename _CharT> _CharT tolower(_CharT, const locale &);

  struct ctype_base;
  template <typename _CharT> class ctype;
  template <> class ctype<char>;

  template <> class ctype<wchar_t>;

  template <typename _CharT> class ctype_byname;

  class codecvt_base;
  template <typename _InternT, typename _ExternT, typename _StateT>
  class codecvt;
  template <> class codecvt<char, char, mbstate_t>;

  template <> class codecvt<wchar_t, char, mbstate_t>;

  template <> class codecvt<char16_t, char, mbstate_t>;
  template <> class codecvt<char32_t, char, mbstate_t>;

  template <> class codecvt<char16_t, char8_t, mbstate_t>;
  template <> class codecvt<char32_t, char8_t, mbstate_t>;

  template <typename _InternT, typename _ExternT, typename _StateT>
  class codecvt_byname;

  template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>>
  class num_get;
  template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>>
  class num_put;

  namespace __cxx11 {
  template <typename _CharT> class numpunct;
  template <typename _CharT> class numpunct_byname;
  } // namespace __cxx11

  namespace __cxx11 {

  template <typename _CharT> class collate;
  template <typename _CharT> class collate_byname;
  } // namespace __cxx11

  class time_base;
  namespace __cxx11 {
  template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>>
  class time_get;
  template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>>
  class time_get_byname;
  } // namespace __cxx11
  template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>>
  class time_put;
  template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>>
  class time_put_byname;

  class money_base;
  namespace __cxx11 {
  template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>>
  class money_get;
  template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>>
  class money_put;
  } // namespace __cxx11
  namespace __cxx11 {
  template <typename _CharT, bool _Intl = false> class moneypunct;
  template <typename _CharT, bool _Intl = false> class moneypunct_byname;
  } // namespace __cxx11

  struct messages_base;
  namespace __cxx11 {
  template <typename _CharT> class messages;
  template <typename _CharT> class messages_byname;
  } // namespace __cxx11

} // namespace std
# 44 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ios" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/atomicity.h" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/atomicity.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/gthr.h" 1 3
# 30 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/gthr.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/gthr-default.h" 1 3
# 35 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 22 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 18 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 3 4
typedef long unsigned int size_t;
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 92 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3 4
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 30 "/usr/include/sched.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 32 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec {

  __time_t tv_sec;

  __syscall_slong_t tv_nsec;
# 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 33 "/usr/include/sched.h" 2 3 4

typedef __pid_t pid_t;

# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 80 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h" 3 4
struct sched_param {
  int sched_priority;
};
# 81 "/usr/include/x86_64-linux-gnu/bits/sched.h" 2 3 4

extern "C" {

extern int clone(int (*__fn)(void *__arg), void *__child_stack, int __flags,
                 void *__arg, ...) noexcept(true);

extern int unshare(int __flags) noexcept(true);

extern int sched_getcpu(void) noexcept(true);

extern int getcpu(unsigned int *, unsigned int *) noexcept(true);

extern int setns(int __fd, int __nstype) noexcept(true);
}
# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;

typedef struct {
  __cpu_mask __bits[1024 / (8 * sizeof(__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
extern "C" {

extern int __sched_cpucount(size_t __setsize,
                            const cpu_set_t *__setp) noexcept(true);
extern cpu_set_t *__sched_cpualloc(size_t __count) noexcept(true);
extern void __sched_cpufree(cpu_set_t *__set) noexcept(true);
}
# 45 "/usr/include/sched.h" 2 3 4

extern "C" {

extern int sched_setparam(__pid_t __pid,
                          const struct sched_param *__param) noexcept(true);

extern int sched_getparam(__pid_t __pid,
                          struct sched_param *__param) noexcept(true);

extern int sched_setscheduler(__pid_t __pid, int __policy,
                              const struct sched_param *__param) noexcept(true);

extern int sched_getscheduler(__pid_t __pid) noexcept(true);

extern int sched_yield(void) noexcept(true);

extern int sched_get_priority_max(int __algorithm) noexcept(true);

extern int sched_get_priority_min(int __algorithm) noexcept(true);

extern int sched_rr_get_interval(__pid_t __pid,
                                 struct timespec *__t) noexcept(true);
# 130 "/usr/include/sched.h" 3 4
extern int sched_setaffinity(__pid_t __pid, size_t __cpusetsize,
                             const cpu_set_t *__cpuset) noexcept(true);

extern int sched_getaffinity(__pid_t __pid, size_t __cpusetsize,
                             cpu_set_t *__cpuset) noexcept(true);
}
# 23 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 18 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 3 4
typedef long unsigned int size_t;
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 92 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3 4
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 30 "/usr/include/time.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4

struct timeval {

  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 23 "/usr/include/x86_64-linux-gnu/bits/timex.h" 2 3 4

struct timex {
# 58 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;

  int : 32;
  int : 32;
  int : 32;
  int : 32;
  int : 32;
  int : 32;
  int : 32;
  int : 32;
  int : 32;
  int : 32;
  int : 32;
};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {

extern int clock_adjtime(__clockid_t __clock_id,
                         struct timex *__utx) noexcept(true)
    __attribute__((__nonnull__(2)));
# 90 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
}
# 34 "/usr/include/time.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4

typedef __clock_t clock_t;
# 38 "/usr/include/time.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4

struct tm {
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;

  long int tm_gmtoff;
  const char *tm_zone;
};
# 40 "/usr/include/time.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4

typedef __clockid_t clockid_t;
# 47 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4

typedef __timer_t timer_t;
# 48 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4

struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4
extern "C" {

extern clock_t clock(void) noexcept(true);

extern time_t time(time_t *__timer) noexcept(true);

extern double difftime(time_t __time1, time_t __time0) noexcept(true)
    __attribute__((__const__));

extern time_t mktime(struct tm *__tp) noexcept(true);
# 100 "/usr/include/time.h" 3 4
extern size_t strftime(char *__restrict __s, size_t __maxsize,
                       const char *__restrict __format,
                       const struct tm *__restrict __tp) noexcept(true)
    __attribute__((__nonnull__(1, 3, 4)));

extern char *strptime(const char *__restrict __s, const char *__restrict __fmt,
                      struct tm *__tp) noexcept(true);

extern size_t strftime_l(char *__restrict __s, size_t __maxsize,
                         const char *__restrict __format,
                         const struct tm *__restrict __tp,
                         locale_t __loc) noexcept(true);

extern char *strptime_l(const char *__restrict __s,
                        const char *__restrict __fmt, struct tm *__tp,
                        locale_t __loc) noexcept(true);

extern struct tm *gmtime(const time_t *__timer) noexcept(true);

extern struct tm *localtime(const time_t *__timer) noexcept(true);
# 155 "/usr/include/time.h" 3 4
extern struct tm *gmtime_r(const time_t *__restrict __timer,
                           struct tm *__restrict __tp) noexcept(true);

extern struct tm *localtime_r(const time_t *__restrict __timer,
                              struct tm *__restrict __tp) noexcept(true);
# 180 "/usr/include/time.h" 3 4
extern char *asctime(const struct tm *__tp) noexcept(true);

extern char *ctime(const time_t *__timer) noexcept(true);
# 198 "/usr/include/time.h" 3 4
extern char *asctime_r(const struct tm *__restrict __tp,
                       char *__restrict __buf) noexcept(true);

extern char *ctime_r(const time_t *__restrict __timer,
                     char *__restrict __buf) noexcept(true);
# 218 "/usr/include/time.h" 3 4
extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;

extern char *tzname[2];

extern void tzset(void) noexcept(true);

extern int daylight;
extern long int timezone;
# 247 "/usr/include/time.h" 3 4
extern time_t timegm(struct tm *__tp) noexcept(true);
# 264 "/usr/include/time.h" 3 4
extern time_t timelocal(struct tm *__tp) noexcept(true);

extern int dysize(int __year) noexcept(true) __attribute__((__const__));
# 282 "/usr/include/time.h" 3 4
extern int nanosleep(const struct timespec *__requested_time,
                     struct timespec *__remaining);

extern int clock_getres(clockid_t __clock_id,
                        struct timespec *__res) noexcept(true);

extern int clock_gettime(clockid_t __clock_id,
                         struct timespec *__tp) noexcept(true)
    __attribute__((__nonnull__(2)));

extern int clock_settime(clockid_t __clock_id,
                         const struct timespec *__tp) noexcept(true)
    __attribute__((__nonnull__(2)));
# 324 "/usr/include/time.h" 3 4
extern int clock_nanosleep(clockid_t __clock_id, int __flags,
                           const struct timespec *__req,
                           struct timespec *__rem);
# 339 "/usr/include/time.h" 3 4
extern int clock_getcpuclockid(pid_t __pid,
                               clockid_t *__clock_id) noexcept(true);

extern int timer_create(clockid_t __clock_id, struct sigevent *__restrict __evp,
                        timer_t *__restrict __timerid) noexcept(true);

extern int timer_delete(timer_t __timerid) noexcept(true);

extern int timer_settime(timer_t __timerid, int __flags,
                         const struct itimerspec *__restrict __value,
                         struct itimerspec *__restrict __ovalue) noexcept(true);

extern int timer_gettime(timer_t __timerid,
                         struct itimerspec *__value) noexcept(true);
# 377 "/usr/include/time.h" 3 4
extern int timer_getoverrun(timer_t __timerid) noexcept(true);

extern int timespec_get(struct timespec *__ts, int __base) noexcept(true)
    __attribute__((__nonnull__(1)));
# 400 "/usr/include/time.h" 3 4
extern int timespec_getres(struct timespec *__ts, int __base) noexcept(true);
# 426 "/usr/include/time.h" 3 4
extern int getdate_err;
# 435 "/usr/include/time.h" 3 4
extern struct tm *getdate(const char *__string);
# 449 "/usr/include/time.h" 3 4
extern int getdate_r(const char *__restrict __string,
                     struct tm *__restrict __resbufp);
}
# 24 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 3 4
typedef union {
  __extension__ unsigned long long int __value64;
  struct {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4

typedef struct __pthread_internal_list {
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist {
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s {
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;

  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t {
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;

  unsigned char __pad1[7];

  unsigned long int __pad2;

  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 90 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4

struct __pthread_cond_s {
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2];
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct {
  int __data;
} __once_flag;
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4

typedef unsigned long int pthread_t;

typedef union {
  char __size[4];
  int __align;
} pthread_mutexattr_t;

typedef union {
  char __size[4];
  int __align;
} pthread_condattr_t;

typedef unsigned int pthread_key_t;

typedef int pthread_once_t;

union pthread_attr_t {
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;

typedef union {
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union {
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union {
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union {
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;

typedef volatile int pthread_spinlock_t;

typedef union {
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union {
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 27 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4

typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4

typedef struct {
  unsigned long int __val[(1024 / (8 * sizeof(unsigned long int)))];
} __sigset_t;
# 31 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h" 3 4
struct __jmp_buf_tag {

  __jmp_buf __jmpbuf;
  int __mask_was_saved;
  __sigset_t __saved_mask;
};
# 32 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 3 4
extern "C" {
extern long int __sysconf(int __name) noexcept(true);
}
# 34 "/usr/include/pthread.h" 2 3 4

enum {
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};

enum {
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL

  ,
  PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};

enum {
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};

enum { PTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT, PTHREAD_PRIO_PROTECT };
# 104 "/usr/include/pthread.h" 3 4
enum {
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 124 "/usr/include/pthread.h" 3 4
enum {
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};

enum {
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};

enum {
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 159 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer {
  void (*__routine)(void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};

enum {
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum {
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 197 "/usr/include/pthread.h" 3 4
extern "C" {

extern int pthread_create(pthread_t *__restrict __newthread,
                          const pthread_attr_t *__restrict __attr,
                          void *(*__start_routine)(void *),
                          void *__restrict __arg) noexcept(true)
    __attribute__((__nonnull__(1, 3)));

extern void pthread_exit(void *__retval) __attribute__((__noreturn__));

extern int pthread_join(pthread_t __th, void **__thread_return);

extern int pthread_tryjoin_np(pthread_t __th,
                              void **__thread_return) noexcept(true);
# 233 "/usr/include/pthread.h" 3 4
extern int pthread_timedjoin_np(pthread_t __th, void **__thread_return,
                                const struct timespec *__abstime);
# 243 "/usr/include/pthread.h" 3 4
extern int pthread_clockjoin_np(pthread_t __th, void **__thread_return,
                                clockid_t __clockid,
                                const struct timespec *__abstime);
# 269 "/usr/include/pthread.h" 3 4
extern int pthread_detach(pthread_t __th) noexcept(true);

extern pthread_t pthread_self(void) noexcept(true) __attribute__((__const__));

extern int pthread_equal(pthread_t __thread1,
                         pthread_t __thread2) noexcept(true)
    __attribute__((__const__));

extern int pthread_attr_init(pthread_attr_t *__attr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_attr_destroy(pthread_attr_t *__attr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_attr_getdetachstate(const pthread_attr_t *__attr,
                                       int *__detachstate) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_attr_setdetachstate(pthread_attr_t *__attr,
                                       int __detachstate) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_attr_getguardsize(const pthread_attr_t *__attr,
                                     size_t *__guardsize) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_attr_setguardsize(pthread_attr_t *__attr,
                                     size_t __guardsize) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_attr_getschedparam(
    const pthread_attr_t *__restrict __attr,
    struct sched_param *__restrict __param) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_attr_setschedparam(
    pthread_attr_t *__restrict __attr,
    const struct sched_param *__restrict __param) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict __attr,
                                       int *__restrict __policy) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_attr_setschedpolicy(pthread_attr_t *__attr,
                                       int __policy) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int
pthread_attr_getinheritsched(const pthread_attr_t *__restrict __attr,
                             int *__restrict __inherit) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_attr_setinheritsched(pthread_attr_t *__attr,
                                        int __inherit) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_attr_getscope(const pthread_attr_t *__restrict __attr,
                                 int *__restrict __scope) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_attr_setscope(pthread_attr_t *__attr,
                                 int __scope) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int
pthread_attr_getstackaddr(const pthread_attr_t *__restrict __attr,
                          void **__restrict __stackaddr) noexcept(true)
    __attribute__((__nonnull__(1, 2))) __attribute__((__deprecated__));

extern int pthread_attr_setstackaddr(pthread_attr_t *__attr,
                                     void *__stackaddr) noexcept(true)
    __attribute__((__nonnull__(1))) __attribute__((__deprecated__));

extern int
pthread_attr_getstacksize(const pthread_attr_t *__restrict __attr,
                          size_t *__restrict __stacksize) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_attr_setstacksize(pthread_attr_t *__attr,
                                     size_t __stacksize) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_attr_getstack(const pthread_attr_t *__restrict __attr,
                                 void **__restrict __stackaddr,
                                 size_t *__restrict __stacksize) noexcept(true)
    __attribute__((__nonnull__(1, 2, 3)));

extern int pthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr,
                                 size_t __stacksize) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_attr_setaffinity_np(pthread_attr_t *__attr,
                                       size_t __cpusetsize,
                                       const cpu_set_t *__cpuset) noexcept(true)
    __attribute__((__nonnull__(1, 3)));

extern int pthread_attr_getaffinity_np(const pthread_attr_t *__attr,
                                       size_t __cpusetsize,
                                       cpu_set_t *__cpuset) noexcept(true)
    __attribute__((__nonnull__(1, 3)));

extern int pthread_getattr_default_np(pthread_attr_t *__attr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_attr_setsigmask_np(pthread_attr_t *__attr,
                                      const __sigset_t *sigmask);

extern int pthread_attr_getsigmask_np(const pthread_attr_t *__attr,
                                      __sigset_t *sigmask);

extern int
pthread_setattr_default_np(const pthread_attr_t *__attr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_getattr_np(pthread_t __th,
                              pthread_attr_t *__attr) noexcept(true)
    __attribute__((__nonnull__(2)));

extern int
pthread_setschedparam(pthread_t __target_thread, int __policy,
                      const struct sched_param *__param) noexcept(true)
    __attribute__((__nonnull__(3)));

extern int
pthread_getschedparam(pthread_t __target_thread, int *__restrict __policy,
                      struct sched_param *__restrict __param) noexcept(true)
    __attribute__((__nonnull__(2, 3)));

extern int pthread_setschedprio(pthread_t __target_thread,
                                int __prio) noexcept(true);

extern int pthread_getname_np(pthread_t __target_thread, char *__buf,
                              size_t __buflen) noexcept(true)
    __attribute__((__nonnull__(2)));

extern int pthread_setname_np(pthread_t __target_thread,
                              const char *__name) noexcept(true)
    __attribute__((__nonnull__(2)));

extern int pthread_getconcurrency(void) noexcept(true);

extern int pthread_setconcurrency(int __level) noexcept(true);

extern int pthread_yield(void) noexcept(true);

extern int pthread_yield(void) noexcept(true) __asm__(""
                                                      "sched_yield")
    __attribute__((__deprecated__(
        "pthread_yield is deprecated, use sched_yield instead")));
# 489 "/usr/include/pthread.h" 3 4
extern int pthread_setaffinity_np(pthread_t __th, size_t __cpusetsize,
                                  const cpu_set_t *__cpuset) noexcept(true)
    __attribute__((__nonnull__(3)));

extern int pthread_getaffinity_np(pthread_t __th, size_t __cpusetsize,
                                  cpu_set_t *__cpuset) noexcept(true)
    __attribute__((__nonnull__(3)));
# 509 "/usr/include/pthread.h" 3 4
extern int pthread_once(pthread_once_t *__once_control,
                        void (*__init_routine)(void))
    __attribute__((__nonnull__(1, 2)));
# 521 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate(int __state, int *__oldstate);

extern int pthread_setcanceltype(int __type, int *__oldtype);

extern int pthread_cancel(pthread_t __th);

extern void pthread_testcancel(void);

struct __cancel_jmp_buf_tag {
  __jmp_buf __cancel_jmp_buf;
  int __mask_was_saved;
};

typedef struct {
  struct __cancel_jmp_buf_tag __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__((__aligned__));
# 557 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame {
  void (*__cancel_routine)(void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};

class __pthread_cleanup_class {
  void (*__cancel_routine)(void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

public:
  __pthread_cleanup_class(void (*__fct)(void *), void *__arg)
      : __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1) {}
  ~__pthread_cleanup_class() {
    if (__do_it)
      __cancel_routine(__cancel_arg);
  }
  void __setdoit(int __newval) { __do_it = __newval; }
  void __defer() {
    pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &__cancel_type);
  }
  void __restore() const { pthread_setcanceltype(__cancel_type, 0); }
};
# 773 "/usr/include/pthread.h" 3 4
extern int __sigsetjmp(struct __jmp_buf_tag __env[1],
                       int __savemask) noexcept(true);

extern int
pthread_mutex_init(pthread_mutex_t *__mutex,
                   const pthread_mutexattr_t *__mutexattr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_mutex_destroy(pthread_mutex_t *__mutex) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_mutex_trylock(pthread_mutex_t *__mutex) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_mutex_lock(pthread_mutex_t *__mutex) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_mutex_timedlock(
    pthread_mutex_t *__restrict __mutex,
    const struct timespec *__restrict __abstime) noexcept(true)
    __attribute__((__nonnull__(1, 2)));
# 817 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_clocklock(
    pthread_mutex_t *__restrict __mutex, clockid_t __clockid,
    const struct timespec *__restrict __abstime) noexcept(true)
    __attribute__((__nonnull__(1, 3)));
# 835 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_unlock(pthread_mutex_t *__mutex) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int
pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict __mutex,
                             int *__restrict __prioceiling) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int
pthread_mutex_setprioceiling(pthread_mutex_t *__restrict __mutex,
                             int __prioceiling,
                             int *__restrict __old_ceiling) noexcept(true)
    __attribute__((__nonnull__(1, 3)));

extern int pthread_mutex_consistent(pthread_mutex_t *__mutex) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_mutex_consistent_np(pthread_mutex_t *) noexcept(
    true) __asm__(""
                  "pthread_mutex_consistent") __attribute__((__nonnull__(1)))

__attribute__((__deprecated__("pthread_mutex_consistent_np is deprecated, use "
                              "pthread_mutex_consistent")));
# 874 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int
pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict __attr,
                             int *__restrict __pshared) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr,
                                        int __pshared) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int
pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict __attr,
                          int *__restrict __kind) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr,
                                     int __kind) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int
pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict __attr,
                              int *__restrict __protocol) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr,
                                         int __protocol) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int
pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict __attr,
                                 int *__restrict __prioceiling) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr,
                                            int __prioceiling) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr,
                                       int *__robustness) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int
pthread_mutexattr_getrobust_np(pthread_mutexattr_t *, int *) noexcept(
    true) __asm__(""
                  "pthread_mutexattr_getrobust") __attribute__((__nonnull__(1)))

__attribute__((__deprecated__("pthread_mutexattr_getrobust_np is deprecated, "
                              "use pthread_mutexattr_getrobust")));

extern int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr,
                                       int __robustness) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_mutexattr_setrobust_np(pthread_mutexattr_t *, int) noexcept(
    true) __asm__(""
                  "pthread_mutexattr_setrobust") __attribute__((__nonnull__(1)))

__attribute__((__deprecated__("pthread_mutexattr_setrobust_np is deprecated, "
                              "use pthread_mutexattr_setrobust")));
# 967 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init(
    pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict __attr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_rwlock_timedrdlock(
    pthread_rwlock_t *__restrict __rwlock,
    const struct timespec *__restrict __abstime) noexcept(true)
    __attribute__((__nonnull__(1, 2)));
# 1004 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_clockrdlock(
    pthread_rwlock_t *__restrict __rwlock, clockid_t __clockid,
    const struct timespec *__restrict __abstime) noexcept(true)
    __attribute__((__nonnull__(1, 3)));
# 1023 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_rwlock_timedwrlock(
    pthread_rwlock_t *__restrict __rwlock,
    const struct timespec *__restrict __abstime) noexcept(true)
    __attribute__((__nonnull__(1, 2)));
# 1051 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_clockwrlock(
    pthread_rwlock_t *__restrict __rwlock, clockid_t __clockid,
    const struct timespec *__restrict __abstime) noexcept(true)
    __attribute__((__nonnull__(1, 3)));
# 1071 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int
pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int
pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict __attr,
                              int *__restrict __pshared) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr,
                                         int __pshared) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int
pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *__restrict __attr,
                              int *__restrict __pref) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr,
                                         int __pref) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_cond_init(
    pthread_cond_t *__restrict __cond,
    const pthread_condattr_t *__restrict __cond_attr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_cond_destroy(pthread_cond_t *__cond) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_cond_signal(pthread_cond_t *__cond) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_cond_broadcast(pthread_cond_t *__cond) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_cond_wait(pthread_cond_t *__restrict __cond,
                             pthread_mutex_t *__restrict __mutex)
    __attribute__((__nonnull__(1, 2)));
# 1145 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait(pthread_cond_t *__restrict __cond,
                                  pthread_mutex_t *__restrict __mutex,
                                  const struct timespec *__restrict __abstime)
    __attribute__((__nonnull__(1, 2, 3)));
# 1171 "/usr/include/pthread.h" 3 4
extern int pthread_cond_clockwait(pthread_cond_t *__restrict __cond,
                                  pthread_mutex_t *__restrict __mutex,
                                  __clockid_t __clock_id,
                                  const struct timespec *__restrict __abstime)
    __attribute__((__nonnull__(1, 2, 4)));
# 1194 "/usr/include/pthread.h" 3 4
extern int pthread_condattr_init(pthread_condattr_t *__attr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_condattr_destroy(pthread_condattr_t *__attr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int
pthread_condattr_getpshared(const pthread_condattr_t *__restrict __attr,
                            int *__restrict __pshared) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_condattr_setpshared(pthread_condattr_t *__attr,
                                       int __pshared) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int
pthread_condattr_getclock(const pthread_condattr_t *__restrict __attr,
                          __clockid_t *__restrict __clock_id) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_condattr_setclock(pthread_condattr_t *__attr,
                                     __clockid_t __clock_id) noexcept(true)
    __attribute__((__nonnull__(1)));
# 1230 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init(pthread_spinlock_t *__lock,
                             int __pshared) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_spin_destroy(pthread_spinlock_t *__lock) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_spin_lock(pthread_spinlock_t *__lock) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_spin_trylock(pthread_spinlock_t *__lock) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_spin_unlock(pthread_spinlock_t *__lock) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_barrier_init(pthread_barrier_t *__restrict __barrier,
                                const pthread_barrierattr_t *__restrict __attr,
                                unsigned int __count) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_barrier_destroy(pthread_barrier_t *__barrier) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_barrier_wait(pthread_barrier_t *__barrier) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int
pthread_barrierattr_init(pthread_barrierattr_t *__attr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int
pthread_barrierattr_destroy(pthread_barrierattr_t *__attr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int
pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict __attr,
                               int *__restrict __pshared) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr,
                                          int __pshared) noexcept(true)
    __attribute__((__nonnull__(1)));
# 1297 "/usr/include/pthread.h" 3 4
extern int pthread_key_create(pthread_key_t *__key,
                              void (*__destr_function)(void *)) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int pthread_key_delete(pthread_key_t __key) noexcept(true);

extern void *pthread_getspecific(pthread_key_t __key) noexcept(true);

extern int pthread_setspecific(pthread_key_t __key,
                               const void *__pointer) noexcept(true);

extern int pthread_getcpuclockid(pthread_t __thread_id,
                                 __clockid_t *__clock_id) noexcept(true)
    __attribute__((__nonnull__(2)));
# 1332 "/usr/include/pthread.h" 3 4
extern int pthread_atfork(void (*__prepare)(void), void (*__parent)(void),
                          void (*__child)(void)) noexcept(true);
# 1346 "/usr/include/pthread.h" 3 4
}
# 36 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/gthr-default.h" 2 3
# 47 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 299 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/gthr-default.h" 3
static inline int __gthread_active_p(void) { return 1; }
# 659 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/gthr-default.h" 3
static inline int __gthread_create(__gthread_t *__threadid,
                                   void *(*__func)(void *), void *__args) {
  return pthread_create(__threadid, __null, __func, __args);
}

static inline int __gthread_join(__gthread_t __threadid, void **__value_ptr) {
  return pthread_join(__threadid, __value_ptr);
}

static inline int __gthread_detach(__gthread_t __threadid) {
  return pthread_detach(__threadid);
}

static inline int __gthread_equal(__gthread_t __t1, __gthread_t __t2) {
  return pthread_equal(__t1, __t2);
}

static inline __gthread_t __gthread_self(void) { return pthread_self(); }

static inline int __gthread_yield(void) { return sched_yield(); }

static inline int __gthread_once(__gthread_once_t *__once,
                                 void (*__func)(void)) {
  if (__gthread_active_p())
    return pthread_once(__once, __func);
  else
    return -1;
}

static inline int __gthread_key_create(__gthread_key_t *__key,
                                       void (*__dtor)(void *)) {
  return pthread_key_create(__key, __dtor);
}

static inline int __gthread_key_delete(__gthread_key_t __key) {
  return pthread_key_delete(__key);
}

static inline void *__gthread_getspecific(__gthread_key_t __key) {
  return pthread_getspecific(__key);
}

static inline int __gthread_setspecific(__gthread_key_t __key,
                                        const void *__ptr) {
  return pthread_setspecific(__key, __ptr);
}

static inline void __gthread_mutex_init_function(__gthread_mutex_t *__mutex) {
  if (__gthread_active_p())
    pthread_mutex_init(__mutex, __null);
}

static inline int __gthread_mutex_destroy(__gthread_mutex_t *__mutex) {
  if (__gthread_active_p())
    return pthread_mutex_destroy(__mutex);
  else
    return 0;
}

static inline int __gthread_mutex_lock(__gthread_mutex_t *__mutex) {
  if (__gthread_active_p())
    return pthread_mutex_lock(__mutex);
  else
    return 0;
}

static inline int __gthread_mutex_trylock(__gthread_mutex_t *__mutex) {
  if (__gthread_active_p())
    return pthread_mutex_trylock(__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_timedlock(__gthread_mutex_t *__mutex,
                          const __gthread_time_t *__abs_timeout) {
  if (__gthread_active_p())
    return pthread_mutex_timedlock(__mutex, __abs_timeout);
  else
    return 0;
}

static inline int __gthread_mutex_unlock(__gthread_mutex_t *__mutex) {
  if (__gthread_active_p())
    return pthread_mutex_unlock(__mutex);
  else
    return 0;
}
# 808 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *__mutex) {
  return __gthread_mutex_lock(__mutex);
}

static inline int
__gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *__mutex) {
  return __gthread_mutex_trylock(__mutex);
}

static inline int
__gthread_recursive_mutex_timedlock(__gthread_recursive_mutex_t *__mutex,
                                    const __gthread_time_t *__abs_timeout) {
  return __gthread_mutex_timedlock(__mutex, __abs_timeout);
}

static inline int
__gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *__mutex) {
  return __gthread_mutex_unlock(__mutex);
}

static inline int
__gthread_recursive_mutex_destroy(__gthread_recursive_mutex_t *__mutex) {
  return __gthread_mutex_destroy(__mutex);
}
# 850 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/gthr-default.h" 3
static inline int __gthread_cond_broadcast(__gthread_cond_t *__cond) {
  return pthread_cond_broadcast(__cond);
}

static inline int __gthread_cond_signal(__gthread_cond_t *__cond) {
  return pthread_cond_signal(__cond);
}

static inline int __gthread_cond_wait(__gthread_cond_t *__cond,
                                      __gthread_mutex_t *__mutex) {
  return pthread_cond_wait(__cond, __mutex);
}

static inline int
__gthread_cond_timedwait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
                         const __gthread_time_t *__abs_timeout) {
  return pthread_cond_timedwait(__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive(__gthread_cond_t *__cond,
                              __gthread_recursive_mutex_t *__mutex) {
  return __gthread_cond_wait(__cond, __mutex);
}

static inline int __gthread_cond_destroy(__gthread_cond_t *__cond) {
  return pthread_cond_destroy(__cond);
}
# 149 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/gthr.h" 2 3

#pragma GCC visibility pop
# 36 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/atomicity.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/atomic_word.h" 1 3
# 32 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/atomicity.h" 2 3

# 1 "/usr/include/x86_64-linux-gnu/sys/single_threaded.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/single_threaded.h" 3 4
extern "C" {

extern char __libc_single_threaded;
}
# 39 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__((__visibility__("default"))) {

  __attribute__((__always_inline__)) inline bool
  __is_single_threaded() noexcept {

    return ::__libc_single_threaded;
  }

  inline _Atomic_word __attribute__((__always_inline__)) __exchange_and_add(
      volatile _Atomic_word * __mem, int __val) {
    return __atomic_fetch_add(__mem, __val, 4);
  }

  inline void __attribute__((__always_inline__)) __atomic_add(
      volatile _Atomic_word * __mem, int __val) {
    __atomic_fetch_add(__mem, __val, 4);
  }
# 80 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/atomicity.h" 3
  inline _Atomic_word __attribute__((__always_inline__))
  __exchange_and_add_single(_Atomic_word * __mem, int __val) {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  inline void __attribute__((__always_inline__)) __atomic_add_single(
      _Atomic_word * __mem, int __val) {
    *__mem += __val;
  }

  inline _Atomic_word __attribute__((__always_inline__))
  __exchange_and_add_dispatch(_Atomic_word * __mem, int __val) {
    if (__is_single_threaded())
      return __exchange_and_add_single(__mem, __val);
    else
      return __exchange_and_add(__mem, __val);
  }

  inline void __attribute__((__always_inline__)) __atomic_add_dispatch(
      _Atomic_word * __mem, int __val) {
    if (__is_single_threaded())
      __atomic_add_single(__mem, __val);
    else
      __atomic_add(__mem, __val);
  }

} // namespace __gnu_cxx
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string" 1 3
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/allocator.h" 1 3
# 46 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/allocator.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++allocator.h" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++allocator.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/new_allocator.h" 1 3
# 35 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/new_allocator.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/functexcept.h" 1 3
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/functexcept.h" 3
namespace std __attribute__((__visibility__("default"))) {

  void __throw_bad_exception(void) __attribute__((__noreturn__));

  void __throw_bad_alloc(void) __attribute__((__noreturn__));

  void __throw_bad_array_new_length(void) __attribute__((__noreturn__));

  void __throw_bad_cast(void) __attribute__((__noreturn__));

  void __throw_bad_typeid(void) __attribute__((__noreturn__));

  void __throw_logic_error(const char *) __attribute__((__noreturn__));

  void __throw_domain_error(const char *) __attribute__((__noreturn__));

  void __throw_invalid_argument(const char *) __attribute__((__noreturn__));

  void __throw_length_error(const char *) __attribute__((__noreturn__));

  void __throw_out_of_range(const char *) __attribute__((__noreturn__));

  void __throw_out_of_range_fmt(const char *, ...) __attribute__((__noreturn__))
  __attribute__((__format__(__gnu_printf__, 1, 2)));

  void __throw_runtime_error(const char *) __attribute__((__noreturn__));

  void __throw_range_error(const char *) __attribute__((__noreturn__));

  void __throw_overflow_error(const char *) __attribute__((__noreturn__));

  void __throw_underflow_error(const char *) __attribute__((__noreturn__));

  void __throw_ios_failure(const char *) __attribute__((__noreturn__));

  void __throw_ios_failure(const char *, int) __attribute__((__noreturn__));

  void __throw_system_error(int) __attribute__((__noreturn__));

  void __throw_future_error(int) __attribute__((__noreturn__));

  void __throw_bad_function_call() __attribute__((__noreturn__));
# 141 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/functexcept.h" 3
} // namespace std
# 36 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/new_allocator.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 62 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/new_allocator.h" 3
  template <typename _Tp> class __new_allocator {
  public:
    typedef _Tp value_type;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
# 83 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/new_allocator.h" 3
    typedef std::true_type propagate_on_container_move_assignment;

    __attribute__((__always_inline__)) constexpr __new_allocator() noexcept {}

    __attribute__((__always_inline__)) constexpr __new_allocator(
        const __new_allocator &) noexcept {}

    template <typename _Tp1>
    __attribute__((__always_inline__)) constexpr __new_allocator(
        const __new_allocator<_Tp1> &) noexcept {}

    __new_allocator &operator=(const __new_allocator &) = default;
# 125 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/new_allocator.h" 3
    [[__nodiscard__]] _Tp *
    allocate(size_type __n, const void * = static_cast<const void *>(0)) {

      static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");

      if (__builtin_expect(__n > this->_M_max_size(), false)) {

        if (__n > (std::size_t(-1) / sizeof(_Tp)))
          std::__throw_bad_array_new_length();
        std::__throw_bad_alloc();
      }

      if (alignof(_Tp) > 16UL) {
        std::align_val_t __al = std::align_val_t(alignof(_Tp));
        return static_cast<_Tp *>(
            __builtin_operator_new(__n * sizeof(_Tp), __al));
      }

      return static_cast<_Tp *>(__builtin_operator_new(__n * sizeof(_Tp)));
    }

    void deallocate(_Tp *__p, size_type __n __attribute__((__unused__))) {

      if (alignof(_Tp) > 16UL) {
        __builtin_operator_delete((__p), std::align_val_t(alignof(_Tp)));
        return;
      }

      __builtin_operator_delete((__p));
    }
# 213 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/new_allocator.h" 3
    template <typename _Up>
    friend __attribute__((__always_inline__)) constexpr bool
    operator==(const __new_allocator &, const __new_allocator<_Up> &) noexcept {
      return true;
    }
# 227 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/new_allocator.h" 3
  private:
    __attribute__((__always_inline__)) constexpr size_type
    _M_max_size() const noexcept {

      return std::size_t(9223372036854775807L) / sizeof(_Tp);
    }
  };

} // namespace std
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++allocator.h" 2 3

namespace std {
# 46 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++allocator.h" 3
template <typename _Tp> using __allocator_base = __new_allocator<_Tp>;
} // namespace std
# 47 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/allocator.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 74 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/allocator.h" 3
  template <> class allocator<void> {
  public:
    typedef void value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
# 95 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/allocator.h" 3
    using propagate_on_container_move_assignment = true_type;

    using is_always_equal
        __attribute__((__deprecated__("use '"
                                      "std::allocator_traits::is_always_equal"
                                      "' instead"))) = true_type;

    allocator() = default;
    ~allocator() = default;

    template <typename _Up>
    __attribute__((__always_inline__)) constexpr allocator(
        const allocator<_Up> &) noexcept {}
  };
# 129 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/allocator.h" 3
  template <typename _Tp> class allocator : public __allocator_base<_Tp> {
  public:
    typedef _Tp value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
# 152 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/allocator.h" 3
    using propagate_on_container_move_assignment = true_type;

    using is_always_equal
        __attribute__((__deprecated__("use '"
                                      "std::allocator_traits::is_always_equal"
                                      "' instead"))) = true_type;

    __attribute__((__always_inline__)) constexpr allocator() noexcept {}

    __attribute__((__always_inline__)) constexpr allocator(
        const allocator &__a) noexcept
        : __allocator_base<_Tp>(__a) {}

    allocator &operator=(const allocator &) = default;

    template <typename _Tp1>
    __attribute__((__always_inline__)) constexpr allocator(
        const allocator<_Tp1> &) noexcept {}

    __attribute__((__always_inline__))

    constexpr

        ~allocator() noexcept {}

    [[nodiscard, __gnu__::__always_inline__]]
    constexpr _Tp *allocate(size_t __n) {
      if (std::__is_constant_evaluated()) {
        if (__builtin_mul_overflow(__n, sizeof(_Tp), &__n))
          std::__throw_bad_array_new_length();
        return static_cast<_Tp *>(::operator new(__n));
      }

      return __allocator_base<_Tp>::allocate(__n, 0);
    }

    [[__gnu__::__always_inline__]]
    constexpr void deallocate(_Tp *__p, size_t __n) {
      if (std::__is_constant_evaluated()) {
        ::operator delete(__p);
        return;
      }
      __allocator_base<_Tp>::deallocate(__p, __n);
    }

    friend __attribute__((__always_inline__)) constexpr bool
    operator==(const allocator &, const allocator &) noexcept {
      return true;
    }
# 227 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/allocator.h" 3
  };

  template <typename _T1, typename _T2>
  __attribute__((__always_inline__)) inline constexpr bool operator==(
      const allocator<_T1> &, const allocator<_T2> &) noexcept {
    return true;
  }
# 254 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/allocator.h" 3
  template <typename _Tp> class allocator<const _Tp> {
  public:
    typedef _Tp value_type;
    allocator() {}
    template <typename _Up> allocator(const allocator<_Up> &) {}
  };

  template <typename _Tp> class allocator<volatile _Tp> {
  public:
    typedef _Tp value_type;
    allocator() {}
    template <typename _Up> allocator(const allocator<_Up> &) {}
  };

  template <typename _Tp> class allocator<const volatile _Tp> {
  public:
    typedef _Tp value_type;
    allocator() {}
    template <typename _Up> allocator(const allocator<_Up> &) {}
  };

  extern template class allocator<char>;
  extern template class allocator<wchar_t>;

} // namespace std
# 44 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/cpp_type_traits.h" 1 3
# 36 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/cpp_type_traits.h" 3
# 67 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__((__visibility__("default"))) {

  struct __true_type {};
  struct __false_type {};

  template <bool> struct __truth_type {
    typedef __false_type __type;
  };

  template <> struct __truth_type<true> {
    typedef __true_type __type;
  };

  template <class _Sp, class _Tp> struct __traitor {
    enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
    typedef typename __truth_type<__value>::__type __type;
  };

  template <typename, typename> struct __are_same {
    enum { __value = 0 };
    typedef __false_type __type;
  };

  template <typename _Tp> struct __are_same<_Tp, _Tp> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <typename _Tp> struct __is_void {
    enum { __value = 0 };
    typedef __false_type __type;
  };

  template <> struct __is_void<void> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <typename _Tp> struct __is_integer {
    enum { __value = 0 };
    typedef __false_type __type;
  };

  template <> struct __is_integer<bool> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_integer<char> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_integer<signed char> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_integer<unsigned char> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_integer<wchar_t> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_integer<char8_t> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_integer<char16_t> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_integer<char32_t> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_integer<short> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_integer<unsigned short> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_integer<int> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_integer<unsigned int> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_integer<long> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_integer<unsigned long> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_integer<long long> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_integer<unsigned long long> {
    enum { __value = 1 };
    typedef __true_type __type;
  };
# 289 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/cpp_type_traits.h" 3
  template <typename _Tp> struct __is_floating {
    enum { __value = 0 };
    typedef __false_type __type;
  };

  template <> struct __is_floating<float> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_floating<double> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_floating<long double> {
    enum { __value = 1 };
    typedef __true_type __type;
  };
# 366 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/cpp_type_traits.h" 3
  template <typename _Tp> struct __is_pointer {
    enum { __value = 0 };
    typedef __false_type __type;
  };

  template <typename _Tp> struct __is_pointer<_Tp *> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <typename _Tp>
  struct __is_arithmetic
      : public __traitor<__is_integer<_Tp>, __is_floating<_Tp>>{};

  template <typename _Tp>
  struct __is_scalar
      : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp>>{};

  template <typename _Tp> struct __is_char {
    enum { __value = 0 };
    typedef __false_type __type;
  };

  template <> struct __is_char<char> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_char<wchar_t> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <typename _Tp> struct __is_byte {
    enum { __value = 0 };
    typedef __false_type __type;
  };

  template <> struct __is_byte<char> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_byte<signed char> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_byte<unsigned char> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  enum class byte : unsigned char;

  template <> struct __is_byte<byte> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <> struct __is_byte<char8_t> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <typename> struct iterator_traits;

  template <typename _Tp> struct __is_nonvolatile_trivially_copyable {
    enum { __value = __is_trivially_copyable(_Tp) };
  };

  template <typename _Tp>
  struct __is_nonvolatile_trivially_copyable<volatile _Tp> {
    enum { __value = 0 };
  };

  template <typename _OutputIter, typename _InputIter> struct __memcpyable {
    enum { __value = 0 };
  };

  template <typename _Tp>
  struct __memcpyable<_Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
  };

  template <typename _Tp>
  struct __memcpyable<_Tp *, const _Tp *>
      : __is_nonvolatile_trivially_copyable<_Tp> {};

  template <typename _Iter1, typename _Iter2> struct __memcmpable {
    enum { __value = 0 };
  };

  template <typename _Tp>
  struct __memcmpable<_Tp *, _Tp *> : __is_nonvolatile_trivially_copyable<_Tp> {
  };

  template <typename _Tp>
  struct __memcmpable<const _Tp *, _Tp *>
      : __is_nonvolatile_trivially_copyable<_Tp> {};

  template <typename _Tp>
  struct __memcmpable<_Tp *, const _Tp *>
      : __is_nonvolatile_trivially_copyable<_Tp> {};

  template <typename _Tp, bool _TreatAsBytes =

                              __is_byte<_Tp>::__value

            >
  struct __is_memcmp_ordered {
    static const bool __value = _Tp(-1) > _Tp(1);
  };

  template <typename _Tp> struct __is_memcmp_ordered<_Tp, false> {
    static const bool __value = false;
  };

  template <typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)>
  struct __is_memcmp_ordered_with {
    static const bool __value =
        __is_memcmp_ordered<_Tp>::__value && __is_memcmp_ordered<_Up>::__value;
  };

  template <typename _Tp, typename _Up>
  struct __is_memcmp_ordered_with<_Tp, _Up, false> {
    static const bool __value = false;
  };
# 579 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/cpp_type_traits.h" 3
  template <> struct __is_memcmp_ordered_with<std::byte, std::byte, true> {
    static constexpr bool __value = true;
  };

  template <typename _Tp, bool _SameSize>
  struct __is_memcmp_ordered_with<_Tp, std::byte, _SameSize> {
    static constexpr bool __value = false;
  };

  template <typename _Up, bool _SameSize>
  struct __is_memcmp_ordered_with<std::byte, _Up, _SameSize> {
    static constexpr bool __value = false;
  };

  template <typename _Tp> struct __is_move_iterator {
    enum { __value = 0 };
    typedef __false_type __type;
  };

  template <typename _Iterator>
  constexpr inline _Iterator __miter_base(_Iterator __it) {
    return __it;
  }

} // namespace std
}
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ostream_insert.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ostream_insert.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/cxxabi_forced.h" 1 3
# 35 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)

namespace __cxxabiv1 {

class __forced_unwind {
  virtual ~__forced_unwind() throw();

  virtual void __pure_dummy() = 0;
};
} // namespace __cxxabiv1

#pragma GCC visibility pop
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ostream_insert.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _CharT, typename _Traits>
  inline void __ostream_write(basic_ostream<_CharT, _Traits> & __out,
                              const _CharT *__s, streamsize __n) {
    typedef basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename __ostream_type::ios_base __ios_base;

    const streamsize __put = __out.rdbuf()->sputn(__s, __n);
    if (__put != __n)
      __out.setstate(__ios_base::badbit);
  }

  template <typename _CharT, typename _Traits>
  inline void __ostream_fill(basic_ostream<_CharT, _Traits> & __out,
                             streamsize __n) {
    typedef basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename __ostream_type::ios_base __ios_base;

    const _CharT __c = __out.fill();
    for (; __n > 0; --__n) {
      const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
      if (_Traits::eq_int_type(__put, _Traits::eof())) {
        __out.setstate(__ios_base::badbit);
        break;
      }
    }
  }

  template <typename _CharT, typename _Traits>
  basic_ostream<_CharT, _Traits> &__ostream_insert(
      basic_ostream<_CharT, _Traits> & __out, const _CharT *__s,
      streamsize __n) {
    typedef basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename __ostream_type::ios_base __ios_base;

    typename __ostream_type::sentry __cerb(__out);
    if (__cerb) {
      try {
        const streamsize __w = __out.width();
        if (__w > __n) {
          const bool __left =
              ((__out.flags() & __ios_base::adjustfield) == __ios_base::left);
          if (!__left)
            __ostream_fill(__out, __w - __n);
          if (__out.good())
            __ostream_write(__out, __s, __n);
          if (__left && __out.good())
            __ostream_fill(__out, __w - __n);
        } else
          __ostream_write(__out, __s, __n);
        __out.width(0);
      } catch (__cxxabiv1::__forced_unwind &) {
        __out._M_setstate(__ios_base::badbit);
        throw;
      } catch (...) {
        __out._M_setstate(__ios_base::badbit);
      }
    }
    return __out;
  }

  extern template ostream &__ostream_insert(ostream &, const char *,
                                            streamsize);

  extern template wostream &__ostream_insert(wostream &, const wchar_t *,
                                             streamsize);

} // namespace std
# 47 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 1 3
# 65 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/type_traits.h" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/type_traits.h" 3

extern "C++" {

namespace __gnu_cxx __attribute__((__visibility__("default"))) {

  template <bool, typename> struct __enable_if {};

  template <typename _Tp> struct __enable_if<true, _Tp> {
    typedef _Tp __type;
  };

  template <bool _Cond, typename _Iftrue, typename _Iffalse>
  struct __conditional_type {
    typedef _Iftrue __type;
  };

  template <typename _Iftrue, typename _Iffalse>
  struct __conditional_type<false, _Iftrue, _Iffalse> {
    typedef _Iffalse __type;
  };

  template <typename _Tp> struct __add_unsigned {
  private:
    typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

  public:
    typedef typename __if_type::__type __type;
  };

  template <> struct __add_unsigned<char> {
    typedef unsigned char __type;
  };

  template <> struct __add_unsigned<signed char> {
    typedef unsigned char __type;
  };

  template <> struct __add_unsigned<short> {
    typedef unsigned short __type;
  };

  template <> struct __add_unsigned<int> {
    typedef unsigned int __type;
  };

  template <> struct __add_unsigned<long> {
    typedef unsigned long __type;
  };

  template <> struct __add_unsigned<long long> {
    typedef unsigned long long __type;
  };

  template <> struct __add_unsigned<bool>;

  template <> struct __add_unsigned<wchar_t>;

  template <typename _Tp> struct __remove_unsigned {
  private:
    typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

  public:
    typedef typename __if_type::__type __type;
  };

  template <> struct __remove_unsigned<char> {
    typedef signed char __type;
  };

  template <> struct __remove_unsigned<unsigned char> {
    typedef signed char __type;
  };

  template <> struct __remove_unsigned<unsigned short> {
    typedef short __type;
  };

  template <> struct __remove_unsigned<unsigned int> {
    typedef int __type;
  };

  template <> struct __remove_unsigned<unsigned long> {
    typedef long __type;
  };

  template <> struct __remove_unsigned<unsigned long long> {
    typedef long long __type;
  };

  template <> struct __remove_unsigned<bool>;

  template <> struct __remove_unsigned<wchar_t>;

  template <typename _Type>
  constexpr inline bool __is_null_pointer(_Type * __ptr) {
    return __ptr == 0;
  }

  template <typename _Type> constexpr inline bool __is_null_pointer(_Type) {
    return false;
  }

  constexpr bool __is_null_pointer(std::nullptr_t) { return true; }

  template <typename _Tp, bool = std::__is_integer<_Tp>::__value>
  struct __promote {
    typedef double __type;
  };

  template <typename _Tp> struct __promote<_Tp, false> {};

  template <> struct __promote<long double> {
    typedef long double __type;
  };

  template <> struct __promote<double> {
    typedef double __type;
  };

  template <> struct __promote<float> {
    typedef float __type;
  };
# 225 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/type_traits.h" 3
  template <typename... _Tp>
  using __promoted_t = decltype((typename __promote<_Tp>::__type(0) + ...));

  template <typename _Tp, typename _Up>
  using __promote_2 = __promote<__promoted_t<_Tp, _Up>>;

  template <typename _Tp, typename _Up, typename _Vp>
  using __promote_3 = __promote<__promoted_t<_Tp, _Up, _Vp>>;

  template <typename _Tp, typename _Up, typename _Vp, typename _Wp>
  using __promote_4 = __promote<__promoted_t<_Tp, _Up, _Vp, _Wp>>;
# 270 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/type_traits.h" 3
} // namespace __gnu_cxx
}
# 66 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 2 3
# 88 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
namespace std __attribute__((__visibility__("default"))) {
# 98 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  namespace __detail {

  template <typename _Cat, typename _Limit, typename _Otherwise = _Cat>
  using __clamp_iter_cat =
      __conditional_t<derived_from<_Cat, _Limit>, _Limit, _Otherwise>;

  template <typename _Tp, typename _Up>
  concept __different_from = !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;
  } // namespace __detail

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 135 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _Iterator>
  class reverse_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference> {
    template <typename _Iter> friend class reverse_iterator;

    template <typename _Iter>
    static constexpr bool __convertible =
        !is_same_v<_Iter, _Iterator> &&
        convertible_to<const _Iter &, _Iterator>;

  protected:
    _Iterator current;

    typedef iterator_traits<_Iterator> __traits_type;

  public:
    typedef _Iterator iterator_type;
    typedef typename __traits_type::pointer pointer;

    using iterator_concept =
        __conditional_t<random_access_iterator<_Iterator>,
                        random_access_iterator_tag, bidirectional_iterator_tag>;
    using iterator_category =
        __detail::__clamp_iter_cat<typename __traits_type::iterator_category,
                                   random_access_iterator_tag>;
    using value_type = iter_value_t<_Iterator>;
    using difference_type = iter_difference_t<_Iterator>;
    using reference = iter_reference_t<_Iterator>;
# 185 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
    constexpr reverse_iterator() noexcept(noexcept(_Iterator())) : current() {}

    explicit constexpr reverse_iterator(iterator_type __x) noexcept(
        noexcept(_Iterator(__x)))
        : current(__x) {}

    constexpr reverse_iterator(const reverse_iterator &__x) noexcept(
        noexcept(_Iterator(__x.current)))
        : current(__x.current) {}

    reverse_iterator &operator=(const reverse_iterator &) = default;

    template <typename _Iter>

      requires __convertible<_Iter>

    constexpr reverse_iterator(const reverse_iterator<_Iter> &__x) noexcept(
        noexcept(_Iterator(__x.current)))
        : current(__x.current) {}

    template <typename _Iter>

      requires __convertible<_Iter> &&
               assignable_from<_Iterator &, const _Iter &>

    constexpr reverse_iterator &
    operator=(const reverse_iterator<_Iter> &__x) noexcept(
        noexcept(current = __x.current)) {
      current = __x.current;
      return *this;
    }

    [[__nodiscard__]]
    constexpr iterator_type base() const
        noexcept(noexcept(_Iterator(current))) {
      return current;
    }
# 262 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
    [[__nodiscard__]]
    constexpr reference operator*() const {
      _Iterator __tmp = current;
      return *--__tmp;
    }

    [[__nodiscard__]]
    constexpr pointer operator->() const

      requires is_pointer_v<_Iterator> ||
               requires(const _Iterator __i) { __i.operator->(); }

    {

      _Iterator __tmp = current;
      --__tmp;
      return _S_to_pointer(__tmp);
    }

    constexpr reverse_iterator &operator++() {
      --current;
      return *this;
    }

    constexpr reverse_iterator operator++(int) {
      reverse_iterator __tmp = *this;
      --current;
      return __tmp;
    }

    constexpr reverse_iterator &operator--() {
      ++current;
      return *this;
    }

    constexpr reverse_iterator operator--(int) {
      reverse_iterator __tmp = *this;
      ++current;
      return __tmp;
    }

    [[__nodiscard__]]
    constexpr reverse_iterator operator+(difference_type __n) const {
      return reverse_iterator(current - __n);
    }

    constexpr reverse_iterator &operator+=(difference_type __n) {
      current -= __n;
      return *this;
    }

    [[__nodiscard__]]
    constexpr reverse_iterator operator-(difference_type __n) const {
      return reverse_iterator(current + __n);
    }

    constexpr reverse_iterator &operator-=(difference_type __n) {
      current += __n;
      return *this;
    }

    [[__nodiscard__]]
    constexpr reference operator[](difference_type __n) const {
      return *(*this + __n);
    }

    [[nodiscard]]
    friend constexpr iter_rvalue_reference_t<_Iterator>
    iter_move(const reverse_iterator &__i) noexcept(
        is_nothrow_copy_constructible_v<_Iterator> &&
        noexcept(ranges::iter_move(--std::declval<_Iterator &>()))) {
      auto __tmp = __i.base();
      return ranges::iter_move(--__tmp);
    }

    template <indirectly_swappable<_Iterator> _Iter2>
    friend constexpr void
    iter_swap(const reverse_iterator &__x,
              const reverse_iterator<_Iter2>
                  &__y) noexcept(is_nothrow_copy_constructible_v<_Iterator> &&
                                 is_nothrow_copy_constructible_v<_Iter2> &&
                                 noexcept(ranges::iter_swap(
                                     --std::declval<_Iterator &>(),
                                     --std::declval<_Iter2 &>()))) {
      auto __xtmp = __x.base();
      auto __ytmp = __y.base();
      ranges::iter_swap(--__xtmp, --__ytmp);
    }

  private:
    template <typename _Tp> static constexpr _Tp *_S_to_pointer(_Tp *__p) {
      return __p;
    }

    template <typename _Tp> static constexpr pointer _S_to_pointer(_Tp __t) {
      return __t.operator->();
    }
  };
# 531 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _IteratorL, typename _IteratorR>
  [[nodiscard]]
  constexpr bool operator==(const reverse_iterator<_IteratorL> &__x,
                            const reverse_iterator<_IteratorR> &__y)
    requires requires {
      { __x.base() == __y.base() } -> convertible_to<bool>;
    }
  {
    return __x.base() == __y.base();
  }

  template <typename _IteratorL, typename _IteratorR>
  [[nodiscard]]
  constexpr bool operator!=(const reverse_iterator<_IteratorL> &__x,
                            const reverse_iterator<_IteratorR> &__y)
    requires requires {
      { __x.base() != __y.base() } -> convertible_to<bool>;
    }
  {
    return __x.base() != __y.base();
  }

  template <typename _IteratorL, typename _IteratorR>
  [[nodiscard]]
  constexpr bool operator<(const reverse_iterator<_IteratorL> &__x,
                           const reverse_iterator<_IteratorR> &__y)
    requires requires {
      { __x.base() > __y.base() } -> convertible_to<bool>;
    }
  {
    return __x.base() > __y.base();
  }

  template <typename _IteratorL, typename _IteratorR>
  [[nodiscard]]
  constexpr bool operator>(const reverse_iterator<_IteratorL> &__x,
                           const reverse_iterator<_IteratorR> &__y)
    requires requires {
      { __x.base() < __y.base() } -> convertible_to<bool>;
    }
  {
    return __x.base() < __y.base();
  }

  template <typename _IteratorL, typename _IteratorR>
  [[nodiscard]]
  constexpr bool operator<=(const reverse_iterator<_IteratorL> &__x,
                            const reverse_iterator<_IteratorR> &__y)
    requires requires {
      { __x.base() >= __y.base() } -> convertible_to<bool>;
    }
  {
    return __x.base() >= __y.base();
  }

  template <typename _IteratorL, typename _IteratorR>
  [[nodiscard]]
  constexpr bool operator>=(const reverse_iterator<_IteratorL> &__x,
                            const reverse_iterator<_IteratorR> &__y)
    requires requires {
      { __x.base() <= __y.base() } -> convertible_to<bool>;
    }
  {
    return __x.base() <= __y.base();
  }

  template <typename _IteratorL,
            three_way_comparable_with<_IteratorL> _IteratorR>
  [[nodiscard]]
  constexpr compare_three_way_result_t<_IteratorL, _IteratorR> operator<=>(
      const reverse_iterator<_IteratorL> &__x,
      const reverse_iterator<_IteratorR> &__y) {
    return __y.base() <=> __x.base();
  }

  template <typename _Iterator>
  [[nodiscard]]
  constexpr bool operator==(const reverse_iterator<_Iterator> &__x,
                            const reverse_iterator<_Iterator> &__y)
    requires requires {
      { __x.base() == __y.base() } -> convertible_to<bool>;
    }
  {
    return __x.base() == __y.base();
  }

  template <three_way_comparable _Iterator>
  [[nodiscard]]
  constexpr compare_three_way_result_t<_Iterator, _Iterator> operator<=>(
      const reverse_iterator<_Iterator> &__x,
      const reverse_iterator<_Iterator> &__y) {
    return __y.base() <=> __x.base();
  }
# 622 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _IteratorL, typename _IteratorR>
  [[__nodiscard__]]
  inline constexpr auto operator-(const reverse_iterator<_IteratorL> &__x,
                                  const reverse_iterator<_IteratorR> &__y)
      ->decltype(__y.base() - __x.base()) {
    return __y.base() - __x.base();
  }

  template <typename _Iterator>
  [[__nodiscard__]]
  inline constexpr reverse_iterator<_Iterator> operator+(
      typename reverse_iterator<_Iterator>::difference_type __n,
      const reverse_iterator<_Iterator> &__x) {
    return reverse_iterator<_Iterator>(__x.base() - __n);
  }

  template <typename _Iterator>
  inline constexpr reverse_iterator<_Iterator> __make_reverse_iterator(
      _Iterator __i) {
    return reverse_iterator<_Iterator>(__i);
  }

  template <typename _Iterator>
  [[__nodiscard__]]
  inline constexpr reverse_iterator<_Iterator> make_reverse_iterator(
      _Iterator __i) {
    return reverse_iterator<_Iterator>(__i);
  }

  template <typename _Iterator1, typename _Iterator2>
    requires(!sized_sentinel_for<_Iterator1, _Iterator2>)
  inline constexpr bool disable_sized_sentinel_for<
      reverse_iterator<_Iterator1>, reverse_iterator<_Iterator2>> = true;

  template <typename _Iterator>
  constexpr auto __niter_base(reverse_iterator<_Iterator> __it)
      -> decltype(__make_reverse_iterator(__niter_base(__it.base()))) {
    return __make_reverse_iterator(__niter_base(__it.base()));
  }

  template <typename _Iterator>
  struct __is_move_iterator<reverse_iterator<_Iterator>>
      : __is_move_iterator<_Iterator> {};

  template <typename _Iterator>
  constexpr auto __miter_base(reverse_iterator<_Iterator> __it)
      -> decltype(__make_reverse_iterator(__miter_base(__it.base()))) {
    return __make_reverse_iterator(__miter_base(__it.base()));
  }
# 697 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _Container>
  class back_insert_iterator
      : public iterator<output_iterator_tag, void, void, void, void> {
  protected:
    _Container *container;

  public:
    typedef _Container container_type;

    using difference_type = ptrdiff_t;

    explicit constexpr back_insert_iterator(_Container &__x)
        : container(std::__addressof(__x)) {}
# 735 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
    constexpr back_insert_iterator &
    operator=(const typename _Container::value_type &__value) {
      container->push_back(__value);
      return *this;
    }

    constexpr back_insert_iterator &
    operator=(typename _Container::value_type &&__value) {
      container->push_back(std::move(__value));
      return *this;
    }

    [[__nodiscard__]] constexpr back_insert_iterator &operator*() {
      return *this;
    }

    constexpr back_insert_iterator &operator++() { return *this; }

    constexpr back_insert_iterator operator++(int) { return *this; }
  };
# 782 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _Container>
  [[__nodiscard__]] constexpr inline back_insert_iterator<_Container>
  back_inserter(_Container & __x) {
    return back_insert_iterator<_Container>(__x);
  }
# 798 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _Container>
  class front_insert_iterator
      : public iterator<output_iterator_tag, void, void, void, void> {
  protected:
    _Container *container;

  public:
    typedef _Container container_type;

    using difference_type = ptrdiff_t;

    explicit constexpr front_insert_iterator(_Container &__x)
        : container(std::__addressof(__x)) {}
# 836 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
    constexpr front_insert_iterator &
    operator=(const typename _Container::value_type &__value) {
      container->push_front(__value);
      return *this;
    }

    constexpr front_insert_iterator &
    operator=(typename _Container::value_type &&__value) {
      container->push_front(std::move(__value));
      return *this;
    }

    [[__nodiscard__]] constexpr front_insert_iterator &operator*() {
      return *this;
    }

    constexpr front_insert_iterator &operator++() { return *this; }

    constexpr front_insert_iterator operator++(int) { return *this; }
  };
# 883 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _Container>
  [[__nodiscard__]] constexpr inline front_insert_iterator<_Container>
  front_inserter(_Container & __x) {
    return front_insert_iterator<_Container>(__x);
  }
# 903 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _Container>
  class insert_iterator
      : public iterator<output_iterator_tag, void, void, void, void> {

    using _Iter = std::__detail::__range_iter_t<_Container>;

  protected:
    _Container *container;
    _Iter iter;

  public:
    typedef _Container container_type;

    using difference_type = ptrdiff_t;

    constexpr insert_iterator(_Container &__x, _Iter __i)
        : container(std::__addressof(__x)), iter(__i) {}
# 964 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
    constexpr insert_iterator &
    operator=(const typename _Container::value_type &__value) {
      iter = container->insert(iter, __value);
      ++iter;
      return *this;
    }

    constexpr insert_iterator &
    operator=(typename _Container::value_type &&__value) {
      iter = container->insert(iter, std::move(__value));
      ++iter;
      return *this;
    }

    [[__nodiscard__]] constexpr insert_iterator &operator*() { return *this; }

    constexpr insert_iterator &operator++() { return *this; }

    constexpr insert_iterator &operator++(int) { return *this; }
  };

#pragma GCC diagnostic pop
# 1017 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _Container>
  [[nodiscard]]
  constexpr insert_iterator<_Container> inserter(
      _Container & __x, std::__detail::__range_iter_t<_Container> __i) {
    return insert_iterator<_Container>(__x, __i);
  }
# 1033 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
} // namespace std

namespace __gnu_cxx __attribute__((__visibility__("default"))) {
# 1046 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _Iterator, typename _Container> class __normal_iterator {
  protected:
    _Iterator _M_current;

    typedef std::iterator_traits<_Iterator> __traits_type;

    template <typename _Iter>
    using __convertible_from =
        std::__enable_if_t<std::is_convertible<_Iter, _Iterator>::value>;

  public:
    typedef _Iterator iterator_type;
    typedef typename __traits_type::iterator_category iterator_category;
    typedef typename __traits_type::value_type value_type;
    typedef typename __traits_type::difference_type difference_type;
    typedef typename __traits_type::reference reference;
    typedef typename __traits_type::pointer pointer;

    using iterator_concept = std::__detail::__iter_concept<_Iterator>;

    constexpr __normal_iterator() noexcept : _M_current(_Iterator()) {}

    explicit constexpr __normal_iterator(const _Iterator &__i) noexcept
        : _M_current(__i) {}

    template <typename _Iter, typename = __convertible_from<_Iter>>
    constexpr __normal_iterator(
        const __normal_iterator<_Iter, _Container> &__i) noexcept
# 1094 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
        : _M_current(__i.base()) {
    }

    constexpr reference operator*() const noexcept { return *_M_current; }

    constexpr pointer operator->() const noexcept { return _M_current; }

    constexpr __normal_iterator &operator++() noexcept {
      ++_M_current;
      return *this;
    }

    constexpr __normal_iterator operator++(int) noexcept {
      return __normal_iterator(_M_current++);
    }

    constexpr __normal_iterator &operator--() noexcept {
      --_M_current;
      return *this;
    }

    constexpr __normal_iterator operator--(int) noexcept {
      return __normal_iterator(_M_current--);
    }

    constexpr reference operator[](difference_type __n) const noexcept {
      return _M_current[__n];
    }

    constexpr __normal_iterator &operator+=(difference_type __n) noexcept {
      _M_current += __n;
      return *this;
    }

    constexpr __normal_iterator operator+(difference_type __n) const noexcept {
      return __normal_iterator(_M_current + __n);
    }

    constexpr __normal_iterator &operator-=(difference_type __n) noexcept {
      _M_current -= __n;
      return *this;
    }

    constexpr __normal_iterator operator-(difference_type __n) const noexcept {
      return __normal_iterator(_M_current - __n);
    }

    constexpr const _Iterator &base() const noexcept { return _M_current; }
  };
# 1175 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _IteratorL, typename _IteratorR, typename _Container>
  [[nodiscard]]
  constexpr bool operator==(
      const __normal_iterator<_IteratorL, _Container> &__lhs,
      const __normal_iterator<_IteratorR, _Container>
          &__rhs) noexcept(noexcept(__lhs.base() == __rhs.base()))
    requires requires {
      { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>;
    }
  {
    return __lhs.base() == __rhs.base();
  }

  template <typename _IteratorL, typename _IteratorR, typename _Container>
  [[nodiscard]]
  constexpr std::__detail::__synth3way_t<_IteratorR, _IteratorL> operator<=>(
      const __normal_iterator<_IteratorL, _Container> &__lhs,
      const __normal_iterator<_IteratorR, _Container>
          &__rhs) noexcept(noexcept(std::__detail::__synth3way(__lhs.base(),
                                                               __rhs.base()))) {
    return std::__detail::__synth3way(__lhs.base(), __rhs.base());
  }

  template <typename _Iterator, typename _Container>
  [[nodiscard]]
  constexpr bool operator==(
      const __normal_iterator<_Iterator, _Container> &__lhs,
      const __normal_iterator<_Iterator, _Container>
          &__rhs) noexcept(noexcept(__lhs.base() == __rhs.base()))
    requires requires {
      { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>;
    }
  {
    return __lhs.base() == __rhs.base();
  }

  template <typename _Iterator, typename _Container>
  [[nodiscard]]
  constexpr std::__detail::__synth3way_t<_Iterator> operator<=>(
      const __normal_iterator<_Iterator, _Container> &__lhs,
      const __normal_iterator<_Iterator, _Container>
          &__rhs) noexcept(noexcept(std::__detail::__synth3way(__lhs.base(),
                                                               __rhs.base()))) {
    return std::__detail::__synth3way(__lhs.base(), __rhs.base());
  }
# 1316 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _IteratorL, typename _IteratorR, typename _Container>

  [[__nodiscard__]] constexpr inline auto operator-(
      const __normal_iterator<_IteratorL, _Container> &__lhs,
      const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept
      -> decltype(__lhs.base() - __rhs.base())

  {
    return __lhs.base() - __rhs.base();
  }

  template <typename _Iterator, typename _Container>
  [[__nodiscard__]] constexpr inline
      typename __normal_iterator<_Iterator, _Container>::difference_type
      operator-(
          const __normal_iterator<_Iterator, _Container> &__lhs,
          const __normal_iterator<_Iterator, _Container> &__rhs) noexcept {
    return __lhs.base() - __rhs.base();
  }

  template <typename _Iterator, typename _Container>
  [[__nodiscard__]] constexpr inline __normal_iterator<_Iterator, _Container>
  operator+(
      typename __normal_iterator<_Iterator, _Container>::difference_type __n,
      const __normal_iterator<_Iterator, _Container> &__i) noexcept {
    return __normal_iterator<_Iterator, _Container>(__i.base() + __n);
  }

} // namespace __gnu_cxx

namespace std __attribute__((__visibility__("default"))) {

  template <typename _Iterator, typename _Container>
  constexpr _Iterator __niter_base(
      __gnu_cxx::__normal_iterator<_Iterator, _Container>
          __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value) {
    return __it.base();
  }
# 1380 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <semiregular _Sent> class move_sentinel {
  public:
    constexpr move_sentinel() noexcept(
        is_nothrow_default_constructible_v<_Sent>)
        : _M_last() {}

    constexpr explicit move_sentinel(_Sent __s) noexcept(
        is_nothrow_move_constructible_v<_Sent>)
        : _M_last(std::move(__s)) {}

    template <typename _S2>
      requires convertible_to<const _S2 &, _Sent>
    constexpr move_sentinel(const move_sentinel<_S2> &__s) noexcept(
        is_nothrow_constructible_v<_Sent, const _S2 &>)
        : _M_last(__s.base()) {}

    template <typename _S2>
      requires assignable_from<_Sent &, const _S2 &>
    constexpr move_sentinel &operator=(const move_sentinel<_S2> &__s) noexcept(
        is_nothrow_assignable_v<_Sent, const _S2 &>) {
      _M_last = __s.base();
      return *this;
    }

    [[nodiscard]]
    constexpr _Sent base() const
        noexcept(is_nothrow_copy_constructible_v<_Sent>) {
      return _M_last;
    }

  private:
    _Sent _M_last;
  };

  namespace __detail {

  template <typename _Iterator> struct __move_iter_cat {};

  template <typename _Iterator>
    requires requires { typename __iter_category_t<_Iterator>; }
  struct __move_iter_cat<_Iterator> {
    using iterator_category = __clamp_iter_cat<__iter_category_t<_Iterator>,
                                               random_access_iterator_tag>;
  };

  } // namespace __detail
# 1448 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _Iterator>
  class move_iterator

      : public __detail::__move_iter_cat<_Iterator>

  {
    _Iterator _M_current;

    using __traits_type = iterator_traits<_Iterator>;

    template <typename _Iter2> friend class move_iterator;

    template <typename _Iter2>
    static constexpr bool __convertible =
        !is_same_v<_Iter2, _Iterator> &&
        convertible_to<const _Iter2 &, _Iterator>;

    static auto _S_iter_concept() {
      if constexpr (random_access_iterator<_Iterator>)
        return random_access_iterator_tag{};
      else if constexpr (bidirectional_iterator<_Iterator>)
        return bidirectional_iterator_tag{};
      else if constexpr (forward_iterator<_Iterator>)
        return forward_iterator_tag{};
      else
        return input_iterator_tag{};
    }

  public:
    using iterator_type = _Iterator;

    using iterator_concept = decltype(_S_iter_concept());

    using value_type = iter_value_t<_Iterator>;
    using difference_type = iter_difference_t<_Iterator>;
    using pointer = _Iterator;
    using reference = iter_rvalue_reference_t<_Iterator>;
# 1514 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
    constexpr move_iterator() : _M_current() {}

    explicit constexpr move_iterator(iterator_type __i)
        : _M_current(std::move(__i)) {}

    template <typename _Iter>

      requires __convertible<_Iter>

    constexpr move_iterator(const move_iterator<_Iter> &__i)
        : _M_current(__i._M_current) {}

    template <typename _Iter>

      requires __convertible<_Iter> &&
               assignable_from<_Iterator &, const _Iter &>

    constexpr move_iterator &operator=(const move_iterator<_Iter> &__i) {
      _M_current = __i._M_current;
      return *this;
    }

    [[nodiscard]]
    constexpr const iterator_type &base() const & noexcept {
      return _M_current;
    }

    [[nodiscard]]
    constexpr iterator_type base() && {
      return std::move(_M_current);
    }

    [[__nodiscard__]]
    constexpr reference operator*() const

    {
      return ranges::iter_move(_M_current);
    }

    [[__nodiscard__]]
    constexpr pointer operator->() const {
      return _M_current;
    }

    constexpr move_iterator &operator++() {
      ++_M_current;
      return *this;
    }

    constexpr move_iterator operator++(int) {
      move_iterator __tmp = *this;
      ++_M_current;
      return __tmp;
    }

    constexpr void operator++(int)
      requires(!forward_iterator<_Iterator>)
    {
      ++_M_current;
    }

    constexpr move_iterator &operator--() {
      --_M_current;
      return *this;
    }

    constexpr move_iterator operator--(int) {
      move_iterator __tmp = *this;
      --_M_current;
      return __tmp;
    }

    [[__nodiscard__]]
    constexpr move_iterator operator+(difference_type __n) const {
      return move_iterator(_M_current + __n);
    }

    constexpr move_iterator &operator+=(difference_type __n) {
      _M_current += __n;
      return *this;
    }

    [[__nodiscard__]]
    constexpr move_iterator operator-(difference_type __n) const {
      return move_iterator(_M_current - __n);
    }

    constexpr move_iterator &operator-=(difference_type __n) {
      _M_current -= __n;
      return *this;
    }

    [[__nodiscard__]]
    constexpr reference operator[](difference_type __n) const

    {
      return ranges::iter_move(_M_current + __n);
    }

    template <sentinel_for<_Iterator> _Sent>
    [[nodiscard]]
    friend constexpr bool operator==(const move_iterator &__x,
                                     const move_sentinel<_Sent> &__y) {
      return __x.base() == __y.base();
    }

    template <sized_sentinel_for<_Iterator> _Sent>
    [[nodiscard]]
    friend constexpr iter_difference_t<_Iterator>
    operator-(const move_sentinel<_Sent> &__x, const move_iterator &__y) {
      return __x.base() - __y.base();
    }

    template <sized_sentinel_for<_Iterator> _Sent>
    [[nodiscard]]
    friend constexpr iter_difference_t<_Iterator>
    operator-(const move_iterator &__x, const move_sentinel<_Sent> &__y) {
      return __x.base() - __y.base();
    }

    [[nodiscard]]
    friend constexpr iter_rvalue_reference_t<_Iterator>
    iter_move(const move_iterator &__i) noexcept(
        noexcept(ranges::iter_move(__i._M_current))) {
      return ranges::iter_move(__i._M_current);
    }

    template <indirectly_swappable<_Iterator> _Iter2>
    friend constexpr void
    iter_swap(const move_iterator &__x,
              const move_iterator<_Iter2>
                  &__y) noexcept(noexcept(ranges::iter_swap(__x._M_current,
                                                            __y._M_current))) {
      return ranges::iter_swap(__x._M_current, __y._M_current);
    }
  };

  template <typename _IteratorL, typename _IteratorR>
  [[__nodiscard__]]
  inline constexpr bool operator==(const move_iterator<_IteratorL> &__x,
                                   const move_iterator<_IteratorR> &__y)

    requires requires {
      { __x.base() == __y.base() } -> convertible_to<bool>;
    }

  {
    return __x.base() == __y.base();
  }

  template <typename _IteratorL,
            three_way_comparable_with<_IteratorL> _IteratorR>
  [[__nodiscard__]]
  constexpr compare_three_way_result_t<_IteratorL, _IteratorR> operator<=>(
      const move_iterator<_IteratorL> &__x,
      const move_iterator<_IteratorR> &__y) {
    return __x.base() <=> __y.base();
  }
# 1702 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _IteratorL, typename _IteratorR>
  [[__nodiscard__]]
  inline constexpr bool operator<(const move_iterator<_IteratorL> &__x,
                                  const move_iterator<_IteratorR> &__y)

    requires requires {
      { __x.base() < __y.base() } -> convertible_to<bool>;
    }

  {
    return __x.base() < __y.base();
  }

  template <typename _IteratorL, typename _IteratorR>
  [[__nodiscard__]]
  inline constexpr bool operator<=(const move_iterator<_IteratorL> &__x,
                                   const move_iterator<_IteratorR> &__y)

    requires requires {
      { __y.base() < __x.base() } -> convertible_to<bool>;
    }

  {
    return !(__y < __x);
  }

  template <typename _IteratorL, typename _IteratorR>
  [[__nodiscard__]]
  inline constexpr bool operator>(const move_iterator<_IteratorL> &__x,
                                  const move_iterator<_IteratorR> &__y)

    requires requires {
      { __y.base() < __x.base() } -> convertible_to<bool>;
    }

  {
    return __y < __x;
  }

  template <typename _IteratorL, typename _IteratorR>
  [[__nodiscard__]]
  inline constexpr bool operator>=(const move_iterator<_IteratorL> &__x,
                                   const move_iterator<_IteratorR> &__y)

    requires requires {
      { __x.base() < __y.base() } -> convertible_to<bool>;
    }

  {
    return !(__x < __y);
  }

  template <typename _Iterator>
  [[__nodiscard__]]
  inline constexpr bool operator==(const move_iterator<_Iterator> &__x,
                                   const move_iterator<_Iterator> &__y) {
    return __x.base() == __y.base();
  }

  template <three_way_comparable _Iterator>
  [[__nodiscard__]]
  constexpr compare_three_way_result_t<_Iterator> operator<=>(
      const move_iterator<_Iterator> &__x,
      const move_iterator<_Iterator> &__y) {
    return __x.base() <=> __y.base();
  }
# 1797 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _IteratorL, typename _IteratorR>
  [[__nodiscard__]]
  inline constexpr auto operator-(const move_iterator<_IteratorL> &__x,
                                  const move_iterator<_IteratorR> &__y)
      ->decltype(__x.base() - __y.base()) {
    return __x.base() - __y.base();
  }

  template <typename _Iterator>
  [[__nodiscard__]]
  inline constexpr move_iterator<_Iterator> operator+(
      typename move_iterator<_Iterator>::difference_type __n,
      const move_iterator<_Iterator> &__x) {
    return __x + __n;
  }

  template <typename _Iterator>
  [[__nodiscard__]]
  inline constexpr move_iterator<_Iterator> make_move_iterator(_Iterator __i) {
    return move_iterator<_Iterator>(std::move(__i));
  }

  template <typename _Iterator,
            typename _ReturnType = __conditional_t<
                __move_if_noexcept_cond<
                    typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>>
  inline constexpr _ReturnType __make_move_if_noexcept_iterator(_Iterator __i) {
    return _ReturnType(__i);
  }

  template <typename _Tp,
            typename _ReturnType =
                __conditional_t<__move_if_noexcept_cond<_Tp>::value,
                                const _Tp *, move_iterator<_Tp *>>>
  inline constexpr _ReturnType __make_move_if_noexcept_iterator(_Tp * __i) {
    return _ReturnType(__i);
  }

  namespace __detail {
  template <typename _It>
  concept __common_iter_has_arrow =
      indirectly_readable<const _It> &&
      (requires(const _It &__it) { __it.operator->(); } ||
       is_reference_v<iter_reference_t<_It>> ||
       constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);

  template <typename _It>
  concept __common_iter_use_postfix_proxy =
      (!requires(_It &__i) {
        { *__i++ } -> __can_reference;
      }) && constructible_from<iter_value_t<_It>, iter_reference_t<_It>> &&
      move_constructible<iter_value_t<_It>>;
  } // namespace __detail

  template <input_or_output_iterator _It, sentinel_for<_It> _Sent>
    requires(!same_as<_It, _Sent>) && copyable<_It>
  class common_iterator {
    template <typename _Tp, typename _Up> static constexpr bool _S_noexcept1() {
      if constexpr (is_trivially_default_constructible_v<_Tp>)
        return is_nothrow_assignable_v<_Tp &, _Up>;
      else
        return is_nothrow_constructible_v<_Tp, _Up>;
    }

    template <typename _It2, typename _Sent2>
    static constexpr bool _S_noexcept() {
      return _S_noexcept1<_It, _It2>() && _S_noexcept1<_Sent, _Sent2>();
    }

    class __arrow_proxy {
      iter_value_t<_It> _M_keep;

      constexpr __arrow_proxy(iter_reference_t<_It> &&__x)
          : _M_keep(std::move(__x)) {}

      friend class common_iterator;

    public:
      constexpr const iter_value_t<_It> *operator->() const noexcept {
        return std::__addressof(_M_keep);
      }
    };

    class __postfix_proxy {
      iter_value_t<_It> _M_keep;

      constexpr __postfix_proxy(iter_reference_t<_It> &&__x)
          : _M_keep(std::forward<iter_reference_t<_It>>(__x)) {}

      friend class common_iterator;

    public:
      constexpr const iter_value_t<_It> &operator*() const noexcept {
        return _M_keep;
      }
    };

  public:
    constexpr common_iterator() noexcept(
        is_nothrow_default_constructible_v<_It>)
      requires default_initializable<_It>
        : _M_it(), _M_index(0) {}

    constexpr common_iterator(_It __i) noexcept(
        is_nothrow_move_constructible_v<_It>)
        : _M_it(std::move(__i)), _M_index(0) {}

    constexpr common_iterator(_Sent __s) noexcept(
        is_nothrow_move_constructible_v<_Sent>)
        : _M_sent(std::move(__s)), _M_index(1) {}

    template <typename _It2, typename _Sent2>
      requires convertible_to<const _It2 &, _It> &&
                   convertible_to<const _Sent2 &, _Sent>
    constexpr common_iterator(
        const common_iterator<_It2, _Sent2>
            &__x) noexcept(_S_noexcept<const _It2 &, const _Sent2 &>())
        : _M_valueless(), _M_index(__x._M_index) {
      do {
        if (std::__is_constant_evaluated() && !bool(__x._M_has_value()))
          __builtin_unreachable();
      } while (false);
      if (_M_index == 0) {
        if constexpr (is_trivially_default_constructible_v<_It>)
          _M_it = std::move(__x._M_it);
        else
          std::construct_at(std::__addressof(_M_it), __x._M_it);
      } else if (_M_index == 1) {
        if constexpr (is_trivially_default_constructible_v<_Sent>)
          _M_sent = std::move(__x._M_sent);
        else
          std::construct_at(std::__addressof(_M_sent), __x._M_sent);
      }
    }

    common_iterator(const common_iterator &) = default;

    constexpr common_iterator(const common_iterator &__x) noexcept(
        _S_noexcept<const _It &, const _Sent &>())
      requires(!is_trivially_copyable_v<_It> || !is_trivially_copyable_v<_Sent>)
        : _M_valueless(), _M_index(__x._M_index) {
      if (_M_index == 0) {
        if constexpr (is_trivially_default_constructible_v<_It>)
          _M_it = __x._M_it;
        else
          std::construct_at(std::__addressof(_M_it), __x._M_it);
      } else if (_M_index == 1) {
        if constexpr (is_trivially_default_constructible_v<_Sent>)
          _M_sent = __x._M_sent;
        else
          std::construct_at(std::__addressof(_M_sent), __x._M_sent);
      }
    }

    common_iterator(common_iterator &&) = default;

    constexpr common_iterator(common_iterator &&__x) noexcept(
        _S_noexcept<_It, _Sent>())
      requires(!is_trivially_copyable_v<_It> || !is_trivially_copyable_v<_Sent>)
        : _M_valueless(), _M_index(__x._M_index) {
      if (_M_index == 0) {
        if constexpr (is_trivially_default_constructible_v<_It>)
          _M_it = std::move(__x._M_it);
        else
          std::construct_at(std::__addressof(_M_it), std::move(__x._M_it));
      } else if (_M_index == 1) {
        if constexpr (is_trivially_default_constructible_v<_Sent>)
          _M_sent = std::move(__x._M_sent);
        else
          std::construct_at(std::__addressof(_M_sent), std::move(__x._M_sent));
      }
    }

    constexpr common_iterator &operator=(const common_iterator &) = default;

    constexpr common_iterator &operator=(const common_iterator &__x) noexcept(
        is_nothrow_copy_assignable_v<_It> &&
        is_nothrow_copy_assignable_v<_Sent> &&
        is_nothrow_copy_constructible_v<_It> &&
        is_nothrow_copy_constructible_v<_Sent>)
      requires(!is_trivially_copy_assignable_v<_It> ||
               !is_trivially_copy_assignable_v<_Sent>)
    {
      _M_assign(__x);
      return *this;
    }

    constexpr common_iterator &operator=(common_iterator &&) = default;

    constexpr common_iterator &operator=(common_iterator &&__x) noexcept(
        is_nothrow_move_assignable_v<_It> &&
        is_nothrow_move_assignable_v<_Sent> &&
        is_nothrow_move_constructible_v<_It> &&
        is_nothrow_move_constructible_v<_Sent>)
      requires(!is_trivially_move_assignable_v<_It> ||
               !is_trivially_move_assignable_v<_Sent>)
    {
      _M_assign(std::move(__x));
      return *this;
    }

    template <typename _It2, typename _Sent2>
      requires convertible_to<const _It2 &, _It> &&
               convertible_to<const _Sent2 &, _Sent> &&
               assignable_from<_It &, const _It2 &> &&
               assignable_from<_Sent &, const _Sent2 &>
    constexpr common_iterator &
    operator=(const common_iterator<_It2, _Sent2> &__x) noexcept(
        is_nothrow_constructible_v<_It, const _It2 &> &&
        is_nothrow_constructible_v<_Sent, const _Sent2 &> &&
        is_nothrow_assignable_v<_It &, const _It2 &> &&
        is_nothrow_assignable_v<_Sent &, const _Sent2 &>) {
      do {
        if (std::__is_constant_evaluated() && !bool(__x._M_has_value()))
          __builtin_unreachable();
      } while (false);
      _M_assign(__x);
      return *this;
    }
# 2056 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
    constexpr ~common_iterator()

    {
      if (_M_index == 0)
        _M_it.~_It();
      else if (_M_index == 1)
        _M_sent.~_Sent();
    }

    [[nodiscard]]
    constexpr decltype(auto) operator*() {
      do {
        if (std::__is_constant_evaluated() && !bool(_M_index == 0))
          __builtin_unreachable();
      } while (false);
      return *_M_it;
    }

    [[nodiscard]]
    constexpr decltype(auto) operator*() const
      requires __detail::__dereferenceable<const _It>
    {
      do {
        if (std::__is_constant_evaluated() && !bool(_M_index == 0))
          __builtin_unreachable();
      } while (false);
      return *_M_it;
    }

    [[nodiscard]]
    constexpr auto operator->() const
      requires __detail::__common_iter_has_arrow<_It>
    {
      do {
        if (std::__is_constant_evaluated() && !bool(_M_index == 0))
          __builtin_unreachable();
      } while (false);
      if constexpr (is_pointer_v<_It> || requires { _M_it.operator->(); })
        return _M_it;
      else if constexpr (is_reference_v<iter_reference_t<_It>>) {
        auto &&__tmp = *_M_it;
        return std::__addressof(__tmp);
      } else
        return __arrow_proxy{*_M_it};
    }

    constexpr common_iterator &operator++() {
      do {
        if (std::__is_constant_evaluated() && !bool(_M_index == 0))
          __builtin_unreachable();
      } while (false);
      ++_M_it;
      return *this;
    }

    constexpr decltype(auto) operator++(int) {
      do {
        if (std::__is_constant_evaluated() && !bool(_M_index == 0))
          __builtin_unreachable();
      } while (false);
      if constexpr (forward_iterator<_It>) {
        common_iterator __tmp = *this;
        ++*this;
        return __tmp;
      } else if constexpr (!__detail::__common_iter_use_postfix_proxy<_It>)
        return _M_it++;
      else {
        __postfix_proxy __p(**this);
        ++*this;
        return __p;
      }
    }

    template <typename _It2, sentinel_for<_It> _Sent2>
      requires sentinel_for<_Sent, _It2>
    friend constexpr bool operator==
        [[nodiscard]] (const common_iterator &__x,
                       const common_iterator<_It2, _Sent2> &__y) {
      switch (__x._M_index << 2 | __y._M_index) {
      case 0b0000:
      case 0b0101:
        return true;
      case 0b0001:
        return __x._M_it == __y._M_sent;
      case 0b0100:
        return __x._M_sent == __y._M_it;
      default:
        do {
          if (std::__is_constant_evaluated() && !bool(__x._M_has_value()))
            __builtin_unreachable();
        } while (false);
        do {
          if (std::__is_constant_evaluated() && !bool(__y._M_has_value()))
            __builtin_unreachable();
        } while (false);
        __builtin_unreachable();
      }
    }

    template <typename _It2, sentinel_for<_It> _Sent2>
      requires sentinel_for<_Sent, _It2> && equality_comparable_with<_It, _It2>
    friend constexpr bool operator==
        [[nodiscard]] (const common_iterator &__x,
                       const common_iterator<_It2, _Sent2> &__y) {
      switch (__x._M_index << 2 | __y._M_index) {
      case 0b0101:
        return true;
      case 0b0000:
        return __x._M_it == __y._M_it;
      case 0b0001:
        return __x._M_it == __y._M_sent;
      case 0b0100:
        return __x._M_sent == __y._M_it;
      default:
        do {
          if (std::__is_constant_evaluated() && !bool(__x._M_has_value()))
            __builtin_unreachable();
        } while (false);
        do {
          if (std::__is_constant_evaluated() && !bool(__y._M_has_value()))
            __builtin_unreachable();
        } while (false);
        __builtin_unreachable();
      }
    }

    template <sized_sentinel_for<_It> _It2, sized_sentinel_for<_It> _Sent2>
      requires sized_sentinel_for<_Sent, _It2>
    friend constexpr iter_difference_t<_It2> operator-
        [[nodiscard]] (const common_iterator & __x,
                       const common_iterator<_It2, _Sent2> &__y) {
      switch (__x._M_index << 2 | __y._M_index) {
      case 0b0101:
        return 0;
      case 0b0000:
        return __x._M_it - __y._M_it;
      case 0b0001:
        return __x._M_it - __y._M_sent;
      case 0b0100:
        return __x._M_sent - __y._M_it;
      default:
        do {
          if (std::__is_constant_evaluated() && !bool(__x._M_has_value()))
            __builtin_unreachable();
        } while (false);
        do {
          if (std::__is_constant_evaluated() && !bool(__y._M_has_value()))
            __builtin_unreachable();
        } while (false);
        __builtin_unreachable();
      }
    }

    [[nodiscard]]
    friend constexpr iter_rvalue_reference_t<_It>
    iter_move(const common_iterator &__i) noexcept(
        noexcept(ranges::iter_move(std::declval<const _It &>())))
      requires input_iterator<_It>
    {
      do {
        if (std::__is_constant_evaluated() && !bool(__i._M_index == 0))
          __builtin_unreachable();
      } while (false);
      return ranges::iter_move(__i._M_it);
    }

    template <indirectly_swappable<_It> _It2, typename _Sent2>
    friend constexpr void iter_swap(
        const common_iterator &__x,
        const common_iterator<_It2, _Sent2>
            &__y) noexcept(noexcept(ranges::
                                        iter_swap(
                                            std::declval<const _It &>(),
                                            std::declval<const _It2 &>()))) {
      do {
        if (std::__is_constant_evaluated() && !bool(__x._M_index == 0))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() && !bool(__y._M_index == 0))
          __builtin_unreachable();
      } while (false);
      return ranges::iter_swap(__x._M_it, __y._M_it);
    }

  private:
    template <input_or_output_iterator _It2, sentinel_for<_It2> _Sent2>
      requires(!same_as<_It2, _Sent2>) && copyable<_It2>
    friend class common_iterator;

    constexpr bool _M_has_value() const noexcept {
      return _M_index != _S_valueless;
    }

    template <typename _CIt> constexpr void _M_assign(_CIt &&__x) {
      if (_M_index == __x._M_index) {
        if (_M_index == 0)
          _M_it = std::forward<_CIt>(__x)._M_it;
        else if (_M_index == 1)
          _M_sent = std::forward<_CIt>(__x)._M_sent;
      } else {
        if (_M_index == 0)
          _M_it.~_It();
        else if (_M_index == 1)
          _M_sent.~_Sent();
        _M_index = _S_valueless;

        if (__x._M_index == 0)
          std::construct_at(std::__addressof(_M_it),
                            std::forward<_CIt>(__x)._M_it);
        else if (__x._M_index == 1)
          std::construct_at(std::__addressof(_M_sent),
                            std::forward<_CIt>(__x)._M_sent);
        _M_index = __x._M_index;
      }
    }

    union {
      _It _M_it;
      _Sent _M_sent;
      unsigned char _M_valueless;
    };
    unsigned char _M_index;

    static constexpr unsigned char _S_valueless{2};
  };

  template <typename _It, typename _Sent>
  struct incrementable_traits<common_iterator<_It, _Sent>> {
    using difference_type = iter_difference_t<_It>;
  };

  template <input_iterator _It, typename _Sent>
  struct iterator_traits<common_iterator<_It, _Sent>> {
  private:
    template <typename _Iter> struct __ptr {
      using type = void;
    };

    template <typename _Iter>
      requires __detail::__common_iter_has_arrow<_Iter>
    struct __ptr<_Iter> {
      using _CIter = common_iterator<_Iter, _Sent>;
      using type = decltype(std::declval<const _CIter &>().operator->());
    };

    static auto _S_iter_cat() {
      if constexpr (requires {
                      requires derived_from<__iter_category_t<_It>,
                                            forward_iterator_tag>;
                    })
        return forward_iterator_tag{};
      else
        return input_iterator_tag{};
    }

  public:
    using iterator_concept =
        __conditional_t<forward_iterator<_It>, forward_iterator_tag,
                        input_iterator_tag>;
    using iterator_category = decltype(_S_iter_cat());
    using value_type = iter_value_t<_It>;
    using difference_type = iter_difference_t<_It>;
    using pointer = typename __ptr<_It>::type;
    using reference = iter_reference_t<_It>;
  };

  namespace __detail {
  template <typename _It> struct __counted_iter_value_type {};

  template <indirectly_readable _It> struct __counted_iter_value_type<_It> {
    using value_type = iter_value_t<_It>;
  };

  template <typename _It> struct __counted_iter_concept {};

  template <typename _It>
    requires requires { typename _It::iterator_concept; }
  struct __counted_iter_concept<_It> {
    using iterator_concept = typename _It::iterator_concept;
  };

  template <typename _It> struct __counted_iter_cat {};

  template <typename _It>
    requires requires { typename _It::iterator_category; }
  struct __counted_iter_cat<_It> {
    using iterator_category = typename _It::iterator_category;
  };
  } // namespace __detail

  template <input_or_output_iterator _It>
  class counted_iterator : public __detail::__counted_iter_value_type<_It>,
                           public __detail::__counted_iter_concept<_It>,
                           public __detail::__counted_iter_cat<_It> {
  public:
    using iterator_type = _It;

    using difference_type = iter_difference_t<_It>;

    constexpr counted_iterator()
      requires default_initializable<_It>
    = default;

    constexpr counted_iterator(_It __i, iter_difference_t<_It> __n)
        : _M_current(std::move(__i)), _M_length(__n) {
      do {
        if (std::__is_constant_evaluated() && !bool(__n >= 0))
          __builtin_unreachable();
      } while (false);
    }

    template <typename _It2>
      requires convertible_to<const _It2 &, _It>
    constexpr counted_iterator(const counted_iterator<_It2> &__x)
        : _M_current(__x._M_current), _M_length(__x._M_length) {}

    template <typename _It2>
      requires assignable_from<_It &, const _It2 &>
    constexpr counted_iterator &operator=(const counted_iterator<_It2> &__x) {
      _M_current = __x._M_current;
      _M_length = __x._M_length;
      return *this;
    }

    [[nodiscard]]
    constexpr const _It &base() const & noexcept {
      return _M_current;
    }

    [[nodiscard]]
    constexpr _It base() && noexcept(is_nothrow_move_constructible_v<_It>) {
      return std::move(_M_current);
    }

    [[nodiscard]]
    constexpr iter_difference_t<_It> count() const noexcept {
      return _M_length;
    }

    [[nodiscard]]
    constexpr decltype(auto) operator*() noexcept(noexcept(*_M_current)) {
      do {
        if (std::__is_constant_evaluated() && !bool(_M_length > 0))
          __builtin_unreachable();
      } while (false);
      return *_M_current;
    }

    [[nodiscard]]
    constexpr decltype(auto) operator*() const noexcept(noexcept(*_M_current))
      requires __detail::__dereferenceable<const _It>
    {
      do {
        if (std::__is_constant_evaluated() && !bool(_M_length > 0))
          __builtin_unreachable();
      } while (false);
      return *_M_current;
    }

    [[nodiscard]]
    constexpr auto operator->() const noexcept
      requires contiguous_iterator<_It>
    {
      return std::to_address(_M_current);
    }

    constexpr counted_iterator &operator++() {
      do {
        if (std::__is_constant_evaluated() && !bool(_M_length > 0))
          __builtin_unreachable();
      } while (false);
      ++_M_current;
      --_M_length;
      return *this;
    }

    constexpr decltype(auto) operator++(int) {
      do {
        if (std::__is_constant_evaluated() && !bool(_M_length > 0))
          __builtin_unreachable();
      } while (false);
      --_M_length;
      try {
        return _M_current++;
      } catch (...) {
        ++_M_length;
        throw;
      }
    }

    constexpr counted_iterator operator++(int)
      requires forward_iterator<_It>
    {
      auto __tmp = *this;
      ++*this;
      return __tmp;
    }

    constexpr counted_iterator &operator--()
      requires bidirectional_iterator<_It>
    {
      --_M_current;
      ++_M_length;
      return *this;
    }

    constexpr counted_iterator operator--(int)
      requires bidirectional_iterator<_It>
    {
      auto __tmp = *this;
      --*this;
      return __tmp;
    }

    [[nodiscard]]
    constexpr counted_iterator operator+(iter_difference_t<_It> __n) const
      requires random_access_iterator<_It>
    {
      return counted_iterator(_M_current + __n, _M_length - __n);
    }

    [[nodiscard]]
    friend constexpr counted_iterator operator+(iter_difference_t<_It> __n,
                                                const counted_iterator &__x)
      requires random_access_iterator<_It>
    {
      return __x + __n;
    }

    constexpr counted_iterator &operator+=(iter_difference_t<_It> __n)
      requires random_access_iterator<_It>
    {
      do {
        if (std::__is_constant_evaluated() && !bool(__n <= _M_length))
          __builtin_unreachable();
      } while (false);
      _M_current += __n;
      _M_length -= __n;
      return *this;
    }

    [[nodiscard]]
    constexpr counted_iterator operator-(iter_difference_t<_It> __n) const
      requires random_access_iterator<_It>
    {
      return counted_iterator(_M_current - __n, _M_length + __n);
    }

    template <common_with<_It> _It2>
    [[nodiscard]]
    friend constexpr iter_difference_t<_It2>
    operator-(const counted_iterator &__x, const counted_iterator<_It2> &__y) {
      return __y._M_length - __x._M_length;
    }

    [[nodiscard]]
    friend constexpr iter_difference_t<_It>
    operator-(const counted_iterator &__x, default_sentinel_t) {
      return -__x._M_length;
    }

    [[nodiscard]]
    friend constexpr iter_difference_t<_It>
    operator-(default_sentinel_t, const counted_iterator &__y) {
      return __y._M_length;
    }

    constexpr counted_iterator &operator-=(iter_difference_t<_It> __n)
      requires random_access_iterator<_It>
    {
      do {
        if (std::__is_constant_evaluated() && !bool(-__n <= _M_length))
          __builtin_unreachable();
      } while (false);
      _M_current -= __n;
      _M_length += __n;
      return *this;
    }

    [[nodiscard]]
    constexpr decltype(auto) operator[](iter_difference_t<_It> __n) const
        noexcept(noexcept(_M_current[__n]))
      requires random_access_iterator<_It>
    {
      do {
        if (std::__is_constant_evaluated() && !bool(__n < _M_length))
          __builtin_unreachable();
      } while (false);
      return _M_current[__n];
    }

    template <common_with<_It> _It2>
    [[nodiscard]]
    friend constexpr bool operator==(const counted_iterator &__x,
                                     const counted_iterator<_It2> &__y) {
      return __x._M_length == __y._M_length;
    }

    [[nodiscard]]
    friend constexpr bool operator==(const counted_iterator &__x,
                                     default_sentinel_t) {
      return __x._M_length == 0;
    }

    template <common_with<_It> _It2>
    [[nodiscard]]
    friend constexpr strong_ordering
    operator<=>(const counted_iterator &__x,
                const counted_iterator<_It2> &__y) {
      return __y._M_length <=> __x._M_length;
    }

    [[nodiscard]]
    friend constexpr iter_rvalue_reference_t<_It>
    iter_move(const counted_iterator &__i) noexcept(
        noexcept(ranges::iter_move(__i._M_current)))
      requires input_iterator<_It>
    {
      do {
        if (std::__is_constant_evaluated() && !bool(__i._M_length > 0))
          __builtin_unreachable();
      } while (false);
      return ranges::iter_move(__i._M_current);
    }

    template <indirectly_swappable<_It> _It2>
    friend constexpr void
    iter_swap(const counted_iterator &__x,
              const counted_iterator<_It2>
                  &__y) noexcept(noexcept(ranges::iter_swap(__x._M_current,
                                                            __y._M_current))) {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__x._M_length > 0 && __y._M_length > 0))
          __builtin_unreachable();
      } while (false);
      ranges::iter_swap(__x._M_current, __y._M_current);
    }

  private:
    template <input_or_output_iterator _It2> friend class counted_iterator;

    _It _M_current = _It();
    iter_difference_t<_It> _M_length = 0;
  };

  template <input_iterator _It>
    requires same_as<__detail::__iter_traits<_It>, iterator_traits<_It>>
  struct iterator_traits<counted_iterator<_It>> : iterator_traits<_It> {
    using pointer = __conditional_t<contiguous_iterator<_It>,
                                    add_pointer_t<iter_reference_t<_It>>, void>;
  };
# 2951 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _Iterator>
  constexpr auto __niter_base(move_iterator<_Iterator> __it)
      -> decltype(make_move_iterator(__niter_base(__it.base()))) {
    return make_move_iterator(__niter_base(__it.base()));
  }

  template <typename _Iterator>
  struct __is_move_iterator<move_iterator<_Iterator>> {
    enum { __value = 1 };
    typedef __true_type __type;
  };

  template <typename _Iterator>
  constexpr auto __miter_base(
      move_iterator<_Iterator> __it) -> decltype(__miter_base(__it.base())) {
    return __miter_base(__it.base());
  }
# 2983 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_iterator.h" 3
  template <typename _InputIterator>
  using __iter_key_t = remove_const_t<
      typename iterator_traits<_InputIterator>::value_type::first_type>;

  template <typename _InputIterator>
  using __iter_val_t =
      typename iterator_traits<_InputIterator>::value_type::second_type;

  template <typename _T1, typename _T2> struct pair;

  template <typename _InputIterator>
  using __iter_to_alloc_t =
      pair<const __iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>>;

} // namespace std
# 49 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_function.h" 1 3
# 63 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_function.h" 3
namespace std __attribute__((__visibility__("default"))) {
# 116 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_function.h" 3
  template <typename _Arg, typename _Result> struct unary_function {

    typedef _Arg argument_type;

    typedef _Result result_type;
  } __attribute__((__deprecated__));

  template <typename _Arg1, typename _Arg2, typename _Result>
  struct binary_function {

    typedef _Arg1 first_argument_type;

    typedef _Arg2 second_argument_type;

    typedef _Result result_type;
  } __attribute__((__deprecated__));
# 157 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_function.h" 3
  struct __is_transparent;

  template <typename _Tp = void> struct plus;

  template <typename _Tp = void> struct minus;

  template <typename _Tp = void> struct multiplies;

  template <typename _Tp = void> struct divides;

  template <typename _Tp = void> struct modulus;

  template <typename _Tp = void> struct negate;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

  template <typename _Tp> struct plus : public binary_function<_Tp, _Tp, _Tp> {

    constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
      return __x + __y;
    }
  };

  template <typename _Tp> struct minus : public binary_function<_Tp, _Tp, _Tp> {
    constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
      return __x - __y;
    }
  };

  template <typename _Tp>
  struct multiplies : public binary_function<_Tp, _Tp, _Tp> {
    constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
      return __x * __y;
    }
  };

  template <typename _Tp>
  struct divides : public binary_function<_Tp, _Tp, _Tp> {
    constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
      return __x / __y;
    }
  };

  template <typename _Tp>
  struct modulus : public binary_function<_Tp, _Tp, _Tp> {
    constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
      return __x % __y;
    }
  };

  template <typename _Tp> struct negate : public unary_function<_Tp, _Tp> {
    constexpr _Tp operator()(const _Tp &__x) const { return -__x; }
  };
#pragma GCC diagnostic pop

  template <> struct plus<void> {
    template <typename _Tp, typename _Up>
    constexpr auto operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
            -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u)) {
      return std::forward<_Tp>(__t) + std::forward<_Up>(__u);
    }

    typedef __is_transparent is_transparent;
  };

  template <> struct minus<void> {
    template <typename _Tp, typename _Up>
    constexpr auto operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
            -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u)) {
      return std::forward<_Tp>(__t) - std::forward<_Up>(__u);
    }

    typedef __is_transparent is_transparent;
  };

  template <> struct multiplies<void> {
    template <typename _Tp, typename _Up>
    constexpr auto operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
            -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u)) {
      return std::forward<_Tp>(__t) * std::forward<_Up>(__u);
    }

    typedef __is_transparent is_transparent;
  };

  template <> struct divides<void> {
    template <typename _Tp, typename _Up>
    constexpr auto operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
            -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u)) {
      return std::forward<_Tp>(__t) / std::forward<_Up>(__u);
    }

    typedef __is_transparent is_transparent;
  };

  template <> struct modulus<void> {
    template <typename _Tp, typename _Up>
    constexpr auto operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
            -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u)) {
      return std::forward<_Tp>(__t) % std::forward<_Up>(__u);
    }

    typedef __is_transparent is_transparent;
  };

  template <> struct negate<void> {
    template <typename _Tp>
    constexpr auto operator()(_Tp &&__t) const
        noexcept(noexcept(-std::forward<_Tp>(__t)))
            -> decltype(-std::forward<_Tp>(__t)) {
      return -std::forward<_Tp>(__t);
    }

    typedef __is_transparent is_transparent;
  };
# 349 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_function.h" 3
  template <typename _Tp = void> struct equal_to;

  template <typename _Tp = void> struct not_equal_to;

  template <typename _Tp = void> struct greater;

  template <typename _Tp = void> struct less;

  template <typename _Tp = void> struct greater_equal;

  template <typename _Tp = void> struct less_equal;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

  template <typename _Tp>
  struct equal_to : public binary_function<_Tp, _Tp, bool> {
    constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
      return __x == __y;
    }
  };

  template <typename _Tp>
  struct not_equal_to : public binary_function<_Tp, _Tp, bool> {
    constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
      return __x != __y;
    }
  };

  template <typename _Tp>
  struct greater : public binary_function<_Tp, _Tp, bool> {
    constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
      return __x > __y;
    }
  };

  template <typename _Tp> struct less : public binary_function<_Tp, _Tp, bool> {
    constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
      return __x < __y;
    }
  };

  template <typename _Tp>
  struct greater_equal : public binary_function<_Tp, _Tp, bool> {
    constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
      return __x >= __y;
    }
  };

  template <typename _Tp>
  struct less_equal : public binary_function<_Tp, _Tp, bool> {
    constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
      return __x <= __y;
    }
  };

  template <typename _Tp>
  struct greater<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
    constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept {

      if (std::__is_constant_evaluated())
        return __x > __y;

      return (long unsigned int)__x > (long unsigned int)__y;
    }
  };

  template <typename _Tp>
  struct less<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
    constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept {

      if (std::__is_constant_evaluated())
        return __x < __y;

      return (long unsigned int)__x < (long unsigned int)__y;
    }
  };

  template <typename _Tp>
  struct greater_equal<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
    constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept {

      if (std::__is_constant_evaluated())
        return __x >= __y;

      return (long unsigned int)__x >= (long unsigned int)__y;
    }
  };

  template <typename _Tp>
  struct less_equal<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
    constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept {

      if (std::__is_constant_evaluated())
        return __x <= __y;

      return (long unsigned int)__x <= (long unsigned int)__y;
    }
  };
#pragma GCC diagnostic pop

  template <> struct equal_to<void> {
    template <typename _Tp, typename _Up>
    constexpr auto operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
            -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u)) {
      return std::forward<_Tp>(__t) == std::forward<_Up>(__u);
    }

    typedef __is_transparent is_transparent;
  };

  template <> struct not_equal_to<void> {
    template <typename _Tp, typename _Up>
    constexpr auto operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
            -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u)) {
      return std::forward<_Tp>(__t) != std::forward<_Up>(__u);
    }

    typedef __is_transparent is_transparent;
  };

  template <> struct greater<void> {
    template <typename _Tp, typename _Up>
    constexpr auto operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
            -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u)) {
      return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
                    __ptr_cmp<_Tp, _Up>{});
    }

    template <typename _Tp, typename _Up>
    constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept {
      return greater<common_type_t<_Tp *, _Up *>>{}(__t, __u);
    }

    typedef __is_transparent is_transparent;

  private:
    template <typename _Tp, typename _Up>
    static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, false_type) {
      return std::forward<_Tp>(__t) > std::forward<_Up>(__u);
    }

    template <typename _Tp, typename _Up>
    static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, true_type) noexcept {
      return greater<const volatile void *>{}(
          static_cast<const volatile void *>(std::forward<_Tp>(__t)),
          static_cast<const volatile void *>(std::forward<_Up>(__u)));
    }

    template <typename _Tp, typename _Up, typename = void>
    struct __not_overloaded2 : true_type {};

    template <typename _Tp, typename _Up>
    struct __not_overloaded2<
        _Tp, _Up,
        __void_t<decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>>
        : false_type {};

    template <typename _Tp, typename _Up, typename = void>
    struct __not_overloaded : __not_overloaded2<_Tp, _Up> {};

    template <typename _Tp, typename _Up>
    struct __not_overloaded<
        _Tp, _Up,
        __void_t<decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>>
        : false_type {};

    template <typename _Tp, typename _Up>
    using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
                             is_convertible<_Tp, const volatile void *>,
                             is_convertible<_Up, const volatile void *>>;
  };

  template <> struct less<void> {
    template <typename _Tp, typename _Up>
    constexpr auto operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
            -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u)) {
      return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
                    __ptr_cmp<_Tp, _Up>{});
    }

    template <typename _Tp, typename _Up>
    constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept {
      return less<common_type_t<_Tp *, _Up *>>{}(__t, __u);
    }

    typedef __is_transparent is_transparent;

  private:
    template <typename _Tp, typename _Up>
    static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, false_type) {
      return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
    }

    template <typename _Tp, typename _Up>
    static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, true_type) noexcept {
      return less<const volatile void *>{}(
          static_cast<const volatile void *>(std::forward<_Tp>(__t)),
          static_cast<const volatile void *>(std::forward<_Up>(__u)));
    }

    template <typename _Tp, typename _Up, typename = void>
    struct __not_overloaded2 : true_type {};

    template <typename _Tp, typename _Up>
    struct __not_overloaded2<
        _Tp, _Up,
        __void_t<decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>>
        : false_type {};

    template <typename _Tp, typename _Up, typename = void>
    struct __not_overloaded : __not_overloaded2<_Tp, _Up> {};

    template <typename _Tp, typename _Up>
    struct __not_overloaded<
        _Tp, _Up,
        __void_t<decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>>
        : false_type {};

    template <typename _Tp, typename _Up>
    using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
                             is_convertible<_Tp, const volatile void *>,
                             is_convertible<_Up, const volatile void *>>;
  };

  template <> struct greater_equal<void> {
    template <typename _Tp, typename _Up>
    constexpr auto operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
            -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)) {
      return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
                    __ptr_cmp<_Tp, _Up>{});
    }

    template <typename _Tp, typename _Up>
    constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept {
      return greater_equal<common_type_t<_Tp *, _Up *>>{}(__t, __u);
    }

    typedef __is_transparent is_transparent;

  private:
    template <typename _Tp, typename _Up>
    static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, false_type) {
      return std::forward<_Tp>(__t) >= std::forward<_Up>(__u);
    }

    template <typename _Tp, typename _Up>
    static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, true_type) noexcept {
      return greater_equal<const volatile void *>{}(
          static_cast<const volatile void *>(std::forward<_Tp>(__t)),
          static_cast<const volatile void *>(std::forward<_Up>(__u)));
    }

    template <typename _Tp, typename _Up, typename = void>
    struct __not_overloaded2 : true_type {};

    template <typename _Tp, typename _Up>
    struct __not_overloaded2<
        _Tp, _Up,
        __void_t<decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>>
        : false_type {};

    template <typename _Tp, typename _Up, typename = void>
    struct __not_overloaded : __not_overloaded2<_Tp, _Up> {};

    template <typename _Tp, typename _Up>
    struct __not_overloaded<_Tp, _Up,
                            __void_t<decltype(operator>=(std::declval<_Tp>(),
                                                         std::declval<_Up>()))>>
        : false_type {};

    template <typename _Tp, typename _Up>
    using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
                             is_convertible<_Tp, const volatile void *>,
                             is_convertible<_Up, const volatile void *>>;
  };

  template <> struct less_equal<void> {
    template <typename _Tp, typename _Up>
    constexpr auto operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
            -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)) {
      return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
                    __ptr_cmp<_Tp, _Up>{});
    }

    template <typename _Tp, typename _Up>
    constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept {
      return less_equal<common_type_t<_Tp *, _Up *>>{}(__t, __u);
    }

    typedef __is_transparent is_transparent;

  private:
    template <typename _Tp, typename _Up>
    static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, false_type) {
      return std::forward<_Tp>(__t) <= std::forward<_Up>(__u);
    }

    template <typename _Tp, typename _Up>
    static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, true_type) noexcept {
      return less_equal<const volatile void *>{}(
          static_cast<const volatile void *>(std::forward<_Tp>(__t)),
          static_cast<const volatile void *>(std::forward<_Up>(__u)));
    }

    template <typename _Tp, typename _Up, typename = void>
    struct __not_overloaded2 : true_type {};

    template <typename _Tp, typename _Up>
    struct __not_overloaded2<
        _Tp, _Up,
        __void_t<decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>>
        : false_type {};

    template <typename _Tp, typename _Up, typename = void>
    struct __not_overloaded : __not_overloaded2<_Tp, _Up> {};

    template <typename _Tp, typename _Up>
    struct __not_overloaded<_Tp, _Up,
                            __void_t<decltype(operator<=(std::declval<_Tp>(),
                                                         std::declval<_Up>()))>>
        : false_type {};

    template <typename _Tp, typename _Up>
    using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
                             is_convertible<_Tp, const volatile void *>,
                             is_convertible<_Up, const volatile void *>>;
  };
# 781 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_function.h" 3
  template <typename _Tp = void> struct logical_and;

  template <typename _Tp = void> struct logical_or;

  template <typename _Tp = void> struct logical_not;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

  template <typename _Tp>
  struct logical_and : public binary_function<_Tp, _Tp, bool> {
    constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
      return __x && __y;
    }
  };

  template <typename _Tp>
  struct logical_or : public binary_function<_Tp, _Tp, bool> {
    constexpr bool operator()(const _Tp &__x, const _Tp &__y) const {
      return __x || __y;
    }
  };

  template <typename _Tp>
  struct logical_not : public unary_function<_Tp, bool> {
    constexpr bool operator()(const _Tp &__x) const { return !__x; }
  };
#pragma GCC diagnostic pop

  template <> struct logical_and<void> {
    template <typename _Tp, typename _Up>
    constexpr auto operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
            -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u)) {
      return std::forward<_Tp>(__t) && std::forward<_Up>(__u);
    }

    typedef __is_transparent is_transparent;
  };

  template <> struct logical_or<void> {
    template <typename _Tp, typename _Up>
    constexpr auto operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
            -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u)) {
      return std::forward<_Tp>(__t) || std::forward<_Up>(__u);
    }

    typedef __is_transparent is_transparent;
  };

  template <> struct logical_not<void> {
    template <typename _Tp>
    constexpr auto operator()(_Tp &&__t) const
        noexcept(noexcept(!std::forward<_Tp>(__t)))
            -> decltype(!std::forward<_Tp>(__t)) {
      return !std::forward<_Tp>(__t);
    }

    typedef __is_transparent is_transparent;
  };

  template <typename _Tp = void> struct bit_and;

  template <typename _Tp = void> struct bit_or;

  template <typename _Tp = void> struct bit_xor;

  template <typename _Tp = void> struct bit_not;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

  template <typename _Tp>
  struct bit_and : public binary_function<_Tp, _Tp, _Tp> {
    constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
      return __x & __y;
    }
  };

  template <typename _Tp>
  struct bit_or : public binary_function<_Tp, _Tp, _Tp> {
    constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
      return __x | __y;
    }
  };

  template <typename _Tp>
  struct bit_xor : public binary_function<_Tp, _Tp, _Tp> {
    constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const {
      return __x ^ __y;
    }
  };

  template <typename _Tp> struct bit_not : public unary_function<_Tp, _Tp> {
    constexpr _Tp operator()(const _Tp &__x) const { return ~__x; }
  };
#pragma GCC diagnostic pop

  template <> struct bit_and<void> {
    template <typename _Tp, typename _Up>
    constexpr auto operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
            -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u)) {
      return std::forward<_Tp>(__t) & std::forward<_Up>(__u);
    }

    typedef __is_transparent is_transparent;
  };

  template <> struct bit_or<void> {
    template <typename _Tp, typename _Up>
    constexpr auto operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
            -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u)) {
      return std::forward<_Tp>(__t) | std::forward<_Up>(__u);
    }

    typedef __is_transparent is_transparent;
  };

  template <> struct bit_xor<void> {
    template <typename _Tp, typename _Up>
    constexpr auto operator()(_Tp &&__t, _Up &&__u) const
        noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
            -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)) {
      return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u);
    }

    typedef __is_transparent is_transparent;
  };

  template <> struct bit_not<void> {
    template <typename _Tp>
    constexpr auto operator()(_Tp &&__t) const
        noexcept(noexcept(~std::forward<_Tp>(__t)))
            -> decltype(~std::forward<_Tp>(__t)) {
      return ~std::forward<_Tp>(__t);
    }

    typedef __is_transparent is_transparent;
  };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 1023 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_function.h" 3
  template <typename _Predicate>
  class [[__deprecated__]] unary_negate
      : public unary_function<typename _Predicate::argument_type, bool> {
  protected:
    _Predicate _M_pred;

  public:
    constexpr explicit unary_negate(const _Predicate &__x) : _M_pred(__x) {}

    constexpr bool
    operator()(const typename _Predicate::argument_type &__x) const {
      return !_M_pred(__x);
    }
  };

  template <typename _Predicate>
  __attribute__((
      __deprecated__("use '"
                     "std::not_fn"
                     "' instead"))) constexpr inline unary_negate<_Predicate>
  not1(const _Predicate &__pred) {
    return unary_negate<_Predicate>(__pred);
  }

  template <typename _Predicate>
  class [[__deprecated__]] binary_negate
      : public binary_function<typename _Predicate::first_argument_type,
                               typename _Predicate::second_argument_type,
                               bool> {
  protected:
    _Predicate _M_pred;

  public:
    constexpr explicit binary_negate(const _Predicate &__x) : _M_pred(__x) {}

    constexpr bool
    operator()(const typename _Predicate::first_argument_type &__x,
               const typename _Predicate::second_argument_type &__y) const {
      return !_M_pred(__x, __y);
    }
  };

  template <typename _Predicate>
  __attribute__((
      __deprecated__("use '"
                     "std::not_fn"
                     "' instead"))) constexpr inline binary_negate<_Predicate>
  not2(const _Predicate &__pred) {
    return binary_negate<_Predicate>(__pred);
  }
# 1104 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_function.h" 3
  template <typename _Arg, typename _Result>
  class pointer_to_unary_function : public unary_function<_Arg, _Result> {
  protected:
    _Result (*_M_ptr)(_Arg);

  public:
    pointer_to_unary_function() {}

    explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) {}

    _Result operator()(_Arg __x) const { return _M_ptr(__x); }
  } __attribute__((__deprecated__));

  template <typename _Arg, typename _Result>
  __attribute__((__deprecated__(
      "use '"
      "std::function"
      "' instead"))) inline pointer_to_unary_function<_Arg, _Result>
  ptr_fun(_Result(*__x)(_Arg)) {
    return pointer_to_unary_function<_Arg, _Result>(__x);
  }

  template <typename _Arg1, typename _Arg2, typename _Result>
  class pointer_to_binary_function
      : public binary_function<_Arg1, _Arg2, _Result> {
  protected:
    _Result (*_M_ptr)(_Arg1, _Arg2);

  public:
    pointer_to_binary_function() {}

    explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
        : _M_ptr(__x) {}

    _Result operator()(_Arg1 __x, _Arg2 __y) const { return _M_ptr(__x, __y); }
  } __attribute__((__deprecated__));

  template <typename _Arg1, typename _Arg2, typename _Result>
  __attribute__((__deprecated__(
      "use '"
      "std::function"
      "' instead"))) inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
  ptr_fun(_Result(*__x)(_Arg1, _Arg2)) {
    return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x);
  }

  template <typename _Tp> struct _Identity : public unary_function<_Tp, _Tp> {
    _Tp &operator()(_Tp &__x) const { return __x; }

    const _Tp &operator()(const _Tp &__x) const { return __x; }
  };

  template <typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> {};

  template <typename _Pair>
  struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
    typename _Pair::first_type &operator()(_Pair &__x) const {
      return __x.first;
    }

    const typename _Pair::first_type &operator()(const _Pair &__x) const {
      return __x.first;
    }

    template <typename _Pair2>
    typename _Pair2::first_type &operator()(_Pair2 &__x) const {
      return __x.first;
    }

    template <typename _Pair2>
    const typename _Pair2::first_type &operator()(const _Pair2 &__x) const {
      return __x.first;
    }
  };

  template <typename _Pair>
  struct _Select2nd
      : public unary_function<_Pair, typename _Pair::second_type> {
    typename _Pair::second_type &operator()(_Pair &__x) const {
      return __x.second;
    }

    const typename _Pair::second_type &operator()(const _Pair &__x) const {
      return __x.second;
    }
  };
# 1231 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_function.h" 3
  template <typename _Ret, typename _Tp>
  class mem_fun_t : public unary_function<_Tp *, _Ret> {
  public:
    explicit mem_fun_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}

    _Ret operator()(_Tp *__p) const { return (__p->*_M_f)(); }

  private:
    _Ret (_Tp::*_M_f)();
  } __attribute__((__deprecated__));

  template <typename _Ret, typename _Tp>
  class const_mem_fun_t : public unary_function<const _Tp *, _Ret> {
  public:
    explicit const_mem_fun_t(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {}

    _Ret operator()(const _Tp *__p) const { return (__p->*_M_f)(); }

  private:
    _Ret (_Tp::*_M_f)() const;
  } __attribute__((__deprecated__));

  template <typename _Ret, typename _Tp>
  class mem_fun_ref_t : public unary_function<_Tp, _Ret> {
  public:
    explicit mem_fun_ref_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}

    _Ret operator()(_Tp &__r) const { return (__r.*_M_f)(); }

  private:
    _Ret (_Tp::*_M_f)();
  } __attribute__((__deprecated__));

  template <typename _Ret, typename _Tp>
  class const_mem_fun_ref_t : public unary_function<_Tp, _Ret> {
  public:
    explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {}

    _Ret operator()(const _Tp &__r) const { return (__r.*_M_f)(); }

  private:
    _Ret (_Tp::*_M_f)() const;
  } __attribute__((__deprecated__));

  template <typename _Ret, typename _Tp, typename _Arg>
  class mem_fun1_t : public binary_function<_Tp *, _Arg, _Ret> {
  public:
    explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}

    _Ret operator()(_Tp *__p, _Arg __x) const { return (__p->*_M_f)(__x); }

  private:
    _Ret (_Tp::*_M_f)(_Arg);
  } __attribute__((__deprecated__));

  template <typename _Ret, typename _Tp, typename _Arg>
  class const_mem_fun1_t : public binary_function<const _Tp *, _Arg, _Ret> {
  public:
    explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}

    _Ret operator()(const _Tp *__p, _Arg __x) const {
      return (__p->*_M_f)(__x);
    }

  private:
    _Ret (_Tp::*_M_f)(_Arg) const;
  } __attribute__((__deprecated__));

  template <typename _Ret, typename _Tp, typename _Arg>
  class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
  public:
    explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}

    _Ret operator()(_Tp &__r, _Arg __x) const { return (__r.*_M_f)(__x); }

  private:
    _Ret (_Tp::*_M_f)(_Arg);
  } __attribute__((__deprecated__));

  template <typename _Ret, typename _Tp, typename _Arg>
  class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
  public:
    explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}

    _Ret operator()(const _Tp &__r, _Arg __x) const { return (__r.*_M_f)(__x); }

  private:
    _Ret (_Tp::*_M_f)(_Arg) const;
  } __attribute__((__deprecated__));

  template <typename _Ret, typename _Tp>
  __attribute__((__deprecated__("use '"
                                "std::mem_fn"
                                "' instead"))) inline mem_fun_t<_Ret, _Tp>
  mem_fun(_Ret(_Tp::*__f)()) {
    return mem_fun_t<_Ret, _Tp>(__f);
  }

  template <typename _Ret, typename _Tp>
  __attribute__((__deprecated__("use '"
                                "std::mem_fn"
                                "' instead"))) inline const_mem_fun_t<_Ret, _Tp>
  mem_fun(_Ret(_Tp::*__f)() const) {
    return const_mem_fun_t<_Ret, _Tp>(__f);
  }

  template <typename _Ret, typename _Tp>
  __attribute__((__deprecated__("use '"
                                "std::mem_fn"
                                "' instead"))) inline mem_fun_ref_t<_Ret, _Tp>
  mem_fun_ref(_Ret(_Tp::*__f)()) {
    return mem_fun_ref_t<_Ret, _Tp>(__f);
  }

  template <typename _Ret, typename _Tp>
  __attribute__((
      __deprecated__("use '"
                     "std::mem_fn"
                     "' instead"))) inline const_mem_fun_ref_t<_Ret, _Tp>
  mem_fun_ref(_Ret(_Tp::*__f)() const) {
    return const_mem_fun_ref_t<_Ret, _Tp>(__f);
  }

  template <typename _Ret, typename _Tp, typename _Arg>
  __attribute__((
      __deprecated__("use '"
                     "std::mem_fn"
                     "' instead"))) inline mem_fun1_t<_Ret, _Tp, _Arg>
  mem_fun(_Ret(_Tp::*__f)(_Arg)) {
    return mem_fun1_t<_Ret, _Tp, _Arg>(__f);
  }

  template <typename _Ret, typename _Tp, typename _Arg>
  __attribute__((
      __deprecated__("use '"
                     "std::mem_fn"
                     "' instead"))) inline const_mem_fun1_t<_Ret, _Tp, _Arg>
  mem_fun(_Ret(_Tp::*__f)(_Arg) const) {
    return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f);
  }

  template <typename _Ret, typename _Tp, typename _Arg>
  __attribute__((
      __deprecated__("use '"
                     "std::mem_fn"
                     "' instead"))) inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
  mem_fun_ref(_Ret(_Tp::*__f)(_Arg)) {
    return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
  }

  template <typename _Ret, typename _Tp, typename _Arg>
  __attribute__((
      __deprecated__("use '"
                     "std::mem_fn"
                     "' instead"))) inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
  mem_fun_ref(_Ret(_Tp::*__f)(_Arg) const) {
    return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
  }
#pragma GCC diagnostic pop

  template <typename _Func, typename _SfinaeType, typename = __void_t<>>
  struct __has_is_transparent {};

  template <typename _Func, typename _SfinaeType>
  struct __has_is_transparent<_Func, _SfinaeType,
                              __void_t<typename _Func::is_transparent>> {
    typedef void type;
  };

  template <typename _Func, typename _SfinaeType>
  using __has_is_transparent_t =
      typename __has_is_transparent<_Func, _SfinaeType>::type;

} // namespace std

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/binders.h" 1 3
# 60 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__((__visibility__("default"))) {
# 107 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/binders.h" 3
  template <typename _Operation>
  class binder1st
      : public unary_function<typename _Operation::second_argument_type,
                              typename _Operation::result_type> {
  protected:
    _Operation op;
    typename _Operation::first_argument_type value;

  public:
    binder1st(const _Operation &__x,
              const typename _Operation::first_argument_type &__y)
        : op(__x), value(__y) {}

    typename _Operation::result_type
    operator()(const typename _Operation::second_argument_type &__x) const {
      return op(value, __x);
    }

    typename _Operation::result_type
    operator()(typename _Operation::second_argument_type &__x) const {
      return op(value, __x);
    }
  } __attribute__((__deprecated__("use '"
                                  "std::bind"
                                  "' instead")));

  template <typename _Operation, typename _Tp>
  __attribute__((__deprecated__("use '"
                                "std::bind"
                                "' instead"))) inline binder1st<_Operation>
  bind1st(const _Operation &__fn, const _Tp &__x) {
    typedef typename _Operation::first_argument_type _Arg1_type;
    return binder1st<_Operation>(__fn, _Arg1_type(__x));
  }

  template <typename _Operation>
  class binder2nd
      : public unary_function<typename _Operation::first_argument_type,
                              typename _Operation::result_type> {
  protected:
    _Operation op;
    typename _Operation::second_argument_type value;

  public:
    binder2nd(const _Operation &__x,
              const typename _Operation::second_argument_type &__y)
        : op(__x), value(__y) {}

    typename _Operation::result_type
    operator()(const typename _Operation::first_argument_type &__x) const {
      return op(__x, value);
    }

    typename _Operation::result_type
    operator()(typename _Operation::first_argument_type &__x) const {
      return op(__x, value);
    }
  } __attribute__((__deprecated__("use '"
                                  "std::bind"
                                  "' instead")));

  template <typename _Operation, typename _Tp>
  __attribute__((__deprecated__("use '"
                                "std::bind"
                                "' instead"))) inline binder2nd<_Operation>
  bind2nd(const _Operation &__fn, const _Tp &__x) {
    typedef typename _Operation::second_argument_type _Arg2_type;
    return binder2nd<_Operation>(__fn, _Arg2_type(__x));
  }

} // namespace std

#pragma GCC diagnostic pop
# 1439 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_function.h" 2 3
# 50 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/numeric_traits.h" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/numeric_traits.h" 3

namespace __gnu_cxx __attribute__((__visibility__("default"))) {
# 50 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/numeric_traits.h" 3
  template <typename _Tp>
  struct __is_integer_nonstrict : public std::__is_integer<_Tp> {
    using std::__is_integer<_Tp>::__value;

    enum { __width = __value ? sizeof(_Tp) * 8 : 0 };
  };

  template <typename _Value> struct __numeric_traits_integer {

    static_assert(__is_integer_nonstrict<_Value>::__value,
                  "invalid specialization");

    static const bool __is_signed = (_Value)(-1) < 0;
    static const int __digits =
        __is_integer_nonstrict<_Value>::__width - __is_signed;

    static const _Value __max =
        __is_signed ? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)
                    : ~(_Value)0;
    static const _Value __min = __is_signed ? -__max - 1 : (_Value)0;
  };

  template <typename _Value>
  const _Value __numeric_traits_integer<_Value>::__min;

  template <typename _Value>
  const _Value __numeric_traits_integer<_Value>::__max;

  template <typename _Value>
  const bool __numeric_traits_integer<_Value>::__is_signed;

  template <typename _Value>
  const int __numeric_traits_integer<_Value>::__digits;
# 130 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/numeric_traits.h" 3
  __extension__ template <> struct __is_integer_nonstrict<__int128> {
    enum { __value = 1 };
    typedef std::__true_type __type;
    enum { __width = 128 };
  };
  __extension__ template <> struct __is_integer_nonstrict<unsigned __int128> {
    enum { __value = 1 };
    typedef std::__true_type __type;
    enum { __width = 128 };
  };

  template <typename _Tp> using __int_traits = __numeric_traits_integer<_Tp>;
# 157 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/numeric_traits.h" 3
  template <typename _Value> struct __numeric_traits_floating {

    static const int __max_digits10 =
        (2 + (std::__are_same<_Value, float>::__value    ? 24
              : std::__are_same<_Value, double>::__value ? 53
                                                         : 64) *
                 643L / 2136);

    static const bool __is_signed = true;
    static const int __digits10 =
        (std::__are_same<_Value, float>::__value    ? 6
         : std::__are_same<_Value, double>::__value ? 15
                                                    : 18);
    static const int __max_exponent10 =
        (std::__are_same<_Value, float>::__value    ? 38
         : std::__are_same<_Value, double>::__value ? 308
                                                    : 4932);
  };

  template <typename _Value>
  const int __numeric_traits_floating<_Value>::__max_digits10;

  template <typename _Value>
  const bool __numeric_traits_floating<_Value>::__is_signed;

  template <typename _Value>
  const int __numeric_traits_floating<_Value>::__digits10;

  template <typename _Value>
  const int __numeric_traits_floating<_Value>::__max_exponent10;

  template <typename _Value>
  struct __numeric_traits : public __numeric_traits_integer<_Value> {};

  template <>
  struct __numeric_traits<float> : public __numeric_traits_floating<float> {};

  template <>
  struct __numeric_traits<double> : public __numeric_traits_floating<double> {};

  template <>
  struct __numeric_traits<long double>
      : public __numeric_traits_floating<long double> {};
# 239 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/numeric_traits.h" 3
} // namespace __gnu_cxx
# 51 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 1 3
# 64 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_pair.h" 1 3
# 62 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_pair.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/utility.h" 1 3
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/utility.h" 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _Tp> struct tuple_size;

  template <typename _Tp, typename _Up = typename remove_cv<_Tp>::type,
            typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
            size_t = tuple_size<_Tp>::value>
  using __enable_if_has_tuple_size = _Tp;

  template <typename _Tp>
  struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
      : public tuple_size<_Tp> {};

  template <typename _Tp>
  struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
      : public tuple_size<_Tp> {};

  template <typename _Tp>
  struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
      : public tuple_size<_Tp> {};

  template <typename _Tp>
  inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;

  template <size_t __i, typename _Tp> struct tuple_element;

  template <size_t __i, typename _Tp>
  using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template <size_t __i, typename _Tp> struct tuple_element<__i, const _Tp> {
    using type = const __tuple_element_t<__i, _Tp>;
  };

  template <size_t __i, typename _Tp> struct tuple_element<__i, volatile _Tp> {
    using type = volatile __tuple_element_t<__i, _Tp>;
  };

  template <size_t __i, typename _Tp>
  struct tuple_element<__i, const volatile _Tp> {
    using type = const volatile __tuple_element_t<__i, _Tp>;
  };

  template <typename _Tp, typename... _Types>
  constexpr size_t __find_uniq_type_in_pack() {
    constexpr size_t __sz = sizeof...(_Types);
    constexpr bool __found[__sz] = {__is_same(_Tp, _Types)...};
    size_t __n = __sz;
    for (size_t __i = 0; __i < __sz; ++__i) {
      if (__found[__i]) {
        if (__n < __sz)
          return __sz;
        __n = __i;
      }
    }
    return __n;
  }
# 134 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/utility.h" 3
  template <size_t __i, typename _Tp>
  using tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template <size_t... _Indexes> struct _Index_tuple {};

  template <size_t _Num> struct _Build_index_tuple {

    template <typename, size_t... _Indices>
    using _IdxTuple = _Index_tuple<_Indices...>;

    using __type = __make_integer_seq<_IdxTuple, size_t, _Num>;
  };

  template <typename _Tp, _Tp... _Idx> struct integer_sequence {

    static_assert(is_integral_v<_Tp>);

    typedef _Tp value_type;
    static constexpr size_t size() noexcept { return sizeof...(_Idx); }
  };

  template <typename _Tp, _Tp _Num>
  using make_integer_sequence

      = __make_integer_seq<integer_sequence, _Tp, _Num>;

  template <size_t... _Idx>
  using index_sequence = integer_sequence<size_t, _Idx...>;

  template <size_t _Num>
  using make_index_sequence = make_integer_sequence<size_t, _Num>;

  template <typename... _Types>
  using index_sequence_for = make_index_sequence<sizeof...(_Types)>;

  struct in_place_t {
    explicit in_place_t() = default;
  };

  inline constexpr in_place_t in_place{};

  template <typename _Tp> struct in_place_type_t {
    explicit in_place_type_t() = default;
  };

  template <typename _Tp> inline constexpr in_place_type_t<_Tp> in_place_type{};

  template <size_t _Idx> struct in_place_index_t {
    explicit in_place_index_t() = default;
  };

  template <size_t _Idx>
  inline constexpr in_place_index_t<_Idx> in_place_index{};

  template <typename> inline constexpr bool __is_in_place_type_v = false;

  template <typename _Tp>
  inline constexpr bool __is_in_place_type_v<in_place_type_t<_Tp>> = true;

  template <typename _Tp>
  using __is_in_place_type = bool_constant<__is_in_place_type_v<_Tp>>;

  template <size_t _Np, typename... _Types> struct _Nth_type {};

  template <typename _Tp0, typename... _Rest>
  struct _Nth_type<0, _Tp0, _Rest...> {
    using type = _Tp0;
  };

  template <typename _Tp0, typename _Tp1, typename... _Rest>
  struct _Nth_type<1, _Tp0, _Tp1, _Rest...> {
    using type = _Tp1;
  };

  template <typename _Tp0, typename _Tp1, typename _Tp2, typename... _Rest>
  struct _Nth_type<2, _Tp0, _Tp1, _Tp2, _Rest...> {
    using type = _Tp2;
  };

  template <size_t _Np, typename _Tp0, typename _Tp1, typename _Tp2,
            typename... _Rest>

    requires(_Np >= 3)

  struct _Nth_type<_Np, _Tp0, _Tp1, _Tp2, _Rest...>
      : _Nth_type<_Np - 3, _Rest...> {};
# 270 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/utility.h" 3
} // namespace std
# 63 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_pair.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 80 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_pair.h" 3
  struct piecewise_construct_t {
    explicit piecewise_construct_t() = default;
  };

  inline constexpr piecewise_construct_t piecewise_construct =
      piecewise_construct_t();

  template <typename...> class tuple;

  template <size_t...> struct _Index_tuple;
# 163 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_pair.h" 3
  template <typename _U1, typename _U2> class __pair_base {};
# 186 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_pair.h" 3
  template <typename _T1, typename _T2>
  struct pair : public __pair_base<_T1, _T2> {
    typedef _T1 first_type;
    typedef _T2 second_type;

    _T1 first;
    _T2 second;

    constexpr pair(const pair &) = default;
    constexpr pair(pair &&) = default;

    template <typename... _Args1, typename... _Args2>
    constexpr pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

    constexpr void
    swap(pair &__p) noexcept(__and_<__is_nothrow_swappable<_T1>,
                                    __is_nothrow_swappable<_T2>>::value) {
      using std::swap;
      swap(first, __p.first);
      swap(second, __p.second);
    }
# 234 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_pair.h" 3
  private:
    template <typename... _Args1, size_t... _Indexes1, typename... _Args2,
              size_t... _Indexes2>
    constexpr pair(tuple<_Args1...> &, tuple<_Args2...> &,
                   _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

  public:
    constexpr explicit(
        __not_<__and_<__is_implicitly_default_constructible<_T1>,
                      __is_implicitly_default_constructible<_T2>>>()) pair()
      requires is_default_constructible_v<_T1> &&
                   is_default_constructible_v<_T2>
        : first(), second() {}

  private:
    template <typename _U1, typename _U2>
    static constexpr bool _S_constructible() {
      if constexpr (is_constructible_v<_T1, _U1>)
        return is_constructible_v<_T2, _U2>;
      return false;
    }

    template <typename _U1, typename _U2>
    static constexpr bool _S_nothrow_constructible() {
      if constexpr (is_nothrow_constructible_v<_T1, _U1>)
        return is_nothrow_constructible_v<_T2, _U2>;
      return false;
    }

    template <typename _U1, typename _U2>
    static constexpr bool _S_convertible() {
      if constexpr (is_convertible_v<_U1, _T1>)
        return is_convertible_v<_U2, _T2>;
      return false;
    }

    template <typename _U1, typename _U2> static constexpr bool _S_dangles() {

      if constexpr (__reference_constructs_from_temporary(_T1, _U1 &&))
        return true;
      else
        return __reference_constructs_from_temporary(_T2, _U2 &&);
    }

  public:
    constexpr explicit(!_S_convertible<const _T1 &, const _T2 &>())
        pair(const _T1 &__x, const _T2 &__y) noexcept(
            _S_nothrow_constructible<const _T1 &, const _T2 &>())
      requires(_S_constructible<const _T1 &, const _T2 &>())
        : first(__x), second(__y) {}

    template <typename _U1, typename _U2>
      requires(_S_constructible<_U1, _U2>()) && (!_S_dangles<_U1, _U2>())
    constexpr explicit(!_S_convertible<_U1, _U2>())
        pair(_U1 &&__x,
             _U2 &&__y) noexcept(_S_nothrow_constructible<_U1, _U2>())
        : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) {}

    template <typename _U1, typename _U2>
      requires(_S_constructible<_U1, _U2>()) && (_S_dangles<_U1, _U2>())
    constexpr explicit(!_S_convertible<_U1, _U2>())
        pair(_U1 &&, _U2 &&) = delete;

    template <typename _U1, typename _U2>
      requires(_S_constructible<const _U1 &, const _U2 &>()) &&
                  (!_S_dangles<_U1, _U2>())
    constexpr explicit(!_S_convertible<const _U1 &, const _U2 &>())
        pair(const pair<_U1, _U2> &__p) noexcept(
            _S_nothrow_constructible<const _U1 &, const _U2 &>())
        : first(__p.first), second(__p.second) {}

    template <typename _U1, typename _U2>
      requires(_S_constructible<const _U1 &, const _U2 &>()) &&
                  (_S_dangles<const _U1 &, const _U2 &>())
    constexpr explicit(!_S_convertible<const _U1 &, const _U2 &>())
        pair(const pair<_U1, _U2> &) = delete;

    template <typename _U1, typename _U2>
      requires(_S_constructible<_U1, _U2>()) && (!_S_dangles<_U1, _U2>())
    constexpr explicit(!_S_convertible<_U1, _U2>()) pair(
        pair<_U1, _U2> &&__p) noexcept(_S_nothrow_constructible<_U1, _U2>())
        : first(std::forward<_U1>(__p.first)),
          second(std::forward<_U2>(__p.second)) {}

    template <typename _U1, typename _U2>
      requires(_S_constructible<_U1, _U2>()) && (_S_dangles<_U1, _U2>())
    constexpr explicit(!_S_convertible<_U1, _U2>())
        pair(pair<_U1, _U2> &&) = delete;
# 389 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_pair.h" 3
  private:
    template <typename _U1, typename _U2>
    static constexpr bool _S_assignable() {
      if constexpr (is_assignable_v<_T1 &, _U1>)
        return is_assignable_v<_T2 &, _U2>;
      return false;
    }

    template <typename _U1, typename _U2>
    static constexpr bool _S_nothrow_assignable() {
      if constexpr (is_nothrow_assignable_v<_T1 &, _U1>)
        return is_nothrow_assignable_v<_T2 &, _U2>;
      return false;
    }

  public:
    pair &operator=(const pair &) = delete;

    constexpr pair &operator=(const pair &__p) noexcept(
        _S_nothrow_assignable<const _T1 &, const _T2 &>())
      requires(_S_assignable<const _T1 &, const _T2 &>())
    {
      first = __p.first;
      second = __p.second;
      return *this;
    }

    constexpr pair &
    operator=(pair &&__p) noexcept(_S_nothrow_assignable<_T1, _T2>())
      requires(_S_assignable<_T1, _T2>())
    {
      first = std::forward<first_type>(__p.first);
      second = std::forward<second_type>(__p.second);
      return *this;
    }

    template <typename _U1, typename _U2>
    constexpr pair &operator=(const pair<_U1, _U2> &__p) noexcept(
        _S_nothrow_assignable<const _U1 &, const _U2 &>())
      requires(_S_assignable<const _U1 &, const _U2 &>())
    {
      first = __p.first;
      second = __p.second;
      return *this;
    }

    template <typename _U1, typename _U2>
    constexpr pair &
    operator=(pair<_U1, _U2> &&__p) noexcept(_S_nothrow_assignable<_U1, _U2>())
      requires(_S_assignable<_U1, _U2>())
    {
      first = std::forward<_U1>(__p.first);
      second = std::forward<_U2>(__p.second);
      return *this;
    }
# 801 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_pair.h" 3
  };

  template <typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;

  template <typename _T1, typename _T2>
  inline constexpr bool operator==(const pair<_T1, _T2> &__x,
                                   const pair<_T1, _T2> &__y) {
    return __x.first == __y.first && __x.second == __y.second;
  }

  template <typename _T1, typename _T2>
  constexpr common_comparison_category_t<__detail::__synth3way_t<_T1>,
                                         __detail::__synth3way_t<_T2>>
  operator<=>(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
    if (auto __c = __detail::__synth3way(__x.first, __y.first); __c != 0)
      return __c;
    return __detail::__synth3way(__x.second, __y.second);
  }
# 870 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_pair.h" 3
  template <typename _T1, typename _T2>
  constexpr inline

      typename enable_if<
          __and_<__is_swappable<_T1>, __is_swappable<_T2>>::value>::type

      swap(pair<_T1, _T2> & __x,
           pair<_T1, _T2> & __y) noexcept(noexcept(__x.swap(__y))) {
    __x.swap(__y);
  }
# 893 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_pair.h" 3
  template <typename _T1, typename _T2>
  typename enable_if<
      !__and_<__is_swappable<_T1>, __is_swappable<_T2>>::value>::type
  swap(pair<_T1, _T2> &, pair<_T1, _T2> &) = delete;
# 919 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_pair.h" 3
  template <typename _T1, typename _T2>
  constexpr pair<typename __decay_and_strip<_T1>::__type,
                 typename __decay_and_strip<_T2>::__type>
  make_pair(_T1 && __x, _T2 && __y) {
    typedef typename __decay_and_strip<_T1>::__type __ds_type1;
    typedef typename __decay_and_strip<_T2>::__type __ds_type2;
    typedef pair<__ds_type1, __ds_type2> __pair_type;
    return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
  }
# 942 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_pair.h" 3
  template <typename _T1, typename _T2>
  struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type {};

  template <class _Tp1, class _Tp2>
  struct tuple_size<pair<_Tp1, _Tp2>> : public integral_constant<size_t, 2> {};

  template <class _Tp1, class _Tp2> struct tuple_element<0, pair<_Tp1, _Tp2>> {
    typedef _Tp1 type;
  };

  template <class _Tp1, class _Tp2> struct tuple_element<1, pair<_Tp1, _Tp2>> {
    typedef _Tp2 type;
  };

  template <typename _Tp1, typename _Tp2>
  inline constexpr size_t tuple_size_v<pair<_Tp1, _Tp2>> = 2;

  template <typename _Tp1, typename _Tp2>
  inline constexpr size_t tuple_size_v<const pair<_Tp1, _Tp2>> = 2;

  template <typename _Tp> inline constexpr bool __is_pair = false;

  template <typename _Tp, typename _Up>
  inline constexpr bool __is_pair<pair<_Tp, _Up>> = true;

  template <size_t _Int> struct __pair_get;

  template <> struct __pair_get<0> {
    template <typename _Tp1, typename _Tp2>
    static constexpr _Tp1 &__get(pair<_Tp1, _Tp2> &__pair) noexcept {
      return __pair.first;
    }

    template <typename _Tp1, typename _Tp2>
    static constexpr _Tp1 &&__move_get(pair<_Tp1, _Tp2> &&__pair) noexcept {
      return std::forward<_Tp1>(__pair.first);
    }

    template <typename _Tp1, typename _Tp2>
    static constexpr const _Tp1 &
    __const_get(const pair<_Tp1, _Tp2> &__pair) noexcept {
      return __pair.first;
    }

    template <typename _Tp1, typename _Tp2>
    static constexpr const _Tp1 &&
    __const_move_get(const pair<_Tp1, _Tp2> &&__pair) noexcept {
      return std::forward<const _Tp1>(__pair.first);
    }
  };

  template <> struct __pair_get<1> {
    template <typename _Tp1, typename _Tp2>
    static constexpr _Tp2 &__get(pair<_Tp1, _Tp2> &__pair) noexcept {
      return __pair.second;
    }

    template <typename _Tp1, typename _Tp2>
    static constexpr _Tp2 &&__move_get(pair<_Tp1, _Tp2> &&__pair) noexcept {
      return std::forward<_Tp2>(__pair.second);
    }

    template <typename _Tp1, typename _Tp2>
    static constexpr const _Tp2 &
    __const_get(const pair<_Tp1, _Tp2> &__pair) noexcept {
      return __pair.second;
    }

    template <typename _Tp1, typename _Tp2>
    static constexpr const _Tp2 &&
    __const_move_get(const pair<_Tp1, _Tp2> &&__pair) noexcept {
      return std::forward<const _Tp2>(__pair.second);
    }
  };

  template <size_t _Int, class _Tp1, class _Tp2>
  constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &get(
      pair<_Tp1, _Tp2> & __in) noexcept {
    return __pair_get<_Int>::__get(__in);
  }

  template <size_t _Int, class _Tp1, class _Tp2>
  constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &&get(
      pair<_Tp1, _Tp2> && __in) noexcept {
    return __pair_get<_Int>::__move_get(std::move(__in));
  }

  template <size_t _Int, class _Tp1, class _Tp2>
  constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &get(
      const pair<_Tp1, _Tp2> &__in) noexcept {
    return __pair_get<_Int>::__const_get(__in);
  }

  template <size_t _Int, class _Tp1, class _Tp2>
  constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type &&get(
      const pair<_Tp1, _Tp2> &&__in) noexcept {
    return __pair_get<_Int>::__const_move_get(std::move(__in));
  }

  template <typename _Tp, typename _Up>
  constexpr _Tp &get(pair<_Tp, _Up> & __p) noexcept {
    return __p.first;
  }

  template <typename _Tp, typename _Up>
  constexpr const _Tp &get(const pair<_Tp, _Up> &__p) noexcept {
    return __p.first;
  }

  template <typename _Tp, typename _Up>
  constexpr _Tp &&get(pair<_Tp, _Up> && __p) noexcept {
    return std::move(__p.first);
  }

  template <typename _Tp, typename _Up>
  constexpr const _Tp &&get(const pair<_Tp, _Up> &&__p) noexcept {
    return std::move(__p.first);
  }

  template <typename _Tp, typename _Up>
  constexpr _Tp &get(pair<_Up, _Tp> & __p) noexcept {
    return __p.second;
  }

  template <typename _Tp, typename _Up>
  constexpr const _Tp &get(const pair<_Up, _Tp> &__p) noexcept {
    return __p.second;
  }

  template <typename _Tp, typename _Up>
  constexpr _Tp &&get(pair<_Up, _Tp> && __p) noexcept {
    return std::move(__p.second);
  }

  template <typename _Tp, typename _Up>
  constexpr const _Tp &&get(const pair<_Up, _Tp> &&__p) noexcept {
    return std::move(__p.second);
  }
# 1119 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_pair.h" 3
} // namespace std
# 65 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/debug/debug.h" 1 3
# 48 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/debug/debug.h" 3
namespace std {
namespace __debug {}
} // namespace std

namespace __gnu_debug {
using namespace std::__debug;

template <typename _Ite, typename _Seq, typename _Cat> struct _Safe_iterator;
} // namespace __gnu_debug
# 70 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/predefined_ops.h" 1 3
# 35 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/predefined_ops.h" 3
namespace __gnu_cxx {
namespace __ops {
struct _Iter_less_iter {
  template <typename _Iterator1, typename _Iterator2>
  constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) const {
    return *__it1 < *__it2;
  }
};

constexpr inline _Iter_less_iter __iter_less_iter() {
  return _Iter_less_iter();
}

struct _Iter_less_val {

  constexpr _Iter_less_val() = default;

  constexpr explicit _Iter_less_val(_Iter_less_iter) {}

  template <typename _Iterator, typename _Value>
  constexpr bool operator()(_Iterator __it, _Value &__val) const {
    return *__it < __val;
  }
};

constexpr inline _Iter_less_val __iter_less_val() { return _Iter_less_val(); }

constexpr inline _Iter_less_val __iter_comp_val(_Iter_less_iter) {
  return _Iter_less_val();
}

struct _Val_less_iter {

  constexpr _Val_less_iter() = default;

  constexpr explicit _Val_less_iter(_Iter_less_iter) {}

  template <typename _Value, typename _Iterator>
  constexpr bool operator()(_Value &__val, _Iterator __it) const {
    return __val < *__it;
  }
};

constexpr inline _Val_less_iter __val_less_iter() { return _Val_less_iter(); }

constexpr inline _Val_less_iter __val_comp_iter(_Iter_less_iter) {
  return _Val_less_iter();
}

struct _Iter_equal_to_iter {
  template <typename _Iterator1, typename _Iterator2>
  constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) const {
    return *__it1 == *__it2;
  }
};

constexpr inline _Iter_equal_to_iter __iter_equal_to_iter() {
  return _Iter_equal_to_iter();
}

struct _Iter_equal_to_val {
  template <typename _Iterator, typename _Value>
  constexpr bool operator()(_Iterator __it, _Value &__val) const {
    return *__it == __val;
  }
};

constexpr inline _Iter_equal_to_val __iter_equal_to_val() {
  return _Iter_equal_to_val();
}

constexpr inline _Iter_equal_to_val __iter_comp_val(_Iter_equal_to_iter) {
  return _Iter_equal_to_val();
}

template <typename _Compare> struct _Iter_comp_iter {
  _Compare _M_comp;

  explicit constexpr _Iter_comp_iter(_Compare __comp)
      : _M_comp(std::move(__comp)) {}

  template <typename _Iterator1, typename _Iterator2>
  constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) {
    return bool(_M_comp(*__it1, *__it2));
  }
};

template <typename _Compare>
constexpr inline _Iter_comp_iter<_Compare> __iter_comp_iter(_Compare __comp) {
  return _Iter_comp_iter<_Compare>(std::move(__comp));
}

template <typename _Compare> struct _Iter_comp_val {
  _Compare _M_comp;

  constexpr explicit _Iter_comp_val(_Compare __comp)
      : _M_comp(std::move(__comp)) {}

  constexpr explicit _Iter_comp_val(const _Iter_comp_iter<_Compare> &__comp)
      : _M_comp(__comp._M_comp) {}

  constexpr explicit _Iter_comp_val(_Iter_comp_iter<_Compare> &&__comp)
      : _M_comp(std::move(__comp._M_comp)) {}

  template <typename _Iterator, typename _Value>
  constexpr bool operator()(_Iterator __it, _Value &__val) {
    return bool(_M_comp(*__it, __val));
  }
};

template <typename _Compare>
constexpr inline _Iter_comp_val<_Compare> __iter_comp_val(_Compare __comp) {
  return _Iter_comp_val<_Compare>(std::move(__comp));
}

template <typename _Compare>
constexpr inline _Iter_comp_val<_Compare>
__iter_comp_val(_Iter_comp_iter<_Compare> __comp) {
  return _Iter_comp_val<_Compare>(std::move(__comp));
}

template <typename _Compare> struct _Val_comp_iter {
  _Compare _M_comp;

  constexpr explicit _Val_comp_iter(_Compare __comp)
      : _M_comp(std::move(__comp)) {}

  constexpr explicit _Val_comp_iter(const _Iter_comp_iter<_Compare> &__comp)
      : _M_comp(__comp._M_comp) {}

  constexpr explicit _Val_comp_iter(_Iter_comp_iter<_Compare> &&__comp)
      : _M_comp(std::move(__comp._M_comp)) {}

  template <typename _Value, typename _Iterator>
  constexpr bool operator()(_Value &__val, _Iterator __it) {
    return bool(_M_comp(__val, *__it));
  }
};

template <typename _Compare>
constexpr inline _Val_comp_iter<_Compare> __val_comp_iter(_Compare __comp) {
  return _Val_comp_iter<_Compare>(std::move(__comp));
}

template <typename _Compare>
constexpr inline _Val_comp_iter<_Compare>
__val_comp_iter(_Iter_comp_iter<_Compare> __comp) {
  return _Val_comp_iter<_Compare>(std::move(__comp));
}

template <typename _Value> struct _Iter_equals_val {
  _Value &_M_value;

  constexpr explicit _Iter_equals_val(_Value &__value) : _M_value(__value) {}

  template <typename _Iterator> constexpr bool operator()(_Iterator __it) {
    return *__it == _M_value;
  }
};

template <typename _Value>
constexpr inline _Iter_equals_val<_Value> __iter_equals_val(_Value &__val) {
  return _Iter_equals_val<_Value>(__val);
}

template <typename _Iterator1> struct _Iter_equals_iter {
  _Iterator1 _M_it1;

  constexpr explicit _Iter_equals_iter(_Iterator1 __it1) : _M_it1(__it1) {}

  template <typename _Iterator2> constexpr bool operator()(_Iterator2 __it2) {
    return *__it2 == *_M_it1;
  }
};

template <typename _Iterator>
constexpr inline _Iter_equals_iter<_Iterator>
__iter_comp_iter(_Iter_equal_to_iter, _Iterator __it) {
  return _Iter_equals_iter<_Iterator>(__it);
}

template <typename _Predicate> struct _Iter_pred {
  _Predicate _M_pred;

  constexpr explicit _Iter_pred(_Predicate __pred)
      : _M_pred(std::move(__pred)) {}

  template <typename _Iterator> constexpr bool operator()(_Iterator __it) {
    return bool(_M_pred(*__it));
  }
};

template <typename _Predicate>
constexpr inline _Iter_pred<_Predicate> __pred_iter(_Predicate __pred) {
  return _Iter_pred<_Predicate>(std::move(__pred));
}

template <typename _Compare, typename _Value> struct _Iter_comp_to_val {
  _Compare _M_comp;
  _Value &_M_value;

  constexpr _Iter_comp_to_val(_Compare __comp, _Value &__value)
      : _M_comp(std::move(__comp)), _M_value(__value) {}

  template <typename _Iterator> constexpr bool operator()(_Iterator __it) {
    return bool(_M_comp(*__it, _M_value));
  }
};

template <typename _Compare, typename _Value>
_Iter_comp_to_val<_Compare, _Value> constexpr __iter_comp_val(_Compare __comp,
                                                              _Value &__val) {
  return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
}

template <typename _Compare, typename _Iterator1> struct _Iter_comp_to_iter {
  _Compare _M_comp;
  _Iterator1 _M_it1;

  constexpr _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
      : _M_comp(std::move(__comp)), _M_it1(__it1) {}

  template <typename _Iterator2> constexpr bool operator()(_Iterator2 __it2) {
    return bool(_M_comp(*__it2, *_M_it1));
  }
};

template <typename _Compare, typename _Iterator>
constexpr inline _Iter_comp_to_iter<_Compare, _Iterator>
__iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it) {
  return _Iter_comp_to_iter<_Compare, _Iterator>(std::move(__comp._M_comp),
                                                 __it);
}

template <typename _Predicate> struct _Iter_negate {
  _Predicate _M_pred;

  constexpr explicit _Iter_negate(_Predicate __pred)
      : _M_pred(std::move(__pred)) {}

  template <typename _Iterator> constexpr bool operator()(_Iterator __it) {
    return !bool(_M_pred(*__it));
  }
};

template <typename _Predicate>
constexpr inline _Iter_negate<_Predicate>
__negate(_Iter_pred<_Predicate> __pred) {
  return _Iter_negate<_Predicate>(std::move(__pred._M_pred));
}

} // namespace __ops
} // namespace __gnu_cxx
# 72 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bit" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bit" 3
# 55 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bit" 3
namespace std __attribute__((__visibility__("default"))) {
# 78 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bit" 3
  template <typename _To, typename _From>
  [[nodiscard]]
  constexpr _To bit_cast(const _From &__from) noexcept

    requires(sizeof(_To) == sizeof(_From)) && __is_trivially_copyable
  (_To) &&
      __is_trivially_copyable(_From)

  {
    return __builtin_bit_cast(_To, __from);
  }
# 149 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bit" 3
  template <typename _Tp> constexpr _Tp __rotl(_Tp __x, int __s) noexcept {
    constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
    if constexpr ((_Nd & (_Nd - 1)) == 0) {

      constexpr unsigned __uNd = _Nd;
      const unsigned __r = __s;
      return (__x << (__r % __uNd)) | (__x >> ((-__r) % __uNd));
    }
    const int __r = __s % _Nd;
    if (__r == 0)
      return __x;
    else if (__r > 0)
      return (__x << __r) | (__x >> ((_Nd - __r) % _Nd));
    else
      return (__x >> -__r) | (__x << ((_Nd + __r) % _Nd));
  }

  template <typename _Tp> constexpr _Tp __rotr(_Tp __x, int __s) noexcept {
    constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
    if constexpr ((_Nd & (_Nd - 1)) == 0) {

      constexpr unsigned __uNd = _Nd;
      const unsigned __r = __s;
      return (__x >> (__r % __uNd)) | (__x << ((-__r) % __uNd));
    }
    const int __r = __s % _Nd;
    if (__r == 0)
      return __x;
    else if (__r > 0)
      return (__x >> __r) | (__x << ((_Nd - __r) % _Nd));
    else
      return (__x << -__r) | (__x >> ((_Nd + __r) % _Nd));
  }

  template <typename _Tp> constexpr int __countl_zero(_Tp __x) noexcept {
    using __gnu_cxx::__int_traits;
    constexpr auto _Nd = __int_traits<_Tp>::__digits;

    if (__x == 0)
      return _Nd;

    constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
    constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
    constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

    if constexpr (_Nd <= _Nd_u) {
      constexpr int __diff = _Nd_u - _Nd;
      return __builtin_clz(__x) - __diff;
    } else if constexpr (_Nd <= _Nd_ul) {
      constexpr int __diff = _Nd_ul - _Nd;
      return __builtin_clzl(__x) - __diff;
    } else if constexpr (_Nd <= _Nd_ull) {
      constexpr int __diff = _Nd_ull - _Nd;
      return __builtin_clzll(__x) - __diff;
    } else {
      static_assert(_Nd <= (2 * _Nd_ull),
                    "Maximum supported integer size is 128-bit");

      unsigned long long __high = __x >> _Nd_ull;
      if (__high != 0) {
        constexpr int __diff = (2 * _Nd_ull) - _Nd;
        return __builtin_clzll(__high) - __diff;
      }
      constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
      unsigned long long __low = __x & __max_ull;
      return (_Nd - _Nd_ull) + __builtin_clzll(__low);
    }
  }

  template <typename _Tp> constexpr int __countl_one(_Tp __x) noexcept {
    return std::__countl_zero<_Tp>((_Tp)~__x);
  }

  template <typename _Tp> constexpr int __countr_zero(_Tp __x) noexcept {
    using __gnu_cxx::__int_traits;
    constexpr auto _Nd = __int_traits<_Tp>::__digits;

    if (__x == 0)
      return _Nd;

    constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
    constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
    constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

    if constexpr (_Nd <= _Nd_u)
      return __builtin_ctz(__x);
    else if constexpr (_Nd <= _Nd_ul)
      return __builtin_ctzl(__x);
    else if constexpr (_Nd <= _Nd_ull)
      return __builtin_ctzll(__x);
    else {
      static_assert(_Nd <= (2 * _Nd_ull),
                    "Maximum supported integer size is 128-bit");

      constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
      unsigned long long __low = __x & __max_ull;
      if (__low != 0)
        return __builtin_ctzll(__low);
      unsigned long long __high = __x >> _Nd_ull;
      return __builtin_ctzll(__high) + _Nd_ull;
    }
  }

  template <typename _Tp> constexpr int __countr_one(_Tp __x) noexcept {
    return std::__countr_zero((_Tp)~__x);
  }

  template <typename _Tp> constexpr int __popcount(_Tp __x) noexcept {
    using __gnu_cxx::__int_traits;
    constexpr auto _Nd = __int_traits<_Tp>::__digits;

    constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
    constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
    constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

    if constexpr (_Nd <= _Nd_u)
      return __builtin_popcount(__x);
    else if constexpr (_Nd <= _Nd_ul)
      return __builtin_popcountl(__x);
    else if constexpr (_Nd <= _Nd_ull)
      return __builtin_popcountll(__x);
    else {
      static_assert(_Nd <= (2 * _Nd_ull),
                    "Maximum supported integer size is 128-bit");

      constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
      unsigned long long __low = __x & __max_ull;
      unsigned long long __high = __x >> _Nd_ull;
      return __builtin_popcountll(__low) + __builtin_popcountll(__high);
    }
  }

  template <typename _Tp> constexpr bool __has_single_bit(_Tp __x) noexcept {
    return std::__popcount(__x) == 1;
  }

  template <typename _Tp> constexpr _Tp __bit_ceil(_Tp __x) noexcept {
    using __gnu_cxx::__int_traits;
    constexpr auto _Nd = __int_traits<_Tp>::__digits;
    if (__x == 0 || __x == 1)
      return 1;
    auto __shift_exponent = _Nd - std::__countl_zero((_Tp)(__x - 1u));

    if (!std::__is_constant_evaluated()) {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__shift_exponent != __int_traits<_Tp>::__digits))
          __builtin_unreachable();
      } while (false);
    }

    using __promoted_type = decltype(__x << 1);
    if constexpr (!is_same<__promoted_type, _Tp>::value) {

      const int __extra_exp = sizeof(__promoted_type) / sizeof(_Tp) / 2;
      __shift_exponent |= (__shift_exponent & _Nd) << __extra_exp;
    }
    return (_Tp)1u << __shift_exponent;
  }

  template <typename _Tp> constexpr _Tp __bit_floor(_Tp __x) noexcept {
    constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
    if (__x == 0)
      return 0;
    return (_Tp)1u << (_Nd - std::__countl_zero((_Tp)(__x >> 1)));
  }

  template <typename _Tp> constexpr int __bit_width(_Tp __x) noexcept {
    constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
    return _Nd - std::__countl_zero(__x);
  }
# 378 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bit" 3
  template <typename _Tp, typename _Up = _Tp>
  using _If_is_unsigned_integer =
      enable_if_t<__is_unsigned_integer<_Tp>::value, _Up>;

  template <typename _Tp>
  [[nodiscard]] constexpr _If_is_unsigned_integer<_Tp> rotl(_Tp __x,
                                                            int __s) noexcept {
    return std::__rotl(__x, __s);
  }

  template <typename _Tp>
  [[nodiscard]] constexpr _If_is_unsigned_integer<_Tp> rotr(_Tp __x,
                                                            int __s) noexcept {
    return std::__rotr(__x, __s);
  }

  template <typename _Tp>
  constexpr _If_is_unsigned_integer<_Tp, int> countl_zero(_Tp __x) noexcept {
    return std::__countl_zero(__x);
  }

  template <typename _Tp>
  constexpr _If_is_unsigned_integer<_Tp, int> countl_one(_Tp __x) noexcept {
    return std::__countl_one(__x);
  }

  template <typename _Tp>
  constexpr _If_is_unsigned_integer<_Tp, int> countr_zero(_Tp __x) noexcept {
    return std::__countr_zero(__x);
  }

  template <typename _Tp>
  constexpr _If_is_unsigned_integer<_Tp, int> countr_one(_Tp __x) noexcept {
    return std::__countr_one(__x);
  }

  template <typename _Tp>
  constexpr _If_is_unsigned_integer<_Tp, int> popcount(_Tp __x) noexcept {
    return std::__popcount(__x);
  }

  template <typename _Tp>
  constexpr _If_is_unsigned_integer<_Tp, bool> has_single_bit(
      _Tp __x) noexcept {
    return std::__has_single_bit(__x);
  }

  template <typename _Tp>
  constexpr _If_is_unsigned_integer<_Tp> bit_ceil(_Tp __x) noexcept {
    return std::__bit_ceil(__x);
  }

  template <typename _Tp>
  constexpr _If_is_unsigned_integer<_Tp> bit_floor(_Tp __x) noexcept {
    return std::__bit_floor(__x);
  }

  template <typename _Tp>
  constexpr _If_is_unsigned_integer<_Tp, int> bit_width(_Tp __x) noexcept {
    return std::__bit_width(__x);
  }
# 468 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bit" 3
  enum class endian { little = 1234, big = 4321, native = 1234 };

} // namespace std
# 77 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _Tp, typename _Up>
  constexpr inline int __memcmp(const _Tp *__first1, const _Up *__first2,
                                size_t __num) {

    static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");

    if (std::is_constant_evaluated()) {
      for (; __num > 0; ++__first1, ++__first2, --__num)
        if (*__first1 != *__first2)
          return *__first1 < *__first2 ? -1 : 1;
      return 0;
    } else

      return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
  }
# 152 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _ForwardIterator1, typename _ForwardIterator2>
  constexpr inline void iter_swap(_ForwardIterator1 __a,
                                  _ForwardIterator2 __b) {
# 185 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
    swap(*__a, *__b);
  }
# 201 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _ForwardIterator1, typename _ForwardIterator2>
  constexpr _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1,
                                          _ForwardIterator1 __last1,
                                          _ForwardIterator2 __first2) {

    ;

    for (; __first1 != __last1; ++__first1, (void)++__first2)
      std::iter_swap(__first1, __first2);
    return __first2;
  }
# 230 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _Tp>
  constexpr inline const _Tp &min(const _Tp &__a, const _Tp &__b) {

    if (__b < __a)
      return __b;
    return __a;
  }
# 254 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _Tp>
  constexpr inline const _Tp &max(const _Tp &__a, const _Tp &__b) {

    if (__a < __b)
      return __b;
    return __a;
  }
# 278 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _Tp, typename _Compare>
  constexpr inline const _Tp &min(const _Tp &__a, const _Tp &__b,
                                  _Compare __comp) {

    if (__comp(__b, __a))
      return __b;
    return __a;
  }
# 300 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _Tp, typename _Compare>
  constexpr inline const _Tp &max(const _Tp &__a, const _Tp &__b,
                                  _Compare __comp) {

    if (__comp(__a, __b))
      return __b;
    return __a;
  }

  template <typename _Iterator>
  constexpr inline _Iterator __niter_base(_Iterator __it) noexcept(
      std::is_nothrow_copy_constructible<_Iterator>::value) {
    return __it;
  }

  template <typename _Ite, typename _Seq>
  _Ite __niter_base(
      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq,
                                          std::random_access_iterator_tag> &);

  template <typename _From, typename _To>
  constexpr inline _From __niter_wrap(_From __from, _To __res) {
    return __from + (__res - std::__niter_base(__from));
  }

  template <typename _Iterator>
  constexpr inline _Iterator __niter_wrap(const _Iterator &, _Iterator __res) {
    return __res;
  }

  template <bool _IsMove, bool _IsSimple, typename _Category>
  struct __copy_move {
    template <typename _II, typename _OI>
    constexpr static _OI __copy_m(_II __first, _II __last, _OI __result) {
      for (; __first != __last; ++__result, (void)++__first)
        *__result = *__first;
      return __result;
    }
  };

  template <typename _Category> struct __copy_move<true, false, _Category> {
    template <typename _II, typename _OI>
    constexpr static _OI __copy_m(_II __first, _II __last, _OI __result) {
      for (; __first != __last; ++__result, (void)++__first)
        *__result = std::move(*__first);
      return __result;
    }
  };

  template <> struct __copy_move<false, false, random_access_iterator_tag> {
    template <typename _II, typename _OI>
    constexpr static _OI __copy_m(_II __first, _II __last, _OI __result) {
      typedef typename iterator_traits<_II>::difference_type _Distance;
      for (_Distance __n = __last - __first; __n > 0; --__n) {
        *__result = *__first;
        ++__first;
        ++__result;
      }
      return __result;
    }

    template <typename _Tp, typename _Up>
    static void __assign_one(_Tp *__to, _Up *__from) {
      *__to = *__from;
    }
  };

  template <> struct __copy_move<true, false, random_access_iterator_tag> {
    template <typename _II, typename _OI>
    constexpr static _OI __copy_m(_II __first, _II __last, _OI __result) {
      typedef typename iterator_traits<_II>::difference_type _Distance;
      for (_Distance __n = __last - __first; __n > 0; --__n) {
        *__result = std::move(*__first);
        ++__first;
        ++__result;
      }
      return __result;
    }

    template <typename _Tp, typename _Up>
    static void __assign_one(_Tp *__to, _Up *__from) {
      *__to = std::move(*__from);
    }
  };

  template <bool _IsMove>
  struct __copy_move<_IsMove, true, random_access_iterator_tag> {
    template <typename _Tp, typename _Up>
    constexpr static _Up *__copy_m(_Tp *__first, _Tp *__last, _Up *__result) {
      const ptrdiff_t _Num = __last - __first;
      if (__builtin_expect(_Num > 1, true))
        __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
      else if (_Num == 1)
        std::__copy_move<_IsMove, false,
                         random_access_iterator_tag>::__assign_one(__result,
                                                                   __first);
      return __result + _Num;
    }
  };

  template <typename _Tp, typename _Ref, typename _Ptr> struct _Deque_iterator;

  struct _Bit_iterator;

  template <typename _CharT> struct char_traits;

  template <typename _CharT, typename _Traits> class istreambuf_iterator;

  template <typename _CharT, typename _Traits> class ostreambuf_iterator;

  template <bool _IsMove, typename _CharT>
  typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT>>>::__type
  __copy_move_a2(_CharT *, _CharT *,
                 ostreambuf_iterator<_CharT, char_traits<_CharT>>);

  template <bool _IsMove, typename _CharT>
  typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT>>>::__type
  __copy_move_a2(const _CharT *, const _CharT *,
                 ostreambuf_iterator<_CharT, char_traits<_CharT>>);

  template <bool _IsMove, typename _CharT>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type
  __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT>>,
                 istreambuf_iterator<_CharT, char_traits<_CharT>>, _CharT *);

  template <bool _IsMove, typename _CharT>
  typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT &, _CharT *>>::__type
      __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT>>,
                     istreambuf_iterator<_CharT, char_traits<_CharT>>,
                     std::_Deque_iterator<_CharT, _CharT &, _CharT *>);

  template <bool _IsMove, typename _II, typename _OI>
  constexpr inline _OI __copy_move_a2(_II __first, _II __last, _OI __result) {
    typedef typename iterator_traits<_II>::iterator_category _Category;

    if (std::is_constant_evaluated())
      return std::__copy_move<_IsMove, false, _Category>::__copy_m(
          __first, __last, __result);

    return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
                            _Category>::__copy_m(__first, __last, __result);
  }

  template <bool _IsMove, typename _Tp, typename _Ref, typename _Ptr,
            typename _OI>
  _OI __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
                     std::_Deque_iterator<_Tp, _Ref, _Ptr>, _OI);

  template <bool _IsMove, typename _ITp, typename _IRef, typename _IPtr,
            typename _OTp>
  std::_Deque_iterator<_OTp, _OTp &, _OTp *> __copy_move_a1(
      std::_Deque_iterator<_ITp, _IRef, _IPtr>,
      std::_Deque_iterator<_ITp, _IRef, _IPtr>,
      std::_Deque_iterator<_OTp, _OTp &, _OTp *>);

  template <bool _IsMove, typename _II, typename _Tp>
  typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value,
                                  std::_Deque_iterator<_Tp, _Tp &, _Tp *>>::
      __type __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp &, _Tp *>);

  template <bool _IsMove, typename _II, typename _OI>
  constexpr inline _OI __copy_move_a1(_II __first, _II __last, _OI __result) {
    return std::__copy_move_a2<_IsMove>(__first, __last, __result);
  }

  template <bool _IsMove, typename _II, typename _OI>
  constexpr inline _OI __copy_move_a(_II __first, _II __last, _OI __result) {
    return std::__niter_wrap(
        __result, std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
                                               std::__niter_base(__last),
                                               std::__niter_base(__result)));
  }

  template <bool _IsMove, typename _Ite, typename _Seq, typename _Cat,
            typename _OI>
  _OI __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &,
                    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &,
                    _OI);

  template <bool _IsMove, typename _II, typename _Ite, typename _Seq,
            typename _Cat>
  __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __copy_move_a(
      _II, _II, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &);

  template <bool _IsMove, typename _IIte, typename _ISeq, typename _ICat,
            typename _OIte, typename _OSeq, typename _OCat>
  ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> __copy_move_a(
      const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &,
      const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &,
      const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> &);

  template <typename _InputIterator, typename _Size, typename _OutputIterator>
  constexpr _OutputIterator __copy_n_a(_InputIterator __first, _Size __n,
                                       _OutputIterator __result, bool) {
    if (__n > 0) {
      while (true) {
        *__result = *__first;
        ++__result;
        if (--__n > 0)
          ++__first;
        else
          break;
      }
    }
    return __result;
  }

  template <typename _CharT, typename _Size>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type
  __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT>>, _Size, _CharT *,
             bool);

  template <typename _CharT, typename _Size>
  typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT &, _CharT *>>::__type
  __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT>>, _Size,
             std::_Deque_iterator<_CharT, _CharT &, _CharT *>, bool);
# 621 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _II, typename _OI>
  constexpr inline _OI copy(_II __first, _II __last, _OI __result) {

    ;

    return std::__copy_move_a<__is_move_iterator<_II>::__value>(
        std::__miter_base(__first), std::__miter_base(__last), __result);
  }
# 654 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _II, typename _OI>
  constexpr inline _OI move(_II __first, _II __last, _OI __result) {

    ;

    return std::__copy_move_a<true>(std::__miter_base(__first),
                                    std::__miter_base(__last), __result);
  }

  template <bool _IsMove, bool _IsSimple, typename _Category>
  struct __copy_move_backward {
    template <typename _BI1, typename _BI2>
    constexpr static _BI2 __copy_move_b(_BI1 __first, _BI1 __last,
                                        _BI2 __result) {
      while (__first != __last)
        *--__result = *--__last;
      return __result;
    }
  };

  template <typename _Category>
  struct __copy_move_backward<true, false, _Category> {
    template <typename _BI1, typename _BI2>
    constexpr static _BI2 __copy_move_b(_BI1 __first, _BI1 __last,
                                        _BI2 __result) {
      while (__first != __last)
        *--__result = std::move(*--__last);
      return __result;
    }
  };

  template <>
  struct __copy_move_backward<false, false, random_access_iterator_tag> {
    template <typename _BI1, typename _BI2>
    constexpr static _BI2 __copy_move_b(_BI1 __first, _BI1 __last,
                                        _BI2 __result) {
      typename iterator_traits<_BI1>::difference_type __n = __last - __first;
      for (; __n > 0; --__n)
        *--__result = *--__last;
      return __result;
    }
  };

  template <>
  struct __copy_move_backward<true, false, random_access_iterator_tag> {
    template <typename _BI1, typename _BI2>
    constexpr static _BI2 __copy_move_b(_BI1 __first, _BI1 __last,
                                        _BI2 __result) {
      typename iterator_traits<_BI1>::difference_type __n = __last - __first;
      for (; __n > 0; --__n)
        *--__result = std::move(*--__last);
      return __result;
    }
  };

  template <bool _IsMove>
  struct __copy_move_backward<_IsMove, true, random_access_iterator_tag> {
    template <typename _Tp, typename _Up>
    constexpr static _Up *__copy_move_b(_Tp *__first, _Tp *__last,
                                        _Up *__result) {
      const ptrdiff_t _Num = __last - __first;
      if (__builtin_expect(_Num > 1, true))
        __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
      else if (_Num == 1)
        std::__copy_move<_IsMove, false,
                         random_access_iterator_tag>::__assign_one(__result - 1,
                                                                   __first);
      return __result - _Num;
    }
  };

  template <bool _IsMove, typename _BI1, typename _BI2>
  constexpr inline _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last,
                                                _BI2 __result) {
    typedef typename iterator_traits<_BI1>::iterator_category _Category;

    if (std::is_constant_evaluated())
      return std::__copy_move_backward<_IsMove, false,
                                       _Category>::__copy_move_b(__first,
                                                                 __last,
                                                                 __result);

    return std::__copy_move_backward<_IsMove, __memcpyable<_BI2, _BI1>::__value,
                                     _Category>::__copy_move_b(__first, __last,
                                                               __result);
  }

  template <bool _IsMove, typename _BI1, typename _BI2>
  constexpr inline _BI2 __copy_move_backward_a1(_BI1 __first, _BI1 __last,
                                                _BI2 __result) {
    return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result);
  }

  template <bool _IsMove, typename _Tp, typename _Ref, typename _Ptr,
            typename _OI>
  _OI __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
                              std::_Deque_iterator<_Tp, _Ref, _Ptr>, _OI);

  template <bool _IsMove, typename _ITp, typename _IRef, typename _IPtr,
            typename _OTp>
  std::_Deque_iterator<_OTp, _OTp &, _OTp *> __copy_move_backward_a1(
      std::_Deque_iterator<_ITp, _IRef, _IPtr>,
      std::_Deque_iterator<_ITp, _IRef, _IPtr>,
      std::_Deque_iterator<_OTp, _OTp &, _OTp *>);

  template <bool _IsMove, typename _II, typename _Tp>
  typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value,
                                  std::_Deque_iterator<_Tp, _Tp &, _Tp *>>::
      __type __copy_move_backward_a1(_II, _II,
                                     std::_Deque_iterator<_Tp, _Tp &, _Tp *>);

  template <bool _IsMove, typename _II, typename _OI>
  constexpr inline _OI __copy_move_backward_a(_II __first, _II __last,
                                              _OI __result) {
    return std::__niter_wrap(__result, std::__copy_move_backward_a1<_IsMove>(
                                           std::__niter_base(__first),
                                           std::__niter_base(__last),
                                           std::__niter_base(__result)));
  }

  template <bool _IsMove, typename _Ite, typename _Seq, typename _Cat,
            typename _OI>
  _OI __copy_move_backward_a(
      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &,
      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &, _OI);

  template <bool _IsMove, typename _II, typename _Ite, typename _Seq,
            typename _Cat>
  __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __copy_move_backward_a(
      _II, _II, const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &);

  template <bool _IsMove, typename _IIte, typename _ISeq, typename _ICat,
            typename _OIte, typename _OSeq, typename _OCat>
  ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> __copy_move_backward_a(
      const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &,
      const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat> &,
      const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat> &);
# 854 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _BI1, typename _BI2>
  constexpr inline _BI2 copy_backward(_BI1 __first, _BI1 __last,
                                      _BI2 __result) {

    ;

    return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>(
        std::__miter_base(__first), std::__miter_base(__last), __result);
  }
# 889 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _BI1, typename _BI2>
  constexpr inline _BI2 move_backward(_BI1 __first, _BI1 __last,
                                      _BI2 __result) {

    ;

    return std::__copy_move_backward_a<true>(
        std::__miter_base(__first), std::__miter_base(__last), __result);
  }

  template <typename _ForwardIterator, typename _Tp>
  constexpr inline
      typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
      __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
                const _Tp &__value) {
    for (; __first != __last; ++__first)
      *__first = __value;
  }

  template <typename _ForwardIterator, typename _Tp>
  constexpr inline
      typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
      __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
                const _Tp &__value) {
    const _Tp __tmp = __value;
    for (; __first != __last; ++__first)
      *__first = __tmp;
  }

  template <typename _Tp>
  constexpr inline
      typename __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
      __fill_a1(_Tp * __first, _Tp * __last, const _Tp &__c) {
    const _Tp __tmp = __c;

    if (std::is_constant_evaluated()) {
      for (; __first != __last; ++__first)
        *__first = __tmp;
      return;
    }

    if (const size_t __len = __last - __first)
      __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
  }

  template <typename _Ite, typename _Cont, typename _Tp>
  constexpr inline void __fill_a1(
      ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
      ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last, const _Tp &__value) {
    std::__fill_a1(__first.base(), __last.base(), __value);
  }

  template <typename _Tp, typename _VTp>
  void __fill_a1(const std::_Deque_iterator<_Tp, _Tp &, _Tp *> &,
                 const std::_Deque_iterator<_Tp, _Tp &, _Tp *> &, const _VTp &);

  constexpr void __fill_a1(std::_Bit_iterator, std::_Bit_iterator,
                           const bool &);

  template <typename _FIte, typename _Tp>
  constexpr inline void __fill_a(_FIte __first, _FIte __last,
                                 const _Tp &__value) {
    std::__fill_a1(__first, __last, __value);
  }

  template <typename _Ite, typename _Seq, typename _Cat, typename _Tp>
  void __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &,
                const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &,
                const _Tp &);
# 997 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _ForwardIterator, typename _Tp>
  constexpr inline void fill(_ForwardIterator __first, _ForwardIterator __last,
                             const _Tp &__value) {

    ;

    std::__fill_a(__first, __last, __value);
  }

  inline constexpr int __size_to_integer(int __n) { return __n; }
  inline constexpr unsigned __size_to_integer(unsigned __n) { return __n; }
  inline constexpr long __size_to_integer(long __n) { return __n; }
  inline constexpr unsigned long __size_to_integer(unsigned long __n) {
    return __n;
  }
  inline constexpr long long __size_to_integer(long long __n) { return __n; }
  inline constexpr unsigned long long __size_to_integer(
      unsigned long long __n) {
    return __n;
  }
# 1049 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  inline constexpr long long __size_to_integer(float __n) {
    return (long long)__n;
  }
  inline constexpr long long __size_to_integer(double __n) {
    return (long long)__n;
  }
  inline constexpr long long __size_to_integer(long double __n) {
    return (long long)__n;
  }

  template <typename _OutputIterator, typename _Size, typename _Tp>
  constexpr inline typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value,
                                                   _OutputIterator>::__type
  __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp &__value) {
    for (; __n > 0; --__n, (void)++__first)
      *__first = __value;
    return __first;
  }

  template <typename _OutputIterator, typename _Size, typename _Tp>
  constexpr inline typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value,
                                                   _OutputIterator>::__type
  __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp &__value) {
    const _Tp __tmp = __value;
    for (; __n > 0; --__n, (void)++__first)
      *__first = __tmp;
    return __first;
  }

  template <typename _Ite, typename _Seq, typename _Cat, typename _Size,
            typename _Tp>
  ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> __fill_n_a(
      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat> &__first, _Size __n,
      const _Tp &__value, std::input_iterator_tag);

  template <typename _OutputIterator, typename _Size, typename _Tp>
  constexpr inline _OutputIterator __fill_n_a(_OutputIterator __first,
                                              _Size __n, const _Tp &__value,
                                              std::output_iterator_tag) {

    static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

    return __fill_n_a1(__first, __n, __value);
  }

  template <typename _OutputIterator, typename _Size, typename _Tp>
  constexpr inline _OutputIterator __fill_n_a(_OutputIterator __first,
                                              _Size __n, const _Tp &__value,
                                              std::input_iterator_tag) {

    static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

    return __fill_n_a1(__first, __n, __value);
  }

  template <typename _OutputIterator, typename _Size, typename _Tp>
  constexpr inline _OutputIterator __fill_n_a(_OutputIterator __first,
                                              _Size __n, const _Tp &__value,
                                              std::random_access_iterator_tag) {

    static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

    if (__n <= 0)
      return __first;

    ;

    std::__fill_a(__first, __first + __n, __value);
    return __first + __n;
  }
# 1149 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _OI, typename _Size, typename _Tp>
  constexpr inline _OI fill_n(_OI __first, _Size __n, const _Tp &__value) {

    return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
                           std::__iterator_category(__first));
  }

  template <bool _BoolType> struct __equal {
    template <typename _II1, typename _II2>
    constexpr static bool equal(_II1 __first1, _II1 __last1, _II2 __first2) {
      for (; __first1 != __last1; ++__first1, (void)++__first2)
        if (!(*__first1 == *__first2))
          return false;
      return true;
    }
  };

  template <> struct __equal<true> {
    template <typename _Tp>
    constexpr static bool equal(const _Tp *__first1, const _Tp *__last1,
                                const _Tp *__first2) {
      if (const size_t __len = (__last1 - __first1))
        return !std::__memcmp(__first1, __first2, __len);
      return true;
    }
  };

  template <typename _Tp, typename _Ref, typename _Ptr, typename _II>
  typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value,
                                  bool>::__type
      __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
                   std::_Deque_iterator<_Tp, _Ref, _Ptr>, _II);

  template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2,
            typename _Ref2, typename _Ptr2>
  bool __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                    std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                    std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template <typename _II, typename _Tp, typename _Ref, typename _Ptr>
  typename __gnu_cxx::__enable_if<__is_random_access_iter<_II>::__value,
                                  bool>::__type
      __equal_aux1(_II, _II, std::_Deque_iterator<_Tp, _Ref, _Ptr>);

  template <typename _II1, typename _II2>
  constexpr inline bool __equal_aux1(_II1 __first1, _II1 __last1,
                                     _II2 __first2) {
    typedef typename iterator_traits<_II1>::value_type _ValueType1;
    const bool __simple = ((__is_integer<_ValueType1>::__value ||
                            __is_pointer<_ValueType1>::__value) &&
                           __memcmpable<_II1, _II2>::__value);
    return std::__equal<__simple>::equal(__first1, __last1, __first2);
  }

  template <typename _II1, typename _II2>
  constexpr inline bool __equal_aux(_II1 __first1, _II1 __last1,
                                    _II2 __first2) {
    return std::__equal_aux1(std::__niter_base(__first1),
                             std::__niter_base(__last1),
                             std::__niter_base(__first2));
  }

  template <typename _II1, typename _Seq1, typename _Cat1, typename _II2>
  bool __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &,
                   const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &,
                   _II2);

  template <typename _II1, typename _II2, typename _Seq2, typename _Cat2>
  bool __equal_aux(_II1, _II1,
                   const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2> &);

  template <typename _II1, typename _Seq1, typename _Cat1, typename _II2,
            typename _Seq2, typename _Cat2>
  bool __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &,
                   const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1> &,
                   const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2> &);

  template <typename, typename> struct __lc_rai {
    template <typename _II1, typename _II2>
    constexpr static _II1 __newlast1(_II1, _II1 __last1, _II2, _II2) {
      return __last1;
    }

    template <typename _II>
    constexpr static bool __cnd2(_II __first, _II __last) {
      return __first != __last;
    }
  };

  template <>
  struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag> {
    template <typename _RAI1, typename _RAI2>
    constexpr static _RAI1 __newlast1(_RAI1 __first1, _RAI1 __last1,
                                      _RAI2 __first2, _RAI2 __last2) {
      const typename iterator_traits<_RAI1>::difference_type __diff1 =
          __last1 - __first1;
      const typename iterator_traits<_RAI2>::difference_type __diff2 =
          __last2 - __first2;
      return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
    }

    template <typename _RAI> static constexpr bool __cnd2(_RAI, _RAI) {
      return true;
    }
  };

  template <typename _II1, typename _II2, typename _Compare>
  constexpr bool __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
                                                _II2 __first2, _II2 __last2,
                                                _Compare __comp) {
    typedef typename iterator_traits<_II1>::iterator_category _Category1;
    typedef typename iterator_traits<_II2>::iterator_category _Category2;
    typedef std::__lc_rai<_Category1, _Category2> __rai_type;

    __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
    for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
         ++__first1, (void)++__first2) {
      if (__comp(__first1, __first2))
        return true;
      if (__comp(__first2, __first1))
        return false;
    }
    return __first1 == __last1 && __first2 != __last2;
  }

  template <bool _BoolType> struct __lexicographical_compare {
    template <typename _II1, typename _II2>
    constexpr static bool __lc(_II1 __first1, _II1 __last1, _II2 __first2,
                               _II2 __last2) {
      using __gnu_cxx::__ops::__iter_less_iter;
      return std::__lexicographical_compare_impl(__first1, __last1, __first2,
                                                 __last2, __iter_less_iter());
    }

    template <typename _II1, typename _II2>
    constexpr static int __3way(_II1 __first1, _II1 __last1, _II2 __first2,
                                _II2 __last2) {
      while (__first1 != __last1) {
        if (__first2 == __last2)
          return +1;
        if (*__first1 < *__first2)
          return -1;
        if (*__first2 < *__first1)
          return +1;
        ++__first1;
        ++__first2;
      }
      return int(__first2 == __last2) - 1;
    }
  };

  template <> struct __lexicographical_compare<true> {
    template <typename _Tp, typename _Up>
    constexpr static bool __lc(const _Tp *__first1, const _Tp *__last1,
                               const _Up *__first2, const _Up *__last2) {
      return __3way(__first1, __last1, __first2, __last2) < 0;
    }

    template <typename _Tp, typename _Up>
    constexpr static ptrdiff_t __3way(const _Tp *__first1, const _Tp *__last1,
                                      const _Up *__first2, const _Up *__last2) {
      const size_t __len1 = __last1 - __first1;
      const size_t __len2 = __last2 - __first2;
      if (const size_t __len = std::min(__len1, __len2))
        if (int __result = std::__memcmp(__first1, __first2, __len))
          return __result;
      return ptrdiff_t(__len1 - __len2);
    }
  };

  template <typename _II1, typename _II2>
  constexpr inline bool __lexicographical_compare_aux1(
      _II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
    typedef typename iterator_traits<_II1>::value_type _ValueType1;
    typedef typename iterator_traits<_II2>::value_type _ValueType2;
    const bool __simple =
        (__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value &&
         __is_pointer<_II1>::__value && __is_pointer<_II2>::__value

         && !is_volatile_v<remove_reference_t<iter_reference_t<_II1>>> &&
         !is_volatile_v<remove_reference_t<iter_reference_t<_II2>>>

        );

    return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
                                                          __first2, __last2);
  }

  template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2>
  bool __lexicographical_compare_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                                      std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                                      _Tp2 *, _Tp2 *);

  template <typename _Tp1, typename _Tp2, typename _Ref2, typename _Ptr2>
  bool __lexicographical_compare_aux1(_Tp1 *, _Tp1 *,
                                      std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
                                      std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template <typename _Tp1, typename _Ref1, typename _Ptr1, typename _Tp2,
            typename _Ref2, typename _Ptr2>
  bool __lexicographical_compare_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                                      std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                                      std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
                                      std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template <typename _II1, typename _II2>
  constexpr inline bool __lexicographical_compare_aux(
      _II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) {
    return std::__lexicographical_compare_aux1(
        std::__niter_base(__first1), std::__niter_base(__last1),
        std::__niter_base(__first2), std::__niter_base(__last2));
  }

  template <typename _Iter1, typename _Seq1, typename _Cat1, typename _II2>
  bool __lexicographical_compare_aux(
      const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &,
      const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &, _II2, _II2);

  template <typename _II1, typename _Iter2, typename _Seq2, typename _Cat2>
  bool __lexicographical_compare_aux(
      _II1, _II1, const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &,
      const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &);

  template <typename _Iter1, typename _Seq1, typename _Cat1, typename _Iter2,
            typename _Seq2, typename _Cat2>
  bool __lexicographical_compare_aux(
      const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &,
      const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1> &,
      const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &,
      const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2> &);

  template <typename _ForwardIterator, typename _Tp, typename _Compare>
  constexpr _ForwardIterator __lower_bound(_ForwardIterator __first,
                                           _ForwardIterator __last,
                                           const _Tp &__val, _Compare __comp) {
    typedef typename iterator_traits<_ForwardIterator>::difference_type
        _DistanceType;

    _DistanceType __len = std::distance(__first, __last);

    while (__len > 0) {
      _DistanceType __half = __len >> 1;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __half);
      if (__comp(__middle, __val)) {
        __first = __middle;
        ++__first;
        __len = __len - __half - 1;
      } else
        __len = __half;
    }
    return __first;
  }
# 1495 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _ForwardIterator, typename _Tp>
  constexpr inline _ForwardIterator lower_bound(
      _ForwardIterator __first, _ForwardIterator __last, const _Tp &__val) {

    ;

    return std::__lower_bound(__first, __last, __val,
                              __gnu_cxx::__ops::__iter_less_val());
  }

  template <typename _Tp> inline constexpr _Tp __lg(_Tp __n) {

    return std::__bit_width(make_unsigned_t<_Tp>(__n)) - 1;
# 1528 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  }
# 1544 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _II1, typename _II2>
  constexpr inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2) {

    ;

    return std::__equal_aux(__first1, __last1, __first2);
  }
# 1575 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _IIter1, typename _IIter2, typename _BinaryPredicate>
  constexpr inline bool equal(_IIter1 __first1, _IIter1 __last1,
                              _IIter2 __first2,
                              _BinaryPredicate __binary_pred) {

    ;

    for (; __first1 != __last1; ++__first1, (void)++__first2)
      if (!bool(__binary_pred(*__first1, *__first2)))
        return false;
    return true;
  }

  template <typename _II1, typename _II2>
  constexpr inline bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2,
                                 _II2 __last2) {
    using _RATag = random_access_iterator_tag;
    using _Cat1 = typename iterator_traits<_II1>::iterator_category;
    using _Cat2 = typename iterator_traits<_II2>::iterator_category;
    using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
    if (_RAIters()) {
      auto __d1 = std::distance(__first1, __last1);
      auto __d2 = std::distance(__first2, __last2);
      if (__d1 != __d2)
        return false;
      return std::equal(__first1, __last1, __first2);
    }

    for (; __first1 != __last1 && __first2 != __last2;
         ++__first1, (void)++__first2)
      if (!(*__first1 == *__first2))
        return false;
    return __first1 == __last1 && __first2 == __last2;
  }

  template <typename _II1, typename _II2, typename _BinaryPredicate>
  constexpr inline bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2,
                                 _II2 __last2, _BinaryPredicate __binary_pred) {
    using _RATag = random_access_iterator_tag;
    using _Cat1 = typename iterator_traits<_II1>::iterator_category;
    using _Cat2 = typename iterator_traits<_II2>::iterator_category;
    using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
    if (_RAIters()) {
      auto __d1 = std::distance(__first1, __last1);
      auto __d2 = std::distance(__first2, __last2);
      if (__d1 != __d2)
        return false;
      return std::equal(__first1, __last1, __first2, __binary_pred);
    }

    for (; __first1 != __last1 && __first2 != __last2;
         ++__first1, (void)++__first2)
      if (!bool(__binary_pred(*__first1, *__first2)))
        return false;
    return __first1 == __last1 && __first2 == __last2;
  }
# 1665 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _II1, typename _II2>
  constexpr inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2,
                              _II2 __last2) {

    ;
    ;

    return std::__equal4(__first1, __last1, __first2, __last2);
  }
# 1698 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _IIter1, typename _IIter2, typename _BinaryPredicate>
  constexpr inline bool equal(_IIter1 __first1, _IIter1 __last1,
                              _IIter2 __first2, _IIter2 __last2,
                              _BinaryPredicate __binary_pred) {

    ;
    ;

    return std::__equal4(__first1, __last1, __first2, __last2, __binary_pred);
  }
# 1730 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _II1, typename _II2>
  constexpr inline bool lexicographical_compare(_II1 __first1, _II1 __last1,
                                                _II2 __first2, _II2 __last2) {
# 1745 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
    ;
    ;

    return std::__lexicographical_compare_aux(__first1, __last1, __first2,
                                              __last2);
  }
# 1765 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _II1, typename _II2, typename _Compare>
  constexpr inline bool lexicographical_compare(_II1 __first1, _II1 __last1,
                                                _II2 __first2, _II2 __last2,
                                                _Compare __comp) {

    ;
    ;

    return std::__lexicographical_compare_impl(
        __first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _Iter1, typename _Iter2>
  concept __memcmp_ordered_with =
      (__is_memcmp_ordered_with<iter_value_t<_Iter1>,
                                iter_value_t<_Iter2>>::__value) &&
      contiguous_iterator<_Iter1> && contiguous_iterator<_Iter2>;

  template <typename _Tp> constexpr auto __min_cmp(_Tp __x, _Tp __y) {
    struct _Res {
      _Tp _M_min;
      decltype(__x <=> __y) _M_cmp;
    };
    auto __c = __x <=> __y;
    if (__c > 0)
      return _Res{__y, __c};
    return _Res{__x, __c};
  }
# 1819 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _InputIter1, typename _InputIter2, typename _Comp>
  constexpr auto lexicographical_compare_three_way(
      _InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2,
      _InputIter2 __last2,
      _Comp __comp) -> decltype(__comp(*__first1, *__first2)) {

    ;
    ;

    using _Cat = decltype(__comp(*__first1, *__first2));
    static_assert(same_as<common_comparison_category_t<_Cat>, _Cat>);

    if (!std::__is_constant_evaluated())
      if constexpr (same_as<_Comp, __detail::_Synth3way> ||
                    same_as<_Comp, compare_three_way>)
        if constexpr (__memcmp_ordered_with<_InputIter1, _InputIter2>) {
          const auto [__len, __lencmp] =
              std::__min_cmp(__last1 - __first1, __last2 - __first2);
          if (__len) {
            const auto __blen = __len * sizeof(*__first1);
            const auto __c =
                __builtin_memcmp(&*__first1, &*__first2, __blen) <=> 0;
            if (__c != 0)
              return __c;
          }
          return __lencmp;
        }

    while (__first1 != __last1) {
      if (__first2 == __last2)
        return strong_ordering::greater;
      if (auto __cmp = __comp(*__first1, *__first2); __cmp != 0)
        return __cmp;
      ++__first1;
      ++__first2;
    }
    return (__first2 == __last2) <=> true;
  }

  template <typename _InputIter1, typename _InputIter2>
  constexpr auto lexicographical_compare_three_way(
      _InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2,
      _InputIter2 __last2) {
    return std::lexicographical_compare_three_way(__first1, __last1, __first2,
                                                  __last2, compare_three_way{});
  }

  template <typename _InputIterator1, typename _InputIterator2,
            typename _BinaryPredicate>
  constexpr pair<_InputIterator1, _InputIterator2> __mismatch(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred) {
    while (__first1 != __last1 && __binary_pred(__first1, __first2)) {
      ++__first1;
      ++__first2;
    }
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
  }
# 1908 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _InputIterator1, typename _InputIterator2>
  constexpr inline pair<_InputIterator1, _InputIterator2> mismatch(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2) {

    ;

    return std::__mismatch(__first1, __last1, __first2,
                           __gnu_cxx::__ops::__iter_equal_to_iter());
  }
# 1942 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _InputIterator1, typename _InputIterator2,
            typename _BinaryPredicate>
  constexpr inline pair<_InputIterator1, _InputIterator2> mismatch(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred) {

    ;

    return std::__mismatch(__first1, __last1, __first2,
                           __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
  }

  template <typename _InputIterator1, typename _InputIterator2,
            typename _BinaryPredicate>
  constexpr pair<_InputIterator1, _InputIterator2> __mismatch(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred) {
    while (__first1 != __last1 && __first2 != __last2 &&
           __binary_pred(__first1, __first2)) {
      ++__first1;
      ++__first2;
    }
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
  }
# 1991 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _InputIterator1, typename _InputIterator2>
  constexpr inline pair<_InputIterator1, _InputIterator2> mismatch(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2) {

    ;
    ;

    return std::__mismatch(__first1, __last1, __first2, __last2,
                           __gnu_cxx::__ops::__iter_equal_to_iter());
  }
# 2027 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _InputIterator1, typename _InputIterator2,
            typename _BinaryPredicate>
  constexpr inline pair<_InputIterator1, _InputIterator2> mismatch(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred) {

    ;
    ;

    return std::__mismatch(__first1, __last1, __first2, __last2,
                           __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
  }

  template <typename _InputIterator, typename _Predicate>
  constexpr inline _InputIterator __find_if(
      _InputIterator __first, _InputIterator __last, _Predicate __pred,
      input_iterator_tag) {
    while (__first != __last && !__pred(__first))
      ++__first;
    return __first;
  }

  template <typename _RandomAccessIterator, typename _Predicate>
  constexpr _RandomAccessIterator __find_if(
      _RandomAccessIterator __first, _RandomAccessIterator __last,
      _Predicate __pred, random_access_iterator_tag) {
    typename iterator_traits<_RandomAccessIterator>::difference_type
        __trip_count = (__last - __first) >> 2;

    for (; __trip_count > 0; --__trip_count) {
      if (__pred(__first))
        return __first;
      ++__first;

      if (__pred(__first))
        return __first;
      ++__first;

      if (__pred(__first))
        return __first;
      ++__first;

      if (__pred(__first))
        return __first;
      ++__first;
    }

    switch (__last - __first) {
    case 3:
      if (__pred(__first))
        return __first;
      ++__first;

    case 2:
      if (__pred(__first))
        return __first;
      ++__first;

    case 1:
      if (__pred(__first))
        return __first;
      ++__first;

    case 0:
    default:
      return __last;
    }
  }

  template <typename _Iterator, typename _Predicate>
  constexpr inline _Iterator __find_if(_Iterator __first, _Iterator __last,
                                       _Predicate __pred) {
    return __find_if(__first, __last, __pred,
                     std::__iterator_category(__first));
  }

  template <typename _InputIterator, typename _Predicate>
  constexpr typename iterator_traits<_InputIterator>::difference_type
  __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
    typename iterator_traits<_InputIterator>::difference_type __n = 0;
    for (; __first != __last; ++__first)
      if (__pred(__first))
        ++__n;
    return __n;
  }

  template <typename _ForwardIterator, typename _Predicate>
  constexpr _ForwardIterator __remove_if(
      _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
    __first = std::__find_if(__first, __last, __pred);
    if (__first == __last)
      return __first;
    _ForwardIterator __result = __first;
    ++__first;
    for (; __first != __last; ++__first)
      if (!__pred(__first)) {
        *__result = std::move(*__first);
        ++__result;
      }
    return __result;
  }

  template <typename _ForwardIterator1, typename _ForwardIterator2,
            typename _BinaryPredicate>
  constexpr bool __is_permutation(
      _ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _BinaryPredicate __pred) {

    for (; __first1 != __last1; ++__first1, (void)++__first2)
      if (!__pred(__first1, __first2))
        break;

    if (__first1 == __last1)
      return true;

    _ForwardIterator2 __last2 = __first2;
    std::advance(__last2, std::distance(__first1, __last1));
    for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan) {
      if (__scan !=
          std::__find_if(__first1, __scan,
                         __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
        continue;

      auto __matches =
          std::__count_if(__first2, __last2,
                          __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
      if (0 == __matches || std::__count_if(__scan, __last1,
                                            __gnu_cxx::__ops::__iter_comp_iter(
                                                __pred, __scan)) != __matches)
        return false;
    }
    return true;
  }
# 2204 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algobase.h" 3
  template <typename _ForwardIterator1, typename _ForwardIterator2>
  constexpr inline bool is_permutation(_ForwardIterator1 __first1,
                                       _ForwardIterator1 __last1,
                                       _ForwardIterator2 __first2) {

    ;

    return std::__is_permutation(__first1, __last1, __first2,
                                 __gnu_cxx::__ops::__iter_equal_to_iter());
  }

} // namespace std
# 52 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/refwrap.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/refwrap.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/invoke.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/invoke.h" 3

namespace std __attribute__((__visibility__("default"))) {
# 53 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/invoke.h" 3
  template <typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
  constexpr _Up &&__invfwd(typename remove_reference<_Tp>::type &
                           __t) noexcept {
    return static_cast<_Up &&>(__t);
  }

  template <typename _Res, typename _Fn, typename... _Args>
  constexpr _Res __invoke_impl(__invoke_other, _Fn && __f, _Args && ...__args) {
    return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...);
  }

  template <typename _Res, typename _MemFun, typename _Tp, typename... _Args>
  constexpr _Res __invoke_impl(__invoke_memfun_ref, _MemFun && __f, _Tp && __t,
                               _Args && ...__args) {
    return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...);
  }

  template <typename _Res, typename _MemFun, typename _Tp, typename... _Args>
  constexpr _Res __invoke_impl(__invoke_memfun_deref, _MemFun && __f,
                               _Tp && __t, _Args && ...__args) {
    return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
  }

  template <typename _Res, typename _MemPtr, typename _Tp>
  constexpr _Res __invoke_impl(__invoke_memobj_ref, _MemPtr && __f,
                               _Tp && __t) {
    return __invfwd<_Tp>(__t).*__f;
  }

  template <typename _Res, typename _MemPtr, typename _Tp>
  constexpr _Res __invoke_impl(__invoke_memobj_deref, _MemPtr && __f,
                               _Tp && __t) {
    return (*std::forward<_Tp>(__t)).*__f;
  }

  template <typename _Callable, typename... _Args>
  constexpr typename __invoke_result<_Callable, _Args...>::type
  __invoke(_Callable && __fn, _Args && ...__args) noexcept(
      __is_nothrow_invocable<_Callable, _Args...>::value) {
    using __result = __invoke_result<_Callable, _Args...>;
    using __type = typename __result::type;
    using __tag = typename __result::__invoke_type;
    return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
                                      std::forward<_Args>(__args)...);
  }

  template <typename _Res, typename _Callable, typename... _Args>
  constexpr enable_if_t<is_invocable_r_v<_Res, _Callable, _Args...>, _Res>
  __invoke_r(_Callable && __fn, _Args && ...__args) noexcept(
      is_nothrow_invocable_r_v<_Res, _Callable, _Args...>) {
    using __result = __invoke_result<_Callable, _Args...>;
    using __type = typename __result::type;
    using __tag = typename __result::__invoke_type;
    if constexpr (is_void_v<_Res>)
      std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
                                 std::forward<_Args>(__args)...);
    else
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
                                        std::forward<_Args>(__args)...);
  }
# 156 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/invoke.h" 3
} // namespace std
# 39 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/refwrap.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 52 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/refwrap.h" 3
  template <typename _Res, typename... _ArgTypes>
  struct _Maybe_unary_or_binary_function {};

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

  template <typename _Res, typename _T1>
  struct _Maybe_unary_or_binary_function<_Res, _T1>
      : std::unary_function<_T1, _Res> {};

  template <typename _Res, typename _T1, typename _T2>
  struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
      : std::binary_function<_T1, _T2, _Res> {};

#pragma GCC diagnostic pop

  template <typename _Signature> struct _Mem_fn_traits;

  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits_base {
    using __result_type = _Res;
    using __maybe_type =
        _Maybe_unary_or_binary_function<_Res, _Class *, _ArgTypes...>;
    using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
  };
# 103 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/refwrap.h" 3
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...)>
      : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......)>
      : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const>
      : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const>
      : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile>
      : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) volatile>
      : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile>
      : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const volatile>
      : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &>
      : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) &>
      : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &>
      : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const &>
      : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &>
      : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) volatile &>
      : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &>
      : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const volatile &>
      : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&>
      : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) &&>
      : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&>
      : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const &&>
      : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&>
      : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) volatile &&>
      : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&>
      : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const volatile &&>
      : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
    using __vararg = true_type;
  };

  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) noexcept>
      : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) noexcept>
      : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const noexcept>
      : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const noexcept>
      : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile noexcept>
      : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) volatile noexcept>
      : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile noexcept>
      : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......)
                            const volatile noexcept>
      : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) & noexcept>
      : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) & noexcept>
      : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const & noexcept>
      : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const & noexcept>
      : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile & noexcept>
      : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) volatile & noexcept>
      : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &
                        noexcept>
      : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const volatile &
                        noexcept>
      : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) && noexcept>
      : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) && noexcept>
      : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const && noexcept>
      : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const && noexcept>
      : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile && noexcept>
      : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) volatile && noexcept>
      : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> {
    using __vararg = true_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&
                        noexcept>
      : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
    using __vararg = false_type;
  };
  template <typename _Res, typename _Class, typename... _ArgTypes>
  struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes......) const volatile &&
                        noexcept>
      : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> {
    using __vararg = true_type;
  };

  template <typename _Functor, typename = __void_t<>>
  struct _Maybe_get_result_type {};

  template <typename _Functor>
  struct _Maybe_get_result_type<_Functor,
                                __void_t<typename _Functor::result_type>> {
    typedef typename _Functor::result_type result_type;
  };

  template <typename _Functor>
  struct _Weak_result_type_impl : _Maybe_get_result_type<_Functor> {};

  template <typename _Res, typename... _ArgTypes, bool _NE>
  struct _Weak_result_type_impl<_Res(_ArgTypes...) noexcept(_NE)> {
    typedef _Res result_type;
  };

  template <typename _Res, typename... _ArgTypes, bool _NE>
  struct _Weak_result_type_impl<_Res(_ArgTypes......) noexcept(_NE)> {
    typedef _Res result_type;
  };

  template <typename _Res, typename... _ArgTypes, bool _NE>
  struct _Weak_result_type_impl<_Res (*)(_ArgTypes...) noexcept(_NE)> {
    typedef _Res result_type;
  };

  template <typename _Res, typename... _ArgTypes, bool _NE>
  struct _Weak_result_type_impl<_Res (*)(_ArgTypes......) noexcept(_NE)> {
    typedef _Res result_type;
  };

  template <typename _Functor,
            bool = is_member_function_pointer<_Functor>::value>
  struct _Weak_result_type_memfun : _Weak_result_type_impl<_Functor> {};

  template <typename _MemFunPtr>
  struct _Weak_result_type_memfun<_MemFunPtr, true> {
    using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
  };

  template <typename _Func, typename _Class>
  struct _Weak_result_type_memfun<_Func _Class::*, false> {};

  template <typename _Functor>
  struct _Weak_result_type
      : _Weak_result_type_memfun<typename remove_cv<_Functor>::type> {};
# 302 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/refwrap.h" 3
  template <typename _Tp>
  class reference_wrapper

  {
    _Tp *_M_data;

    constexpr static _Tp *_S_fun(_Tp &__r) noexcept {
      return std::__addressof(__r);
    }

    static void _S_fun(_Tp &&) = delete;

    template <typename _Up, typename _Up2 = __remove_cvref_t<_Up>>
    using __not_same =
        typename enable_if<!is_same<reference_wrapper, _Up2>::value>::type;

  public:
    typedef _Tp type;

    template <
        typename _Up, typename = __not_same<_Up>,
        typename = decltype(reference_wrapper::_S_fun(std::declval<_Up>()))>
    constexpr reference_wrapper(_Up &&__uref) noexcept(
        noexcept(reference_wrapper::_S_fun(std::declval<_Up>())))
        : _M_data(reference_wrapper::_S_fun(std::forward<_Up>(__uref))) {}

    reference_wrapper(const reference_wrapper &) = default;

    reference_wrapper &operator=(const reference_wrapper &) = default;

    constexpr operator _Tp &() const noexcept { return this->get(); }

    constexpr _Tp &get() const noexcept { return *_M_data; }

    template <typename... _Args>
    constexpr typename __invoke_result<_Tp &, _Args...>::type
    operator()(_Args &&...__args) const
        noexcept(__is_nothrow_invocable<_Tp &, _Args...>::value) {

      if constexpr (is_object_v<type>)
        static_assert(sizeof(type), "type must be complete");

      return std::__invoke(get(), std::forward<_Args>(__args)...);
    }
  };

  template <typename _Tp> reference_wrapper(_Tp &) -> reference_wrapper<_Tp>;

  template <typename _Tp>
  constexpr inline reference_wrapper<_Tp> ref(_Tp & __t) noexcept {
    return reference_wrapper<_Tp>(__t);
  }

  template <typename _Tp>
  constexpr inline reference_wrapper<const _Tp> cref(const _Tp &__t) noexcept {
    return reference_wrapper<const _Tp>(__t);
  }

  template <typename _Tp> void ref(const _Tp &&) = delete;

  template <typename _Tp> void cref(const _Tp &&) = delete;

  template <typename _Tp>
  constexpr inline reference_wrapper<_Tp> ref(
      reference_wrapper<_Tp> __t) noexcept {
    return __t;
  }

  template <typename _Tp>
  constexpr inline reference_wrapper<const _Tp> cref(
      reference_wrapper<_Tp> __t) noexcept {
    return {__t.get()};
  }

} // namespace std
# 53 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/range_access.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/range_access.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/initializer_list" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/initializer_list" 3

namespace std __attribute__((__visibility__("default"))) {

  template <class _E> class initializer_list {
  public:
    typedef _E value_type;
    typedef const _E &reference;
    typedef const _E &const_reference;
    typedef size_t size_type;
    typedef const _E *iterator;
    typedef const _E *const_iterator;

  private:
    iterator _M_array;
    size_type _M_len;

    constexpr initializer_list(const_iterator __a, size_type __l)
        : _M_array(__a), _M_len(__l) {}

  public:
    constexpr initializer_list() noexcept : _M_array(0), _M_len(0) {}

    constexpr size_type size() const noexcept { return _M_len; }

    constexpr const_iterator begin() const noexcept { return _M_array; }

    constexpr const_iterator end() const noexcept { return begin() + size(); }
  };

  template <class _Tp>
  constexpr const _Tp *begin(initializer_list<_Tp> __ils) noexcept {
    return __ils.begin();
  }

  template <class _Tp>
  constexpr const _Tp *end(initializer_list<_Tp> __ils) noexcept {
    return __ils.end();
  }
} // namespace std
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/range_access.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _Container>
  [[__nodiscard__, __gnu__::__always_inline__]]
  inline constexpr auto begin(_Container & __cont) -> decltype(__cont.begin()) {
    return __cont.begin();
  }

  template <typename _Container>
  [[__nodiscard__, __gnu__::__always_inline__]]
  inline constexpr auto begin(
      const _Container &__cont) -> decltype(__cont.begin()) {
    return __cont.begin();
  }

  template <typename _Container>
  [[__nodiscard__, __gnu__::__always_inline__]]
  inline constexpr auto end(_Container & __cont) -> decltype(__cont.end()) {
    return __cont.end();
  }

  template <typename _Container>
  [[__nodiscard__, __gnu__::__always_inline__]]
  inline constexpr auto end(
      const _Container &__cont) -> decltype(__cont.end()) {
    return __cont.end();
  }

  template <typename _Tp, size_t _Nm>
  [[__nodiscard__, __gnu__::__always_inline__]]
  inline constexpr _Tp *begin(_Tp(&__arr)[_Nm]) noexcept {
    return __arr;
  }

  template <typename _Tp, size_t _Nm>
  [[__nodiscard__, __gnu__::__always_inline__]]
  inline constexpr _Tp *end(_Tp(&__arr)[_Nm]) noexcept {
    return __arr + _Nm;
  }

  template <typename _Tp> class valarray;

  template <typename _Tp> _Tp *begin(valarray<_Tp> &) noexcept;
  template <typename _Tp> const _Tp *begin(const valarray<_Tp> &) noexcept;
  template <typename _Tp> _Tp *end(valarray<_Tp> &) noexcept;
  template <typename _Tp> const _Tp *end(const valarray<_Tp> &) noexcept;

  template <typename _Container>
  [[__nodiscard__, __gnu__::__always_inline__]]
  constexpr auto cbegin(const _Container &__cont) noexcept(
      noexcept(std::begin(__cont))) -> decltype(std::begin(__cont)) {
    return std::begin(__cont);
  }

  template <typename _Container>
  [[__nodiscard__, __gnu__::__always_inline__]]
  constexpr auto cend(const _Container &__cont) noexcept(
      noexcept(std::end(__cont))) -> decltype(std::end(__cont)) {
    return std::end(__cont);
  }

  template <typename _Container>
  [[__nodiscard__, __gnu__::__always_inline__]]
  inline constexpr auto rbegin(_Container &
                               __cont) -> decltype(__cont.rbegin()) {
    return __cont.rbegin();
  }

  template <typename _Container>
  [[__nodiscard__, __gnu__::__always_inline__]]
  inline constexpr auto rbegin(
      const _Container &__cont) -> decltype(__cont.rbegin()) {
    return __cont.rbegin();
  }

  template <typename _Container>
  [[__nodiscard__, __gnu__::__always_inline__]]
  inline constexpr auto rend(_Container & __cont) -> decltype(__cont.rend()) {
    return __cont.rend();
  }

  template <typename _Container>
  [[__nodiscard__, __gnu__::__always_inline__]]
  inline constexpr auto rend(
      const _Container &__cont) -> decltype(__cont.rend()) {
    return __cont.rend();
  }

  template <typename _Tp, size_t _Nm>
  [[__nodiscard__]]
  inline constexpr reverse_iterator<_Tp *> rbegin(_Tp(&__arr)[_Nm]) noexcept {
    return reverse_iterator<_Tp *>(__arr + _Nm);
  }

  template <typename _Tp, size_t _Nm>
  [[__nodiscard__]]
  inline constexpr reverse_iterator<_Tp *> rend(_Tp(&__arr)[_Nm]) noexcept {
    return reverse_iterator<_Tp *>(__arr);
  }

  template <typename _Tp>
  [[__nodiscard__]]
  inline constexpr reverse_iterator<const _Tp *> rbegin(
      initializer_list<_Tp> __il) noexcept {
    return reverse_iterator<const _Tp *>(__il.end());
  }

  template <typename _Tp>
  [[__nodiscard__]]
  inline constexpr reverse_iterator<const _Tp *> rend(
      initializer_list<_Tp> __il) noexcept {
    return reverse_iterator<const _Tp *>(__il.begin());
  }

  template <typename _Container>
  [[__nodiscard__, __gnu__::__always_inline__]]
  inline constexpr auto crbegin(
      const _Container &__cont) -> decltype(std::rbegin(__cont)) {
    return std::rbegin(__cont);
  }

  template <typename _Container>
  [[__nodiscard__, __gnu__::__always_inline__]]
  inline constexpr auto crend(
      const _Container &__cont) -> decltype(std::rend(__cont)) {
    return std::rend(__cont);
  }
# 261 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/range_access.h" 3
  template <typename _Container>
  [[nodiscard, __gnu__::__always_inline__]]
  constexpr auto size(const _Container &__cont) noexcept(
      noexcept(__cont.size())) -> decltype(__cont.size()) {
    return __cont.size();
  }

  template <typename _Tp, size_t _Nm>
  [[nodiscard, __gnu__::__always_inline__]]
  constexpr size_t size(const _Tp(&)[_Nm]) noexcept {
    return _Nm;
  }

  template <typename _Container>
  [[nodiscard, __gnu__::__always_inline__]]
  constexpr auto empty(const _Container &__cont) noexcept(
      noexcept(__cont.empty())) -> decltype(__cont.empty()) {
    return __cont.empty();
  }

  template <typename _Tp, size_t _Nm>
  [[nodiscard, __gnu__::__always_inline__]]
  constexpr bool empty(const _Tp(&)[_Nm]) noexcept {
    return false;
  }

  template <typename _Tp>
  [[nodiscard, __gnu__::__always_inline__]]
  constexpr bool empty(initializer_list<_Tp> __il) noexcept {
    return __il.size() == 0;
  }

  template <typename _Container>
  [[nodiscard, __gnu__::__always_inline__]]
  constexpr auto data(_Container & __cont) noexcept(
      noexcept(__cont.data())) -> decltype(__cont.data()) {
    return __cont.data();
  }

  template <typename _Container>
  [[nodiscard, __gnu__::__always_inline__]]
  constexpr auto data(const _Container &__cont) noexcept(
      noexcept(__cont.data())) -> decltype(__cont.data()) {
    return __cont.data();
  }

  template <typename _Tp, size_t _Nm>
  [[nodiscard, __gnu__::__always_inline__]]
  constexpr _Tp *data(_Tp(&__array)[_Nm]) noexcept {
    return __array;
  }

  template <typename _Tp>
  [[nodiscard, __gnu__::__always_inline__]]
  constexpr const _Tp *data(initializer_list<_Tp> __il) noexcept {
    return __il.begin();
  }

  template <typename _Container>
  [[nodiscard, __gnu__::__always_inline__]]
  constexpr auto ssize(const _Container &__cont) noexcept(
      noexcept(__cont.size()))
      -> common_type_t<ptrdiff_t, make_signed_t<decltype(__cont.size())>> {
    using type = make_signed_t<decltype(__cont.size())>;
    return static_cast<common_type_t<ptrdiff_t, type>>(__cont.size());
  }

  template <typename _Tp, ptrdiff_t _Num>
  [[nodiscard, __gnu__::__always_inline__]]
  constexpr ptrdiff_t ssize(const _Tp(&)[_Num]) noexcept {
    return _Num;
  }

} // namespace std
# 54 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/alloc_traits.h" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/alloc_traits.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 1 3
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
namespace std __attribute__((__visibility__("default"))) {

  struct __allocator_traits_base {
    template <typename _Tp, typename _Up, typename = void>
    struct __rebind : __replace_first_arg<_Tp, _Up> {
      static_assert(
          is_same<
              typename __replace_first_arg<_Tp, typename _Tp::value_type>::type,
              _Tp>::value,
          "allocator_traits<A>::rebind_alloc<A::value_type> must be A");
    };

    template <typename _Tp, typename _Up>
    struct __rebind<_Tp, _Up,
                    __void_t<typename _Tp::template rebind<_Up>::other>> {
      using type = typename _Tp::template rebind<_Up>::other;

      static_assert(
          is_same<
              typename _Tp::template rebind<typename _Tp::value_type>::other,
              _Tp>::value,
          "allocator_traits<A>::rebind_alloc<A::value_type> must be A");
    };

  protected:
    template <typename _Tp> using __pointer = typename _Tp::pointer;
    template <typename _Tp> using __c_pointer = typename _Tp::const_pointer;
    template <typename _Tp> using __v_pointer = typename _Tp::void_pointer;
    template <typename _Tp>
    using __cv_pointer = typename _Tp::const_void_pointer;
    template <typename _Tp>
    using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template <typename _Tp>
    using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template <typename _Tp>
    using __pocs = typename _Tp::propagate_on_container_swap;
    template <typename _Tp>
    using __equal = __type_identity<typename _Tp::is_always_equal>;
  };

  template <typename _Alloc, typename _Up>
  using __alloc_rebind =
      typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
# 104 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
  template <typename _Alloc> struct allocator_traits : __allocator_traits_base {

    typedef _Alloc allocator_type;

    typedef typename _Alloc::value_type value_type;

    using pointer = __detected_or_t<value_type *, __pointer, _Alloc>;

  private:
    template <template <typename> class _Func, typename _Tp, typename = void>
    struct _Ptr {
      using type = typename pointer_traits<pointer>::template rebind<_Tp>;
    };

    template <template <typename> class _Func, typename _Tp>
    struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>> {
      using type = _Func<_Alloc>;
    };

    template <typename _A2, typename _PtrT, typename = void> struct _Diff {
      using type = typename pointer_traits<_PtrT>::difference_type;
    };

    template <typename _A2, typename _PtrT>
    struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>> {
      using type = typename _A2::difference_type;
    };

    template <typename _A2, typename _DiffT, typename = void>
    struct _Size : make_unsigned<_DiffT> {};

    template <typename _A2, typename _DiffT>
    struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>> {
      using type = typename _A2::size_type;
    };

  public:
    using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;

    using void_pointer = typename _Ptr<__v_pointer, void>::type;

    using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;

    using difference_type = typename _Diff<_Alloc, pointer>::type;

    using size_type = typename _Size<_Alloc, difference_type>::type;

    using propagate_on_container_copy_assignment =
        __detected_or_t<false_type, __pocca, _Alloc>;

    using propagate_on_container_move_assignment =
        __detected_or_t<false_type, __pocma, _Alloc>;

    using propagate_on_container_swap =
        __detected_or_t<false_type, __pocs, _Alloc>;

    using is_always_equal =
        typename __detected_or_t<is_empty<_Alloc>, __equal, _Alloc>::type;

    template <typename _Tp> using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
    template <typename _Tp>
    using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

  private:
    template <typename _Alloc2>
    static constexpr auto
    _S_allocate(_Alloc2 &__a, size_type __n, const_void_pointer __hint,
                int) -> decltype(__a.allocate(__n, __hint)) {
      return __a.allocate(__n, __hint);
    }

    template <typename _Alloc2>
    static constexpr pointer _S_allocate(_Alloc2 &__a, size_type __n,
                                         const_void_pointer, ...) {
      return __a.allocate(__n);
    }

    template <typename _Tp, typename... _Args> struct __construct_helper {
      template <typename _Alloc2,
                typename = decltype(std::declval<_Alloc2 *>()->construct(
                    std::declval<_Tp *>(), std::declval<_Args>()...))>
      static true_type __test(int);

      template <typename> static false_type __test(...);

      using type = decltype(__test<_Alloc>(0));
    };

    template <typename _Tp, typename... _Args>
    using __has_construct = typename __construct_helper<_Tp, _Args...>::type;

    template <typename _Tp, typename... _Args>
    static constexpr _Require<__has_construct<_Tp, _Args...>>
    _S_construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(
        noexcept(__a.construct(__p, std::forward<_Args>(__args)...))) {
      __a.construct(__p, std::forward<_Args>(__args)...);
    }

    template <typename _Tp, typename... _Args>
    static constexpr _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
                                     is_constructible<_Tp, _Args...>>>
    _S_construct(_Alloc &, _Tp *__p, _Args &&...__args) noexcept(
        std::is_nothrow_constructible<_Tp, _Args...>::value) {

      std::construct_at(__p, std::forward<_Args>(__args)...);
    }

    template <typename _Alloc2, typename _Tp>
    static constexpr auto _S_destroy(_Alloc2 &__a, _Tp *__p, int) noexcept(
        noexcept(__a.destroy(__p))) -> decltype(__a.destroy(__p)) {
      __a.destroy(__p);
    }

    template <typename _Alloc2, typename _Tp>
    static constexpr void
    _S_destroy(_Alloc2 &, _Tp *__p,
               ...) noexcept(std::is_nothrow_destructible<_Tp>::value) {
      std::_Destroy(__p);
    }

    template <typename _Alloc2>
    static constexpr auto _S_max_size(_Alloc2 &__a,
                                      int) -> decltype(__a.max_size()) {
      return __a.max_size();
    }

    template <typename _Alloc2>
    static constexpr size_type _S_max_size(_Alloc2 &, ...) {

      return __gnu_cxx::__numeric_traits<size_type>::__max / sizeof(value_type);
    }

    template <typename _Alloc2>
    static constexpr auto _S_select(_Alloc2 &__a, int)
        -> decltype(__a.select_on_container_copy_construction()) {
      return __a.select_on_container_copy_construction();
    }

    template <typename _Alloc2>
    static constexpr _Alloc2 _S_select(_Alloc2 &__a, ...) {
      return __a;
    }

  public:
# 331 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
    [[__nodiscard__]] static constexpr pointer allocate(_Alloc &__a,
                                                        size_type __n) {
      return __a.allocate(__n);
    }
# 346 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
    [[__nodiscard__]] static constexpr pointer
    allocate(_Alloc &__a, size_type __n, const_void_pointer __hint) {
      return _S_allocate(__a, __n, __hint, 0);
    }
# 358 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
    static constexpr void deallocate(_Alloc &__a, pointer __p, size_type __n) {
      __a.deallocate(__p, __n);
    }
# 373 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
    template <typename _Tp, typename... _Args>
    static constexpr auto
    construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(
        noexcept(_S_construct(__a, __p, std::forward<_Args>(__args)...)))
        -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...)) {
      _S_construct(__a, __p, std::forward<_Args>(__args)...);
    }
# 389 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
    template <typename _Tp>
    static constexpr void
    destroy(_Alloc &__a, _Tp *__p) noexcept(noexcept(_S_destroy(__a, __p, 0))) {
      _S_destroy(__a, __p, 0);
    }
# 403 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
    static constexpr size_type max_size(const _Alloc &__a) noexcept {
      return _S_max_size(__a, 0);
    }
# 415 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
    static constexpr _Alloc
    select_on_container_copy_construction(const _Alloc &__rhs) {
      return _S_select(__rhs, 0);
    }
  };
# 427 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
  template <typename _Tp> struct allocator_traits<allocator<_Tp>> {

    using allocator_type = allocator<_Tp>;

    using value_type = _Tp;

    using pointer = _Tp *;

    using const_pointer = const _Tp *;

    using void_pointer = void *;

    using const_void_pointer = const void *;

    using difference_type = std::ptrdiff_t;

    using size_type = std::size_t;

    using propagate_on_container_copy_assignment = false_type;

    using propagate_on_container_move_assignment = true_type;

    using propagate_on_container_swap = false_type;

    using is_always_equal = true_type;

    template <typename _Up> using rebind_alloc = allocator<_Up>;

    template <typename _Up>
    using rebind_traits = allocator_traits<allocator<_Up>>;
# 479 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
    [[__nodiscard__, __gnu__::__always_inline__]]
    static constexpr pointer allocate(allocator_type &__a, size_type __n) {
      return __a.allocate(__n);
    }
# 494 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
    [[__nodiscard__, __gnu__::__always_inline__]]
    static constexpr pointer
    allocate(allocator_type &__a, size_type __n,
             [[maybe_unused]] const_void_pointer __hint) {

      return __a.allocate(__n);
    }
# 514 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
    [[__gnu__::__always_inline__]]
    static constexpr void deallocate(allocator_type &__a, pointer __p,
                                     size_type __n) {
      __a.deallocate(__p, __n);
    }
# 530 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
    template <typename _Up, typename... _Args>
    [[__gnu__::__always_inline__]]
    static constexpr void construct(
        allocator_type &__a __attribute__((__unused__)), _Up *__p,
        _Args
            &&...__args) noexcept(std::is_nothrow_constructible<_Up, _Args...>::
                                      value) {

      std::construct_at(__p, std::forward<_Args>(__args)...);
    }
# 551 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
    template <typename _Up>
    [[__gnu__::__always_inline__]]
    static constexpr void
    destroy(allocator_type &__a __attribute__((__unused__)),
            _Up *__p) noexcept(is_nothrow_destructible<_Up>::value) {

      std::destroy_at(__p);
    }

    [[__gnu__::__always_inline__]]
    static constexpr size_type max_size(const allocator_type &__a
                                        __attribute__((__unused__))) noexcept {

      return size_t(-1) / sizeof(value_type);
    }

    [[__gnu__::__always_inline__]]
    static constexpr allocator_type
    select_on_container_copy_construction(const allocator_type &__rhs) {
      return __rhs;
    }
  };

  template <> struct allocator_traits<allocator<void>> {

    using allocator_type = allocator<void>;

    using value_type = void;

    using pointer = void *;

    using const_pointer = const void *;

    using void_pointer = void *;

    using const_void_pointer = const void *;

    using difference_type = std::ptrdiff_t;

    using size_type = std::size_t;

    using propagate_on_container_copy_assignment = false_type;

    using propagate_on_container_move_assignment = true_type;

    using propagate_on_container_swap = false_type;

    using is_always_equal = true_type;

    template <typename _Up> using rebind_alloc = allocator<_Up>;

    template <typename _Up>
    using rebind_traits = allocator_traits<allocator<_Up>>;

    static void *allocate(allocator_type &, size_type,
                          const void * = nullptr) = delete;

    static void deallocate(allocator_type &, void *, size_type) = delete;
# 656 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
    template <typename _Up, typename... _Args>
    [[__gnu__::__always_inline__]]
    static constexpr void
    construct(allocator_type &, _Up *__p, _Args &&...__args) noexcept(
        std::is_nothrow_constructible<_Up, _Args...>::value) {
      std::_Construct(__p, std::forward<_Args>(__args)...);
    }
# 670 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
    template <typename _Up>
    [[__gnu__::__always_inline__]]
    static constexpr void
    destroy(allocator_type &,
            _Up *__p) noexcept(is_nothrow_destructible<_Up>::value) {
      std::_Destroy(__p);
    }

    static size_type max_size(const allocator_type &) = delete;

    [[__gnu__::__always_inline__]]
    static constexpr allocator_type
    select_on_container_copy_construction(const allocator_type &__rhs) {
      return __rhs;
    }
  };
# 708 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
  template <typename _Alloc>
  [[__gnu__::__always_inline__]]
  constexpr inline void __alloc_on_copy(_Alloc & __one, const _Alloc &__two) {
    using __traits = allocator_traits<_Alloc>;
    using __pocca =
        typename __traits::propagate_on_container_copy_assignment::type;

    if constexpr (__pocca::value)
      __one = __two;
  }

  template <typename _Alloc>
  [[__gnu__::__always_inline__]]
  constexpr _Alloc __alloc_on_copy(const _Alloc &__a) {
    typedef allocator_traits<_Alloc> __traits;
    return __traits::select_on_container_copy_construction(__a);
  }
# 745 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
  template <typename _Alloc>
  [[__gnu__::__always_inline__]]
  constexpr inline void __alloc_on_move(_Alloc & __one, _Alloc & __two) {
    using __traits = allocator_traits<_Alloc>;
    using __pocma =
        typename __traits::propagate_on_container_move_assignment::type;

    if constexpr (__pocma::value)
      __one = std::move(__two);
  }
# 776 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
  template <typename _Alloc>
  [[__gnu__::__always_inline__]]
  constexpr inline void __alloc_on_swap(_Alloc & __one, _Alloc & __two) {
    using __traits = allocator_traits<_Alloc>;
    using __pocs = typename __traits::propagate_on_container_swap::type;

    if constexpr (__pocs::value) {
      using std::swap;
      swap(__one, __two);
    }
  }

  template <typename _Alloc, typename _Tp,
            typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
            typename = void>
  struct __is_alloc_insertable_impl : false_type {};

  template <typename _Alloc, typename _Tp, typename _ValueT>
  struct __is_alloc_insertable_impl<
      _Alloc, _Tp, _ValueT,
      __void_t<decltype(allocator_traits<_Alloc>::construct(
          std::declval<_Alloc &>(), std::declval<_ValueT *>(),
          std::declval<_Tp>()))>> : true_type {};

  template <typename _Alloc>
  struct __is_copy_insertable
      : __is_alloc_insertable_impl<_Alloc,
                                   typename _Alloc::value_type const &>::type {
  };

  template <typename _Tp>
  struct __is_copy_insertable<allocator<_Tp>> : is_copy_constructible<_Tp> {};

  template <typename _Alloc>
  struct __is_move_insertable
      : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type {
  };

  template <typename _Tp>
  struct __is_move_insertable<allocator<_Tp>> : is_move_constructible<_Tp> {};

  template <typename _Alloc, typename = void>
  struct __is_allocator : false_type {};

  template <typename _Alloc>
  struct __is_allocator<
      _Alloc, __void_t<typename _Alloc::value_type,
                       decltype(std::declval<_Alloc &>().allocate(size_t{}))>>
      : true_type {};

  template <typename _Alloc>
  using _RequireAllocator =
      typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;

  template <typename _Alloc>
  using _RequireNotAllocator =
      typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;

  template <typename _Alloc>
  concept __allocator_like = requires(_Alloc &__a) {
    typename _Alloc::value_type;
    __a.deallocate(__a.allocate(1u), 1u);
  };

  template <typename _Alloc, bool = __is_empty(_Alloc)> struct __alloc_swap {
    static void _S_do_it(_Alloc &, _Alloc &) noexcept {}
  };

  template <typename _Alloc> struct __alloc_swap<_Alloc, false> {
    static void _S_do_it(_Alloc &__one, _Alloc &__two) noexcept {

      if (__one != __two)
        swap(__one, __two);
    }
  };

  template <typename _Tp,
            bool = __or_<
                is_copy_constructible<typename _Tp::value_type>,
                is_nothrow_move_constructible<typename _Tp::value_type>>::value>
  struct __shrink_to_fit_aux {
    static bool _S_do_it(_Tp &) noexcept { return false; }
  };

  template <typename _Tp> struct __shrink_to_fit_aux<_Tp, true> {
    constexpr static bool _S_do_it(_Tp &__c) noexcept {

      try {
        _Tp(__make_move_if_noexcept_iterator(__c.begin()),
            __make_move_if_noexcept_iterator(__c.end()), __c.get_allocator())
            .swap(__c);
        return true;
      } catch (...) {
        return false;
      }
    }
  };
# 926 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/alloc_traits.h" 3
  template <typename _ForwardIterator, typename _Allocator>
  constexpr void _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                          _Allocator & __alloc) {
    for (; __first != __last; ++__first)

      allocator_traits<_Allocator>::destroy(__alloc,
                                            std::__addressof(*__first));
  }

  template <typename _ForwardIterator, typename _Tp>
  __attribute__((__always_inline__)) constexpr inline void _Destroy(
      _ForwardIterator __first, _ForwardIterator __last, allocator<_Tp> &) {
    std::_Destroy(__first, __last);
  }

} // namespace std
# 35 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/alloc_traits.h" 2 3

namespace __gnu_cxx __attribute__((__visibility__("default"))) {

  template <typename _Alloc, typename = typename _Alloc::value_type>
  struct __alloc_traits

      : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type &reference;
    typedef const value_type &const_reference;
    using _Base_type::allocate;
    using _Base_type::construct;
    using _Base_type::deallocate;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template <typename _Ptr>
    using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>,
                                            std::__not_<std::is_pointer<_Ptr>>>;

  public:
    template <typename _Ptr, typename... _Args>
    [[__gnu__::__always_inline__]]
    static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
    construct(_Alloc &__a, _Ptr __p, _Args &&...__args) noexcept(
        noexcept(_Base_type::construct(__a, std::__to_address(__p),
                                       std::forward<_Args>(__args)...))) {
      _Base_type::construct(__a, std::__to_address(__p),
                            std::forward<_Args>(__args)...);
    }

    template <typename _Ptr>
    [[__gnu__::__always_inline__]]
    static constexpr std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
    destroy(_Alloc &__a, _Ptr __p) noexcept(
        noexcept(_Base_type::destroy(__a, std::__to_address(__p)))) {
      _Base_type::destroy(__a, std::__to_address(__p));
    }

    [[__gnu__::__always_inline__]]
    static constexpr _Alloc _S_select_on_copy(const _Alloc &__a) {
      return _Base_type::select_on_container_copy_construction(__a);
    }

    [[__gnu__::__always_inline__]]
    static constexpr void _S_on_swap(_Alloc &__a, _Alloc &__b) {
      std::__alloc_on_swap(__a, __b);
    }

    [[__gnu__::__always_inline__]]
    static constexpr bool _S_propagate_on_copy_assign() {
      return _Base_type::propagate_on_container_copy_assignment::value;
    }

    [[__gnu__::__always_inline__]]
    static constexpr bool _S_propagate_on_move_assign() {
      return _Base_type::propagate_on_container_move_assignment::value;
    }

    [[__gnu__::__always_inline__]]
    static constexpr bool _S_propagate_on_swap() {
      return _Base_type::propagate_on_container_swap::value;
    }

    [[__gnu__::__always_inline__]]
    static constexpr bool _S_always_equal() {
      return _Base_type::is_always_equal::value;
    }

    __attribute__((__always_inline__)) static constexpr bool _S_nothrow_move() {
      return _S_propagate_on_move_assign() || _S_always_equal();
    }

    template <typename _Tp> struct rebind {
      typedef typename _Base_type::template rebind_alloc<_Tp> other;
    };
# 180 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/alloc_traits.h" 3
  };

} // namespace __gnu_cxx
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string_view" 1 3
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string_view" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/functional_hash.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/functional_hash.h" 3

namespace std __attribute__((__visibility__("default"))) {
# 50 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/functional_hash.h" 3
  template <typename _Result, typename _Arg> struct __hash_base {
    typedef _Result result_type [[__deprecated__]];
    typedef _Arg argument_type [[__deprecated__]];
  };

  template <typename _Tp> struct hash;

  template <typename _Tp, typename = void> struct __poison_hash {
    static constexpr bool __enable_hash_call = false;

  private:
    __poison_hash(__poison_hash &&);
    ~__poison_hash();
  };

  template <typename _Tp>
  struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>> {
    static constexpr bool __enable_hash_call = true;
  };

  template <typename _Tp, bool = is_enum<_Tp>::value> struct __hash_enum {
  private:
    __hash_enum(__hash_enum &&);
    ~__hash_enum();
  };

  template <typename _Tp>
  struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp> {
    size_t operator()(_Tp __val) const noexcept {
      using __type = typename underlying_type<_Tp>::type;
      return hash<__type>{}(static_cast<__type>(__val));
    }
  };

  template <typename _Tp> struct hash : __hash_enum<_Tp> {};

  template <typename _Tp>
  struct hash<_Tp *> : public __hash_base<size_t, _Tp *> {
    size_t operator()(_Tp *__p) const noexcept {
      return reinterpret_cast<size_t>(__p);
    }
  };
# 125 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/functional_hash.h" 3
  template <> struct hash<bool> : public __hash_base<size_t, bool> {
    size_t operator()(bool __val) const noexcept {
      return static_cast<size_t>(__val);
    }
  };

  template <> struct hash<char> : public __hash_base<size_t, char> {
    size_t operator()(char __val) const noexcept {
      return static_cast<size_t>(__val);
    }
  };

  template <>
  struct hash<signed char> : public __hash_base<size_t, signed char> {
    size_t operator()(signed char __val) const noexcept {
      return static_cast<size_t>(__val);
    }
  };

  template <>
  struct hash<unsigned char> : public __hash_base<size_t, unsigned char> {
    size_t operator()(unsigned char __val) const noexcept {
      return static_cast<size_t>(__val);
    }
  };

  template <> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> {
    size_t operator()(wchar_t __val) const noexcept {
      return static_cast<size_t>(__val);
    }
  };

  template <> struct hash<char8_t> : public __hash_base<size_t, char8_t> {
    size_t operator()(char8_t __val) const noexcept {
      return static_cast<size_t>(__val);
    }
  };

  template <> struct hash<char16_t> : public __hash_base<size_t, char16_t> {
    size_t operator()(char16_t __val) const noexcept {
      return static_cast<size_t>(__val);
    }
  };

  template <> struct hash<char32_t> : public __hash_base<size_t, char32_t> {
    size_t operator()(char32_t __val) const noexcept {
      return static_cast<size_t>(__val);
    }
  };

  template <> struct hash<short> : public __hash_base<size_t, short> {
    size_t operator()(short __val) const noexcept {
      return static_cast<size_t>(__val);
    }
  };

  template <> struct hash<int> : public __hash_base<size_t, int> {
    size_t operator()(int __val) const noexcept {
      return static_cast<size_t>(__val);
    }
  };

  template <> struct hash<long> : public __hash_base<size_t, long> {
    size_t operator()(long __val) const noexcept {
      return static_cast<size_t>(__val);
    }
  };

  template <> struct hash<long long> : public __hash_base<size_t, long long> {
    size_t operator()(long long __val) const noexcept {
      return static_cast<size_t>(__val);
    }
  };

  template <>
  struct hash<unsigned short> : public __hash_base<size_t, unsigned short> {
    size_t operator()(unsigned short __val) const noexcept {
      return static_cast<size_t>(__val);
    }
  };

  template <>
  struct hash<unsigned int> : public __hash_base<size_t, unsigned int> {
    size_t operator()(unsigned int __val) const noexcept {
      return static_cast<size_t>(__val);
    }
  };

  template <>
  struct hash<unsigned long> : public __hash_base<size_t, unsigned long> {
    size_t operator()(unsigned long __val) const noexcept {
      return static_cast<size_t>(__val);
    }
  };

  template <>
  struct hash<unsigned long long>
      : public __hash_base<size_t, unsigned long long> {
    size_t operator()(unsigned long long __val) const noexcept {
      return static_cast<size_t>(__val);
    }
  };
# 201 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/functional_hash.h" 3
  struct _Hash_impl {
    static size_t hash(const void *__ptr, size_t __clength,
                       size_t __seed = static_cast<size_t>(0xc70f6907UL)) {
      return _Hash_bytes(__ptr, __clength, __seed);
    }

    template <typename _Tp> static size_t hash(const _Tp &__val) {
      return hash(&__val, sizeof(__val));
    }

    template <typename _Tp>
    static size_t __hash_combine(const _Tp &__val, size_t __hash) {
      return hash(&__val, sizeof(__val), __hash);
    }
  };

  struct _Fnv_hash_impl {
    static size_t hash(const void *__ptr, size_t __clength,
                       size_t __seed = static_cast<size_t>(2166136261UL)) {
      return _Fnv_hash_bytes(__ptr, __clength, __seed);
    }

    template <typename _Tp> static size_t hash(const _Tp &__val) {
      return hash(&__val, sizeof(__val));
    }

    template <typename _Tp>
    static size_t __hash_combine(const _Tp &__val, size_t __hash) {
      return hash(&__val, sizeof(__val), __hash);
    }
  };

  template <> struct hash<float> : public __hash_base<size_t, float> {
    size_t operator()(float __val) const noexcept {

      return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
    }
  };

  template <> struct hash<double> : public __hash_base<size_t, double> {
    size_t operator()(double __val) const noexcept {

      return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
    }
  };

  template <>
  struct hash<long double> : public __hash_base<size_t, long double> {
    __attribute__((__pure__)) size_t
    operator()(long double __val) const noexcept;
  };

  template <> struct hash<nullptr_t> : public __hash_base<size_t, nullptr_t> {
    size_t operator()(nullptr_t) const noexcept { return 0; }
  };
# 294 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/functional_hash.h" 3
  template <typename _Hash> struct __is_fast_hash : public std::true_type {};

  template <>
  struct __is_fast_hash<hash<long double>> : public std::false_type {};

} // namespace std
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string_view" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_base.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_base.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/max_size_type.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/max_size_type.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numbers" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numbers" 3

namespace std __attribute__((__visibility__("default"))) {
# 48 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numbers" 3
  namespace numbers {

  template <typename _Tp>
  using _Enable_if_floating = enable_if_t<is_floating_point_v<_Tp>, _Tp>;

  template <typename _Tp>
  inline constexpr _Tp e_v =
      _Enable_if_floating<_Tp>(2.718281828459045235360287471352662498L);

  template <typename _Tp>
  inline constexpr _Tp log2e_v =
      _Enable_if_floating<_Tp>(1.442695040888963407359924681001892137L);

  template <typename _Tp>
  inline constexpr _Tp log10e_v =
      _Enable_if_floating<_Tp>(0.434294481903251827651128918916605082L);

  template <typename _Tp>
  inline constexpr _Tp pi_v =
      _Enable_if_floating<_Tp>(3.141592653589793238462643383279502884L);

  template <typename _Tp>
  inline constexpr _Tp inv_pi_v =
      _Enable_if_floating<_Tp>(0.318309886183790671537767526745028724L);

  template <typename _Tp>
  inline constexpr _Tp inv_sqrtpi_v =
      _Enable_if_floating<_Tp>(0.564189583547756286948079451560772586L);

  template <typename _Tp>
  inline constexpr _Tp ln2_v =
      _Enable_if_floating<_Tp>(0.693147180559945309417232121458176568L);

  template <typename _Tp>
  inline constexpr _Tp ln10_v =
      _Enable_if_floating<_Tp>(2.302585092994045684017991454684364208L);

  template <typename _Tp>
  inline constexpr _Tp sqrt2_v =
      _Enable_if_floating<_Tp>(1.414213562373095048801688724209698079L);

  template <typename _Tp>
  inline constexpr _Tp sqrt3_v =
      _Enable_if_floating<_Tp>(1.732050807568877293527446341505872367L);

  template <typename _Tp>
  inline constexpr _Tp inv_sqrt3_v =
      _Enable_if_floating<_Tp>(0.577350269189625764509148780501957456L);

  template <typename _Tp>
  inline constexpr _Tp egamma_v =
      _Enable_if_floating<_Tp>(0.577215664901532860606512090082402431L);

  template <typename _Tp>
  inline constexpr _Tp phi_v =
      _Enable_if_floating<_Tp>(1.618033988749894848204586834365638118L);

  inline constexpr double e = e_v<double>;
  inline constexpr double log2e = log2e_v<double>;
  inline constexpr double log10e = log10e_v<double>;
  inline constexpr double pi = pi_v<double>;
  inline constexpr double inv_pi = inv_pi_v<double>;
  inline constexpr double inv_sqrtpi = inv_sqrtpi_v<double>;
  inline constexpr double ln2 = ln2_v<double>;
  inline constexpr double ln10 = ln10_v<double>;
  inline constexpr double sqrt2 = sqrt2_v<double>;
  inline constexpr double sqrt3 = sqrt3_v<double>;
  inline constexpr double inv_sqrt3 = inv_sqrt3_v<double>;
  inline constexpr double egamma = egamma_v<double>;
  inline constexpr double phi = phi_v<double>;
# 228 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numbers" 3
  } // namespace numbers

} // namespace std
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/max_size_type.h" 2 3
# 48 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/max_size_type.h" 3
namespace std __attribute__((__visibility__("default"))) {

  template <typename _Tp> struct numeric_limits;

  namespace ranges {
  namespace __detail {
  class __max_size_type {
  public:
    __max_size_type() = default;

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    constexpr __max_size_type(_Tp __i) noexcept
        : _M_val(__i), _M_msb(__i < 0) {}

    constexpr explicit __max_size_type(const __max_diff_type &__d) noexcept;

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    constexpr explicit operator _Tp() const noexcept {
      return _M_val;
    }

    constexpr explicit operator bool() const noexcept {
      return _M_val != 0 || _M_msb != 0;
    }

    constexpr __max_size_type operator+() const noexcept { return *this; }

    constexpr __max_size_type operator~() const noexcept {
      return __max_size_type{~_M_val, !_M_msb};
    }

    constexpr __max_size_type operator-() const noexcept {
      return operator~() + 1;
    }

    constexpr __max_size_type &operator++() noexcept { return *this += 1; }

    constexpr __max_size_type operator++(int) noexcept {
      auto __tmp = *this;
      ++*this;
      return __tmp;
    }

    constexpr __max_size_type &operator--() noexcept { return *this -= 1; }

    constexpr __max_size_type operator--(int) noexcept {
      auto __tmp = *this;
      --*this;
      return __tmp;
    }

    constexpr __max_size_type &operator+=(const __max_size_type &__r) noexcept {
      const auto __sum = _M_val + __r._M_val;
      const bool __overflow = (__sum < _M_val);
      _M_msb = _M_msb ^ __r._M_msb ^ __overflow;
      _M_val = __sum;
      return *this;
    }

    constexpr __max_size_type &operator-=(const __max_size_type &__r) noexcept {
      return *this += -__r;
    }

    constexpr __max_size_type &operator*=(__max_size_type __r) noexcept {
      constexpr __max_size_type __threshold = __rep(1) << (_S_rep_bits / 2 - 1);
      if (_M_val < __threshold && __r < __threshold)

        _M_val = _M_val * __r._M_val;
      else {

        const bool __lsb = _M_val & 1;
        const bool __rlsb = __r._M_val & 1;
        *this >>= 1;
        __r >>= 1;
        _M_val =
            (2 * _M_val * __r._M_val + _M_val * __rlsb + __r._M_val * __lsb);
        *this <<= 1;
        *this += __rlsb * __lsb;
      }

      return *this;
    }

    constexpr __max_size_type &operator/=(const __max_size_type &__r) noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(__r != 0))
          __builtin_unreachable();
      } while (false);

      if (!_M_msb && !__r._M_msb) [[likely]]
        _M_val /= __r._M_val;
      else if (_M_msb && __r._M_msb) {
        _M_val = (_M_val >= __r._M_val);
        _M_msb = 0;
      } else if (!_M_msb && __r._M_msb)
        _M_val = 0;
      else if (_M_msb && !__r._M_msb) {

        const auto __orig = *this;
        *this >>= 1;
        _M_val /= __r._M_val;
        *this <<= 1;
        if (__orig - *this * __r >= __r)
          ++_M_val;
      }
      return *this;
    }

    constexpr __max_size_type &operator%=(const __max_size_type &__r) noexcept {
      if (!_M_msb && !__r._M_msb) [[likely]]
        _M_val %= __r._M_val;
      else
        *this -= (*this / __r) * __r;
      return *this;
    }

    constexpr __max_size_type &
    operator<<=(const __max_size_type &__r) noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(__r <= _S_rep_bits))
          __builtin_unreachable();
      } while (false);
      if (__r != 0) {
        _M_msb = (_M_val >> (_S_rep_bits - __r._M_val)) & 1;

        if (__r._M_val == _S_rep_bits) [[unlikely]]
          _M_val = 0;
        else
          _M_val <<= __r._M_val;
      }
      return *this;
    }

    constexpr __max_size_type &
    operator>>=(const __max_size_type &__r) noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(__r <= _S_rep_bits))
          __builtin_unreachable();
      } while (false);
      if (__r != 0) {
        if (__r._M_val == _S_rep_bits) [[unlikely]]
          _M_val = 0;
        else
          _M_val >>= __r._M_val;

        if (_M_msb) [[unlikely]] {
          _M_val |= __rep(1) << (_S_rep_bits - __r._M_val);
          _M_msb = 0;
        }
      }
      return *this;
    }

    constexpr __max_size_type &operator&=(const __max_size_type &__r) noexcept {
      _M_val &= __r._M_val;
      _M_msb &= __r._M_msb;
      return *this;
    }

    constexpr __max_size_type &operator|=(const __max_size_type &__r) noexcept {
      _M_val |= __r._M_val;
      _M_msb |= __r._M_msb;
      return *this;
    }

    constexpr __max_size_type &operator^=(const __max_size_type &__r) noexcept {
      _M_val ^= __r._M_val;
      _M_msb ^= __r._M_msb;
      return *this;
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator+=(_Tp &__a,
                                     const __max_size_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a + __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator-=(_Tp &__a,
                                     const __max_size_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a - __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator*=(_Tp &__a,
                                     const __max_size_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a * __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator/=(_Tp &__a,
                                     const __max_size_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a / __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator%=(_Tp &__a,
                                     const __max_size_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a % __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator&=(_Tp &__a,
                                     const __max_size_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a & __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator|=(_Tp &__a,
                                     const __max_size_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a | __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator^=(_Tp &__a,
                                     const __max_size_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a ^ __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator<<=(_Tp &__a,
                                      const __max_size_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a << __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator>>=(_Tp &__a,
                                      const __max_size_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a >> __b));
    }

    friend constexpr __max_size_type
    operator+(__max_size_type __l, const __max_size_type &__r) noexcept {
      __l += __r;
      return __l;
    }

    friend constexpr __max_size_type
    operator-(__max_size_type __l, const __max_size_type &__r) noexcept {
      __l -= __r;
      return __l;
    }

    friend constexpr __max_size_type
    operator*(__max_size_type __l, const __max_size_type &__r) noexcept {
      __l *= __r;
      return __l;
    }

    friend constexpr __max_size_type
    operator/(__max_size_type __l, const __max_size_type &__r) noexcept {
      __l /= __r;
      return __l;
    }

    friend constexpr __max_size_type
    operator%(__max_size_type __l, const __max_size_type &__r) noexcept {
      __l %= __r;
      return __l;
    }

    friend constexpr __max_size_type
    operator<<(__max_size_type __l, const __max_size_type &__r) noexcept {
      __l <<= __r;
      return __l;
    }

    friend constexpr __max_size_type
    operator>>(__max_size_type __l, const __max_size_type &__r) noexcept {
      __l >>= __r;
      return __l;
    }

    friend constexpr __max_size_type
    operator&(__max_size_type __l, const __max_size_type &__r) noexcept {
      __l &= __r;
      return __l;
    }

    friend constexpr __max_size_type
    operator|(__max_size_type __l, const __max_size_type &__r) noexcept {
      __l |= __r;
      return __l;
    }

    friend constexpr __max_size_type
    operator^(__max_size_type __l, const __max_size_type &__r) noexcept {
      __l ^= __r;
      return __l;
    }

    friend constexpr bool operator==(const __max_size_type &__l,
                                     const __max_size_type &__r) noexcept {
      return __l._M_val == __r._M_val && __l._M_msb == __r._M_msb;
    }

    friend constexpr strong_ordering
    operator<=>(const __max_size_type &__l,
                const __max_size_type &__r) noexcept {
      if (__l._M_msb ^ __r._M_msb)
        return __l._M_msb ? strong_ordering::greater : strong_ordering::less;
      else
        return __l._M_val <=> __r._M_val;
    }
# 420 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/max_size_type.h" 3
    __extension__ using __rep = unsigned __int128;

    static constexpr size_t _S_rep_bits = sizeof(__rep) * 8;

  private:
    __rep _M_val = 0;
    unsigned _M_msb : 1 = 0;

    constexpr explicit __max_size_type(__rep __val, int __msb) noexcept
        : _M_val(__val), _M_msb(__msb) {}

    friend __max_diff_type;
    friend std::numeric_limits<__max_size_type>;
    friend std::numeric_limits<__max_diff_type>;
  };

  class __max_diff_type {
  public:
    __max_diff_type() = default;

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    constexpr __max_diff_type(_Tp __i) noexcept : _M_rep(__i) {}

    constexpr explicit __max_diff_type(const __max_size_type &__d) noexcept
        : _M_rep(__d) {}

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    constexpr explicit operator _Tp() const noexcept {
      return static_cast<_Tp>(_M_rep);
    }

    constexpr explicit operator bool() const noexcept { return _M_rep != 0; }

    constexpr __max_diff_type operator+() const noexcept { return *this; }

    constexpr __max_diff_type operator-() const noexcept {
      return __max_diff_type(-_M_rep);
    }

    constexpr __max_diff_type operator~() const noexcept {
      return __max_diff_type(~_M_rep);
    }

    constexpr __max_diff_type &operator++() noexcept { return *this += 1; }

    constexpr __max_diff_type operator++(int) noexcept {
      auto __tmp = *this;
      ++*this;
      return __tmp;
    }

    constexpr __max_diff_type &operator--() noexcept { return *this -= 1; }

    constexpr __max_diff_type operator--(int) noexcept {
      auto __tmp = *this;
      --*this;
      return __tmp;
    }

    constexpr __max_diff_type &operator+=(const __max_diff_type &__r) noexcept {
      _M_rep += __r._M_rep;
      return *this;
    }

    constexpr __max_diff_type &operator-=(const __max_diff_type &__r) noexcept {
      _M_rep -= __r._M_rep;
      return *this;
    }

    constexpr __max_diff_type &operator*=(const __max_diff_type &__r) noexcept {
      _M_rep *= __r._M_rep;
      return *this;
    }

    constexpr __max_diff_type &operator/=(const __max_diff_type &__r) noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(__r != 0))
          __builtin_unreachable();
      } while (false);
      const bool __neg = *this < 0;
      const bool __rneg = __r < 0;
      if (!__neg && !__rneg)
        _M_rep = _M_rep / __r._M_rep;
      else if (__neg && __rneg)
        _M_rep = -_M_rep / -__r._M_rep;
      else if (__neg && !__rneg)
        _M_rep = -(-_M_rep / __r._M_rep);
      else
        _M_rep = -(_M_rep / -__r._M_rep);
      return *this;
    }

    constexpr __max_diff_type &operator%=(const __max_diff_type &__r) noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(__r != 0))
          __builtin_unreachable();
      } while (false);
      if (*this >= 0 && __r > 0)
        _M_rep %= __r._M_rep;
      else
        *this -= (*this / __r) * __r;
      return *this;
    }

    constexpr __max_diff_type &
    operator<<=(const __max_diff_type &__r) noexcept {
      _M_rep.operator<<=(__r._M_rep);
      return *this;
    }

    constexpr __max_diff_type &
    operator>>=(const __max_diff_type &__r) noexcept {

      const auto __msb = _M_rep._M_msb;
      _M_rep >>= __r._M_rep;
      if (__msb)
        _M_rep |= ~(__max_size_type(-1) >> __r._M_rep);
      return *this;
    }

    constexpr __max_diff_type &operator&=(const __max_diff_type &__r) noexcept {
      _M_rep &= __r._M_rep;
      return *this;
    }

    constexpr __max_diff_type &operator|=(const __max_diff_type &__r) noexcept {
      _M_rep |= __r._M_rep;
      return *this;
    }

    constexpr __max_diff_type &operator^=(const __max_diff_type &__r) noexcept {
      _M_rep ^= __r._M_rep;
      return *this;
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator+=(_Tp &__a,
                                     const __max_diff_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a + __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator-=(_Tp &__a,
                                     const __max_diff_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a - __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator*=(_Tp &__a,
                                     const __max_diff_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a * __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator/=(_Tp &__a,
                                     const __max_diff_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a / __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator%=(_Tp &__a,
                                     const __max_diff_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a % __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator&=(_Tp &__a,
                                     const __max_diff_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a & __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator|=(_Tp &__a,
                                     const __max_diff_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a | __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator^=(_Tp &__a,
                                     const __max_diff_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a ^ __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator<<=(_Tp &__a,
                                      const __max_diff_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a << __b));
    }

    template <typename _Tp>
      requires integral<_Tp> || __is_int128<_Tp>
    friend constexpr _Tp &operator>>=(_Tp &__a,
                                      const __max_diff_type &__b) noexcept {
      return (__a = static_cast<_Tp>(__a >> __b));
    }

    friend constexpr __max_diff_type
    operator+(__max_diff_type __l, const __max_diff_type &__r) noexcept {
      __l += __r;
      return __l;
    }

    friend constexpr __max_diff_type
    operator-(__max_diff_type __l, const __max_diff_type &__r) noexcept {
      __l -= __r;
      return __l;
    }

    friend constexpr __max_diff_type
    operator*(__max_diff_type __l, const __max_diff_type &__r) noexcept {
      __l *= __r;
      return __l;
    }

    friend constexpr __max_diff_type
    operator/(__max_diff_type __l, const __max_diff_type &__r) noexcept {
      __l /= __r;
      return __l;
    }

    friend constexpr __max_diff_type
    operator%(__max_diff_type __l, const __max_diff_type &__r) noexcept {
      __l %= __r;
      return __l;
    }

    friend constexpr __max_diff_type
    operator<<(__max_diff_type __l, const __max_diff_type &__r) noexcept {
      __l <<= __r;
      return __l;
    }

    friend constexpr __max_diff_type
    operator>>(__max_diff_type __l, const __max_diff_type &__r) noexcept {
      __l >>= __r;
      return __l;
    }

    friend constexpr __max_diff_type
    operator&(__max_diff_type __l, const __max_diff_type &__r) noexcept {
      __l &= __r;
      return __l;
    }

    friend constexpr __max_diff_type
    operator|(__max_diff_type __l, const __max_diff_type &__r) noexcept {
      __l |= __r;
      return __l;
    }

    friend constexpr __max_diff_type
    operator^(__max_diff_type __l, const __max_diff_type &__r) noexcept {
      __l ^= __r;
      return __l;
    }

    friend constexpr bool operator==(const __max_diff_type &__l,
                                     const __max_diff_type &__r) noexcept {
      return __l._M_rep == __r._M_rep;
    }

    constexpr strong_ordering
    operator<=>(const __max_diff_type &__r) const noexcept {
      const auto __lsign = _M_rep._M_msb;
      const auto __rsign = __r._M_rep._M_msb;
      if (__lsign ^ __rsign)
        return __lsign ? strong_ordering::less : strong_ordering::greater;
      else
        return _M_rep <=> __r._M_rep;
    }
# 753 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/max_size_type.h" 3
  private:
    __max_size_type _M_rep = 0;

    friend class __max_size_type;
  };

  constexpr __max_size_type::__max_size_type(
      const __max_diff_type &__d) noexcept
      : __max_size_type(__d._M_rep) {}

  } // namespace __detail
  } // namespace ranges

  template <> struct numeric_limits<ranges::__detail::__max_size_type> {
    using _Sp = ranges::__detail::__max_size_type;
    static constexpr bool is_specialized = true;
    static constexpr bool is_signed = false;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int digits =
        __gnu_cxx::__int_traits<_Sp::__rep>::__digits + 1;
    static constexpr int digits10 =
        static_cast<int>(digits * numbers::ln2 / numbers::ln10);

    static constexpr _Sp min() noexcept { return 0; }

    static constexpr _Sp max() noexcept {
      return _Sp(static_cast<_Sp::__rep>(-1), 1);
    }

    static constexpr _Sp lowest() noexcept { return min(); }
  };

  template <> struct numeric_limits<ranges::__detail::__max_diff_type> {
    using _Dp = ranges::__detail::__max_diff_type;
    using _Sp = ranges::__detail::__max_size_type;
    static constexpr bool is_specialized = true;
    static constexpr bool is_signed = true;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int digits = numeric_limits<_Sp>::digits - 1;
    static constexpr int digits10 =
        static_cast<int>(digits * numbers::ln2 / numbers::ln10);

    static constexpr _Dp min() noexcept { return _Dp(_Sp(0, 1)); }

    static constexpr _Dp max() noexcept {
      return _Dp(_Sp(static_cast<_Sp::__rep>(-1), 0));
    }

    static constexpr _Dp lowest() noexcept { return min(); }
  };

} // namespace std
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_base.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  namespace ranges {
  template <typename> inline constexpr bool disable_sized_range = false;

  template <typename _Tp> inline constexpr bool enable_borrowed_range = false;

  namespace __detail {
  constexpr __max_size_type __to_unsigned_like(__max_size_type __t) noexcept {
    return __t;
  }

  constexpr __max_size_type __to_unsigned_like(__max_diff_type __t) noexcept {
    return __max_size_type(__t);
  }

  template <integral _Tp> constexpr auto __to_unsigned_like(_Tp __t) noexcept {
    return static_cast<make_unsigned_t<_Tp>>(__t);
  }

  constexpr unsigned __int128 __to_unsigned_like(__int128 __t) noexcept {
    return __t;
  }

  constexpr unsigned __int128
  __to_unsigned_like(unsigned __int128 __t) noexcept {
    return __t;
  }

  template <typename _Tp>
  using __make_unsigned_like_t =
      decltype(__detail::__to_unsigned_like(std::declval<_Tp>()));

  template <typename _Tp>
  concept __maybe_borrowed_range =
      is_lvalue_reference_v<_Tp> || enable_borrowed_range<remove_cvref_t<_Tp>>;

  } // namespace __detail

  namespace __cust_access {
  using std::__detail::__range_iter_t;
  using std::ranges::__detail::__maybe_borrowed_range;

  struct _Begin {
  private:
    template <typename _Tp> static constexpr bool _S_noexcept() {
      if constexpr (is_array_v<remove_reference_t<_Tp>>)
        return true;
      else if constexpr (__member_begin<_Tp>)
        return noexcept(__decay_copy(std::declval<_Tp &>().begin()));
      else
        return noexcept(__decay_copy(begin(std::declval<_Tp &>())));
    }

  public:
    template <__maybe_borrowed_range _Tp>
      requires is_array_v<remove_reference_t<_Tp>> || __member_begin<_Tp> ||
               __adl_begin<_Tp>
    constexpr auto operator() [[nodiscard]] (_Tp &&__t) const
        noexcept(_S_noexcept<_Tp &>()) {
      if constexpr (is_array_v<remove_reference_t<_Tp>>) {
        static_assert(is_lvalue_reference_v<_Tp>);
        return __t + 0;
      } else if constexpr (__member_begin<_Tp>)
        return __t.begin();
      else
        return begin(__t);
    }
  };

  template <typename _Tp>
  concept __member_end = requires(_Tp &__t) {
    { __decay_copy(__t.end()) } -> sentinel_for<__range_iter_t<_Tp>>;
  };

  void end(auto &) = delete;
  void end(const auto &) = delete;

  template <typename _Tp>
  concept __adl_end =
      __class_or_enum<remove_reference_t<_Tp>> && requires(_Tp &__t) {
        { __decay_copy(end(__t)) } -> sentinel_for<__range_iter_t<_Tp>>;
      };

  struct _End {
  private:
    template <typename _Tp> static constexpr bool _S_noexcept() {
      if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)
        return true;
      else if constexpr (__member_end<_Tp>)
        return noexcept(__decay_copy(std::declval<_Tp &>().end()));
      else
        return noexcept(__decay_copy(end(std::declval<_Tp &>())));
    }

  public:
    template <__maybe_borrowed_range _Tp>
      requires is_bounded_array_v<remove_reference_t<_Tp>> ||
               __member_end<_Tp> || __adl_end<_Tp>
    constexpr auto operator() [[nodiscard]] (_Tp &&__t) const
        noexcept(_S_noexcept<_Tp &>()) {
      if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>) {
        static_assert(is_lvalue_reference_v<_Tp>);
        return __t + extent_v<remove_reference_t<_Tp>>;
      } else if constexpr (__member_end<_Tp>)
        return __t.end();
      else
        return end(__t);
    }
  };

  template <typename _Tp>
  concept __member_rbegin = requires(_Tp &__t) {
    { __decay_copy(__t.rbegin()) } -> input_or_output_iterator;
  };

  void rbegin(auto &) = delete;
  void rbegin(const auto &) = delete;

  template <typename _Tp>
  concept __adl_rbegin =
      __class_or_enum<remove_reference_t<_Tp>> && requires(_Tp &__t) {
        { __decay_copy(rbegin(__t)) } -> input_or_output_iterator;
      };

  template <typename _Tp>
  concept __reversable = requires(_Tp &__t) {
    { _Begin{}(__t) } -> bidirectional_iterator;
    { _End{}(__t) } -> same_as<decltype(_Begin{}(__t))>;
  };

  struct _RBegin {
  private:
    template <typename _Tp> static constexpr bool _S_noexcept() {
      if constexpr (__member_rbegin<_Tp>)
        return noexcept(__decay_copy(std::declval<_Tp &>().rbegin()));
      else if constexpr (__adl_rbegin<_Tp>)
        return noexcept(__decay_copy(rbegin(std::declval<_Tp &>())));
      else {
        if constexpr (noexcept(_End{}(std::declval<_Tp &>()))) {
          using _It = decltype(_End{}(std::declval<_Tp &>()));

          return is_nothrow_copy_constructible_v<_It>;
        } else
          return false;
      }
    }

  public:
    template <__maybe_borrowed_range _Tp>
      requires __member_rbegin<_Tp> || __adl_rbegin<_Tp> || __reversable<_Tp>
    constexpr auto operator() [[nodiscard]] (_Tp &&__t) const
        noexcept(_S_noexcept<_Tp &>()) {
      if constexpr (__member_rbegin<_Tp>)
        return __t.rbegin();
      else if constexpr (__adl_rbegin<_Tp>)
        return rbegin(__t);
      else
        return std::make_reverse_iterator(_End{}(__t));
    }
  };

  template <typename _Tp>
  concept __member_rend = requires(_Tp &__t) {
    {
      __decay_copy(__t.rend())
    } -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>;
  };

  void rend(auto &) = delete;
  void rend(const auto &) = delete;

  template <typename _Tp>
  concept __adl_rend =
      __class_or_enum<remove_reference_t<_Tp>> && requires(_Tp &__t) {
        {
          __decay_copy(rend(__t))
        } -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>;
      };

  struct _REnd {
  private:
    template <typename _Tp> static constexpr bool _S_noexcept() {
      if constexpr (__member_rend<_Tp>)
        return noexcept(__decay_copy(std::declval<_Tp &>().rend()));
      else if constexpr (__adl_rend<_Tp>)
        return noexcept(__decay_copy(rend(std::declval<_Tp &>())));
      else {
        if constexpr (noexcept(_Begin{}(std::declval<_Tp &>()))) {
          using _It = decltype(_Begin{}(std::declval<_Tp &>()));

          return is_nothrow_copy_constructible_v<_It>;
        } else
          return false;
      }
    }

  public:
    template <__maybe_borrowed_range _Tp>
      requires __member_rend<_Tp> || __adl_rend<_Tp> || __reversable<_Tp>
    constexpr auto operator() [[nodiscard]] (_Tp &&__t) const
        noexcept(_S_noexcept<_Tp &>()) {
      if constexpr (__member_rend<_Tp>)
        return __t.rend();
      else if constexpr (__adl_rend<_Tp>)
        return rend(__t);
      else
        return std::make_reverse_iterator(_Begin{}(__t));
    }
  };

  template <typename _Tp>
  concept __member_size =
      !disable_sized_range<remove_cvref_t<_Tp>> && requires(_Tp &__t) {
        { __decay_copy(__t.size()) } -> __detail::__is_integer_like;
      };

  void size(auto &) = delete;
  void size(const auto &) = delete;

  template <typename _Tp>
  concept __adl_size =
      __class_or_enum<remove_reference_t<_Tp>> &&
      !disable_sized_range<remove_cvref_t<_Tp>> && requires(_Tp &__t) {
        { __decay_copy(size(__t)) } -> __detail::__is_integer_like;
      };

  template <typename _Tp>
  concept __sentinel_size = requires(_Tp &__t) {
    requires(!is_unbounded_array_v<remove_reference_t<_Tp>>);

    { _Begin{}(__t) } -> forward_iterator;

    { _End{}(__t) } -> sized_sentinel_for<decltype(_Begin{}(__t))>;

    __detail::__to_unsigned_like(_End{}(__t)-_Begin{}(__t));
  };

  struct _Size {
  private:
    template <typename _Tp> static constexpr bool _S_noexcept() {
      if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)
        return true;
      else if constexpr (__member_size<_Tp>)
        return noexcept(__decay_copy(std::declval<_Tp &>().size()));
      else if constexpr (__adl_size<_Tp>)
        return noexcept(__decay_copy(size(std::declval<_Tp &>())));
      else if constexpr (__sentinel_size<_Tp>)
        return noexcept(_End{}(std::declval<_Tp &>()) -
                        _Begin{}(std::declval<_Tp &>()));
    }

  public:
    template <typename _Tp>
      requires is_bounded_array_v<remove_reference_t<_Tp>> ||
               __member_size<_Tp> || __adl_size<_Tp> || __sentinel_size<_Tp>
    constexpr auto operator() [[nodiscard]] (_Tp &&__t) const
        noexcept(_S_noexcept<_Tp &>()) {
      if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)
        return extent_v<remove_reference_t<_Tp>>;
      else if constexpr (__member_size<_Tp>)
        return __t.size();
      else if constexpr (__adl_size<_Tp>)
        return size(__t);
      else if constexpr (__sentinel_size<_Tp>)
        return __detail::__to_unsigned_like(_End{}(__t)-_Begin{}(__t));
    }
  };

  struct _SSize {

    template <typename _Tp>
      requires requires(_Tp &__t) { _Size{}(__t); }
    constexpr auto operator() [[nodiscard]] (_Tp &&__t) const
        noexcept(noexcept(_Size{}(__t))) {
      auto __size = _Size{}(__t);
      using __size_type = decltype(__size);

      if constexpr (integral<__size_type>) {
        using __gnu_cxx::__int_traits;
        if constexpr (__int_traits<__size_type>::__digits <
                      __int_traits<ptrdiff_t>::__digits)
          return static_cast<ptrdiff_t>(__size);
        else
          return static_cast<make_signed_t<__size_type>>(__size);
      }

      else if constexpr (__detail::__is_int128<__size_type>)
        return static_cast<__int128>(__size);

      else
        return __detail::__max_diff_type(__size);
    }
  };

  template <typename _Tp>
  concept __member_empty = requires(_Tp &__t) { bool(__t.empty()); };

  template <typename _Tp>
  concept __size0_empty = requires(_Tp &__t) { _Size{}(__t) == 0; };

  template <typename _Tp>
  concept __eq_iter_empty = requires(_Tp &__t) {
    requires(!is_unbounded_array_v<remove_reference_t<_Tp>>);

    { _Begin{}(__t) } -> forward_iterator;

    bool(_Begin{}(__t) == _End{}(__t));
  };

  struct _Empty {
  private:
    template <typename _Tp> static constexpr bool _S_noexcept() {
      if constexpr (__member_empty<_Tp>)
        return noexcept(bool(std::declval<_Tp &>().empty()));
      else if constexpr (__size0_empty<_Tp>)
        return noexcept(_Size{}(std::declval<_Tp &>()) == 0);
      else
        return noexcept(bool(_Begin{}(std::declval<_Tp &>()) ==
                             _End{}(std::declval<_Tp &>())));
    }

  public:
    template <typename _Tp>
      requires __member_empty<_Tp> || __size0_empty<_Tp> || __eq_iter_empty<_Tp>
    constexpr bool operator() [[nodiscard]] (_Tp &&__t) const
        noexcept(_S_noexcept<_Tp &>()) {
      if constexpr (__member_empty<_Tp>)
        return bool(__t.empty());
      else if constexpr (__size0_empty<_Tp>)
        return _Size{}(__t) == 0;
      else
        return bool(_Begin{}(__t) == _End{}(__t));
    }
  };

  template <typename _Tp>
  concept __pointer_to_object =
      is_pointer_v<_Tp> && is_object_v<remove_pointer_t<_Tp>>;

  template <typename _Tp>
  concept __member_data = requires(_Tp &__t) {
    { __decay_copy(__t.data()) } -> __pointer_to_object;
  };

  template <typename _Tp>
  concept __begin_data = contiguous_iterator<__range_iter_t<_Tp>>;

  struct _Data {
  private:
    template <typename _Tp> static constexpr bool _S_noexcept() {
      if constexpr (__member_data<_Tp>)
        return noexcept(__decay_copy(std::declval<_Tp &>().data()));
      else
        return noexcept(_Begin{}(std::declval<_Tp &>()));
    }

  public:
    template <__maybe_borrowed_range _Tp>
      requires __member_data<_Tp> || __begin_data<_Tp>
    constexpr auto operator() [[nodiscard]] (_Tp &&__t) const
        noexcept(_S_noexcept<_Tp>()) {
      if constexpr (__member_data<_Tp>)
        return __t.data();
      else
        return std::to_address(_Begin{}(__t));
    }
  };

  } // namespace __cust_access

  inline namespace __cust {
  inline constexpr __cust_access::_Begin begin{};
  inline constexpr __cust_access::_End end{};
  inline constexpr __cust_access::_RBegin rbegin{};
  inline constexpr __cust_access::_REnd rend{};
  inline constexpr __cust_access::_Size size{};
  inline constexpr __cust_access::_SSize ssize{};
  inline constexpr __cust_access::_Empty empty{};
  inline constexpr __cust_access::_Data data{};
  } // namespace __cust

  template <typename _Tp>
  concept range = requires(_Tp &__t) {
    ranges::begin(__t);
    ranges::end(__t);
  };

  template <typename _Tp>
  concept borrowed_range = range<_Tp> && __detail::__maybe_borrowed_range<_Tp>;

  template <typename _Tp> using iterator_t = std::__detail::__range_iter_t<_Tp>;

  template <range _Range>
  using sentinel_t = decltype(ranges::end(std::declval<_Range &>()));
# 529 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_base.h" 3
  template <range _Range>
  using range_difference_t = iter_difference_t<iterator_t<_Range>>;

  template <range _Range>
  using range_value_t = iter_value_t<iterator_t<_Range>>;

  template <range _Range>
  using range_reference_t = iter_reference_t<iterator_t<_Range>>;

  template <range _Range>
  using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<_Range>>;

  template <typename _Tp>
  concept sized_range = range<_Tp> && requires(_Tp &__t) { ranges::size(__t); };

  template <sized_range _Range>
  using range_size_t = decltype(ranges::size(std::declval<_Range &>()));

  template <typename _Derived>
    requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
  class view_interface;

  namespace __detail {
  template <typename _Tp, typename _Up>
    requires(!same_as<_Tp, view_interface<_Up>>)
  void __is_derived_from_view_interface_fn(const _Tp &,
                                           const view_interface<_Up> &);

  template <typename _Tp>
  concept __is_derived_from_view_interface =
      requires(_Tp __t) { __is_derived_from_view_interface_fn(__t, __t); };
  } // namespace __detail

  struct view_base {};

  template <typename _Tp>
  inline constexpr bool enable_view =
      derived_from<_Tp, view_base> ||
      __detail::__is_derived_from_view_interface<_Tp>;

  template <typename _Tp>
  concept view = range<_Tp> && movable<_Tp> && enable_view<_Tp>;

  template <typename _Range, typename _Tp>
  concept output_range =
      range<_Range> && output_iterator<iterator_t<_Range>, _Tp>;

  template <typename _Tp>
  concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;

  template <typename _Tp>
  concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;

  template <typename _Tp>
  concept bidirectional_range =
      forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;

  template <typename _Tp>
  concept random_access_range =
      bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;

  template <typename _Tp>
  concept contiguous_range =
      random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>> &&
      requires(_Tp &__t) {
        { ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>;
      };

  template <typename _Tp>
  concept common_range =
      range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;

  namespace __cust_access {
# 641 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_base.h" 3
  template <typename _To, typename _Tp>
  constexpr decltype(auto) __as_const(_Tp &__t) noexcept {
    static_assert(std::is_same_v<_To &, _Tp &>);

    if constexpr (is_lvalue_reference_v<_To>)
      return const_cast<const _Tp &>(__t);
    else
      return static_cast<const _Tp &&>(__t);
  }

  struct _CBegin {
# 670 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_base.h" 3
    template <typename _Tp>
    [[nodiscard]]
    constexpr auto operator()(_Tp &&__e) const
        noexcept(noexcept(_Begin{}(__cust_access::__as_const<_Tp>(__e))))
      requires requires { _Begin{}(__cust_access::__as_const<_Tp>(__e)); }
    {
      return _Begin{}(__cust_access::__as_const<_Tp>(__e));
    }
  };

  struct _CEnd final {
# 698 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_base.h" 3
    template <typename _Tp>
    [[nodiscard]]
    constexpr auto operator()(_Tp &&__e) const
        noexcept(noexcept(_End{}(__cust_access::__as_const<_Tp>(__e))))
      requires requires { _End{}(__cust_access::__as_const<_Tp>(__e)); }
    {
      return _End{}(__cust_access::__as_const<_Tp>(__e));
    }
  };

  struct _CRBegin {
# 726 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_base.h" 3
    template <typename _Tp>
    [[nodiscard]]
    constexpr auto operator()(_Tp &&__e) const
        noexcept(noexcept(_RBegin{}(__cust_access::__as_const<_Tp>(__e))))
      requires requires { _RBegin{}(__cust_access::__as_const<_Tp>(__e)); }
    {
      return _RBegin{}(__cust_access::__as_const<_Tp>(__e));
    }
  };

  struct _CREnd {
# 754 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_base.h" 3
    template <typename _Tp>
    [[nodiscard]]
    constexpr auto operator()(_Tp &&__e) const
        noexcept(noexcept(_REnd{}(__cust_access::__as_const<_Tp>(__e))))
      requires requires { _REnd{}(__cust_access::__as_const<_Tp>(__e)); }
    {
      return _REnd{}(__cust_access::__as_const<_Tp>(__e));
    }
  };

  struct _CData {
# 777 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_base.h" 3
    template <typename _Tp>
    [[nodiscard]]
    constexpr auto operator()(_Tp &&__e) const
        noexcept(noexcept(_Data{}(__cust_access::__as_const<_Tp>(__e))))
      requires requires { _Data{}(__cust_access::__as_const<_Tp>(__e)); }
    {
      return _Data{}(__cust_access::__as_const<_Tp>(__e));
    }
  };

  } // namespace __cust_access

  inline namespace __cust {
  inline constexpr __cust_access::_CBegin cbegin{};
  inline constexpr __cust_access::_CEnd cend{};
  inline constexpr __cust_access::_CRBegin crbegin{};
  inline constexpr __cust_access::_CREnd crend{};
  inline constexpr __cust_access::_CData cdata{};
  } // namespace __cust

  namespace __detail {
  template <typename _Tp> inline constexpr bool __is_initializer_list = false;

  template <typename _Tp>
  inline constexpr bool __is_initializer_list<initializer_list<_Tp>> = true;
  } // namespace __detail

  template <typename _Tp>
  concept viewable_range =
      range<_Tp> &&
      ((view<remove_cvref_t<_Tp>> &&
        constructible_from<remove_cvref_t<_Tp>, _Tp>) ||
       (!view<remove_cvref_t<_Tp>> &&
        (is_lvalue_reference_v<_Tp> ||
         (movable<remove_reference_t<_Tp>> &&
          !__detail::__is_initializer_list<remove_cvref_t<_Tp>>))));

  struct __advance_fn final {
    template <input_or_output_iterator _It>
    constexpr void operator()(_It &__it, iter_difference_t<_It> __n) const {
      if constexpr (random_access_iterator<_It>)
        __it += __n;
      else if constexpr (bidirectional_iterator<_It>) {
        if (__n > 0) {
          do {
            ++__it;
          } while (--__n);
        } else if (__n < 0) {
          do {
            --__it;
          } while (++__n);
        }
      } else {

        do {
          if (std::__is_constant_evaluated() && !bool(__n >= 0))
            __builtin_unreachable();
        } while (false);
        while (__n-- > 0)
          ++__it;
      }
    }

    template <input_or_output_iterator _It, sentinel_for<_It> _Sent>
    constexpr void operator()(_It &__it, _Sent __bound) const {
      if constexpr (assignable_from<_It &, _Sent>)
        __it = std::move(__bound);
      else if constexpr (sized_sentinel_for<_Sent, _It>)
        (*this)(__it, __bound - __it);
      else {
        while (__it != __bound)
          ++__it;
      }
    }

    template <input_or_output_iterator _It, sentinel_for<_It> _Sent>
    constexpr iter_difference_t<_It>
    operator()(_It &__it, iter_difference_t<_It> __n, _Sent __bound) const {
      if constexpr (sized_sentinel_for<_Sent, _It>) {
        const auto __diff = __bound - __it;

        if (__diff == 0)
          return __n;
        else if (__diff > 0 ? __n >= __diff : __n <= __diff) {
          (*this)(__it, __bound);
          return __n - __diff;
        } else if (__n != 0) [[likely]] {

          do {
            if (std::__is_constant_evaluated() &&
                !bool((__n < 0) == (__diff < 0)))
              __builtin_unreachable();
          } while (false);

          (*this)(__it, __n);
          return 0;
        } else
          return 0;
      } else if (__it == __bound || __n == 0)
        return __n;
      else if (__n > 0) {
        iter_difference_t<_It> __m = 0;
        do {
          ++__it;
          ++__m;
        } while (__m != __n && __it != __bound);
        return __n - __m;
      } else if constexpr (bidirectional_iterator<_It> && same_as<_It, _Sent>) {
        iter_difference_t<_It> __m = 0;
        do {
          --__it;
          --__m;
        } while (__m != __n && __it != __bound);
        return __n - __m;
      } else {

        do {
          if (std::__is_constant_evaluated() && !bool(__n >= 0))
            __builtin_unreachable();
        } while (false);
        return __n;
      }
    }

    void operator&() const = delete;
  };

  inline constexpr __advance_fn advance{};

  struct __distance_fn final {
    template <input_or_output_iterator _It, sentinel_for<_It> _Sent>
      requires(!sized_sentinel_for<_Sent, _It>)
    constexpr iter_difference_t<_It> operator()
        [[nodiscard]] (_It __first, _Sent __last) const {
      iter_difference_t<_It> __n = 0;
      while (__first != __last) {
        ++__first;
        ++__n;
      }
      return __n;
    }

    template <input_or_output_iterator _It, sized_sentinel_for<_It> _Sent>
    [[nodiscard]]
    constexpr iter_difference_t<_It> operator()(const _It &__first,
                                                const _Sent &__last) const {
      return __last - __first;
    }

    template <range _Range>
    [[nodiscard]]
    constexpr range_difference_t<_Range> operator()(_Range &&__r) const {
      if constexpr (sized_range<_Range>)
        return static_cast<range_difference_t<_Range>>(ranges::size(__r));
      else
        return (*this)(ranges::begin(__r), ranges::end(__r));
    }

    void operator&() const = delete;
  };

  inline constexpr __distance_fn distance{};

  struct __next_fn final {
    template <input_or_output_iterator _It>
    [[nodiscard]]
    constexpr _It operator()(_It __x) const {
      ++__x;
      return __x;
    }

    template <input_or_output_iterator _It>
    [[nodiscard]]
    constexpr _It operator()(_It __x, iter_difference_t<_It> __n) const {
      ranges::advance(__x, __n);
      return __x;
    }

    template <input_or_output_iterator _It, sentinel_for<_It> _Sent>
    [[nodiscard]]
    constexpr _It operator()(_It __x, _Sent __bound) const {
      ranges::advance(__x, __bound);
      return __x;
    }

    template <input_or_output_iterator _It, sentinel_for<_It> _Sent>
    [[nodiscard]]
    constexpr _It operator()(_It __x, iter_difference_t<_It> __n,
                             _Sent __bound) const {
      ranges::advance(__x, __n, __bound);
      return __x;
    }

    void operator&() const = delete;
  };

  inline constexpr __next_fn next{};

  struct __prev_fn final {
    template <bidirectional_iterator _It>
    [[nodiscard]]
    constexpr _It operator()(_It __x) const {
      --__x;
      return __x;
    }

    template <bidirectional_iterator _It>
    [[nodiscard]]
    constexpr _It operator()(_It __x, iter_difference_t<_It> __n) const {
      ranges::advance(__x, -__n);
      return __x;
    }

    template <bidirectional_iterator _It>
    [[nodiscard]]
    constexpr _It operator()(_It __x, iter_difference_t<_It> __n,
                             _It __bound) const {
      ranges::advance(__x, -__n, __bound);
      return __x;
    }

    void operator&() const = delete;
  };

  inline constexpr __prev_fn prev{};

  struct dangling {
    constexpr dangling() noexcept = default;
    template <typename... _Args> constexpr dangling(_Args &&...) noexcept {}
  };

  template <range _Range>
  using borrowed_iterator_t =
      __conditional_t<borrowed_range<_Range>, iterator_t<_Range>, dangling>;

  } // namespace ranges

} // namespace std
# 49 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string_view" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 69 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string_view" 3
  constexpr size_t __sv_check(size_t __size, size_t __pos, const char *__s) {
    if (__pos > __size)
      __throw_out_of_range_fmt(("%s: __pos (which is %zu) > __size "
                                "(which is %zu)"),
                               __s, __pos, __size);

    return __pos;
  }

  constexpr size_t __sv_limit(size_t __size, size_t __pos,
                              size_t __off) noexcept {
    const bool __testoff = __off < __size - __pos;
    return __testoff ? __off : __size - __pos;
  }
# 105 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string_view" 3
  template <typename _CharT, typename _Traits = std::char_traits<_CharT>>
  class basic_string_view {
    static_assert(!is_array_v<_CharT>);
    static_assert(is_trivial_v<_CharT> && is_standard_layout_v<_CharT>);
    static_assert(is_same_v<_CharT, typename _Traits::char_type>);

  public:
    using traits_type = _Traits;
    using value_type = _CharT;
    using pointer = value_type *;
    using const_pointer = const value_type *;
    using reference = value_type &;
    using const_reference = const value_type &;
    using const_iterator = const value_type *;
    using iterator = const_iterator;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    using reverse_iterator = const_reverse_iterator;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    static constexpr size_type npos = size_type(-1);

    constexpr basic_string_view() noexcept : _M_len{0}, _M_str{nullptr} {}

    constexpr basic_string_view(const basic_string_view &) noexcept = default;

    [[__gnu__::__nonnull__]]
    constexpr basic_string_view(const _CharT *__str) noexcept
        : _M_len{traits_type::length(__str)}, _M_str{__str} {}

    constexpr basic_string_view(const _CharT *__str, size_type __len) noexcept
        : _M_len{__len}, _M_str{__str} {}

    template <contiguous_iterator _It, sized_sentinel_for<_It> _End>
      requires same_as<iter_value_t<_It>, _CharT> &&
                   (!convertible_to<_End, size_type>)
    constexpr basic_string_view(_It __first,
                                _End __last) noexcept(noexcept(__last -
                                                               __first))
        : _M_len(__last - __first), _M_str(std::to_address(__first)) {}
# 180 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string_view" 3
    constexpr basic_string_view &
    operator=(const basic_string_view &) noexcept = default;

    [[nodiscard]]
    constexpr const_iterator begin() const noexcept {
      return this->_M_str;
    }

    [[nodiscard]]
    constexpr const_iterator end() const noexcept {
      return this->_M_str + this->_M_len;
    }

    [[nodiscard]]
    constexpr const_iterator cbegin() const noexcept {
      return this->_M_str;
    }

    [[nodiscard]]
    constexpr const_iterator cend() const noexcept {
      return this->_M_str + this->_M_len;
    }

    [[nodiscard]]
    constexpr const_reverse_iterator rbegin() const noexcept {
      return const_reverse_iterator(this->end());
    }

    [[nodiscard]]
    constexpr const_reverse_iterator rend() const noexcept {
      return const_reverse_iterator(this->begin());
    }

    [[nodiscard]]
    constexpr const_reverse_iterator crbegin() const noexcept {
      return const_reverse_iterator(this->end());
    }

    [[nodiscard]]
    constexpr const_reverse_iterator crend() const noexcept {
      return const_reverse_iterator(this->begin());
    }

    [[nodiscard]]
    constexpr size_type size() const noexcept {
      return this->_M_len;
    }

    [[nodiscard]]
    constexpr size_type length() const noexcept {
      return _M_len;
    }

    [[nodiscard]]
    constexpr size_type max_size() const noexcept {
      return (npos - sizeof(size_type) - sizeof(void *)) / sizeof(value_type) /
             4;
    }

    [[nodiscard]]
    constexpr bool empty() const noexcept {
      return this->_M_len == 0;
    }

    [[nodiscard]]
    constexpr const_reference operator[](size_type __pos) const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(__pos < this->_M_len))
          __builtin_unreachable();
      } while (false);
      return *(this->_M_str + __pos);
    }

    [[nodiscard]]
    constexpr const_reference at(size_type __pos) const {
      if (__pos >= _M_len)
        __throw_out_of_range_fmt(("basic_string_view::at: __pos "
                                  "(which is %zu) >= this->size() "
                                  "(which is %zu)"),
                                 __pos, this->size());

      return *(this->_M_str + __pos);
    }

    [[nodiscard]]
    constexpr const_reference front() const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(this->_M_len > 0))
          __builtin_unreachable();
      } while (false);
      return *this->_M_str;
    }

    [[nodiscard]]
    constexpr const_reference back() const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(this->_M_len > 0))
          __builtin_unreachable();
      } while (false);
      return *(this->_M_str + this->_M_len - 1);
    }

    [[nodiscard]]
    constexpr const_pointer data() const noexcept {
      return this->_M_str;
    }

    constexpr void remove_prefix(size_type __n) noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(this->_M_len >= __n))
          __builtin_unreachable();
      } while (false);
      this->_M_str += __n;
      this->_M_len -= __n;
    }

    constexpr void remove_suffix(size_type __n) noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(this->_M_len >= __n))
          __builtin_unreachable();
      } while (false);
      this->_M_len -= __n;
    }

    constexpr void swap(basic_string_view &__sv) noexcept {
      auto __tmp = *this;
      *this = __sv;
      __sv = __tmp;
    }

    constexpr size_type copy(_CharT *__str, size_type __n,
                             size_type __pos = 0) const {
      ;
      __pos = std::__sv_check(size(), __pos, "basic_string_view::copy");
      const size_type __rlen = std::min<size_t>(__n, _M_len - __pos);

      traits_type::copy(__str, data() + __pos, __rlen);
      return __rlen;
    }

    [[nodiscard]]
    constexpr basic_string_view substr(size_type __pos = 0,
                                       size_type __n = npos) const
        noexcept(false) {
      __pos = std::__sv_check(size(), __pos, "basic_string_view::substr");
      const size_type __rlen = std::min<size_t>(__n, _M_len - __pos);
      return basic_string_view{_M_str + __pos, __rlen};
    }

    [[nodiscard]]
    constexpr int compare(basic_string_view __str) const noexcept {
      const size_type __rlen = std::min(this->_M_len, __str._M_len);
      int __ret = traits_type::compare(this->_M_str, __str._M_str, __rlen);
      if (__ret == 0)
        __ret = _S_compare(this->_M_len, __str._M_len);
      return __ret;
    }

    [[nodiscard]]
    constexpr int compare(size_type __pos1, size_type __n1,
                          basic_string_view __str) const {
      return this->substr(__pos1, __n1).compare(__str);
    }

    [[nodiscard]]
    constexpr int compare(size_type __pos1, size_type __n1,
                          basic_string_view __str, size_type __pos2,
                          size_type __n2) const {
      return this->substr(__pos1, __n1).compare(__str.substr(__pos2, __n2));
    }

    [[nodiscard, __gnu__::__nonnull__]]
    constexpr int compare(const _CharT *__str) const noexcept {
      return this->compare(basic_string_view{__str});
    }

    [[nodiscard, __gnu__::__nonnull__]]
    constexpr int compare(size_type __pos1, size_type __n1,
                          const _CharT *__str) const {
      return this->substr(__pos1, __n1).compare(basic_string_view{__str});
    }

    [[nodiscard]]
    constexpr int compare(size_type __pos1, size_type __n1, const _CharT *__str,
                          size_type __n2) const noexcept(false) {
      return this->substr(__pos1, __n1).compare(basic_string_view(__str, __n2));
    }

    [[nodiscard]]
    constexpr bool starts_with(basic_string_view __x) const noexcept {
      return this->substr(0, __x.size()) == __x;
    }

    [[nodiscard]]
    constexpr bool starts_with(_CharT __x) const noexcept {
      return !this->empty() && traits_type::eq(this->front(), __x);
    }

    [[nodiscard, __gnu__::__nonnull__]]
    constexpr bool starts_with(const _CharT *__x) const noexcept {
      return this->starts_with(basic_string_view(__x));
    }

    [[nodiscard]]
    constexpr bool ends_with(basic_string_view __x) const noexcept {
      const auto __len = this->size();
      const auto __xlen = __x.size();
      return __len >= __xlen &&
             traits_type::compare(end() - __xlen, __x.data(), __xlen) == 0;
    }

    [[nodiscard]]
    constexpr bool ends_with(_CharT __x) const noexcept {
      return !this->empty() && traits_type::eq(this->back(), __x);
    }

    [[nodiscard, __gnu__::__nonnull__]]
    constexpr bool ends_with(const _CharT *__x) const noexcept {
      return this->ends_with(basic_string_view(__x));
    }
# 446 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string_view" 3
    [[nodiscard]]
    constexpr size_type find(basic_string_view __str,
                             size_type __pos = 0) const noexcept {
      return this->find(__str._M_str, __pos, __str._M_len);
    }

    [[nodiscard]]
    constexpr size_type find(_CharT __c, size_type __pos = 0) const noexcept;

    [[nodiscard]]
    constexpr size_type find(const _CharT *__str, size_type __pos,
                             size_type __n) const noexcept;

    [[nodiscard, __gnu__::__nonnull__]]
    constexpr size_type find(const _CharT *__str,
                             size_type __pos = 0) const noexcept {
      return this->find(__str, __pos, traits_type::length(__str));
    }

    [[nodiscard]]
    constexpr size_type rfind(basic_string_view __str,
                              size_type __pos = npos) const noexcept {
      return this->rfind(__str._M_str, __pos, __str._M_len);
    }

    [[nodiscard]]
    constexpr size_type rfind(_CharT __c,
                              size_type __pos = npos) const noexcept;

    [[nodiscard]]
    constexpr size_type rfind(const _CharT *__str, size_type __pos,
                              size_type __n) const noexcept;

    [[nodiscard, __gnu__::__nonnull__]]
    constexpr size_type rfind(const _CharT *__str,
                              size_type __pos = npos) const noexcept {
      return this->rfind(__str, __pos, traits_type::length(__str));
    }

    [[nodiscard]]
    constexpr size_type find_first_of(basic_string_view __str,
                                      size_type __pos = 0) const noexcept {
      return this->find_first_of(__str._M_str, __pos, __str._M_len);
    }

    [[nodiscard]]
    constexpr size_type find_first_of(_CharT __c,
                                      size_type __pos = 0) const noexcept {
      return this->find(__c, __pos);
    }

    [[nodiscard]]
    constexpr size_type find_first_of(const _CharT *__str, size_type __pos,
                                      size_type __n) const noexcept;

    [[nodiscard, __gnu__::__nonnull__]]
    constexpr size_type find_first_of(const _CharT *__str,
                                      size_type __pos = 0) const noexcept {
      return this->find_first_of(__str, __pos, traits_type::length(__str));
    }

    [[nodiscard]]
    constexpr size_type find_last_of(basic_string_view __str,
                                     size_type __pos = npos) const noexcept {
      return this->find_last_of(__str._M_str, __pos, __str._M_len);
    }

    [[nodiscard]]
    constexpr size_type find_last_of(_CharT __c,
                                     size_type __pos = npos) const noexcept {
      return this->rfind(__c, __pos);
    }

    [[nodiscard]]
    constexpr size_type find_last_of(const _CharT *__str, size_type __pos,
                                     size_type __n) const noexcept;

    [[nodiscard, __gnu__::__nonnull__]]
    constexpr size_type find_last_of(const _CharT *__str,
                                     size_type __pos = npos) const noexcept {
      return this->find_last_of(__str, __pos, traits_type::length(__str));
    }

    [[nodiscard]]
    constexpr size_type find_first_not_of(basic_string_view __str,
                                          size_type __pos = 0) const noexcept {
      return this->find_first_not_of(__str._M_str, __pos, __str._M_len);
    }

    [[nodiscard]]
    constexpr size_type find_first_not_of(_CharT __c,
                                          size_type __pos = 0) const noexcept;

    [[nodiscard]]
    constexpr size_type find_first_not_of(const _CharT *__str, size_type __pos,
                                          size_type __n) const noexcept;

    [[nodiscard, __gnu__::__nonnull__]]
    constexpr size_type find_first_not_of(const _CharT *__str,
                                          size_type __pos = 0) const noexcept {
      return this->find_first_not_of(__str, __pos, traits_type::length(__str));
    }

    [[nodiscard]]
    constexpr size_type
    find_last_not_of(basic_string_view __str,
                     size_type __pos = npos) const noexcept {
      return this->find_last_not_of(__str._M_str, __pos, __str._M_len);
    }

    [[nodiscard]]
    constexpr size_type find_last_not_of(_CharT __c,
                                         size_type __pos = npos) const noexcept;

    [[nodiscard]]
    constexpr size_type find_last_not_of(const _CharT *__str, size_type __pos,
                                         size_type __n) const noexcept;

    [[nodiscard, __gnu__::__nonnull__]]
    constexpr size_type
    find_last_not_of(const _CharT *__str,
                     size_type __pos = npos) const noexcept {
      return this->find_last_not_of(__str, __pos, traits_type::length(__str));
    }

  private:
    static constexpr int _S_compare(size_type __n1, size_type __n2) noexcept {
      using __limits = __gnu_cxx::__int_traits<int>;
      const difference_type __diff = __n1 - __n2;
      if (__diff > __limits::__max)
        return __limits::__max;
      if (__diff < __limits::__min)
        return __limits::__min;
      return static_cast<int>(__diff);
    }

    size_t _M_len;
    const _CharT *_M_str;
  };

  template <contiguous_iterator _It, sized_sentinel_for<_It> _End>
  basic_string_view(_It, _End) -> basic_string_view<iter_value_t<_It>>;
# 606 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string_view" 3
  template <typename _CharT, typename _Traits>
  [[nodiscard]]
  constexpr bool operator==(basic_string_view<_CharT, _Traits> __x,
                            basic_string_view<_CharT, _Traits> __y) noexcept {
    return __x.size() == __y.size() && __x.compare(__y) == 0;
  }

  template <typename _CharT, typename _Traits>
  [[nodiscard]]
  constexpr bool operator==(
      basic_string_view<_CharT, _Traits> __x,
      __type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept {
    return __x.size() == __y.size() && __x.compare(__y) == 0;
  }

  template <typename _CharT, typename _Traits>
  [[nodiscard]]
  constexpr auto operator<=>(basic_string_view<_CharT, _Traits> __x,
                             basic_string_view<_CharT, _Traits> __y) noexcept
      -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0)) {
    return __detail::__char_traits_cmp_cat<_Traits>(__x.compare(__y));
  }

  template <typename _CharT, typename _Traits>
  [[nodiscard]]
  constexpr auto operator<=>(
      basic_string_view<_CharT, _Traits> __x,
      __type_identity_t<basic_string_view<_CharT, _Traits>> __y) noexcept
      -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0)) {
    return __detail::__char_traits_cmp_cat<_Traits>(__x.compare(__y));
  }
# 759 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string_view" 3
  template <typename _CharT, typename _Traits>
  inline basic_ostream<_CharT, _Traits> &operator<<(
      basic_ostream<_CharT, _Traits> &__os,
      basic_string_view<_CharT, _Traits> __str) {
    return __ostream_insert(__os, __str.data(), __str.size());
  }

  using string_view = basic_string_view<char>;
  using wstring_view = basic_string_view<wchar_t>;

  using u8string_view = basic_string_view<char8_t>;

  using u16string_view = basic_string_view<char16_t>;
  using u32string_view = basic_string_view<char32_t>;

  template <typename _Tp> struct hash;

  template <>
  struct hash<string_view> : public __hash_base<size_t, string_view> {
    [[nodiscard]]
    size_t operator()(const string_view &__str) const noexcept {
      return std::_Hash_impl::hash(__str.data(), __str.length());
    }
  };

  template <> struct __is_fast_hash<hash<string_view>> : std::false_type {};

  template <>
  struct hash<wstring_view> : public __hash_base<size_t, wstring_view> {
    [[nodiscard]]
    size_t operator()(const wstring_view &__s) const noexcept {
      return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(wchar_t));
    }
  };

  template <> struct __is_fast_hash<hash<wstring_view>> : std::false_type {};

  template <>
  struct hash<u8string_view> : public __hash_base<size_t, u8string_view> {
    [[nodiscard]]
    size_t operator()(const u8string_view &__str) const noexcept {
      return std::_Hash_impl::hash(__str.data(), __str.length());
    }
  };

  template <> struct __is_fast_hash<hash<u8string_view>> : std::false_type {};

  template <>
  struct hash<u16string_view> : public __hash_base<size_t, u16string_view> {
    [[nodiscard]]
    size_t operator()(const u16string_view &__s) const noexcept {
      return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char16_t));
    }
  };

  template <> struct __is_fast_hash<hash<u16string_view>> : std::false_type {};

  template <>
  struct hash<u32string_view> : public __hash_base<size_t, u32string_view> {
    [[nodiscard]]
    size_t operator()(const u32string_view &__s) const noexcept {
      return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char32_t));
    }
  };

  template <> struct __is_fast_hash<hash<u32string_view>> : std::false_type {};

  inline namespace literals {
  inline namespace string_view_literals {
#pragma GCC diagnostic push

  inline constexpr basic_string_view<char> operator""sv(const char *__str,
                                                        size_t __len) noexcept {
    return basic_string_view<char>{__str, __len};
  }

  inline constexpr basic_string_view<wchar_t>
  operator""sv(const wchar_t *__str, size_t __len) noexcept {
    return basic_string_view<wchar_t>{__str, __len};
  }

  inline constexpr basic_string_view<char8_t>
  operator""sv(const char8_t *__str, size_t __len) noexcept {
    return basic_string_view<char8_t>{__str, __len};
  }

  inline constexpr basic_string_view<char16_t>
  operator""sv(const char16_t *__str, size_t __len) noexcept {
    return basic_string_view<char16_t>{__str, __len};
  }

  inline constexpr basic_string_view<char32_t>
  operator""sv(const char32_t *__str, size_t __len) noexcept {
    return basic_string_view<char32_t>{__str, __len};
  }

#pragma GCC diagnostic pop
  } // namespace string_view_literals
  } // namespace literals

  namespace ranges {

  template <typename _CharT, typename _Traits>
  inline constexpr bool
      enable_borrowed_range<basic_string_view<_CharT, _Traits>> = true;

  template <typename _CharT, typename _Traits>
  inline constexpr bool enable_view<basic_string_view<_CharT, _Traits>> = true;
  } // namespace ranges

} // namespace std

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/string_view.tcc" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/string_view.tcc" 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _CharT, typename _Traits>
  constexpr typename basic_string_view<_CharT, _Traits>::size_type
  basic_string_view<_CharT, _Traits>::find(const _CharT *__str, size_type __pos,
                                           size_type __n) const noexcept {
    ;

    if (__n == 0)
      return __pos <= _M_len ? __pos : npos;
    if (__pos >= _M_len)
      return npos;

    const _CharT __elem0 = __str[0];
    const _CharT *__first = _M_str + __pos;
    const _CharT *const __last = _M_str + _M_len;
    size_type __len = _M_len - __pos;

    while (__len >= __n) {

      __first = traits_type::find(__first, __len - __n + 1, __elem0);
      if (!__first)
        return npos;

      if (traits_type::compare(__first, __str, __n) == 0)
        return __first - _M_str;
      __len = __last - ++__first;
    }
    return npos;
  }

  template <typename _CharT, typename _Traits>
  constexpr typename basic_string_view<_CharT, _Traits>::size_type
  basic_string_view<_CharT, _Traits>::find(_CharT __c, size_type __pos)
      const noexcept {
    size_type __ret = npos;
    if (__pos < this->_M_len) {
      const size_type __n = this->_M_len - __pos;
      const _CharT *__p = traits_type::find(this->_M_str + __pos, __n, __c);
      if (__p)
        __ret = __p - this->_M_str;
    }
    return __ret;
  }

  template <typename _CharT, typename _Traits>
  constexpr typename basic_string_view<_CharT, _Traits>::size_type
  basic_string_view<_CharT, _Traits>::rfind(
      const _CharT *__str, size_type __pos, size_type __n) const noexcept {
    ;

    if (__n <= this->_M_len) {
      __pos = std::min(size_type(this->_M_len - __n), __pos);
      do {
        if (traits_type::compare(this->_M_str + __pos, __str, __n) == 0)
          return __pos;
      } while (__pos-- > 0);
    }
    return npos;
  }

  template <typename _CharT, typename _Traits>
  constexpr typename basic_string_view<_CharT, _Traits>::size_type
  basic_string_view<_CharT, _Traits>::rfind(_CharT __c, size_type __pos)
      const noexcept {
    size_type __size = this->_M_len;
    if (__size > 0) {
      if (--__size > __pos)
        __size = __pos;
      for (++__size; __size-- > 0;)
        if (traits_type::eq(this->_M_str[__size], __c))
          return __size;
    }
    return npos;
  }

  template <typename _CharT, typename _Traits>
  constexpr typename basic_string_view<_CharT, _Traits>::size_type
  basic_string_view<_CharT, _Traits>::find_first_of(
      const _CharT *__str, size_type __pos, size_type __n) const noexcept {
    ;
    for (; __n && __pos < this->_M_len; ++__pos) {
      const _CharT *__p = traits_type::find(__str, __n, this->_M_str[__pos]);
      if (__p)
        return __pos;
    }
    return npos;
  }

  template <typename _CharT, typename _Traits>
  constexpr typename basic_string_view<_CharT, _Traits>::size_type
  basic_string_view<_CharT, _Traits>::find_last_of(
      const _CharT *__str, size_type __pos, size_type __n) const noexcept {
    ;
    size_type __size = this->size();
    if (__size && __n) {
      if (--__size > __pos)
        __size = __pos;
      do {
        if (traits_type::find(__str, __n, this->_M_str[__size]))
          return __size;
      } while (__size-- != 0);
    }
    return npos;
  }

  template <typename _CharT, typename _Traits>
  constexpr typename basic_string_view<_CharT, _Traits>::size_type
  basic_string_view<_CharT, _Traits>::find_first_not_of(
      const _CharT *__str, size_type __pos, size_type __n) const noexcept {
    ;
    for (; __pos < this->_M_len; ++__pos)
      if (!traits_type::find(__str, __n, this->_M_str[__pos]))
        return __pos;
    return npos;
  }

  template <typename _CharT, typename _Traits>
  constexpr typename basic_string_view<_CharT, _Traits>::size_type
  basic_string_view<_CharT, _Traits>::find_first_not_of(
      _CharT __c, size_type __pos) const noexcept {
    for (; __pos < this->_M_len; ++__pos)
      if (!traits_type::eq(this->_M_str[__pos], __c))
        return __pos;
    return npos;
  }

  template <typename _CharT, typename _Traits>
  constexpr typename basic_string_view<_CharT, _Traits>::size_type
  basic_string_view<_CharT, _Traits>::find_last_not_of(
      const _CharT *__str, size_type __pos, size_type __n) const noexcept {
    ;
    size_type __size = this->_M_len;
    if (__size) {
      if (--__size > __pos)
        __size = __pos;
      do {
        if (!traits_type::find(__str, __n, this->_M_str[__size]))
          return __size;
      } while (__size--);
    }
    return npos;
  }

  template <typename _CharT, typename _Traits>
  constexpr typename basic_string_view<_CharT, _Traits>::size_type
  basic_string_view<_CharT, _Traits>::find_last_not_of(
      _CharT __c, size_type __pos) const noexcept {
    size_type __size = this->_M_len;
    if (__size) {
      if (--__size > __pos)
        __size = __pos;
      do {
        if (!traits_type::eq(this->_M_str[__size], __c))
          return __size;
      } while (__size--);
    }
    return npos;
  }

} // namespace std
# 906 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string_view" 2 3
# 48 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  namespace __cxx11 {
# 86 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
  class basic_string {
    typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<
        _CharT>::other _Char_alloc_type;

    typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;

  public:
    typedef _Traits traits_type;
    typedef typename _Traits::char_type value_type;
    typedef _Char_alloc_type allocator_type;
    typedef typename _Alloc_traits::size_type size_type;
    typedef typename _Alloc_traits::difference_type difference_type;
    typedef typename _Alloc_traits::reference reference;
    typedef typename _Alloc_traits::const_reference const_reference;
    typedef typename _Alloc_traits::pointer pointer;
    typedef typename _Alloc_traits::const_pointer const_pointer;
    typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
    typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
        const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;

    static const size_type npos = static_cast<size_type>(-1);

  protected:
    typedef const_iterator __const_iterator;

  private:
    static constexpr pointer _S_allocate(_Char_alloc_type &__a, size_type __n) {
      pointer __p = _Alloc_traits::allocate(__a, __n);

      if constexpr (!is_same_v<_Traits, char_traits<_CharT>>)
        if (std::__is_constant_evaluated())

          for (size_type __i = 0; __i < __n; ++__i)
            std::construct_at(__builtin_addressof(__p[__i]));

      return __p;
    }

    typedef basic_string_view<_CharT, _Traits> __sv_type;

    template <typename _Tp, typename _Res>
    using _If_sv = enable_if_t<
        __and_<is_convertible<const _Tp &, __sv_type>,
               __not_<is_convertible<const _Tp *, const basic_string *>>,
               __not_<is_convertible<const _Tp &, const _CharT *>>>::value,
        _Res>;

    constexpr static __sv_type _S_to_string_view(__sv_type __svt) noexcept {
      return __svt;
    }

    struct __sv_wrapper {
      constexpr explicit __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) {}

      __sv_type _M_sv;
    };

    constexpr explicit basic_string(__sv_wrapper __svw, const _Alloc &__a)
        : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) {}

    struct _Alloc_hider : allocator_type {

      constexpr _Alloc_hider(pointer __dat, const _Alloc &__a)
          : allocator_type(__a), _M_p(__dat) {}

      constexpr _Alloc_hider(pointer __dat, _Alloc &&__a = _Alloc())
          : allocator_type(std::move(__a)), _M_p(__dat) {}

      pointer _M_p;
    };

    _Alloc_hider _M_dataplus;
    size_type _M_string_length;

    enum { _S_local_capacity = 15 / sizeof(_CharT) };

    union {
      _CharT _M_local_buf[_S_local_capacity + 1];
      size_type _M_allocated_capacity;
    };

    constexpr void _M_data(pointer __p) { _M_dataplus._M_p = __p; }

    constexpr void _M_length(size_type __length) {
      _M_string_length = __length;
    }

    constexpr pointer _M_data() const { return _M_dataplus._M_p; }

    constexpr pointer _M_local_data() {

      return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);
    }

    constexpr const_pointer _M_local_data() const {

      return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
    }

    constexpr void _M_capacity(size_type __capacity) {
      _M_allocated_capacity = __capacity;
    }

    constexpr void _M_set_length(size_type __n) {
      _M_length(__n);
      traits_type::assign(_M_data()[__n], _CharT());
    }

    constexpr bool _M_is_local() const {
      if (_M_data() == _M_local_data()) {
        if (_M_string_length > _S_local_capacity)
          __builtin_unreachable();
        return true;
      }
      return false;
    }

    constexpr pointer _M_create(size_type &, size_type);

    constexpr void _M_dispose() {
      if (!_M_is_local())
        _M_destroy(_M_allocated_capacity);
    }

    constexpr void _M_destroy(size_type __size) throw() {
      _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1);
    }
# 316 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _InIterator>
    constexpr void _M_construct(_InIterator __beg, _InIterator __end,
                                std::input_iterator_tag);

    template <typename _FwdIterator>
    constexpr void _M_construct(_FwdIterator __beg, _FwdIterator __end,
                                std::forward_iterator_tag);

    constexpr void _M_construct(size_type __req, _CharT __c);

    constexpr allocator_type &_M_get_allocator() { return _M_dataplus; }

    constexpr const allocator_type &_M_get_allocator() const {
      return _M_dataplus;
    }

    __attribute__((__always_inline__)) constexpr void
    _M_init_local_buf() noexcept {

      if (std::is_constant_evaluated())
        for (size_type __i = 0; __i <= _S_local_capacity; ++__i)
          _M_local_buf[__i] = _CharT();
    }

    __attribute__((__always_inline__)) constexpr pointer
    _M_use_local_data() noexcept {

      _M_init_local_buf();

      return _M_local_data();
    }

  private:
# 384 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr size_type _M_check(size_type __pos, const char *__s) const {
      if (__pos > this->size())
        __throw_out_of_range_fmt(("%s: __pos (which is %zu) > "
                                  "this->size() (which is %zu)"),

                                 __s, __pos, this->size());
      return __pos;
    }

    constexpr void _M_check_length(size_type __n1, size_type __n2,
                                   const char *__s) const {
      if (this->max_size() - (this->size() - __n1) < __n2)
        __throw_length_error((__s));
    }

    constexpr size_type _M_limit(size_type __pos,
                                 size_type __off) const noexcept {
      const bool __testoff = __off < this->size() - __pos;
      return __testoff ? __off : this->size() - __pos;
    }

    bool _M_disjunct(const _CharT *__s) const noexcept {
      return (less<const _CharT *>()(__s, _M_data()) ||
              less<const _CharT *>()(_M_data() + this->size(), __s));
    }

    constexpr static void _S_copy(_CharT *__d, const _CharT *__s,
                                  size_type __n) {
      if (__n == 1)
        traits_type::assign(*__d, *__s);
      else
        traits_type::copy(__d, __s, __n);
    }

    constexpr static void _S_move(_CharT *__d, const _CharT *__s,
                                  size_type __n) {
      if (__n == 1)
        traits_type::assign(*__d, *__s);
      else
        traits_type::move(__d, __s, __n);
    }

    constexpr static void _S_assign(_CharT *__d, size_type __n, _CharT __c) {
      if (__n == 1)
        traits_type::assign(*__d, __c);
      else
        traits_type::assign(__d, __n, __c);
    }

    template <class _Iterator>
    constexpr static void _S_copy_chars(_CharT *__p, _Iterator __k1,
                                        _Iterator __k2) {
      for (; __k1 != __k2; ++__k1, (void)++__p)
        traits_type::assign(*__p, *__k1);
    }

    constexpr static void _S_copy_chars(_CharT *__p, iterator __k1,
                                        iterator __k2) noexcept {
      _S_copy_chars(__p, __k1.base(), __k2.base());
    }

    constexpr static void _S_copy_chars(_CharT *__p, const_iterator __k1,
                                        const_iterator __k2) noexcept {
      _S_copy_chars(__p, __k1.base(), __k2.base());
    }

    constexpr static void _S_copy_chars(_CharT *__p, _CharT *__k1,
                                        _CharT *__k2) noexcept {
      _S_copy(__p, __k1, __k2 - __k1);
    }

    constexpr static void _S_copy_chars(_CharT *__p, const _CharT *__k1,
                                        const _CharT *__k2) noexcept {
      _S_copy(__p, __k1, __k2 - __k1);
    }

    constexpr static int _S_compare(size_type __n1, size_type __n2) noexcept {
      const difference_type __d = difference_type(__n1 - __n2);

      if (__d > __gnu_cxx::__numeric_traits<int>::__max)
        return __gnu_cxx::__numeric_traits<int>::__max;
      else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
        return __gnu_cxx::__numeric_traits<int>::__min;
      else
        return int(__d);
    }

    constexpr void _M_assign(const basic_string &);

    constexpr void _M_mutate(size_type __pos, size_type __len1,
                             const _CharT *__s, size_type __len2);

    constexpr void _M_erase(size_type __pos, size_type __n);

  public:
    constexpr basic_string() noexcept(
        is_nothrow_default_constructible<_Alloc>::value)
        : _M_dataplus(_M_local_data()) {
      _M_init_local_buf();
      _M_set_length(0);
    }

    constexpr explicit basic_string(const _Alloc &__a) noexcept
        : _M_dataplus(_M_local_data(), __a) {
      _M_init_local_buf();
      _M_set_length(0);
    }

    constexpr basic_string(const basic_string &__str)
        : _M_dataplus(_M_local_data(), _Alloc_traits::_S_select_on_copy(
                                           __str._M_get_allocator())) {
      _M_construct(__str._M_data(), __str._M_data() + __str.length(),
                   std::forward_iterator_tag());
    }
# 563 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string(const basic_string &__str, size_type __pos,
                           const _Alloc &__a = _Alloc())
        : _M_dataplus(_M_local_data(), __a) {
      const _CharT *__start =
          __str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
      _M_construct(__start, __start + __str._M_limit(__pos, npos),
                   std::forward_iterator_tag());
    }

    constexpr basic_string(const basic_string &__str, size_type __pos,
                           size_type __n)
        : _M_dataplus(_M_local_data()) {
      const _CharT *__start =
          __str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
      _M_construct(__start, __start + __str._M_limit(__pos, __n),
                   std::forward_iterator_tag());
    }
# 598 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string(const basic_string &__str, size_type __pos,
                           size_type __n, const _Alloc &__a)
        : _M_dataplus(_M_local_data(), __a) {
      const _CharT *__start =
          __str._M_data() + __str._M_check(__pos, "string::string");
      _M_construct(__start, __start + __str._M_limit(__pos, __n),
                   std::forward_iterator_tag());
    }
# 618 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string(const _CharT *__s, size_type __n,
                           const _Alloc &__a = _Alloc())
        : _M_dataplus(_M_local_data(), __a) {

      if (__s == 0 && __n > 0)
        std::__throw_logic_error(("basic_string: "
                                  "construction from null is not valid"));

      _M_construct(__s, __s + __n, std::forward_iterator_tag());
    }
# 638 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename = _RequireAllocator<_Alloc>>

    constexpr basic_string(const _CharT *__s, const _Alloc &__a = _Alloc())
        : _M_dataplus(_M_local_data(), __a) {

      if (__s == 0)
        std::__throw_logic_error(("basic_string: "
                                  "construction from null is not valid"));

      const _CharT *__end = __s + traits_type::length(__s);
      _M_construct(__s, __end, forward_iterator_tag());
    }
# 661 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename = _RequireAllocator<_Alloc>>

    constexpr basic_string(size_type __n, _CharT __c,
                           const _Alloc &__a = _Alloc())
        : _M_dataplus(_M_local_data(), __a) {
      _M_construct(__n, __c);
    }
# 676 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string(basic_string &&__str) noexcept
        : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator())) {
      if (__str._M_is_local()) {
        _M_init_local_buf();
        traits_type::copy(_M_local_buf, __str._M_local_buf, __str.length() + 1);
      } else {
        _M_data(__str._M_data());
        _M_capacity(__str._M_allocated_capacity);
      }

      _M_length(__str.length());
      __str._M_data(__str._M_use_local_data());
      __str._M_set_length(0);
    }

    constexpr basic_string(initializer_list<_CharT> __l,
                           const _Alloc &__a = _Alloc())
        : _M_dataplus(_M_local_data(), __a) {
      _M_construct(__l.begin(), __l.end(), std::forward_iterator_tag());
    }

    constexpr basic_string(const basic_string &__str, const _Alloc &__a)
        : _M_dataplus(_M_local_data(), __a) {
      _M_construct(__str.begin(), __str.end(), std::forward_iterator_tag());
    }

    constexpr basic_string(basic_string &&__str, const _Alloc &__a) noexcept(
        _Alloc_traits::_S_always_equal())
        : _M_dataplus(_M_local_data(), __a) {
      if (__str._M_is_local()) {
        _M_init_local_buf();
        traits_type::copy(_M_local_buf, __str._M_local_buf, __str.length() + 1);
        _M_length(__str.length());
        __str._M_set_length(0);
      } else if (_Alloc_traits::_S_always_equal() ||
                 __str.get_allocator() == __a) {
        _M_data(__str._M_data());
        _M_length(__str.length());
        _M_capacity(__str._M_allocated_capacity);
        __str._M_data(__str._M_use_local_data());
        __str._M_set_length(0);
      } else
        _M_construct(__str.begin(), __str.end(), std::forward_iterator_tag());
    }
# 754 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _InputIterator,
              typename = std::_RequireInputIter<_InputIterator>>

    constexpr basic_string(_InputIterator __beg, _InputIterator __end,
                           const _Alloc &__a = _Alloc())
        : _M_dataplus(_M_local_data(), __a), _M_string_length(0) {

      _M_construct(__beg, __end, std::__iterator_category(__beg));
    }
# 780 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp,
              typename = enable_if_t<is_convertible_v<const _Tp &, __sv_type>>>
    constexpr basic_string(const _Tp &__t, size_type __pos, size_type __n,
                           const _Alloc &__a = _Alloc())
        : basic_string(_S_to_string_view(__t).substr(__pos, __n), __a) {}

    template <typename _Tp, typename = _If_sv<_Tp, void>>
    constexpr explicit basic_string(const _Tp &__t,
                                    const _Alloc &__a = _Alloc())
        : basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) {}

    constexpr ~basic_string() { _M_dispose(); }

    constexpr basic_string &operator=(const basic_string &__str) {
      return this->assign(__str);
    }

    constexpr basic_string &operator=(const _CharT *__s) {
      return this->assign(__s);
    }
# 833 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &operator=(_CharT __c) {
      this->assign(1, __c);
      return *this;
    }
# 851 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &
    operator=(basic_string &&__str) noexcept(_Alloc_traits::_S_nothrow_move()) {
      const bool __equal_allocs =
          _Alloc_traits::_S_always_equal() ||
          _M_get_allocator() == __str._M_get_allocator();
      if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign() &&
          !__equal_allocs) {

        _M_destroy(_M_allocated_capacity);
        _M_data(_M_local_data());
        _M_set_length(0);
      }

      std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

      if (__str._M_is_local()) {

        if (__builtin_expect(std::__addressof(__str) != this, true)) {
          if (__str.size())
            this->_S_copy(_M_data(), __str._M_data(), __str.size());
          _M_set_length(__str.size());
        }
      } else if (_Alloc_traits::_S_propagate_on_move_assign() ||
                 __equal_allocs) {

        pointer __data = nullptr;
        size_type __capacity;
        if (!_M_is_local()) {
          if (__equal_allocs) {

            __data = _M_data();
            __capacity = _M_allocated_capacity;
          } else
            _M_destroy(_M_allocated_capacity);
        }

        _M_data(__str._M_data());
        _M_length(__str.length());
        _M_capacity(__str._M_allocated_capacity);
        if (__data) {
          __str._M_data(__data);
          __str._M_capacity(__capacity);
        } else
          __str._M_data(__str._M_use_local_data());
      } else
        assign(__str);
      __str.clear();
      return *this;
    }

    constexpr basic_string &operator=(initializer_list<_CharT> __l) {
      this->assign(__l.begin(), __l.size());
      return *this;
    }

    template <typename _Tp>
    constexpr _If_sv<_Tp, basic_string &> operator=(const _Tp &__svt) {
      return this->assign(__svt);
    }

    constexpr operator __sv_type() const noexcept {
      return __sv_type(data(), size());
    }

    [[__nodiscard__]] constexpr iterator begin() noexcept {
      return iterator(_M_data());
    }

    [[__nodiscard__]] constexpr const_iterator begin() const noexcept {
      return const_iterator(_M_data());
    }

    [[__nodiscard__]] constexpr iterator end() noexcept {
      return iterator(_M_data() + this->size());
    }

    [[__nodiscard__]] constexpr const_iterator end() const noexcept {
      return const_iterator(_M_data() + this->size());
    }

    [[__nodiscard__]] constexpr reverse_iterator rbegin() noexcept {
      return reverse_iterator(this->end());
    }

    [[__nodiscard__]] constexpr const_reverse_iterator rbegin() const noexcept {
      return const_reverse_iterator(this->end());
    }

    [[__nodiscard__]] constexpr reverse_iterator rend() noexcept {
      return reverse_iterator(this->begin());
    }

    [[__nodiscard__]] constexpr const_reverse_iterator rend() const noexcept {
      return const_reverse_iterator(this->begin());
    }

    [[__nodiscard__]] constexpr const_iterator cbegin() const noexcept {
      return const_iterator(this->_M_data());
    }

    [[__nodiscard__]] constexpr const_iterator cend() const noexcept {
      return const_iterator(this->_M_data() + this->size());
    }

    [[__nodiscard__]] constexpr const_reverse_iterator
    crbegin() const noexcept {
      return const_reverse_iterator(this->end());
    }

    [[__nodiscard__]] constexpr const_reverse_iterator crend() const noexcept {
      return const_reverse_iterator(this->begin());
    }

  public:
    [[__nodiscard__]] constexpr size_type size() const noexcept {
      return _M_string_length;
    }

    [[__nodiscard__]] constexpr size_type length() const noexcept {
      return _M_string_length;
    }

    [[__nodiscard__]] constexpr size_type max_size() const noexcept {
      return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2;
    }
# 1097 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr void resize(size_type __n, _CharT __c);
# 1111 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr void resize(size_type __n) { this->resize(__n, _CharT()); }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

    constexpr void shrink_to_fit() noexcept { reserve(); }
#pragma GCC diagnostic pop
# 1167 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type capacity() const noexcept {
      return _M_is_local() ? size_type(_S_local_capacity)
                           : _M_allocated_capacity;
    }
# 1192 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr void reserve(size_type __res_arg);

    [[deprecated("use shrink_to_fit() instead")]]

    constexpr void reserve();

    constexpr void clear() noexcept { _M_set_length(0); }

    [[__nodiscard__]] constexpr bool empty() const noexcept {
      return this->size() == 0;
    }
# 1234 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr const_reference
    operator[](size_type __pos) const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(__pos <= size()))
          __builtin_unreachable();
      } while (false);
      return _M_data()[__pos];
    }
# 1252 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr reference operator[](size_type __pos) {

      do {
        if (std::__is_constant_evaluated() && !bool(__pos <= size()))
          __builtin_unreachable();
      } while (false);

      ;
      return _M_data()[__pos];
    }
# 1274 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr const_reference at(size_type __n) const {
      if (__n >= this->size())
        __throw_out_of_range_fmt(("basic_string::at: __n "
                                  "(which is %zu) >= this->size() "
                                  "(which is %zu)"),

                                 __n, this->size());
      return _M_data()[__n];
    }
# 1296 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr reference at(size_type __n) {
      if (__n >= size())
        __throw_out_of_range_fmt(("basic_string::at: __n "
                                  "(which is %zu) >= this->size() "
                                  "(which is %zu)"),

                                 __n, this->size());
      return _M_data()[__n];
    }

    [[__nodiscard__]] constexpr reference front() noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(!empty()))
          __builtin_unreachable();
      } while (false);
      return operator[](0);
    }

    [[__nodiscard__]] constexpr const_reference front() const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(!empty()))
          __builtin_unreachable();
      } while (false);
      return operator[](0);
    }

    [[__nodiscard__]] constexpr reference back() noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(!empty()))
          __builtin_unreachable();
      } while (false);
      return operator[](this->size() - 1);
    }

    [[__nodiscard__]] constexpr const_reference back() const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(!empty()))
          __builtin_unreachable();
      } while (false);
      return operator[](this->size() - 1);
    }
# 1364 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &operator+=(const basic_string &__str) {
      return this->append(__str);
    }

    constexpr basic_string &operator+=(const _CharT *__s) {
      return this->append(__s);
    }

    constexpr basic_string &operator+=(_CharT __c) {
      this->push_back(__c);
      return *this;
    }

    constexpr basic_string &operator+=(initializer_list<_CharT> __l) {
      return this->append(__l.begin(), __l.size());
    }
# 1410 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    constexpr _If_sv<_Tp, basic_string &> operator+=(const _Tp &__svt) {
      return this->append(__svt);
    }

    constexpr basic_string &append(const basic_string &__str) {
      return this->append(__str._M_data(), __str.size());
    }
# 1440 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &append(const basic_string &__str, size_type __pos,
                                   size_type __n = npos) {
      return this->append(__str._M_data() +
                              __str._M_check(__pos, "basic_string::append"),
                          __str._M_limit(__pos, __n));
    }

    constexpr basic_string &append(const _CharT *__s, size_type __n) {
      ;
      _M_check_length(size_type(0), __n, "basic_string::append");
      return _M_append(__s, __n);
    }

    constexpr basic_string &append(const _CharT *__s) {
      ;
      const size_type __n = traits_type::length(__s);
      _M_check_length(size_type(0), __n, "basic_string::append");
      return _M_append(__s, __n);
    }
# 1485 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &append(size_type __n, _CharT __c) {
      return _M_replace_aux(this->size(), size_type(0), __n, __c);
    }

    constexpr basic_string &append(initializer_list<_CharT> __l) {
      return this->append(__l.begin(), __l.size());
    }
# 1511 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <class _InputIterator,
              typename = std::_RequireInputIter<_InputIterator>>
    constexpr

        basic_string &
        append(_InputIterator __first, _InputIterator __last) {
      return this->replace(end(), end(), __first, __last);
    }

    template <typename _Tp>
    constexpr _If_sv<_Tp, basic_string &> append(const _Tp &__svt) {
      __sv_type __sv = __svt;
      return this->append(__sv.data(), __sv.size());
    }
# 1543 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    constexpr _If_sv<_Tp, basic_string &>
    append(const _Tp &__svt, size_type __pos, size_type __n = npos) {
      __sv_type __sv = __svt;
      return _M_append(__sv.data() + std::__sv_check(__sv.size(), __pos,
                                                     "basic_string::append"),
                       std::__sv_limit(__sv.size(), __pos, __n));
    }

    constexpr void push_back(_CharT __c) {
      const size_type __size = this->size();
      if (__size + 1 > this->capacity())
        this->_M_mutate(__size, size_type(0), 0, size_type(1));
      traits_type::assign(this->_M_data()[__size], __c);
      this->_M_set_length(__size + 1);
    }

    constexpr basic_string &assign(const basic_string &__str) {

      if (_Alloc_traits::_S_propagate_on_copy_assign()) {
        if (!_Alloc_traits::_S_always_equal() && !_M_is_local() &&
            _M_get_allocator() != __str._M_get_allocator()) {

          if (__str.size() <= _S_local_capacity) {
            _M_destroy(_M_allocated_capacity);
            _M_data(_M_use_local_data());
            _M_set_length(0);
          } else {
            const auto __len = __str.size();
            auto __alloc = __str._M_get_allocator();

            auto __ptr = _S_allocate(__alloc, __len + 1);
            _M_destroy(_M_allocated_capacity);
            _M_data(__ptr);
            _M_capacity(__len);
            _M_set_length(__len);
          }
        }
        std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
      }

      this->_M_assign(__str);
      return *this;
    }
# 1621 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &
    assign(basic_string &&__str) noexcept(_Alloc_traits::_S_nothrow_move()) {

      return *this = std::move(__str);
    }
# 1645 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &assign(const basic_string &__str, size_type __pos,
                                   size_type __n = npos) {
      return _M_replace(size_type(0), this->size(),
                        __str._M_data() +
                            __str._M_check(__pos, "basic_string::assign"),
                        __str._M_limit(__pos, __n));
    }
# 1662 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &assign(const _CharT *__s, size_type __n) {
      ;
      return _M_replace(size_type(0), this->size(), __s, __n);
    }
# 1679 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &assign(const _CharT *__s) {
      ;
      return _M_replace(size_type(0), this->size(), __s,
                        traits_type::length(__s));
    }
# 1697 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &assign(size_type __n, _CharT __c) {
      return _M_replace_aux(size_type(0), this->size(), __n, __c);
    }
# 1711 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <class _InputIterator,
              typename = std::_RequireInputIter<_InputIterator>>
    constexpr

        basic_string &
        assign(_InputIterator __first, _InputIterator __last) {
      return this->replace(begin(), end(), __first, __last);
    }

    constexpr basic_string &assign(initializer_list<_CharT> __l) {
      return this->assign(__l.begin(), __l.size());
    }
# 1739 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    constexpr _If_sv<_Tp, basic_string &> assign(const _Tp &__svt) {
      __sv_type __sv = __svt;
      return this->assign(__sv.data(), __sv.size());
    }
# 1755 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    constexpr _If_sv<_Tp, basic_string &>
    assign(const _Tp &__svt, size_type __pos, size_type __n = npos) {
      __sv_type __sv = __svt;
      return _M_replace(size_type(0), this->size(),
                        __sv.data() + std::__sv_check(__sv.size(), __pos,
                                                      "basic_string::assign"),
                        std::__sv_limit(__sv.size(), __pos, __n));
    }
# 1784 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr iterator insert(const_iterator __p, size_type __n, _CharT __c) {
      ;
      const size_type __pos = __p - begin();
      this->replace(__p, __p, __n, __c);
      return iterator(this->_M_data() + __pos);
    }
# 1827 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <class _InputIterator,
              typename = std::_RequireInputIter<_InputIterator>>
    constexpr iterator insert(const_iterator __p, _InputIterator __beg,
                              _InputIterator __end) {
      ;
      const size_type __pos = __p - begin();
      this->replace(__p, __p, __beg, __end);
      return iterator(this->_M_data() + __pos);
    }
# 1864 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr iterator insert(const_iterator __p,
                              initializer_list<_CharT> __l) {
      return this->insert(__p, __l.begin(), __l.end());
    }
# 1892 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &insert(size_type __pos1,
                                   const basic_string &__str) {
      return this->replace(__pos1, size_type(0), __str._M_data(), __str.size());
    }
# 1916 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &insert(size_type __pos1, const basic_string &__str,
                                   size_type __pos2, size_type __n = npos) {
      return this->replace(__pos1, size_type(0),
                           __str._M_data() +
                               __str._M_check(__pos2, "basic_string::insert"),
                           __str._M_limit(__pos2, __n));
    }
# 1940 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &insert(size_type __pos, const _CharT *__s,
                                   size_type __n) {
      return this->replace(__pos, size_type(0), __s, __n);
    }
# 1960 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &insert(size_type __pos, const _CharT *__s) {
      ;
      return this->replace(__pos, size_type(0), __s, traits_type::length(__s));
    }
# 1985 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &insert(size_type __pos, size_type __n, _CharT __c) {
      return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
                            size_type(0), __n, __c);
    }
# 2004 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr iterator insert(__const_iterator __p, _CharT __c) {
      ;
      const size_type __pos = __p - begin();
      _M_replace_aux(__pos, size_type(0), size_type(1), __c);
      return iterator(_M_data() + __pos);
    }
# 2021 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    constexpr _If_sv<_Tp, basic_string &> insert(size_type __pos,
                                                 const _Tp &__svt) {
      __sv_type __sv = __svt;
      return this->insert(__pos, __sv.data(), __sv.size());
    }
# 2038 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    constexpr _If_sv<_Tp, basic_string &>
    insert(size_type __pos1, const _Tp &__svt, size_type __pos2,
           size_type __n = npos) {
      __sv_type __sv = __svt;
      return this->replace(
          __pos1, size_type(0),
          __sv.data() +
              std::__sv_check(__sv.size(), __pos2, "basic_string::insert"),
          std::__sv_limit(__sv.size(), __pos2, __n));
    }
# 2067 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &erase(size_type __pos = 0, size_type __n = npos) {
      _M_check(__pos, "basic_string::erase");
      if (__n == npos)
        this->_M_set_length(__pos);
      else if (__n != 0)
        this->_M_erase(__pos, _M_limit(__pos, __n));
      return *this;
    }
# 2087 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr iterator erase(__const_iterator __position) {

      ;
      const size_type __pos = __position - begin();
      this->_M_erase(__pos, size_type(1));
      return iterator(_M_data() + __pos);
    }
# 2107 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr iterator erase(__const_iterator __first,
                             __const_iterator __last) {

      ;
      const size_type __pos = __first - begin();
      if (__last == end())
        this->_M_set_length(__pos);
      else
        this->_M_erase(__pos, __last - __first);
      return iterator(this->_M_data() + __pos);
    }

    constexpr void pop_back() noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(!empty()))
          __builtin_unreachable();
      } while (false);
      _M_erase(size() - 1, 1);
    }
# 2153 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &replace(size_type __pos, size_type __n,
                                    const basic_string &__str) {
      return this->replace(__pos, __n, __str._M_data(), __str.size());
    }
# 2176 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &replace(size_type __pos1, size_type __n1,
                                    const basic_string &__str, size_type __pos2,
                                    size_type __n2 = npos) {
      return this->replace(__pos1, __n1,
                           __str._M_data() +
                               __str._M_check(__pos2, "basic_string::replace"),
                           __str._M_limit(__pos2, __n2));
    }
# 2202 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &replace(size_type __pos, size_type __n1,
                                    const _CharT *__s, size_type __n2) {
      ;
      return _M_replace(_M_check(__pos, "basic_string::replace"),
                        _M_limit(__pos, __n1), __s, __n2);
    }
# 2228 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &replace(size_type __pos, size_type __n1,
                                    const _CharT *__s) {
      ;
      return this->replace(__pos, __n1, __s, traits_type::length(__s));
    }
# 2253 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &replace(size_type __pos, size_type __n1,
                                    size_type __n2, _CharT __c) {
      return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
                            _M_limit(__pos, __n1), __n2, __c);
    }
# 2272 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &replace(__const_iterator __i1,
                                    __const_iterator __i2,
                                    const basic_string &__str) {
      return this->replace(__i1, __i2, __str._M_data(), __str.size());
    }
# 2293 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &replace(__const_iterator __i1,
                                    __const_iterator __i2, const _CharT *__s,
                                    size_type __n) {

      ;
      return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
    }
# 2316 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &replace(__const_iterator __i1,
                                    __const_iterator __i2, const _CharT *__s) {
      ;
      return this->replace(__i1, __i2, __s, traits_type::length(__s));
    }
# 2338 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &replace(__const_iterator __i1,
                                    __const_iterator __i2, size_type __n,
                                    _CharT __c) {

      ;
      return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
    }
# 2364 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <class _InputIterator,
              typename = std::_RequireInputIter<_InputIterator>>
    constexpr basic_string &replace(const_iterator __i1, const_iterator __i2,
                                    _InputIterator __k1, _InputIterator __k2) {

      ;
      ;
      return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
                                       std::__false_type());
    }
# 2397 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &replace(__const_iterator __i1,
                                    __const_iterator __i2, _CharT *__k1,
                                    _CharT *__k2) {

      ;
      ;
      return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1);
    }

    constexpr basic_string &replace(__const_iterator __i1,
                                    __const_iterator __i2, const _CharT *__k1,
                                    const _CharT *__k2) {

      ;
      ;
      return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1);
    }

    constexpr basic_string &replace(__const_iterator __i1,
                                    __const_iterator __i2, iterator __k1,
                                    iterator __k2) {

      ;
      ;
      return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(),
                           __k2 - __k1);
    }

    constexpr basic_string &replace(__const_iterator __i1,
                                    __const_iterator __i2, const_iterator __k1,
                                    const_iterator __k2) {

      ;
      ;
      return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(),
                           __k2 - __k1);
    }
# 2460 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr basic_string &replace(const_iterator __i1, const_iterator __i2,
                                    initializer_list<_CharT> __l) {
      return this->replace(__i1, __i2, __l.begin(), __l.size());
    }
# 2474 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    constexpr _If_sv<_Tp, basic_string &>
    replace(size_type __pos, size_type __n, const _Tp &__svt) {
      __sv_type __sv = __svt;
      return this->replace(__pos, __n, __sv.data(), __sv.size());
    }
# 2492 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    constexpr _If_sv<_Tp, basic_string &>
    replace(size_type __pos1, size_type __n1, const _Tp &__svt,
            size_type __pos2, size_type __n2 = npos) {
      __sv_type __sv = __svt;
      return this->replace(
          __pos1, __n1,
          __sv.data() +
              std::__sv_check(__sv.size(), __pos2, "basic_string::replace"),
          std::__sv_limit(__sv.size(), __pos2, __n2));
    }
# 2514 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    constexpr _If_sv<_Tp, basic_string &>
    replace(const_iterator __i1, const_iterator __i2, const _Tp &__svt) {
      __sv_type __sv = __svt;
      return this->replace(__i1 - begin(), __i2 - __i1, __sv);
    }

  private:
    template <class _Integer>
    constexpr basic_string &
    _M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer __n,
                        _Integer __val, __true_type) {
      return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val);
    }

    template <class _InputIterator>
    constexpr basic_string &
    _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
                        _InputIterator __k1, _InputIterator __k2, __false_type);

    constexpr basic_string &_M_replace_aux(size_type __pos1, size_type __n1,
                                           size_type __n2, _CharT __c);

    __attribute__((__noinline__, __noclone__, __cold__)) void
    _M_replace_cold(pointer __p, size_type __len1, const _CharT *__s,
                    const size_type __len2, const size_type __how_much);

    constexpr basic_string &_M_replace(size_type __pos, size_type __len1,
                                       const _CharT *__s,
                                       const size_type __len2);

    constexpr basic_string &_M_append(const _CharT *__s, size_type __n);

  public:
# 2571 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr size_type copy(_CharT *__s, size_type __n,
                             size_type __pos = 0) const;
# 2582 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    constexpr void swap(basic_string &__s) noexcept;
# 2593 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr const _CharT *c_str() const noexcept {
      return _M_data();
    }
# 2606 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr const _CharT *data() const noexcept {
      return _M_data();
    }
# 2618 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr _CharT *data() noexcept { return _M_data(); }

    [[__nodiscard__]] constexpr allocator_type get_allocator() const noexcept {
      return _M_get_allocator();
    }
# 2644 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find(const _CharT *__s, size_type __pos, size_type __n) const noexcept;
# 2659 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find(const basic_string &__str, size_type __pos = 0) const noexcept {
      return this->find(__str.data(), __pos, __str.size());
    }
# 2672 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    [[__nodiscard__]] constexpr _If_sv<_Tp, size_type>
    find(const _Tp &__svt, size_type __pos = 0) const
        noexcept(is_same<_Tp, __sv_type>::value) {
      __sv_type __sv = __svt;
      return this->find(__sv.data(), __pos, __sv.size());
    }
# 2693 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find(const _CharT *__s, size_type __pos = 0) const noexcept {
      ;
      return this->find(__s, __pos, traits_type::length(__s));
    }
# 2711 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find(_CharT __c, size_type __pos = 0) const noexcept;
# 2725 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    rfind(const basic_string &__str, size_type __pos = npos) const noexcept {
      return this->rfind(__str.data(), __pos, __str.size());
    }
# 2738 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    [[__nodiscard__]] constexpr _If_sv<_Tp, size_type>
    rfind(const _Tp &__svt, size_type __pos = npos) const
        noexcept(is_same<_Tp, __sv_type>::value) {
      __sv_type __sv = __svt;
      return this->rfind(__sv.data(), __pos, __sv.size());
    }
# 2761 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    rfind(const _CharT *__s, size_type __pos, size_type __n) const noexcept;
# 2776 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type rfind(const _CharT *__s,
                                                size_type __pos = npos) const {
      ;
      return this->rfind(__s, __pos, traits_type::length(__s));
    }
# 2794 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2809 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find_first_of(const basic_string &__str,
                  size_type __pos = 0) const noexcept {
      return this->find_first_of(__str.data(), __pos, __str.size());
    }
# 2823 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    [[__nodiscard__]] constexpr _If_sv<_Tp, size_type>
    find_first_of(const _Tp &__svt, size_type __pos = 0) const
        noexcept(is_same<_Tp, __sv_type>::value) {
      __sv_type __sv = __svt;
      return this->find_first_of(__sv.data(), __pos, __sv.size());
    }
# 2846 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find_first_of(const _CharT *__s, size_type __pos,
                  size_type __n) const noexcept;
# 2861 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find_first_of(const _CharT *__s, size_type __pos = 0) const noexcept {
      ;
      return this->find_first_of(__s, __pos, traits_type::length(__s));
    }
# 2882 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find_first_of(_CharT __c, size_type __pos = 0) const noexcept {
      return this->find(__c, __pos);
    }
# 2898 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find_last_of(const basic_string &__str,
                 size_type __pos = npos) const noexcept {
      return this->find_last_of(__str.data(), __pos, __str.size());
    }
# 2912 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    [[__nodiscard__]] constexpr _If_sv<_Tp, size_type>
    find_last_of(const _Tp &__svt, size_type __pos = npos) const
        noexcept(is_same<_Tp, __sv_type>::value) {
      __sv_type __sv = __svt;
      return this->find_last_of(__sv.data(), __pos, __sv.size());
    }
# 2935 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find_last_of(const _CharT *__s, size_type __pos,
                 size_type __n) const noexcept;
# 2950 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find_last_of(const _CharT *__s, size_type __pos = npos) const noexcept {
      ;
      return this->find_last_of(__s, __pos, traits_type::length(__s));
    }
# 2971 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find_last_of(_CharT __c, size_type __pos = npos) const noexcept {
      return this->rfind(__c, __pos);
    }
# 2986 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find_first_not_of(const basic_string &__str,
                      size_type __pos = 0) const noexcept {
      return this->find_first_not_of(__str.data(), __pos, __str.size());
    }
# 3000 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    [[__nodiscard__]] constexpr _If_sv<_Tp, size_type>
    find_first_not_of(const _Tp &__svt, size_type __pos = 0) const
        noexcept(is_same<_Tp, __sv_type>::value) {
      __sv_type __sv = __svt;
      return this->find_first_not_of(__sv.data(), __pos, __sv.size());
    }
# 3023 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find_first_not_of(const _CharT *__s, size_type __pos,
                      size_type __n) const noexcept;
# 3038 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find_first_not_of(const _CharT *__s, size_type __pos = 0) const noexcept {
      ;
      return this->find_first_not_of(__s, __pos, traits_type::length(__s));
    }
# 3057 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find_first_not_of(_CharT __c, size_type __pos = 0) const noexcept;
# 3073 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find_last_not_of(const basic_string &__str,
                     size_type __pos = npos) const noexcept {
      return this->find_last_not_of(__str.data(), __pos, __str.size());
    }
# 3087 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    [[__nodiscard__]] constexpr _If_sv<_Tp, size_type>
    find_last_not_of(const _Tp &__svt, size_type __pos = npos) const
        noexcept(is_same<_Tp, __sv_type>::value) {
      __sv_type __sv = __svt;
      return this->find_last_not_of(__sv.data(), __pos, __sv.size());
    }
# 3110 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find_last_not_of(const _CharT *__s, size_type __pos,
                     size_type __n) const noexcept;
# 3125 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find_last_not_of(const _CharT *__s, size_type __pos = npos) const noexcept {
      ;
      return this->find_last_not_of(__s, __pos, traits_type::length(__s));
    }
# 3144 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr size_type
    find_last_not_of(_CharT __c, size_type __pos = npos) const noexcept;
# 3161 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr basic_string
    substr(size_type __pos = 0, size_type __n = npos) const {
      return basic_string(*this, _M_check(__pos, "basic_string::substr"), __n);
    }
# 3181 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr int compare(const basic_string &__str) const {
      const size_type __size = this->size();
      const size_type __osize = __str.size();
      const size_type __len = std::min(__size, __osize);

      int __r = traits_type::compare(_M_data(), __str.data(), __len);
      if (!__r)
        __r = _S_compare(__size, __osize);
      return __r;
    }

    template <typename _Tp>
    [[__nodiscard__]] constexpr _If_sv<_Tp, int> compare(const _Tp &__svt) const
        noexcept(is_same<_Tp, __sv_type>::value) {
      __sv_type __sv = __svt;
      const size_type __size = this->size();
      const size_type __osize = __sv.size();
      const size_type __len = std::min(__size, __osize);

      int __r = traits_type::compare(_M_data(), __sv.data(), __len);
      if (!__r)
        __r = _S_compare(__size, __osize);
      return __r;
    }
# 3226 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    [[__nodiscard__]] constexpr _If_sv<_Tp, int>
    compare(size_type __pos, size_type __n, const _Tp &__svt) const
        noexcept(is_same<_Tp, __sv_type>::value) {
      __sv_type __sv = __svt;
      return __sv_type(*this).substr(__pos, __n).compare(__sv);
    }
# 3246 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename _Tp>
    [[__nodiscard__]] constexpr _If_sv<_Tp, int>
    compare(size_type __pos1, size_type __n1, const _Tp &__svt,
            size_type __pos2, size_type __n2 = npos) const
        noexcept(is_same<_Tp, __sv_type>::value) {
      __sv_type __sv = __svt;
      return __sv_type(*this)
          .substr(__pos1, __n1)
          .compare(__sv.substr(__pos2, __n2));
    }
# 3278 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr int compare(size_type __pos, size_type __n,
                                            const basic_string &__str) const {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
        __r = _S_compare(__n, __osize);
      return __r;
    }
# 3315 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr int compare(size_type __pos1, size_type __n1,
                                            const basic_string &__str,
                                            size_type __pos2,
                                            size_type __n2 = npos) const {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1, __str.data() + __pos2,
                                     __len);
      if (!__r)
        __r = _S_compare(__n1, __n2);
      return __r;
    }
# 3346 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr int compare(const _CharT *__s) const noexcept {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
        __r = _S_compare(__size, __osize);
      return __r;
    }
# 3381 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr int compare(size_type __pos, size_type __n1,
                                            const _CharT *__s) const {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
        __r = _S_compare(__n1, __osize);
      return __r;
    }
# 3420 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    [[__nodiscard__]] constexpr int compare(size_type __pos, size_type __n1,
                                            const _CharT *__s,
                                            size_type __n2) const {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
        __r = _S_compare(__n1, __n2);
      return __r;
    }

    [[nodiscard]]
    constexpr bool
    starts_with(basic_string_view<_CharT, _Traits> __x) const noexcept {
      return __sv_type(this->data(), this->size()).starts_with(__x);
    }

    [[nodiscard]]
    constexpr bool starts_with(_CharT __x) const noexcept {
      return __sv_type(this->data(), this->size()).starts_with(__x);
    }

    [[nodiscard, __gnu__::__nonnull__]]
    constexpr bool starts_with(const _CharT *__x) const noexcept {
      return __sv_type(this->data(), this->size()).starts_with(__x);
    }

    [[nodiscard]]
    constexpr bool
    ends_with(basic_string_view<_CharT, _Traits> __x) const noexcept {
      return __sv_type(this->data(), this->size()).ends_with(__x);
    }

    [[nodiscard]]
    constexpr bool ends_with(_CharT __x) const noexcept {
      return __sv_type(this->data(), this->size()).ends_with(__x);
    }

    [[nodiscard, __gnu__::__nonnull__]]
    constexpr bool ends_with(const _CharT *__x) const noexcept {
      return __sv_type(this->data(), this->size()).ends_with(__x);
    }
# 3485 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
    template <typename, typename, typename> friend class basic_stringbuf;
  };
  } // namespace __cxx11

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

  namespace __cxx11 {
  template <
      typename _InputIterator,
      typename _CharT = typename iterator_traits<_InputIterator>::value_type,
      typename _Allocator = allocator<_CharT>,
      typename = _RequireInputIter<_InputIterator>,
      typename = _RequireAllocator<_Allocator>>
  basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator())
      -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;

  template <typename _CharT, typename _Traits,
            typename _Allocator = allocator<_CharT>,
            typename = _RequireAllocator<_Allocator>>
  basic_string(basic_string_view<_CharT, _Traits>,
               const _Allocator & = _Allocator())
      -> basic_string<_CharT, _Traits, _Allocator>;

  template <typename _CharT, typename _Traits,
            typename _Allocator = allocator<_CharT>,
            typename = _RequireAllocator<_Allocator>>
  basic_string(basic_string_view<_CharT, _Traits>,
               typename basic_string<_CharT, _Traits, _Allocator>::size_type,
               typename basic_string<_CharT, _Traits, _Allocator>::size_type,
               const _Allocator & = _Allocator())
      -> basic_string<_CharT, _Traits, _Allocator>;
  } // namespace __cxx11

  template <typename _Str>
  constexpr inline _Str __str_concat(typename _Str::value_type const *__lhs,
                                     typename _Str::size_type __lhs_len,
                                     typename _Str::value_type const *__rhs,
                                     typename _Str::size_type __rhs_len,
                                     typename _Str::allocator_type const &__a) {
    typedef typename _Str::allocator_type allocator_type;
    typedef __gnu_cxx::__alloc_traits<allocator_type> _Alloc_traits;
    _Str __str(_Alloc_traits::_S_select_on_copy(__a));
    __str.reserve(__lhs_len + __rhs_len);
    __str.append(__lhs, __lhs_len);
    __str.append(__rhs, __rhs_len);
    return __str;
  }
# 3550 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
  [[__nodiscard__]] constexpr inline basic_string<_CharT, _Traits, _Alloc>
  operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs,
            const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
    typedef basic_string<_CharT, _Traits, _Alloc> _Str;
    return std::__str_concat<_Str>(__lhs.c_str(), __lhs.size(), __rhs.c_str(),
                                   __rhs.size(), __lhs.get_allocator());
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  [[__nodiscard__]] constexpr inline basic_string<_CharT, _Traits, _Alloc>
  operator+(const _CharT *__lhs,
            const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
    ;
    typedef basic_string<_CharT, _Traits, _Alloc> _Str;
    return std::__str_concat<_Str>(__lhs, _Traits::length(__lhs), __rhs.c_str(),
                                   __rhs.size(), __rhs.get_allocator());
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  [[__nodiscard__]] constexpr inline basic_string<_CharT, _Traits, _Alloc>
  operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
    typedef basic_string<_CharT, _Traits, _Alloc> _Str;
    return std::__str_concat<_Str>(__builtin_addressof(__lhs), 1, __rhs.c_str(),
                                   __rhs.size(), __rhs.get_allocator());
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  [[__nodiscard__]] constexpr inline basic_string<_CharT, _Traits, _Alloc>
  operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs,
            const _CharT *__rhs) {
    ;
    typedef basic_string<_CharT, _Traits, _Alloc> _Str;
    return std::__str_concat<_Str>(__lhs.c_str(), __lhs.size(), __rhs,
                                   _Traits::length(__rhs),
                                   __lhs.get_allocator());
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  [[__nodiscard__]] constexpr inline basic_string<_CharT, _Traits, _Alloc>
  operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, _CharT __rhs) {
    typedef basic_string<_CharT, _Traits, _Alloc> _Str;
    return std::__str_concat<_Str>(__lhs.c_str(), __lhs.size(),
                                   __builtin_addressof(__rhs), 1,
                                   __lhs.get_allocator());
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  [[__nodiscard__]] constexpr inline basic_string<_CharT, _Traits, _Alloc>
  operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs,
            const basic_string<_CharT, _Traits, _Alloc> &__rhs) {
    return std::move(__lhs.append(__rhs));
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr inline basic_string<_CharT, _Traits, _Alloc> operator+(
      const basic_string<_CharT, _Traits, _Alloc> &__lhs,
      basic_string<_CharT, _Traits, _Alloc> &&__rhs) {
    return std::move(__rhs.insert(0, __lhs));
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  [[__nodiscard__]] constexpr inline basic_string<_CharT, _Traits, _Alloc>
  operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs,
            basic_string<_CharT, _Traits, _Alloc> &&__rhs) {

    using _Alloc_traits = allocator_traits<_Alloc>;
    bool __use_rhs = false;
    if constexpr (typename _Alloc_traits::is_always_equal{})
      __use_rhs = true;
    else if (__lhs.get_allocator() == __rhs.get_allocator())
      __use_rhs = true;
    if (__use_rhs)

    {
      const auto __size = __lhs.size() + __rhs.size();
      if (__size > __lhs.capacity() && __size <= __rhs.capacity())
        return std::move(__rhs.insert(0, __lhs));
    }
    return std::move(__lhs.append(__rhs));
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  [[__nodiscard__]] [[__nodiscard__]] constexpr inline basic_string<
      _CharT, _Traits, _Alloc>
  operator+(const _CharT *__lhs,
            basic_string<_CharT, _Traits, _Alloc> &&__rhs) {
    return std::move(__rhs.insert(0, __lhs));
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  [[__nodiscard__]] constexpr inline basic_string<_CharT, _Traits, _Alloc>
  operator+(_CharT __lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs) {
    return std::move(__rhs.insert(0, 1, __lhs));
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  [[__nodiscard__]] constexpr inline basic_string<_CharT, _Traits, _Alloc>
  operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs,
            const _CharT *__rhs) {
    return std::move(__lhs.append(__rhs));
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  [[__nodiscard__]] constexpr inline basic_string<_CharT, _Traits, _Alloc>
  operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, _CharT __rhs) {
    return std::move(__lhs.append(1, __rhs));
  }
# 3707 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
  [[__nodiscard__]] constexpr inline bool operator==(
      const basic_string<_CharT, _Traits, _Alloc> &__lhs,
      const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept {
    return __lhs.size() == __rhs.size() &&
           !_Traits::compare(__lhs.data(), __rhs.data(), __lhs.size());
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  [[__nodiscard__]] constexpr inline bool operator==(
      const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs) {
    return __lhs.size() == _Traits::length(__rhs) &&
           !_Traits::compare(__lhs.data(), __rhs, __lhs.size());
  }
# 3742 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
  [[nodiscard]]
  constexpr auto operator<=>(
      const basic_string<_CharT, _Traits, _Alloc> &__lhs,
      const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept
      -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0)) {
    return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs));
  }
# 3757 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
  [[nodiscard]]
  constexpr auto operator<=>(const basic_string<_CharT, _Traits, _Alloc> &__lhs,
                             const _CharT *__rhs) noexcept
      -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0)) {
    return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs));
  }
# 3991 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr inline void swap(basic_string<_CharT, _Traits, _Alloc> & __lhs,
                             basic_string<_CharT, _Traits, _Alloc> &
                                 __rhs) noexcept(noexcept(__lhs.swap(__rhs))) {
    __lhs.swap(__rhs);
  }
# 4012 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
  basic_istream<_CharT, _Traits> &operator>>(
      basic_istream<_CharT, _Traits> &__is,
      basic_string<_CharT, _Traits, _Alloc> &__str);

  template <>
  basic_istream<char> &operator>>(basic_istream<char> &__is,
                                  basic_string<char> &__str);
# 4030 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
  inline basic_ostream<_CharT, _Traits> &operator<<(
      basic_ostream<_CharT, _Traits> &__os,
      const basic_string<_CharT, _Traits, _Alloc> &__str) {

    return __ostream_insert(__os, __str.data(), __str.size());
  }
# 4053 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
  basic_istream<_CharT, _Traits> &getline(
      basic_istream<_CharT, _Traits> & __is,
      basic_string<_CharT, _Traits, _Alloc> & __str, _CharT __delim);
# 4070 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
  inline basic_istream<_CharT, _Traits> &getline(
      basic_istream<_CharT, _Traits> & __is,
      basic_string<_CharT, _Traits, _Alloc> & __str) {
    return std::getline(__is, __str, __is.widen('\n'));
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  inline basic_istream<_CharT, _Traits> &getline(
      basic_istream<_CharT, _Traits> && __is,
      basic_string<_CharT, _Traits, _Alloc> & __str, _CharT __delim) {
    return std::getline(__is, __str, __delim);
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  inline basic_istream<_CharT, _Traits> &getline(
      basic_istream<_CharT, _Traits> && __is,
      basic_string<_CharT, _Traits, _Alloc> & __str) {
    return std::getline(__is, __str);
  }

  template <>
  basic_istream<char> &getline(basic_istream<char> & __in,
                               basic_string<char> & __str, char __delim);

  template <>
  basic_istream<wchar_t> &getline(basic_istream<wchar_t> & __in,
                                  basic_string<wchar_t> & __str,
                                  wchar_t __delim);

} // namespace std

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/string_conversions.h" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/string_conversions.h" 3
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/string_conversions.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdlib" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdlib" 3
# 79 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4

# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 18 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 3 4
typedef long unsigned int size_t;
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 87 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_wchar_t.h" 1 3 4
# 88 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4

# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3 4
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {

# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 59 "/usr/include/stdlib.h" 3 4
typedef struct {
  int quot;
  int rem;
} div_t;

typedef struct {
  long int quot;
  long int rem;
} ldiv_t;

__extension__ typedef struct {
  long long int quot;
  long long int rem;
} lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max(void) noexcept(true);

extern double atof(const char *__nptr) noexcept(true) __attribute__((__pure__))
__attribute__((__nonnull__(1)));

extern int atoi(const char *__nptr) noexcept(true) __attribute__((__pure__))
__attribute__((__nonnull__(1)));

extern long int atol(const char *__nptr) noexcept(true)
    __attribute__((__pure__)) __attribute__((__nonnull__(1)));

__extension__ extern long long int atoll(const char *__nptr) noexcept(true)
    __attribute__((__pure__)) __attribute__((__nonnull__(1)));

extern double strtod(const char *__restrict __nptr,
                     char **__restrict __endptr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern float strtof(const char *__restrict __nptr,
                    char **__restrict __endptr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern long double strtold(const char *__restrict __nptr,
                           char **__restrict __endptr) noexcept(true)
    __attribute__((__nonnull__(1)));
# 141 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32(const char *__restrict __nptr,
                         char **__restrict __endptr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern _Float64 strtof64(const char *__restrict __nptr,
                         char **__restrict __endptr) noexcept(true)
    __attribute__((__nonnull__(1)));
# 159 "/usr/include/stdlib.h" 3 4
extern _Float32x strtof32x(const char *__restrict __nptr,
                           char **__restrict __endptr) noexcept(true)
    __attribute__((__nonnull__(1)));

extern _Float64x strtof64x(const char *__restrict __nptr,
                           char **__restrict __endptr) noexcept(true)
    __attribute__((__nonnull__(1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol(const char *__restrict __nptr,
                       char **__restrict __endptr, int __base) noexcept(true)
    __attribute__((__nonnull__(1)));

extern unsigned long int strtoul(const char *__restrict __nptr,
                                 char **__restrict __endptr,
                                 int __base) noexcept(true)
    __attribute__((__nonnull__(1)));

__extension__ extern long long int strtoq(const char *__restrict __nptr,
                                          char **__restrict __endptr,
                                          int __base) noexcept(true)
    __attribute__((__nonnull__(1)));

__extension__ extern unsigned long long int
strtouq(const char *__restrict __nptr, char **__restrict __endptr,
        int __base) noexcept(true) __attribute__((__nonnull__(1)));

__extension__ extern long long int strtoll(const char *__restrict __nptr,
                                           char **__restrict __endptr,
                                           int __base) noexcept(true)
    __attribute__((__nonnull__(1)));

__extension__ extern unsigned long long int
strtoull(const char *__restrict __nptr, char **__restrict __endptr,
         int __base) noexcept(true) __attribute__((__nonnull__(1)));

extern long int strtol(const char *__restrict __nptr,
                       char **__restrict __endptr,
                       int __base) noexcept(true) __asm__(""
                                                          "__isoc23_strtol")

    __attribute__((__nonnull__(1)));
extern unsigned long int
strtoul(const char *__restrict __nptr, char **__restrict __endptr,
        int __base) noexcept(true) __asm__(""
                                           "__isoc23_strtoul")

    __attribute__((__nonnull__(1)));

__extension__ extern long long int
strtoq(const char *__restrict __nptr, char **__restrict __endptr,
       int __base) noexcept(true) __asm__(""
                                          "__isoc23_strtoll")

    __attribute__((__nonnull__(1)));
__extension__ extern unsigned long long int
strtouq(const char *__restrict __nptr, char **__restrict __endptr,
        int __base) noexcept(true) __asm__(""
                                           "__isoc23_strtoull")

    __attribute__((__nonnull__(1)));

__extension__ extern long long int
strtoll(const char *__restrict __nptr, char **__restrict __endptr,
        int __base) noexcept(true) __asm__(""
                                           "__isoc23_strtoll")

    __attribute__((__nonnull__(1)));
__extension__ extern unsigned long long int
strtoull(const char *__restrict __nptr, char **__restrict __endptr,
         int __base) noexcept(true) __asm__(""
                                            "__isoc23_strtoull")

    __attribute__((__nonnull__(1)));
# 278 "/usr/include/stdlib.h" 3 4
extern int strfromd(char *__dest, size_t __size, const char *__format,
                    double __f) noexcept(true) __attribute__((__nonnull__(3)));

extern int strfromf(char *__dest, size_t __size, const char *__format,
                    float __f) noexcept(true) __attribute__((__nonnull__(3)));

extern int strfroml(char *__dest, size_t __size, const char *__format,
                    long double __f) noexcept(true)
    __attribute__((__nonnull__(3)));
# 298 "/usr/include/stdlib.h" 3 4
extern int strfromf32(char *__dest, size_t __size, const char *__format,
                      _Float32 __f) noexcept(true)
    __attribute__((__nonnull__(3)));

extern int strfromf64(char *__dest, size_t __size, const char *__format,
                      _Float64 __f) noexcept(true)
    __attribute__((__nonnull__(3)));
# 316 "/usr/include/stdlib.h" 3 4
extern int strfromf32x(char *__dest, size_t __size, const char *__format,
                       _Float32x __f) noexcept(true)
    __attribute__((__nonnull__(3)));

extern int strfromf64x(char *__dest, size_t __size, const char *__format,
                       _Float64x __f) noexcept(true)
    __attribute__((__nonnull__(3)));
# 340 "/usr/include/stdlib.h" 3 4
extern long int strtol_l(const char *__restrict __nptr,
                         char **__restrict __endptr, int __base,
                         locale_t __loc) noexcept(true)
    __attribute__((__nonnull__(1, 4)));

extern unsigned long int strtoul_l(const char *__restrict __nptr,
                                   char **__restrict __endptr, int __base,
                                   locale_t __loc) noexcept(true)
    __attribute__((__nonnull__(1, 4)));

__extension__ extern long long int
strtoll_l(const char *__restrict __nptr, char **__restrict __endptr, int __base,
          locale_t __loc) noexcept(true) __attribute__((__nonnull__(1, 4)));

__extension__ extern unsigned long long int
strtoull_l(const char *__restrict __nptr, char **__restrict __endptr,
           int __base, locale_t __loc) noexcept(true)
    __attribute__((__nonnull__(1, 4)));

extern long int
strtol_l(const char *__restrict __nptr, char **__restrict __endptr, int __base,
         locale_t __loc) noexcept(true) __asm__(""
                                                "__isoc23_strtol_l")

    __attribute__((__nonnull__(1, 4)));
extern unsigned long int
strtoul_l(const char *__restrict __nptr, char **__restrict __endptr, int __base,
          locale_t __loc) noexcept(true) __asm__(""
                                                 "__isoc23_strtoul_l")

    __attribute__((__nonnull__(1, 4)));
__extension__ extern long long int
strtoll_l(const char *__restrict __nptr, char **__restrict __endptr, int __base,
          locale_t __loc) noexcept(true) __asm__(""
                                                 "__isoc23_strtoll_l")

    __attribute__((__nonnull__(1, 4)));
__extension__ extern unsigned long long int
strtoull_l(const char *__restrict __nptr, char **__restrict __endptr,
           int __base,
           locale_t __loc) noexcept(true) __asm__(""
                                                  "__isoc23_strtoull_l")

    __attribute__((__nonnull__(1, 4)));
# 415 "/usr/include/stdlib.h" 3 4
extern double strtod_l(const char *__restrict __nptr,
                       char **__restrict __endptr,
                       locale_t __loc) noexcept(true)
    __attribute__((__nonnull__(1, 3)));

extern float strtof_l(const char *__restrict __nptr, char **__restrict __endptr,
                      locale_t __loc) noexcept(true)
    __attribute__((__nonnull__(1, 3)));

extern long double strtold_l(const char *__restrict __nptr,
                             char **__restrict __endptr,
                             locale_t __loc) noexcept(true)
    __attribute__((__nonnull__(1, 3)));
# 436 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l(const char *__restrict __nptr,
                           char **__restrict __endptr,
                           locale_t __loc) noexcept(true)
    __attribute__((__nonnull__(1, 3)));

extern _Float64 strtof64_l(const char *__restrict __nptr,
                           char **__restrict __endptr,
                           locale_t __loc) noexcept(true)
    __attribute__((__nonnull__(1, 3)));
# 457 "/usr/include/stdlib.h" 3 4
extern _Float32x strtof32x_l(const char *__restrict __nptr,
                             char **__restrict __endptr,
                             locale_t __loc) noexcept(true)
    __attribute__((__nonnull__(1, 3)));

extern _Float64x strtof64x_l(const char *__restrict __nptr,
                             char **__restrict __endptr,
                             locale_t __loc) noexcept(true)
    __attribute__((__nonnull__(1, 3)));
# 505 "/usr/include/stdlib.h" 3 4
extern char *l64a(long int __n) noexcept(true);

extern long int a64l(const char *__s) noexcept(true) __attribute__((__pure__))
__attribute__((__nonnull__(1)));

# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {

typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;

typedef __loff_t loff_t;

typedef __ino_t ino_t;

typedef __ino64_t ino64_t;

typedef __dev_t dev_t;

typedef __gid_t gid_t;

typedef __mode_t mode_t;

typedef __nlink_t nlink_t;

typedef __uid_t uid_t;

typedef __off_t off_t;

typedef __off64_t off64_t;
# 103 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __id_t id_t;

typedef __ssize_t ssize_t;

typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;

typedef __key_t key_t;
# 134 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __useconds_t useconds_t;

typedef __suseconds_t suseconds_t;

# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 18 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 3 4
typedef long unsigned int size_t;
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;

# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;

typedef int register_t __attribute__((__mode__(__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t __bswap_16(__uint16_t __bsx) {

  return ((__uint16_t)((((__bsx) >> 8) & 0xff) | (((__bsx) & 0xff) << 8)));
}

static __inline __uint32_t __bswap_32(__uint32_t __bsx) {

  return ((((__bsx) & 0xff000000u) >> 24) | (((__bsx) & 0x00ff0000u) >> 8) |
          (((__bsx) & 0x0000ff00u) << 8) | (((__bsx) & 0x000000ffu) << 24));
}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t __bswap_64(__uint64_t __bsx) {

  return ((((__bsx) & 0xff00000000000000ull) >> 56) |
          (((__bsx) & 0x00ff000000000000ull) >> 40) |
          (((__bsx) & 0x0000ff0000000000ull) >> 24) |
          (((__bsx) & 0x000000ff00000000ull) >> 8) |
          (((__bsx) & 0x00000000ff000000ull) << 8) |
          (((__bsx) & 0x0000000000ff0000ull) << 24) |
          (((__bsx) & 0x000000000000ff00ull) << 40) |
          (((__bsx) & 0x00000000000000ffull) << 56));
}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t __uint16_identity(__uint16_t __x) { return __x; }

static __inline __uint32_t __uint32_identity(__uint32_t __x) { return __x; }

static __inline __uint64_t __uint64_identity(__uint64_t __x) { return __x; }
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4

typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct {

  __fd_mask fds_bits[1024 / (8 * (int)sizeof(__fd_mask))];

} fd_set;

typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 102 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select(int __nfds, fd_set *__restrict __readfds,
                  fd_set *__restrict __writefds, fd_set *__restrict __exceptfds,
                  struct timeval *__restrict __timeout);
# 127 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect(int __nfds, fd_set *__restrict __readfds,
                   fd_set *__restrict __writefds,
                   fd_set *__restrict __exceptfds,
                   const struct timespec *__restrict __timeout,
                   const __sigset_t *__restrict __sigmask);
# 153 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

typedef __blksize_t blksize_t;

typedef __blkcnt_t blkcnt_t;

typedef __fsblkcnt_t fsblkcnt_t;

typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
# 230 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
}
# 515 "/usr/include/stdlib.h" 2 3 4

extern long int random(void) noexcept(true);

extern void srandom(unsigned int __seed) noexcept(true);

extern char *initstate(unsigned int __seed, char *__statebuf,
                       size_t __statelen) noexcept(true)
    __attribute__((__nonnull__(2)));

extern char *setstate(char *__statebuf) noexcept(true)
    __attribute__((__nonnull__(1)));

struct random_data {
  int32_t *fptr;
  int32_t *rptr;
  int32_t *state;
  int rand_type;
  int rand_deg;
  int rand_sep;
  int32_t *end_ptr;
};

extern int random_r(struct random_data *__restrict __buf,
                    int32_t *__restrict __result) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int srandom_r(unsigned int __seed,
                     struct random_data *__buf) noexcept(true)
    __attribute__((__nonnull__(2)));

extern int initstate_r(unsigned int __seed, char *__restrict __statebuf,
                       size_t __statelen,
                       struct random_data *__restrict __buf) noexcept(true)
    __attribute__((__nonnull__(2, 4)));

extern int setstate_r(char *__restrict __statebuf,
                      struct random_data *__restrict __buf) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int rand(void) noexcept(true);

extern void srand(unsigned int __seed) noexcept(true);

extern int rand_r(unsigned int *__seed) noexcept(true);

extern double drand48(void) noexcept(true);
extern double erand48(unsigned short int __xsubi[3]) noexcept(true)
    __attribute__((__nonnull__(1)));

extern long int lrand48(void) noexcept(true);
extern long int nrand48(unsigned short int __xsubi[3]) noexcept(true)
    __attribute__((__nonnull__(1)));

extern long int mrand48(void) noexcept(true);
extern long int jrand48(unsigned short int __xsubi[3]) noexcept(true)
    __attribute__((__nonnull__(1)));

extern void srand48(long int __seedval) noexcept(true);
extern unsigned short int *
seed48(unsigned short int __seed16v[3]) noexcept(true)
    __attribute__((__nonnull__(1)));
extern void lcong48(unsigned short int __param[7]) noexcept(true)
    __attribute__((__nonnull__(1)));

struct drand48_data {
  unsigned short int __x[3];
  unsigned short int __old_x[3];
  unsigned short int __c;
  unsigned short int __init;
  __extension__ unsigned long long int __a;
};

extern int drand48_r(struct drand48_data *__restrict __buffer,
                     double *__restrict __result) noexcept(true)
    __attribute__((__nonnull__(1, 2)));
extern int erand48_r(unsigned short int __xsubi[3],
                     struct drand48_data *__restrict __buffer,
                     double *__restrict __result) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int lrand48_r(struct drand48_data *__restrict __buffer,
                     long int *__restrict __result) noexcept(true)
    __attribute__((__nonnull__(1, 2)));
extern int nrand48_r(unsigned short int __xsubi[3],
                     struct drand48_data *__restrict __buffer,
                     long int *__restrict __result) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int mrand48_r(struct drand48_data *__restrict __buffer,
                     long int *__restrict __result) noexcept(true)
    __attribute__((__nonnull__(1, 2)));
extern int jrand48_r(unsigned short int __xsubi[3],
                     struct drand48_data *__restrict __buffer,
                     long int *__restrict __result) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int srand48_r(long int __seedval,
                     struct drand48_data *__buffer) noexcept(true)
    __attribute__((__nonnull__(2)));

extern int seed48_r(unsigned short int __seed16v[3],
                    struct drand48_data *__buffer) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int lcong48_r(unsigned short int __param[7],
                     struct drand48_data *__buffer) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern __uint32_t arc4random(void) noexcept(true);

extern void arc4random_buf(void *__buf, size_t __size) noexcept(true)
    __attribute__((__nonnull__(1)));

extern __uint32_t arc4random_uniform(__uint32_t __upper_bound) noexcept(true);

extern void *malloc(size_t __size) noexcept(true) __attribute__((__malloc__));

extern void *calloc(size_t __nmemb, size_t __size) noexcept(true)
    __attribute__((__malloc__));

extern void *realloc(void *__ptr, size_t __size) noexcept(true)
    __attribute__((__warn_unused_result__));

extern void free(void *__ptr) noexcept(true);

extern void *reallocarray(void *__ptr, size_t __nmemb,
                          size_t __size) noexcept(true)
    __attribute__((__warn_unused_result__))

    ;

extern void *reallocarray(void *__ptr, size_t __nmemb,
                          size_t __size) noexcept(true);

# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 18 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 3 4
typedef long unsigned int size_t;
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {

extern void *alloca(size_t __size) noexcept(true);
}
# 707 "/usr/include/stdlib.h" 2 3 4

extern void *valloc(size_t __size) noexcept(true) __attribute__((__malloc__));

extern int posix_memalign(void **__memptr, size_t __alignment,
                          size_t __size) noexcept(true)
    __attribute__((__nonnull__(1)));

extern void *aligned_alloc(size_t __alignment, size_t __size) noexcept(true)
    __attribute__((__malloc__)) __attribute__((__alloc_align__(1)));

extern void abort(void) noexcept(true) __attribute__((__noreturn__));

extern int atexit(void (*__func)(void)) noexcept(true)
    __attribute__((__nonnull__(1)));

extern "C++" int
at_quick_exit(void (*__func)(void)) noexcept(true) __asm("at_quick_exit")
    __attribute__((__nonnull__(1)));
# 749 "/usr/include/stdlib.h" 3 4
extern int on_exit(void (*__func)(int __status, void *__arg),
                   void *__arg) noexcept(true) __attribute__((__nonnull__(1)));

extern void exit(int __status) noexcept(true) __attribute__((__noreturn__));

extern void quick_exit(int __status) noexcept(true)
    __attribute__((__noreturn__));

extern void _Exit(int __status) noexcept(true) __attribute__((__noreturn__));

extern char *getenv(const char *__name) noexcept(true)
    __attribute__((__nonnull__(1)));

extern char *secure_getenv(const char *__name) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int putenv(char *__string) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int setenv(const char *__name, const char *__value,
                  int __replace) noexcept(true) __attribute__((__nonnull__(2)));

extern int unsetenv(const char *__name) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int clearenv(void) noexcept(true);
# 814 "/usr/include/stdlib.h" 3 4
extern char *mktemp(char *__template) noexcept(true)
    __attribute__((__nonnull__(1)));
# 827 "/usr/include/stdlib.h" 3 4
extern int mkstemp(char *__template) __attribute__((__nonnull__(1)));
# 837 "/usr/include/stdlib.h" 3 4
extern int mkstemp64(char *__template) __attribute__((__nonnull__(1)));
# 849 "/usr/include/stdlib.h" 3 4
extern int mkstemps(char *__template, int __suffixlen)
    __attribute__((__nonnull__(1)));
# 859 "/usr/include/stdlib.h" 3 4
extern int mkstemps64(char *__template, int __suffixlen)
    __attribute__((__nonnull__(1)));
# 870 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp(char *__template) noexcept(true)
    __attribute__((__nonnull__(1)));
# 881 "/usr/include/stdlib.h" 3 4
extern int mkostemp(char *__template, int __flags)
    __attribute__((__nonnull__(1)));
# 891 "/usr/include/stdlib.h" 3 4
extern int mkostemp64(char *__template, int __flags)
    __attribute__((__nonnull__(1)));
# 901 "/usr/include/stdlib.h" 3 4
extern int mkostemps(char *__template, int __suffixlen, int __flags)
    __attribute__((__nonnull__(1)));
# 913 "/usr/include/stdlib.h" 3 4
extern int mkostemps64(char *__template, int __suffixlen, int __flags)
    __attribute__((__nonnull__(1)));
# 923 "/usr/include/stdlib.h" 3 4
extern int system(const char *__command);

extern char *canonicalize_file_name(const char *__name) noexcept(true)
    __attribute__((__nonnull__(1))) __attribute__((__malloc__));
# 940 "/usr/include/stdlib.h" 3 4
extern char *realpath(const char *__restrict __name,
                      char *__restrict __resolved) noexcept(true);

typedef int (*__compar_fn_t)(const void *, const void *);

typedef __compar_fn_t comparison_fn_t;

typedef int (*__compar_d_fn_t)(const void *, const void *, void *);

extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
                     size_t __size, __compar_fn_t __compar)
    __attribute__((__nonnull__(1, 2, 5)));

extern void qsort(void *__base, size_t __nmemb, size_t __size,
                  __compar_fn_t __compar) __attribute__((__nonnull__(1, 4)));

extern void qsort_r(void *__base, size_t __nmemb, size_t __size,
                    __compar_d_fn_t __compar, void *__arg)
    __attribute__((__nonnull__(1, 4)));

extern int abs(int __x) noexcept(true) __attribute__((__const__));
extern long int labs(long int __x) noexcept(true) __attribute__((__const__));

__extension__ extern long long int llabs(long long int __x) noexcept(true)
    __attribute__((__const__));

extern div_t div(int __numer, int __denom) noexcept(true)
    __attribute__((__const__));
extern ldiv_t ldiv(long int __numer, long int __denom) noexcept(true)
    __attribute__((__const__));

__extension__ extern lldiv_t lldiv(long long int __numer,
                                   long long int __denom) noexcept(true)
    __attribute__((__const__));
# 1012 "/usr/include/stdlib.h" 3 4
extern char *ecvt(double __value, int __ndigit, int *__restrict __decpt,
                  int *__restrict __sign) noexcept(true)
    __attribute__((__nonnull__(3, 4)));

extern char *fcvt(double __value, int __ndigit, int *__restrict __decpt,
                  int *__restrict __sign) noexcept(true)
    __attribute__((__nonnull__(3, 4)));

extern char *gcvt(double __value, int __ndigit, char *__buf) noexcept(true)
    __attribute__((__nonnull__(3)));

extern char *qecvt(long double __value, int __ndigit, int *__restrict __decpt,
                   int *__restrict __sign) noexcept(true)
    __attribute__((__nonnull__(3, 4)));
extern char *qfcvt(long double __value, int __ndigit, int *__restrict __decpt,
                   int *__restrict __sign) noexcept(true)
    __attribute__((__nonnull__(3, 4)));
extern char *qgcvt(long double __value, int __ndigit,
                   char *__buf) noexcept(true) __attribute__((__nonnull__(3)));

extern int ecvt_r(double __value, int __ndigit, int *__restrict __decpt,
                  int *__restrict __sign, char *__restrict __buf,
                  size_t __len) noexcept(true)
    __attribute__((__nonnull__(3, 4, 5)));
extern int fcvt_r(double __value, int __ndigit, int *__restrict __decpt,
                  int *__restrict __sign, char *__restrict __buf,
                  size_t __len) noexcept(true)
    __attribute__((__nonnull__(3, 4, 5)));

extern int qecvt_r(long double __value, int __ndigit, int *__restrict __decpt,
                   int *__restrict __sign, char *__restrict __buf,
                   size_t __len) noexcept(true)
    __attribute__((__nonnull__(3, 4, 5)));
extern int qfcvt_r(long double __value, int __ndigit, int *__restrict __decpt,
                   int *__restrict __sign, char *__restrict __buf,
                   size_t __len) noexcept(true)
    __attribute__((__nonnull__(3, 4, 5)));

extern int mblen(const char *__s, size_t __n) noexcept(true);

extern int mbtowc(wchar_t *__restrict __pwc, const char *__restrict __s,
                  size_t __n) noexcept(true);

extern int wctomb(char *__s, wchar_t __wchar) noexcept(true);

extern size_t mbstowcs(wchar_t *__restrict __pwcs, const char *__restrict __s,
                       size_t __n) noexcept(true);

extern size_t wcstombs(char *__restrict __s, const wchar_t *__restrict __pwcs,
                       size_t __n) noexcept(true)

    ;

extern int rpmatch(const char *__response) noexcept(true)
    __attribute__((__nonnull__(1)));
# 1099 "/usr/include/stdlib.h" 3 4
extern int getsubopt(char **__restrict __optionp,
                     char *const *__restrict __tokens,
                     char **__restrict __valuep) noexcept(true)
    __attribute__((__nonnull__(1, 2, 3)));

extern int posix_openpt(int __oflag);

extern int grantpt(int __fd) noexcept(true);

extern int unlockpt(int __fd) noexcept(true);

extern char *ptsname(int __fd) noexcept(true);

extern int ptsname_r(int __fd, char *__buf, size_t __buflen) noexcept(true)
    __attribute__((__nonnull__(2)));

extern int getpt(void);

extern int getloadavg(double __loadavg[], int __nelem) noexcept(true)
    __attribute__((__nonnull__(1)));
# 1155 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1156 "/usr/include/stdlib.h" 2 3 4
# 1167 "/usr/include/stdlib.h" 3 4
}
# 80 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdlib" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_abs.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_abs.h" 3
# 46 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_abs.h" 3
extern "C++" {
namespace std __attribute__((__visibility__("default"))) {

  using ::abs;

  inline long abs(long __i) { return __builtin_labs(__i); }

  inline long long abs(long long __x) { return __builtin_llabs(__x); }
# 70 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_abs.h" 3
  inline constexpr double abs(double __x) { return __builtin_fabs(__x); }

  inline constexpr float abs(float __x) { return __builtin_fabsf(__x); }

  inline constexpr long double abs(long double __x) {
    return __builtin_fabsl(__x);
  }
# 151 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_abs.h" 3
} // namespace std
}
# 82 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdlib" 2 3
# 125 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdlib" 3
extern "C++" {
namespace std __attribute__((__visibility__("default"))) {

  using ::div_t;
  using ::ldiv_t;

  using ::abort;

  using ::aligned_alloc;

  using ::atexit;

  using ::at_quick_exit;

  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;

  using ::quick_exit;

  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;

  inline ldiv_t div(long __i, long __j) noexcept { return ldiv(__i, __j); }

} // namespace std
# 199 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdlib" 3
namespace __gnu_cxx __attribute__((__visibility__("default"))) {

  using ::lldiv_t;

  using ::_Exit;

  using ::llabs;

  inline lldiv_t div(long long __n, long long __d) {
    lldiv_t __q;
    __q.quot = __n / __d;
    __q.rem = __n % __d;
    return __q;
  }

  using ::lldiv;
# 231 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;

} // namespace __gnu_cxx

namespace std {

using ::__gnu_cxx::lldiv_t;

using ::__gnu_cxx::_Exit;

using ::__gnu_cxx::div;
using ::__gnu_cxx::llabs;
using ::__gnu_cxx::lldiv;

using ::__gnu_cxx::atoll;
using ::__gnu_cxx::strtof;
using ::__gnu_cxx::strtold;
using ::__gnu_cxx::strtoll;
using ::__gnu_cxx::strtoull;
} // namespace std
}
# 44 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/string_conversions.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cwchar" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cwchar" 3
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/string_conversions.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdio" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdio" 3

# 1 "/usr/include/stdio.h" 1 3 4
# 28 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 29 "/usr/include/stdio.h" 2 3 4

extern "C" {

# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 18 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 3 4
typedef long unsigned int size_t;
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 92 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3 4
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 35 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/lib/llvm-18/lib/clang/18/include/stdarg.h" 1 3 4
# 38 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 3 4
typedef struct _G_fpos_t {
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t {
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 42 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;

typedef void _IO_lock_t;

struct _IO_FILE {
  int _flags;

  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;

  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;

  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof(int) - 4 * sizeof(void *) - sizeof(size_t)];
};
# 45 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t(void *__cookie, char *__buf,
                                         size_t __nbytes);

typedef __ssize_t cookie_write_function_t(void *__cookie, const char *__buf,
                                          size_t __nbytes);

typedef int cookie_seek_function_t(void *__cookie, __off64_t *__pos, int __w);

typedef int cookie_close_function_t(void *__cookie);

typedef struct _IO_cookie_io_functions_t {
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 48 "/usr/include/stdio.h" 2 3 4
# 85 "/usr/include/stdio.h" 3 4
typedef __fpos_t fpos_t;

typedef __fpos64_t fpos64_t;
# 129 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 130 "/usr/include/stdio.h" 2 3 4
# 149 "/usr/include/stdio.h" 3 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;

extern int remove(const char *__filename) noexcept(true);

extern int rename(const char *__old, const char *__new) noexcept(true);

extern int renameat(int __oldfd, const char *__old, int __newfd,
                    const char *__new) noexcept(true);
# 176 "/usr/include/stdio.h" 3 4
extern int renameat2(int __oldfd, const char *__old, int __newfd,
                     const char *__new, unsigned int __flags) noexcept(true);

extern int fclose(FILE *__stream) __attribute__((__nonnull__(1)));
# 194 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile(void) __attribute__((__malloc__));
# 206 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64(void) __attribute__((__malloc__));

extern char *tmpnam(char[20]) noexcept(true);

extern char *tmpnam_r(char __s[20]) noexcept(true);
# 228 "/usr/include/stdio.h" 3 4
extern char *tempnam(const char *__dir, const char *__pfx) noexcept(true)
    __attribute__((__malloc__));

extern int fflush(FILE *__stream);
# 245 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked(FILE *__stream);
# 255 "/usr/include/stdio.h" 3 4
extern int fcloseall(void);
# 264 "/usr/include/stdio.h" 3 4
extern FILE *fopen(const char *__restrict __filename,
                   const char *__restrict __modes) __attribute__((__malloc__));

extern FILE *freopen(const char *__restrict __filename,
                     const char *__restrict __modes, FILE *__restrict __stream)
    __attribute__((__nonnull__(3)));
# 289 "/usr/include/stdio.h" 3 4
extern FILE *fopen64(const char *__restrict __filename,
                     const char *__restrict __modes)
    __attribute__((__malloc__));
extern FILE *freopen64(const char *__restrict __filename,
                       const char *__restrict __modes,
                       FILE *__restrict __stream)
    __attribute__((__nonnull__(3)));

extern FILE *fdopen(int __fd, const char *__modes) noexcept(true)
    __attribute__((__malloc__));

extern FILE *fopencookie(void *__restrict __magic_cookie,
                         const char *__restrict __modes,
                         cookie_io_functions_t __io_funcs) noexcept(true)
    __attribute__((__malloc__));

extern FILE *fmemopen(void *__s, size_t __len,
                      const char *__modes) noexcept(true)
    __attribute__((__malloc__));

extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc) noexcept(true)
    __attribute__((__malloc__));

extern __FILE *open_wmemstream(wchar_t **__bufloc,
                               size_t *__sizeloc) noexcept(true)
    __attribute__((__malloc__));

extern void setbuf(FILE *__restrict __stream,
                   char *__restrict __buf) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int setvbuf(FILE *__restrict __stream, char *__restrict __buf,
                   int __modes, size_t __n) noexcept(true)
    __attribute__((__nonnull__(1)));

extern void setbuffer(FILE *__restrict __stream, char *__restrict __buf,
                      size_t __size) noexcept(true)
    __attribute__((__nonnull__(1)));

extern void setlinebuf(FILE *__stream) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int fprintf(FILE *__restrict __stream, const char *__restrict __format,
                   ...) __attribute__((__nonnull__(1)));

extern int printf(const char *__restrict __format, ...);

extern int sprintf(char *__restrict __s, const char *__restrict __format,
                   ...) noexcept(true);

extern int vfprintf(FILE *__restrict __s, const char *__restrict __format,
                    __gnuc_va_list __arg) __attribute__((__nonnull__(1)));

extern int vprintf(const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf(char *__restrict __s, const char *__restrict __format,
                    __gnuc_va_list __arg) noexcept(true);

extern int snprintf(char *__restrict __s, size_t __maxlen,
                    const char *__restrict __format, ...) noexcept(true)
    __attribute__((__format__(__printf__, 3, 4)));

extern int vsnprintf(char *__restrict __s, size_t __maxlen,
                     const char *__restrict __format,
                     __gnuc_va_list __arg) noexcept(true)
    __attribute__((__format__(__printf__, 3, 0)));

extern int vasprintf(char **__restrict __ptr, const char *__restrict __f,
                     __gnuc_va_list __arg) noexcept(true)
    __attribute__((__format__(__printf__, 2, 0)));
extern int __asprintf(char **__restrict __ptr, const char *__restrict __fmt,
                      ...) noexcept(true)
    __attribute__((__format__(__printf__, 2, 3)));
extern int asprintf(char **__restrict __ptr, const char *__restrict __fmt,
                    ...) noexcept(true)
    __attribute__((__format__(__printf__, 2, 3)));

extern int vdprintf(int __fd, const char *__restrict __fmt,
                    __gnuc_va_list __arg)
    __attribute__((__format__(__printf__, 2, 0)));
extern int dprintf(int __fd, const char *__restrict __fmt, ...)
    __attribute__((__format__(__printf__, 2, 3)));

extern int fscanf(FILE *__restrict __stream, const char *__restrict __format,
                  ...) __attribute__((__nonnull__(1)));

extern int scanf(const char *__restrict __format, ...);

extern int sscanf(const char *__restrict __s, const char *__restrict __format,
                  ...) noexcept(true);
# 442 "/usr/include/stdio.h" 3 4
extern int fscanf(FILE *__restrict __stream, const char *__restrict __format,
                  ...) __asm__(""
                               "__isoc23_fscanf")
    __attribute__((__nonnull__(1)));

extern int scanf(const char *__restrict __format,
                 ...) __asm__(""
                              "__isoc23_scanf");

extern int sscanf(const char *__restrict __s, const char *__restrict __format,
                  ...) noexcept(true) __asm__(""
                                              "__isoc23_sscanf");
# 490 "/usr/include/stdio.h" 3 4
extern int vfscanf(FILE *__restrict __s, const char *__restrict __format,
                   __gnuc_va_list __arg)
    __attribute__((__format__(__scanf__, 2, 0)))
    __attribute__((__nonnull__(1)));

extern int vscanf(const char *__restrict __format, __gnuc_va_list __arg)
    __attribute__((__format__(__scanf__, 1, 0)));

extern int vsscanf(const char *__restrict __s, const char *__restrict __format,
                   __gnuc_va_list __arg) noexcept(true)
    __attribute__((__format__(__scanf__, 2, 0)));

extern int vfscanf(FILE *__restrict __s, const char *__restrict __format,
                   __gnuc_va_list __arg) __asm__(""
                                                 "__isoc23_vfscanf")

    __attribute__((__format__(__scanf__, 2, 0)))
    __attribute__((__nonnull__(1)));
extern int vscanf(const char *__restrict __format,
                  __gnuc_va_list __arg) __asm__(""
                                                "__isoc23_vscanf")

    __attribute__((__format__(__scanf__, 1, 0)));
extern int
vsscanf(const char *__restrict __s, const char *__restrict __format,
        __gnuc_va_list __arg) noexcept(true) __asm__(""
                                                     "__isoc23_vsscanf")

    __attribute__((__format__(__scanf__, 2, 0)));
# 575 "/usr/include/stdio.h" 3 4
extern int fgetc(FILE *__stream) __attribute__((__nonnull__(1)));
extern int getc(FILE *__stream) __attribute__((__nonnull__(1)));

extern int getchar(void);

extern int getc_unlocked(FILE *__stream) __attribute__((__nonnull__(1)));
extern int getchar_unlocked(void);
# 600 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked(FILE *__stream) __attribute__((__nonnull__(1)));
# 611 "/usr/include/stdio.h" 3 4
extern int fputc(int __c, FILE *__stream) __attribute__((__nonnull__(2)));
extern int putc(int __c, FILE *__stream) __attribute__((__nonnull__(2)));

extern int putchar(int __c);
# 627 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked(int __c, FILE *__stream)
    __attribute__((__nonnull__(2)));

extern int putc_unlocked(int __c, FILE *__stream)
    __attribute__((__nonnull__(2)));
extern int putchar_unlocked(int __c);

extern int getw(FILE *__stream) __attribute__((__nonnull__(1)));

extern int putw(int __w, FILE *__stream) __attribute__((__nonnull__(2)));

extern char *fgets(char *__restrict __s, int __n, FILE *__restrict __stream)
    __attribute__((__nonnull__(3)));
# 677 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked(char *__restrict __s, int __n,
                            FILE *__restrict __stream)
    __attribute__((__nonnull__(3)));
# 694 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim(char **__restrict __lineptr, size_t *__restrict __n,
                            int __delimiter, FILE *__restrict __stream)
    __attribute__((__nonnull__(4)));
extern __ssize_t getdelim(char **__restrict __lineptr, size_t *__restrict __n,
                          int __delimiter, FILE *__restrict __stream)
    __attribute__((__nonnull__(4)));

extern __ssize_t getline(char **__restrict __lineptr, size_t *__restrict __n,
                         FILE *__restrict __stream)
    __attribute__((__nonnull__(3)));

extern int fputs(const char *__restrict __s, FILE *__restrict __stream)
    __attribute__((__nonnull__(2)));

extern int puts(const char *__s);

extern int ungetc(int __c, FILE *__stream) __attribute__((__nonnull__(2)));

extern size_t fread(void *__restrict __ptr, size_t __size, size_t __n,
                    FILE *__restrict __stream) __attribute__((__nonnull__(4)));

extern size_t fwrite(const void *__restrict __ptr, size_t __size, size_t __n,
                     FILE *__restrict __s) __attribute__((__nonnull__(4)));
# 755 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked(const char *__restrict __s, FILE *__restrict __stream)
    __attribute__((__nonnull__(2)));
# 766 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked(void *__restrict __ptr, size_t __size, size_t __n,
                             FILE *__restrict __stream)
    __attribute__((__nonnull__(4)));
extern size_t fwrite_unlocked(const void *__restrict __ptr, size_t __size,
                              size_t __n, FILE *__restrict __stream)
    __attribute__((__nonnull__(4)));

extern int fseek(FILE *__stream, long int __off, int __whence)
    __attribute__((__nonnull__(1)));

extern long int ftell(FILE *__stream) __attribute__((__nonnull__(1)));

extern void rewind(FILE *__stream) __attribute__((__nonnull__(1)));
# 803 "/usr/include/stdio.h" 3 4
extern int fseeko(FILE *__stream, __off_t __off, int __whence)
    __attribute__((__nonnull__(1)));

extern __off_t ftello(FILE *__stream) __attribute__((__nonnull__(1)));
# 829 "/usr/include/stdio.h" 3 4
extern int fgetpos(FILE *__restrict __stream, fpos_t *__restrict __pos)
    __attribute__((__nonnull__(1)));

extern int fsetpos(FILE *__stream, const fpos_t *__pos)
    __attribute__((__nonnull__(1)));
# 851 "/usr/include/stdio.h" 3 4
extern int fseeko64(FILE *__stream, __off64_t __off, int __whence)
    __attribute__((__nonnull__(1)));
extern __off64_t ftello64(FILE *__stream) __attribute__((__nonnull__(1)));
extern int fgetpos64(FILE *__restrict __stream, fpos64_t *__restrict __pos)
    __attribute__((__nonnull__(1)));
extern int fsetpos64(FILE *__stream, const fpos64_t *__pos)
    __attribute__((__nonnull__(1)));

extern void clearerr(FILE *__stream) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int feof(FILE *__stream) noexcept(true) __attribute__((__nonnull__(1)));

extern int ferror(FILE *__stream) noexcept(true)
    __attribute__((__nonnull__(1)));

extern void clearerr_unlocked(FILE *__stream) noexcept(true)
    __attribute__((__nonnull__(1)));
extern int feof_unlocked(FILE *__stream) noexcept(true)
    __attribute__((__nonnull__(1)));
extern int ferror_unlocked(FILE *__stream) noexcept(true)
    __attribute__((__nonnull__(1)));

extern void perror(const char *__s) __attribute__((__cold__));

extern int fileno(FILE *__stream) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int fileno_unlocked(FILE *__stream) noexcept(true)
    __attribute__((__nonnull__(1)));
# 897 "/usr/include/stdio.h" 3 4
extern int pclose(FILE *__stream) __attribute__((__nonnull__(1)));

extern FILE *popen(const char *__command, const char *__modes)
    __attribute__((__malloc__));

extern char *ctermid(char *__s) noexcept(true);

extern char *cuserid(char *__s);

struct obstack;

extern int obstack_printf(struct obstack *__restrict __obstack,
                          const char *__restrict __format, ...) noexcept(true)
    __attribute__((__format__(__printf__, 2, 3)));
extern int obstack_vprintf(struct obstack *__restrict __obstack,
                           const char *__restrict __format,
                           __gnuc_va_list __args) noexcept(true)
    __attribute__((__format__(__printf__, 2, 0)));

extern void flockfile(FILE *__stream) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int ftrylockfile(FILE *__stream) noexcept(true)
    __attribute__((__nonnull__(1)));

extern void funlockfile(FILE *__stream) noexcept(true)
    __attribute__((__nonnull__(1)));
# 959 "/usr/include/stdio.h" 3 4
extern int __uflow(FILE *);
extern int __overflow(FILE *, int);
# 983 "/usr/include/stdio.h" 3 4
}
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdio" 2 3
# 96 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdio" 3
namespace std {
using ::FILE;
using ::fpos_t;

using ::clearerr;
using ::fclose;
using ::feof;
using ::ferror;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::fopen;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;
using ::freopen;
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;
using ::getc;
using ::getchar;

using ::perror;
using ::printf;
using ::putc;
using ::putchar;
using ::puts;
using ::remove;
using ::rename;
using ::rewind;
using ::scanf;
using ::setbuf;
using ::setvbuf;
using ::sprintf;
using ::sscanf;
using ::tmpfile;

using ::tmpnam;

using ::ungetc;
using ::vfprintf;
using ::vprintf;
using ::vsprintf;
} // namespace std
# 157 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdio" 3
namespace __gnu_cxx {
# 175 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdio" 3
using ::snprintf;
using ::vfscanf;
using ::vscanf;
using ::vsnprintf;
using ::vsscanf;

} // namespace __gnu_cxx

namespace std {
using ::__gnu_cxx::snprintf;
using ::__gnu_cxx::vfscanf;
using ::__gnu_cxx::vscanf;
using ::__gnu_cxx::vsnprintf;
using ::__gnu_cxx::vsscanf;
} // namespace std
# 46 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/string_conversions.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cerrno" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cerrno" 3

# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4

# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4

extern "C" {

extern int *__errno_location(void) noexcept(true) __attribute__((__const__));

extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4
}
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cerrno" 2 3
# 47 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__((__visibility__("default"))) {

  template <typename _TRet, typename _Ret = _TRet, typename _CharT,
            typename... _Base>
  _Ret __stoa(_TRet(*__convf)(const _CharT *, _CharT **, _Base...),
              const char *__name, const _CharT *__str, std::size_t *__idx,
              _Base... __base) {
    _Ret __ret;

    _CharT *__endptr;

    struct _Save_errno {
      _Save_errno() : _M_errno((*__errno_location())) {
        (*__errno_location()) = 0;
      }
      ~_Save_errno() {
        if ((*__errno_location()) == 0)
          (*__errno_location()) = _M_errno;
      }
      int _M_errno;
    } const __save_errno;

    struct _Range_chk {
      static bool _S_chk(_TRet, std::false_type) { return false; }

      static bool _S_chk(_TRet __val, std::true_type) {
        return __val < _TRet(__numeric_traits<int>::__min) ||
               __val > _TRet(__numeric_traits<int>::__max);
      }
    };

    const _TRet __tmp = __convf(__str, &__endptr, __base...);

    if (__endptr == __str)
      std::__throw_invalid_argument(__name);
    else if ((*__errno_location()) == 34 ||
             _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>{}))
      std::__throw_out_of_range(__name);
    else
      __ret = __tmp;

    if (__idx)
      *__idx = __endptr - __str;

    return __ret;
  }

  template <typename _String, typename _CharT = typename _String::value_type>
  _String __to_xstring(
      int (*__convf)(_CharT *, std::size_t, const _CharT *, __builtin_va_list),
      std::size_t __n, const _CharT *__fmt, ...) {

    _CharT *__s = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __n));

    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);

    const int __len = __convf(__s, __n, __fmt, __args);

    __builtin_va_end(__args);

    return _String(__s, __s + __len);
  }

} // namespace __gnu_cxx
# 4110 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/charconv.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/charconv.h" 3

namespace std __attribute__((__visibility__("default"))) {

  namespace __detail {

  template <typename _Tp>
  constexpr bool __integer_to_chars_is_unsigned =
      !__gnu_cxx::__int_traits<_Tp>::__is_signed;

  template <typename _Tp>
  constexpr unsigned __to_chars_len(_Tp __value, int __base = 10) noexcept {

    static_assert(__integer_to_chars_is_unsigned<_Tp>, "implementation bug");

    unsigned __n = 1;
    const unsigned __b2 = __base * __base;
    const unsigned __b3 = __b2 * __base;
    const unsigned long __b4 = __b3 * __base;
    for (;;) {
      if (__value < (unsigned)__base)
        return __n;
      if (__value < __b2)
        return __n + 1;
      if (__value < __b3)
        return __n + 2;
      if (__value < __b4)
        return __n + 3;
      __value /= __b4;
      __n += 4;
    }
  }

  template <typename _Tp>
  void __to_chars_10_impl(char *__first, unsigned __len, _Tp __val) noexcept {

    static_assert(__integer_to_chars_is_unsigned<_Tp>, "implementation bug");

    constexpr char __digits[201] = "0001020304050607080910111213141516171819"
                                   "2021222324252627282930313233343536373839"
                                   "4041424344454647484950515253545556575859"
                                   "6061626364656667686970717273747576777879"
                                   "8081828384858687888990919293949596979899";
    unsigned __pos = __len - 1;
    while (__val >= 100) {
      auto const __num = (__val % 100) * 2;
      __val /= 100;
      __first[__pos] = __digits[__num + 1];
      __first[__pos - 1] = __digits[__num];
      __pos -= 2;
    }
    if (__val >= 10) {
      auto const __num = __val * 2;
      __first[1] = __digits[__num + 1];
      __first[0] = __digits[__num];
    } else
      __first[0] = '0' + __val;
  }

  } // namespace __detail

} // namespace std
# 4111 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  namespace __cxx11 {

  inline int stoi(const string &__str, size_t *__idx = 0, int __base = 10) {
    return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
                                        __idx, __base);
  }

  inline long stol(const string &__str, size_t *__idx = 0, int __base = 10) {
    return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(), __idx,
                             __base);
  }

  inline unsigned long stoul(const string &__str, size_t *__idx = 0,
                             int __base = 10) {
    return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(), __idx,
                             __base);
  }

  inline long long stoll(const string &__str, size_t *__idx = 0,
                         int __base = 10) {
    return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(), __idx,
                             __base);
  }

  inline unsigned long long stoull(const string &__str, size_t *__idx = 0,
                                   int __base = 10) {
    return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(), __idx,
                             __base);
  }

  inline float stof(const string &__str, size_t *__idx = 0) {
    return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx);
  }

  inline double stod(const string &__str, size_t *__idx = 0) {
    return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx);
  }

  inline long double stold(const string &__str, size_t *__idx = 0) {
    return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx);
  }

  [[__nodiscard__]]
  inline string to_string(int __val)

      noexcept

  {
    const bool __neg = __val < 0;
    const unsigned __uval = __neg ? (unsigned)~__val + 1u : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str(__neg + __len, '-');
    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
    return __str;
  }

  [[__nodiscard__]]
  inline string to_string(unsigned __val)

      noexcept

  {
    string __str(__detail::__to_chars_len(__val), '\0');
    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
    return __str;
  }

  [[__nodiscard__]]
  inline string to_string(long __val)

  {
    const bool __neg = __val < 0;
    const unsigned long __uval = __neg ? (unsigned long)~__val + 1ul : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str(__neg + __len, '-');
    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
    return __str;
  }

  [[__nodiscard__]]
  inline string to_string(unsigned long __val)

  {
    string __str(__detail::__to_chars_len(__val), '\0');
    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
    return __str;
  }

  [[__nodiscard__]]
  inline string to_string(long long __val) {
    const bool __neg = __val < 0;
    const unsigned long long __uval =
        __neg ? (unsigned long long)~__val + 1ull : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str(__neg + __len, '-');
    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
    return __str;
  }

  [[__nodiscard__]]
  inline string to_string(unsigned long long __val) {
    string __str(__detail::__to_chars_len(__val), '\0');
    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
    return __str;
  }

  [[__nodiscard__]]
  inline string to_string(float __val) {
    const int __n = __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n, "%f", __val);
  }

  [[__nodiscard__]]
  inline string to_string(double __val) {
    const int __n = __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n, "%f", __val);
  }

  [[__nodiscard__]]
  inline string to_string(long double __val) {
    const int __n =
        __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n, "%Lf", __val);
  }

  inline int stoi(const wstring &__str, size_t *__idx = 0, int __base = 10) {
    return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
                                        __idx, __base);
  }

  inline long stol(const wstring &__str, size_t *__idx = 0, int __base = 10) {
    return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(), __idx,
                             __base);
  }

  inline unsigned long stoul(const wstring &__str, size_t *__idx = 0,
                             int __base = 10) {
    return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(), __idx,
                             __base);
  }

  inline long long stoll(const wstring &__str, size_t *__idx = 0,
                         int __base = 10) {
    return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(), __idx,
                             __base);
  }

  inline unsigned long long stoull(const wstring &__str, size_t *__idx = 0,
                                   int __base = 10) {
    return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(), __idx,
                             __base);
  }

  inline float stof(const wstring &__str, size_t *__idx = 0) {
    return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx);
  }

  inline double stod(const wstring &__str, size_t *__idx = 0) {
    return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx);
  }

  inline long double stold(const wstring &__str, size_t *__idx = 0) {
    return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx);
  }

  [[__nodiscard__]]
  inline wstring to_wstring(int __val) {
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
                                            L"%d", __val);
  }

  [[__nodiscard__]]
  inline wstring to_wstring(unsigned __val) {
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                                            4 * sizeof(unsigned), L"%u", __val);
  }

  [[__nodiscard__]]
  inline wstring to_wstring(long __val) {
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
                                            L"%ld", __val);
  }

  [[__nodiscard__]]
  inline wstring to_wstring(unsigned long __val) {
    return __gnu_cxx::__to_xstring<wstring>(
        &std::vswprintf, 4 * sizeof(unsigned long), L"%lu", __val);
  }

  [[__nodiscard__]]
  inline wstring to_wstring(long long __val) {
    return __gnu_cxx::__to_xstring<wstring>(
        &std::vswprintf, 4 * sizeof(long long), L"%lld", __val);
  }

  [[__nodiscard__]]
  inline wstring to_wstring(unsigned long long __val) {
    return __gnu_cxx::__to_xstring<wstring>(
        &std::vswprintf, 4 * sizeof(unsigned long long), L"%llu", __val);
  }

  [[__nodiscard__]]
  inline wstring to_wstring(float __val) {
    const int __n = __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n, L"%f", __val);
  }

  [[__nodiscard__]]
  inline wstring to_wstring(double __val) {
    const int __n = __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n, L"%f", __val);
  }

  [[__nodiscard__]]
  inline wstring to_wstring(long double __val) {
    const int __n =
        __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n, L"%Lf",
                                            __val);
  }

  } // namespace __cxx11

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

  template <typename _CharT, typename _Alloc,
            typename _StrT = basic_string<_CharT, char_traits<_CharT>, _Alloc>>
  struct __str_hash_base : public __hash_base<size_t, _StrT> {
    [[__nodiscard__]]
    size_t operator()(const _StrT &__s) const noexcept {
      return _Hash_impl::hash(__s.data(), __s.length() * sizeof(_CharT));
    }
  };

  template <typename _Alloc>
  struct hash<basic_string<char, char_traits<char>, _Alloc>>
      : public __str_hash_base<char, _Alloc> {};

  template <typename _Alloc>
  struct hash<basic_string<wchar_t, char_traits<wchar_t>, _Alloc>>
      : public __str_hash_base<wchar_t, _Alloc> {};

  template <typename _Alloc>
  struct __is_fast_hash<
      hash<basic_string<wchar_t, char_traits<wchar_t>, _Alloc>>>
      : std::false_type {};

  template <typename _Alloc>
  struct hash<basic_string<char8_t, char_traits<char8_t>, _Alloc>>
      : public __str_hash_base<char8_t, _Alloc> {};

  template <typename _Alloc>
  struct hash<basic_string<char16_t, char_traits<char16_t>, _Alloc>>
      : public __str_hash_base<char16_t, _Alloc> {};

  template <typename _Alloc>
  struct hash<basic_string<char32_t, char_traits<char32_t>, _Alloc>>
      : public __str_hash_base<char32_t, _Alloc> {};

  template <> struct __is_fast_hash<hash<string>> : std::false_type {};
  template <> struct __is_fast_hash<hash<wstring>> : std::false_type {};
  template <> struct __is_fast_hash<hash<u16string>> : std::false_type {};
  template <> struct __is_fast_hash<hash<u32string>> : std::false_type {};

  template <> struct __is_fast_hash<hash<u8string>> : std::false_type {};
# 4472 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.h" 3
  inline namespace literals {
  inline namespace string_literals {
#pragma GCC diagnostic push

  __attribute((__abi_tag__("cxx11"))) constexpr inline basic_string<char>
  operator""s(const char *__str, size_t __len) {
    return basic_string<char>{__str, __len};
  }

  __attribute((__abi_tag__("cxx11"))) constexpr inline basic_string<wchar_t>
  operator""s(const wchar_t *__str, size_t __len) {
    return basic_string<wchar_t>{__str, __len};
  }

  __attribute((__abi_tag__("cxx11"))) constexpr inline basic_string<char8_t>
  operator""s(const char8_t *__str, size_t __len) {
    return basic_string<char8_t>{__str, __len};
  }

  __attribute((__abi_tag__("cxx11"))) constexpr inline basic_string<char16_t>
  operator""s(const char16_t *__str, size_t __len) {
    return basic_string<char16_t>{__str, __len};
  }

  __attribute((__abi_tag__("cxx11"))) constexpr inline basic_string<char32_t>
  operator""s(const char32_t *__str, size_t __len) {
    return basic_string<char32_t>{__str, __len};
  }

#pragma GCC diagnostic pop
  } // namespace string_literals
  } // namespace literals

  namespace __detail::__variant {
  template <typename> struct _Never_valueless_alt;

  template <typename _Tp, typename _Traits, typename _Alloc>
  struct _Never_valueless_alt<std::basic_string<_Tp, _Traits, _Alloc>>
      : __and_<is_nothrow_move_constructible<
                   std::basic_string<_Tp, _Traits, _Alloc>>,
               is_nothrow_move_assignable<
                   std::basic_string<_Tp, _Traits, _Alloc>>>::type {};
  } // namespace __detail::__variant

} // namespace std
# 55 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.tcc" 1 3
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.tcc" 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _CharT, typename _Traits, typename _Alloc>
  const typename basic_string<_CharT, _Traits, _Alloc>::size_type
      basic_string<_CharT, _Traits, _Alloc>::npos;

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr void basic_string<_CharT, _Traits, _Alloc>::swap(basic_string &
                                                             __s) noexcept {
    if (this == std::__addressof(__s))
      return;

    _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

    if (_M_is_local())
      if (__s._M_is_local()) {
        if (length() && __s.length()) {
          _CharT __tmp_data[_S_local_capacity + 1];
          traits_type::copy(__tmp_data, __s._M_local_buf, __s.length() + 1);
          traits_type::copy(__s._M_local_buf, _M_local_buf, length() + 1);
          traits_type::copy(_M_local_buf, __tmp_data, __s.length() + 1);
        } else if (__s.length()) {
          _M_init_local_buf();
          traits_type::copy(_M_local_buf, __s._M_local_buf, __s.length() + 1);
          _M_length(__s.length());
          __s._M_set_length(0);
          return;
        } else if (length()) {
          __s._M_init_local_buf();
          traits_type::copy(__s._M_local_buf, _M_local_buf, length() + 1);
          __s._M_length(length());
          _M_set_length(0);
          return;
        }
      } else {
        const size_type __tmp_capacity = __s._M_allocated_capacity;
        __s._M_init_local_buf();
        traits_type::copy(__s._M_local_buf, _M_local_buf, length() + 1);
        _M_data(__s._M_data());
        __s._M_data(__s._M_local_buf);
        _M_capacity(__tmp_capacity);
      }
    else {
      const size_type __tmp_capacity = _M_allocated_capacity;
      if (__s._M_is_local()) {
        _M_init_local_buf();
        traits_type::copy(_M_local_buf, __s._M_local_buf, __s.length() + 1);
        __s._M_data(_M_data());
        _M_data(_M_local_buf);
      } else {
        pointer __tmp_ptr = _M_data();
        _M_data(__s._M_data());
        __s._M_data(__tmp_ptr);
        _M_capacity(__s._M_allocated_capacity);
      }
      __s._M_capacity(__tmp_capacity);
    }

    const size_type __tmp_length = length();
    _M_length(__s.length());
    __s._M_length(__tmp_length);
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr typename basic_string<_CharT, _Traits, _Alloc>::pointer
  basic_string<_CharT, _Traits, _Alloc>::_M_create(size_type & __capacity,
                                                   size_type __old_capacity) {

    if (__capacity > max_size())
      std::__throw_length_error(("basic_string::_M_create"));

    if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
      __capacity = 2 * __old_capacity;

      if (__capacity > max_size())
        __capacity = max_size();
    }

    return _S_allocate(_M_get_allocator(), __capacity + 1);
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  template <typename _InIterator>
  constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_construct(
      _InIterator __beg, _InIterator __end, std::input_iterator_tag) {
    size_type __len = 0;
    size_type __capacity = size_type(_S_local_capacity);

    _M_init_local_buf();

    while (__beg != __end && __len < __capacity) {
      _M_local_buf[__len++] = *__beg;
      ++__beg;
    }

    struct _Guard {
      constexpr explicit _Guard(basic_string *__s) : _M_guarded(__s) {}

      constexpr ~_Guard() {
        if (_M_guarded)
          _M_guarded->_M_dispose();
      }

      basic_string *_M_guarded;
    } __guard(this);

    while (__beg != __end) {
      if (__len == __capacity) {

        __capacity = __len + 1;
        pointer __another = _M_create(__capacity, __len);
        this->_S_copy(__another, _M_data(), __len);
        _M_dispose();
        _M_data(__another);
        _M_capacity(__capacity);
      }
      traits_type::assign(_M_data()[__len++], *__beg);
      ++__beg;
    }

    __guard._M_guarded = 0;

    _M_set_length(__len);
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  template <typename _InIterator>
  constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_construct(
      _InIterator __beg, _InIterator __end, std::forward_iterator_tag) {
    size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

    if (__dnew > size_type(_S_local_capacity)) {
      _M_data(_M_create(__dnew, size_type(0)));
      _M_capacity(__dnew);
    } else
      _M_init_local_buf();

    struct _Guard {
      constexpr explicit _Guard(basic_string *__s) : _M_guarded(__s) {}

      constexpr ~_Guard() {
        if (_M_guarded)
          _M_guarded->_M_dispose();
      }

      basic_string *_M_guarded;
    } __guard(this);

    this->_S_copy_chars(_M_data(), __beg, __end);

    __guard._M_guarded = 0;

    _M_set_length(__dnew);
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_construct(
      size_type __n, _CharT __c) {
    if (__n > size_type(_S_local_capacity)) {
      _M_data(_M_create(__n, size_type(0)));
      _M_capacity(__n);
    } else
      _M_init_local_buf();

    if (__n)
      this->_S_assign(_M_data(), __n, __c);

    _M_set_length(__n);
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_assign(
      const basic_string &__str) {
    if (this != std::__addressof(__str)) {
      const size_type __rsize = __str.length();
      const size_type __capacity = capacity();

      if (__rsize > __capacity) {
        size_type __new_capacity = __rsize;
        pointer __tmp = _M_create(__new_capacity, __capacity);
        _M_dispose();
        _M_data(__tmp);
        _M_capacity(__new_capacity);
      }

      if (__rsize)
        this->_S_copy(_M_data(), __str._M_data(), __rsize);

      _M_set_length(__rsize);
    }
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr void basic_string<_CharT, _Traits, _Alloc>::reserve(
      size_type __res) {
    const size_type __capacity = capacity();

    if (__res <= __capacity)
      return;

    pointer __tmp = _M_create(__res, __capacity);
    this->_S_copy(__tmp, _M_data(), length() + 1);
    _M_dispose();
    _M_data(__tmp);
    _M_capacity(__res);
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_mutate(
      size_type __pos, size_type __len1, const _CharT *__s, size_type __len2) {
    const size_type __how_much = length() - __pos - __len1;

    size_type __new_capacity = length() + __len2 - __len1;
    pointer __r = _M_create(__new_capacity, capacity());

    if (__pos)
      this->_S_copy(__r, _M_data(), __pos);
    if (__s && __len2)
      this->_S_copy(__r + __pos, __s, __len2);
    if (__how_much)
      this->_S_copy(__r + __pos + __len2, _M_data() + __pos + __len1,
                    __how_much);

    _M_dispose();
    _M_data(__r);
    _M_capacity(__new_capacity);
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr void basic_string<_CharT, _Traits, _Alloc>::_M_erase(
      size_type __pos, size_type __n) {
    const size_type __how_much = length() - __pos - __n;

    if (__how_much && __n)
      this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

    _M_set_length(length() - __n);
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr void basic_string<_CharT, _Traits, _Alloc>::reserve() {
    if (_M_is_local())
      return;

    const size_type __length = length();
    const size_type __capacity = _M_allocated_capacity;

    if (__length <= size_type(_S_local_capacity)) {
      _M_init_local_buf();
      this->_S_copy(_M_local_buf, _M_data(), __length + 1);
      _M_destroy(__capacity);
      _M_data(_M_local_data());
    }

    else if (__length < __capacity)
      try {
        pointer __tmp = _S_allocate(_M_get_allocator(), __length + 1);
        this->_S_copy(__tmp, _M_data(), __length + 1);
        _M_dispose();
        _M_data(__tmp);
        _M_capacity(__length);
      } catch (const __cxxabiv1::__forced_unwind &) {
        throw;
      } catch (...) {
      }
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr void basic_string<_CharT, _Traits, _Alloc>::resize(size_type __n,
                                                               _CharT __c) {
    const size_type __size = this->size();
    if (__size < __n)
      this->append(__n - __size, __c);
    else if (__n < __size)
      this->_M_set_length(__n);
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr basic_string<_CharT, _Traits, _Alloc> &
  basic_string<_CharT, _Traits, _Alloc>::_M_append(const _CharT *__s,
                                                   size_type __n) {
    const size_type __len = __n + this->size();

    if (__len <= this->capacity()) {
      if (__n)
        this->_S_copy(this->_M_data() + this->size(), __s, __n);
    } else
      this->_M_mutate(this->size(), size_type(0), __s, __n);

    this->_M_set_length(__len);
    return *this;
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  template <typename _InputIterator>
  constexpr basic_string<_CharT, _Traits, _Alloc> &
  basic_string<_CharT, _Traits, _Alloc>::_M_replace_dispatch(
      const_iterator __i1, const_iterator __i2, _InputIterator __k1,
      _InputIterator __k2, std::__false_type) {

    const basic_string __s(__k1, __k2, this->get_allocator());
    const size_type __n1 = __i2 - __i1;
    return _M_replace(__i1 - begin(), __n1, __s._M_data(), __s.size());
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr basic_string<_CharT, _Traits, _Alloc> &
  basic_string<_CharT, _Traits, _Alloc>::_M_replace_aux(
      size_type __pos1, size_type __n1, size_type __n2, _CharT __c) {
    _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

    const size_type __old_size = this->size();
    const size_type __new_size = __old_size + __n2 - __n1;

    if (__new_size <= this->capacity()) {
      pointer __p = this->_M_data() + __pos1;

      const size_type __how_much = __old_size - __pos1 - __n1;
      if (__how_much && __n1 != __n2)
        this->_S_move(__p + __n2, __p + __n1, __how_much);
    } else
      this->_M_mutate(__pos1, __n1, 0, __n2);

    if (__n2)
      this->_S_assign(this->_M_data() + __pos1, __n2, __c);

    this->_M_set_length(__new_size);
    return *this;
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  __attribute__((__noinline__, __noclone__, __cold__)) void
  basic_string<_CharT, _Traits, _Alloc>::_M_replace_cold(
      pointer __p, size_type __len1, const _CharT *__s, const size_type __len2,
      const size_type __how_much) {

    if (__len2 && __len2 <= __len1)
      this->_S_move(__p, __s, __len2);
    if (__how_much && __len1 != __len2)
      this->_S_move(__p + __len2, __p + __len1, __how_much);
    if (__len2 > __len1) {
      if (__s + __len2 <= __p + __len1)
        this->_S_move(__p, __s, __len2);
      else if (__s >= __p + __len1) {

        const size_type __poff = (__s - __p) + (__len2 - __len1);
        this->_S_copy(__p, __p + __poff, __len2);
      } else {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft);
      }
    }
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr basic_string<_CharT, _Traits, _Alloc> &
  basic_string<_CharT, _Traits, _Alloc>::_M_replace(
      size_type __pos, size_type __len1, const _CharT *__s,
      const size_type __len2) {
    _M_check_length(__len1, __len2, "basic_string::_M_replace");

    const size_type __old_size = this->size();
    const size_type __new_size = __old_size + __len2 - __len1;

    if (__new_size <= this->capacity()) {
      pointer __p = this->_M_data() + __pos;

      const size_type __how_much = __old_size - __pos - __len1;

      if (std::is_constant_evaluated()) {
        auto __newp = _S_allocate(_M_get_allocator(), __new_size);
        _S_copy(__newp, this->_M_data(), __pos);
        _S_copy(__newp + __pos, __s, __len2);
        _S_copy(__newp + __pos + __len2, __p + __len1, __how_much);
        _S_copy(this->_M_data(), __newp, __new_size);
        this->_M_get_allocator().deallocate(__newp, __new_size);
      } else

          if (__builtin_expect(_M_disjunct(__s), true)) {
        if (__how_much && __len1 != __len2)
          this->_S_move(__p + __len2, __p + __len1, __how_much);
        if (__len2)
          this->_S_copy(__p, __s, __len2);
      } else
        _M_replace_cold(__p, __len1, __s, __len2, __how_much);
    } else
      this->_M_mutate(__pos, __len1, __s, __len2);

    this->_M_set_length(__new_size);
    return *this;
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type
  basic_string<_CharT, _Traits, _Alloc>::copy(_CharT * __s, size_type __n,
                                              size_type __pos) const {
    _M_check(__pos, "basic_string::copy");
    __n = _M_limit(__pos, __n);
    ;
    if (__n)
      _S_copy(__s, _M_data() + __pos, __n);

    return __n;
  }
# 615 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.tcc" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type
  basic_string<_CharT, _Traits, _Alloc>::find(
      const _CharT *__s, size_type __pos, size_type __n) const noexcept {
    ;
    const size_type __size = this->size();

    if (__n == 0)
      return __pos <= __size ? __pos : npos;
    if (__pos >= __size)
      return npos;

    const _CharT __elem0 = __s[0];
    const _CharT *const __data = data();
    const _CharT *__first = __data + __pos;
    const _CharT *const __last = __data + __size;
    size_type __len = __size - __pos;

    while (__len >= __n) {

      __first = traits_type::find(__first, __len - __n + 1, __elem0);
      if (!__first)
        return npos;

      if (traits_type::compare(__first, __s, __n) == 0)
        return __first - __data;
      __len = __last - ++__first;
    }
    return npos;
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type
  basic_string<_CharT, _Traits, _Alloc>::find(_CharT __c, size_type __pos)
      const noexcept {
    size_type __ret = npos;
    const size_type __size = this->size();
    if (__pos < __size) {
      const _CharT *__data = _M_data();
      const size_type __n = __size - __pos;
      const _CharT *__p = traits_type::find(__data + __pos, __n, __c);
      if (__p)
        __ret = __p - __data;
    }
    return __ret;
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type
  basic_string<_CharT, _Traits, _Alloc>::rfind(
      const _CharT *__s, size_type __pos, size_type __n) const noexcept {
    ;
    const size_type __size = this->size();
    if (__n <= __size) {
      __pos = std::min(size_type(__size - __n), __pos);
      const _CharT *__data = _M_data();
      do {
        if (traits_type::compare(__data + __pos, __s, __n) == 0)
          return __pos;
      } while (__pos-- > 0);
    }
    return npos;
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type
  basic_string<_CharT, _Traits, _Alloc>::rfind(_CharT __c, size_type __pos)
      const noexcept {
    size_type __size = this->size();
    if (__size) {
      if (--__size > __pos)
        __size = __pos;
      for (++__size; __size-- > 0;)
        if (traits_type::eq(_M_data()[__size], __c))
          return __size;
    }
    return npos;
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type
  basic_string<_CharT, _Traits, _Alloc>::find_first_of(
      const _CharT *__s, size_type __pos, size_type __n) const noexcept {
    ;
    for (; __n && __pos < this->size(); ++__pos) {
      const _CharT *__p = traits_type::find(__s, __n, _M_data()[__pos]);
      if (__p)
        return __pos;
    }
    return npos;
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type
  basic_string<_CharT, _Traits, _Alloc>::find_last_of(
      const _CharT *__s, size_type __pos, size_type __n) const noexcept {
    ;
    size_type __size = this->size();
    if (__size && __n) {
      if (--__size > __pos)
        __size = __pos;
      do {
        if (traits_type::find(__s, __n, _M_data()[__size]))
          return __size;
      } while (__size-- != 0);
    }
    return npos;
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type
  basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(
      const _CharT *__s, size_type __pos, size_type __n) const noexcept {
    ;
    for (; __pos < this->size(); ++__pos)
      if (!traits_type::find(__s, __n, _M_data()[__pos]))
        return __pos;
    return npos;
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type
  basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(
      _CharT __c, size_type __pos) const noexcept {
    for (; __pos < this->size(); ++__pos)
      if (!traits_type::eq(_M_data()[__pos], __c))
        return __pos;
    return npos;
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type
  basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(
      const _CharT *__s, size_type __pos, size_type __n) const noexcept {
    ;
    size_type __size = this->size();
    if (__size) {
      if (--__size > __pos)
        __size = __pos;
      do {
        if (!traits_type::find(__s, __n, _M_data()[__size]))
          return __size;
      } while (__size--);
    }
    return npos;
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  constexpr typename basic_string<_CharT, _Traits, _Alloc>::size_type
  basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(
      _CharT __c, size_type __pos) const noexcept {
    size_type __size = this->size();
    if (__size) {
      if (--__size > __pos)
        __size = __pos;
      do {
        if (!traits_type::eq(_M_data()[__size], __c))
          return __size;
      } while (__size--);
    }
    return npos;
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  basic_istream<_CharT, _Traits> &operator>>(
      basic_istream<_CharT, _Traits> &__in,
      basic_string<_CharT, _Traits, _Alloc> &__str) {
    typedef basic_istream<_CharT, _Traits> __istream_type;
    typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename __istream_type::ios_base __ios_base;
    typedef typename __istream_type::int_type __int_type;
    typedef typename __string_type::size_type __size_type;
    typedef ctype<_CharT> __ctype_type;
    typedef typename __ctype_type::ctype_base __ctype_base;

    __size_type __extracted = 0;
    typename __ios_base::iostate __err = __ios_base::goodbit;
    typename __istream_type::sentry __cerb(__in, false);
    if (__cerb) {
      try {

        __str.erase();
        _CharT __buf[128];
        __size_type __len = 0;
        const streamsize __w = __in.width();
        const __size_type __n =
            __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();
        const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
        const __int_type __eof = _Traits::eof();
        __int_type __c = __in.rdbuf()->sgetc();

        while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) &&
               !__ct.is(__ctype_base::space, _Traits::to_char_type(__c))) {
          if (__len == sizeof(__buf) / sizeof(_CharT)) {
            __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
            __len = 0;
          }
          __buf[__len++] = _Traits::to_char_type(__c);
          ++__extracted;
          __c = __in.rdbuf()->snextc();
        }
        __str.append(__buf, __len);

        if (__extracted < __n && _Traits::eq_int_type(__c, __eof))
          __err |= __ios_base::eofbit;
        __in.width(0);
      } catch (__cxxabiv1::__forced_unwind &) {
        __in._M_setstate(__ios_base::badbit);
        throw;
      } catch (...) {

        __in._M_setstate(__ios_base::badbit);
      }
    }

    if (!__extracted)
      __err |= __ios_base::failbit;
    if (__err)
      __in.setstate(__err);
    return __in;
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  basic_istream<_CharT, _Traits> &getline(
      basic_istream<_CharT, _Traits> & __in,
      basic_string<_CharT, _Traits, _Alloc> & __str, _CharT __delim) {
    typedef basic_istream<_CharT, _Traits> __istream_type;
    typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename __istream_type::ios_base __ios_base;
    typedef typename __istream_type::int_type __int_type;
    typedef typename __string_type::size_type __size_type;

    __size_type __extracted = 0;
    const __size_type __n = __str.max_size();
    typename __ios_base::iostate __err = __ios_base::goodbit;
    typename __istream_type::sentry __cerb(__in, true);
    if (__cerb) {
      try {
        __str.erase();
        const __int_type __idelim = _Traits::to_int_type(__delim);
        const __int_type __eof = _Traits::eof();
        __int_type __c = __in.rdbuf()->sgetc();

        while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) &&
               !_Traits::eq_int_type(__c, __idelim)) {
          __str += _Traits::to_char_type(__c);
          ++__extracted;
          __c = __in.rdbuf()->snextc();
        }

        if (_Traits::eq_int_type(__c, __eof))
          __err |= __ios_base::eofbit;
        else if (_Traits::eq_int_type(__c, __idelim)) {
          ++__extracted;
          __in.rdbuf()->sbumpc();
        } else
          __err |= __ios_base::failbit;
      } catch (__cxxabiv1::__forced_unwind &) {
        __in._M_setstate(__ios_base::badbit);
        throw;
      } catch (...) {

        __in._M_setstate(__ios_base::badbit);
      }
    }
    if (!__extracted)
      __err |= __ios_base::failbit;
    if (__err)
      __in.setstate(__err);
    return __in;
  }
# 977 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.tcc" 3
  extern template void basic_string<char>::_M_replace_cold(
      char *, size_type, const char *, const size_type, const size_type);

  extern template basic_istream<char> &operator>>(basic_istream<char> &,
                                                  string &);
  extern template basic_ostream<char> &operator<<(basic_ostream<char> &,
                                                  const string &);
  extern template basic_istream<char> &getline(basic_istream<char> &, string &,
                                               char);
  extern template basic_istream<char> &getline(basic_istream<char> &, string &);
# 1003 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_string.tcc" 3
  extern template void basic_string<wchar_t>::_M_replace_cold(
      wchar_t *, size_type, const wchar_t *, const size_type, const size_type);

  extern template basic_istream<wchar_t> &operator>>(basic_istream<wchar_t> &,
                                                     wstring &);
  extern template basic_ostream<wchar_t> &operator<<(basic_ostream<wchar_t> &,
                                                     const wstring &);
  extern template basic_istream<wchar_t> &getline(basic_istream<wchar_t> &,
                                                  wstring &, wchar_t);
  extern template basic_istream<wchar_t> &getline(basic_istream<wchar_t> &,
                                                  wstring &);

} // namespace std
# 56 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memory_resource.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memory_resource.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstddef" 1 3
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstddef" 3

# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3
# 72 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_ptrdiff_t.h" 1 3
# 18 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_ptrdiff_t.h" 3
typedef long int ptrdiff_t;
# 73 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3

# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3
# 18 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3
# 87 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_wchar_t.h" 1 3
# 88 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3

# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3

# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_nullptr_t.h" 1 3
# 98 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3
# 112 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_offsetof.h" 1 3
# 113 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3
# 51 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstddef" 2 3

extern "C++" {

namespace std {

using ::max_align_t;
}

namespace std {

enum class byte : unsigned char {};

template <typename _IntegerType> struct __byte_operand {};
template <> struct __byte_operand<bool> {
  using __type = byte;
};
template <> struct __byte_operand<char> {
  using __type = byte;
};
template <> struct __byte_operand<signed char> {
  using __type = byte;
};
template <> struct __byte_operand<unsigned char> {
  using __type = byte;
};
template <> struct __byte_operand<wchar_t> {
  using __type = byte;
};

template <> struct __byte_operand<char8_t> {
  using __type = byte;
};

template <> struct __byte_operand<char16_t> {
  using __type = byte;
};
template <> struct __byte_operand<char32_t> {
  using __type = byte;
};
template <> struct __byte_operand<short> {
  using __type = byte;
};
template <> struct __byte_operand<unsigned short> {
  using __type = byte;
};
template <> struct __byte_operand<int> {
  using __type = byte;
};
template <> struct __byte_operand<unsigned int> {
  using __type = byte;
};
template <> struct __byte_operand<long> {
  using __type = byte;
};
template <> struct __byte_operand<unsigned long> {
  using __type = byte;
};
template <> struct __byte_operand<long long> {
  using __type = byte;
};
template <> struct __byte_operand<unsigned long long> {
  using __type = byte;
};
# 108 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstddef" 3
template <typename _IntegerType>
struct __byte_operand<const _IntegerType> : __byte_operand<_IntegerType> {};
template <typename _IntegerType>
struct __byte_operand<volatile _IntegerType> : __byte_operand<_IntegerType> {};
template <typename _IntegerType>
struct __byte_operand<const volatile _IntegerType>
    : __byte_operand<_IntegerType> {};

template <typename _IntegerType>
using __byte_op_t = typename __byte_operand<_IntegerType>::__type;

template <typename _IntegerType>
[[__gnu__::__always_inline__]]
constexpr __byte_op_t<_IntegerType> operator<<(byte __b,
                                               _IntegerType __shift) noexcept {
  return (byte)(unsigned char)((unsigned)__b << __shift);
}

template <typename _IntegerType>
[[__gnu__::__always_inline__]]
constexpr __byte_op_t<_IntegerType> operator>>(byte __b,
                                               _IntegerType __shift) noexcept {
  return (byte)(unsigned char)((unsigned)__b >> __shift);
}

[[__gnu__::__always_inline__]]
constexpr byte operator|(byte __l, byte __r) noexcept {
  return (byte)(unsigned char)((unsigned)__l | (unsigned)__r);
}

[[__gnu__::__always_inline__]]
constexpr byte operator&(byte __l, byte __r) noexcept {
  return (byte)(unsigned char)((unsigned)__l & (unsigned)__r);
}

[[__gnu__::__always_inline__]]
constexpr byte operator^(byte __l, byte __r) noexcept {
  return (byte)(unsigned char)((unsigned)__l ^ (unsigned)__r);
}

[[__gnu__::__always_inline__]]
constexpr byte operator~(byte __b) noexcept {
  return (byte)(unsigned char)~(unsigned)__b;
}

template <typename _IntegerType>
[[__gnu__::__always_inline__]]
constexpr __byte_op_t<_IntegerType> &
operator<<=(byte &__b, _IntegerType __shift) noexcept {
  return __b = __b << __shift;
}

template <typename _IntegerType>
[[__gnu__::__always_inline__]]
constexpr __byte_op_t<_IntegerType> &
operator>>=(byte &__b, _IntegerType __shift) noexcept {
  return __b = __b >> __shift;
}

[[__gnu__::__always_inline__]]
constexpr byte &operator|=(byte &__l, byte __r) noexcept {
  return __l = __l | __r;
}

[[__gnu__::__always_inline__]]
constexpr byte &operator&=(byte &__l, byte __r) noexcept {
  return __l = __l & __r;
}

[[__gnu__::__always_inline__]]
constexpr byte &operator^=(byte &__l, byte __r) noexcept {
  return __l = __l ^ __r;
}

template <typename _IntegerType>
[[nodiscard, __gnu__::__always_inline__]]
constexpr _IntegerType to_integer(__byte_op_t<_IntegerType> __b) noexcept {
  return _IntegerType(__b);
}

} // namespace std
}
# 39 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memory_resource.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/uses_allocator.h" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/uses_allocator.h" 3
namespace std __attribute__((__visibility__("default"))) {

  struct __erased_type {};

  template <typename _Alloc, typename _Tp>
  using __is_erased_or_convertible =
      __or_<is_convertible<_Alloc, _Tp>, is_same<_Tp, __erased_type>>;

  struct allocator_arg_t {
    explicit allocator_arg_t() = default;
  };

  inline constexpr allocator_arg_t allocator_arg = allocator_arg_t();

  template <typename _Tp, typename _Alloc, typename = __void_t<>>
  struct __uses_allocator_helper : false_type {};

  template <typename _Tp, typename _Alloc>
  struct __uses_allocator_helper<_Tp, _Alloc,
                                 __void_t<typename _Tp::allocator_type>>
      : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type {
  };

  template <typename _Tp, typename _Alloc>
  struct uses_allocator : __uses_allocator_helper<_Tp, _Alloc>::type {};

  struct __uses_alloc_base {};

  struct __uses_alloc0 : __uses_alloc_base {
    struct _Sink {
      void constexpr operator=(const void *) {}
    } _M_a;
  };

  template <typename _Alloc> struct __uses_alloc1 : __uses_alloc_base {
    const _Alloc *_M_a;
  };

  template <typename _Alloc> struct __uses_alloc2 : __uses_alloc_base {
    const _Alloc *_M_a;
  };

  template <bool, typename _Tp, typename _Alloc, typename... _Args>
  struct __uses_alloc;

  template <typename _Tp, typename _Alloc, typename... _Args>
  struct __uses_alloc<true, _Tp, _Alloc, _Args...>
      : __conditional_t<is_constructible<_Tp, allocator_arg_t, const _Alloc &,
                                         _Args...>::value,
                        __uses_alloc1<_Alloc>, __uses_alloc2<_Alloc>> {

    static_assert(
        __or_<is_constructible<_Tp, allocator_arg_t, const _Alloc &, _Args...>,
              is_constructible<_Tp, _Args..., const _Alloc &>>::value,
        "construction with an allocator must be possible"
        " if uses_allocator is true");
  };

  template <typename _Tp, typename _Alloc, typename... _Args>
  struct __uses_alloc<false, _Tp, _Alloc, _Args...> : __uses_alloc0 {};

  template <typename _Tp, typename _Alloc, typename... _Args>
  using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template <typename _Tp, typename _Alloc, typename... _Args>
  constexpr inline __uses_alloc_t<_Tp, _Alloc, _Args...> __use_alloc(
      const _Alloc &__a) {
    __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
    __ret._M_a = std::__addressof(__a);
    return __ret;
  }

  template <typename _Tp, typename _Alloc, typename... _Args>
  void __use_alloc(const _Alloc &&) = delete;

  template <typename _Tp, typename _Alloc>
  inline constexpr bool uses_allocator_v = uses_allocator<_Tp, _Alloc>::value;

  template <template <typename...> class _Predicate, typename _Tp,
            typename _Alloc, typename... _Args>
  struct __is_uses_allocator_predicate
      : __conditional_t<
            uses_allocator<_Tp, _Alloc>::value,
            __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,
                  _Predicate<_Tp, _Args..., _Alloc>>,
            _Predicate<_Tp, _Args...>> {};

  template <typename _Tp, typename _Alloc, typename... _Args>
  struct __is_uses_allocator_constructible
      : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...> {
  };

  template <typename _Tp, typename _Alloc, typename... _Args>
  inline constexpr bool __is_uses_allocator_constructible_v =
      __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;

  template <typename _Tp, typename _Alloc, typename... _Args>
  struct __is_nothrow_uses_allocator_constructible
      : __is_uses_allocator_predicate<is_nothrow_constructible, _Tp, _Alloc,
                                      _Args...> {};

  template <typename _Tp, typename _Alloc, typename... _Args>
  inline constexpr bool __is_nothrow_uses_allocator_constructible_v =
      __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;

  template <typename _Tp, typename... _Args>
  void __uses_allocator_construct_impl(__uses_alloc0, _Tp * __ptr,
                                       _Args && ...__args) {
    ::new ((void *)__ptr) _Tp(std::forward<_Args>(__args)...);
  }

  template <typename _Tp, typename _Alloc, typename... _Args>
  void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp * __ptr,
                                       _Args && ...__args) {
    ::new ((void *)__ptr)
        _Tp(allocator_arg, *__a._M_a, std::forward<_Args>(__args)...);
  }

  template <typename _Tp, typename _Alloc, typename... _Args>
  void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp * __ptr,
                                       _Args && ...__args) {
    ::new ((void *)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a);
  }

  template <typename _Tp, typename _Alloc, typename... _Args>
  void __uses_allocator_construct(const _Alloc &__a, _Tp *__ptr,
                                  _Args &&...__args) {
    std::__uses_allocator_construct_impl(
        std::__use_alloc<_Tp, _Alloc, _Args...>(__a), __ptr,
        std::forward<_Args>(__args)...);
  }

} // namespace std
# 41 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memory_resource.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/uses_allocator_args.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/uses_allocator_args.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
# 44 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_util.h" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_util.h" 3
namespace std __attribute__((__visibility__("default"))) {

  namespace ranges {

  namespace __detail {
  template <typename _Range>
  concept __simple_view =
      view<_Range> && range<const _Range> &&
      same_as<iterator_t<_Range>, iterator_t<const _Range>> &&
      same_as<sentinel_t<_Range>, sentinel_t<const _Range>>;

  template <typename _It>
  concept __has_arrow =
      input_iterator<_It> &&
      (is_pointer_v<_It> || requires(_It __it) { __it.operator->(); });

  using std::__detail::__different_from;
  } // namespace __detail

  template <typename _Derived>
    requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
  class view_interface {
  private:
    constexpr _Derived &_M_derived() noexcept {
      static_assert(derived_from<_Derived, view_interface<_Derived>>);
      static_assert(view<_Derived>);
      return static_cast<_Derived &>(*this);
    }

    constexpr const _Derived &_M_derived() const noexcept {
      static_assert(derived_from<_Derived, view_interface<_Derived>>);
      static_assert(view<_Derived>);
      return static_cast<const _Derived &>(*this);
    }

    static constexpr bool _S_bool(bool) noexcept;

    template <typename _Tp>
    static constexpr bool _S_empty(_Tp &__t) noexcept(
        noexcept(_S_bool(ranges::begin(__t) == ranges::end(__t)))) {
      return ranges::begin(__t) == ranges::end(__t);
    }

    template <typename _Tp>
    static constexpr auto _S_size(_Tp &__t) noexcept(
        noexcept(ranges::end(__t) - ranges::begin(__t))) {
      return ranges::end(__t) - ranges::begin(__t);
    }

  public:
    constexpr bool empty() noexcept(noexcept(_S_empty(_M_derived())))
      requires forward_range<_Derived> && (!sized_range<_Derived>)
    {
      return _S_empty(_M_derived());
    }

    constexpr bool empty() noexcept(noexcept(ranges::size(_M_derived()) == 0))
      requires sized_range<_Derived>
    {
      return ranges::size(_M_derived()) == 0;
    }

    constexpr bool empty() const noexcept(noexcept(_S_empty(_M_derived())))
      requires forward_range<const _Derived> && (!sized_range<const _Derived>)
    {
      return _S_empty(_M_derived());
    }

    constexpr bool empty() const
        noexcept(noexcept(ranges::size(_M_derived()) == 0))
      requires sized_range<const _Derived>
    {
      return ranges::size(_M_derived()) == 0;
    }

    constexpr explicit
    operator bool() noexcept(noexcept(ranges::empty(_M_derived())))
      requires requires { ranges::empty(_M_derived()); }
    {
      return !ranges::empty(_M_derived());
    }

    constexpr explicit operator bool() const
        noexcept(noexcept(ranges::empty(_M_derived())))
      requires requires { ranges::empty(_M_derived()); }
    {
      return !ranges::empty(_M_derived());
    }

    constexpr auto data() noexcept(noexcept(ranges::begin(_M_derived())))
      requires contiguous_iterator<iterator_t<_Derived>>
    {
      return std::to_address(ranges::begin(_M_derived()));
    }

    constexpr auto data() const noexcept(noexcept(ranges::begin(_M_derived())))
      requires range<const _Derived> &&
               contiguous_iterator<iterator_t<const _Derived>>
    {
      return std::to_address(ranges::begin(_M_derived()));
    }

    constexpr auto size() noexcept(noexcept(_S_size(_M_derived())))
      requires forward_range<_Derived> &&
               sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>>
    {
      return _S_size(_M_derived());
    }

    constexpr auto size() const noexcept(noexcept(_S_size(_M_derived())))
      requires forward_range<const _Derived> &&
               sized_sentinel_for<sentinel_t<const _Derived>,
                                  iterator_t<const _Derived>>
    {
      return _S_size(_M_derived());
    }

    constexpr decltype(auto) front()
      requires forward_range<_Derived>
    {
      do {
        if (std::__is_constant_evaluated() && !bool(!empty()))
          __builtin_unreachable();
      } while (false);
      return *ranges::begin(_M_derived());
    }

    constexpr decltype(auto) front() const
      requires forward_range<const _Derived>
    {
      do {
        if (std::__is_constant_evaluated() && !bool(!empty()))
          __builtin_unreachable();
      } while (false);
      return *ranges::begin(_M_derived());
    }

    constexpr decltype(auto) back()
      requires bidirectional_range<_Derived> && common_range<_Derived>
    {
      do {
        if (std::__is_constant_evaluated() && !bool(!empty()))
          __builtin_unreachable();
      } while (false);
      return *ranges::prev(ranges::end(_M_derived()));
    }

    constexpr decltype(auto) back() const
      requires bidirectional_range<const _Derived> &&
               common_range<const _Derived>
    {
      do {
        if (std::__is_constant_evaluated() && !bool(!empty()))
          __builtin_unreachable();
      } while (false);
      return *ranges::prev(ranges::end(_M_derived()));
    }

    template <random_access_range _Range = _Derived>
    constexpr decltype(auto) operator[](range_difference_t<_Range> __n) {
      return ranges::begin(_M_derived())[__n];
    }

    template <random_access_range _Range = const _Derived>
    constexpr decltype(auto) operator[](range_difference_t<_Range> __n) const {
      return ranges::begin(_M_derived())[__n];
    }
# 211 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_util.h" 3
  };

  namespace __detail {
  template <typename _From, typename _To>
  concept __uses_nonqualification_pointer_conversion =
      is_pointer_v<_From> && is_pointer_v<_To> &&
      !convertible_to<remove_pointer_t<_From> (*)[],
                      remove_pointer_t<_To> (*)[]>;

  template <typename _From, typename _To>
  concept __convertible_to_non_slicing =
      convertible_to<_From, _To> &&
      !__uses_nonqualification_pointer_conversion<decay_t<_From>, decay_t<_To>>;

  template <typename _Tp>
  concept __pair_like = !is_reference_v<_Tp> && requires(_Tp __t) {
    typename tuple_size<_Tp>::type;
    requires derived_from<tuple_size<_Tp>, integral_constant<size_t, 2>>;
    typename tuple_element_t<0, remove_const_t<_Tp>>;
    typename tuple_element_t<1, remove_const_t<_Tp>>;
    { get<0>(__t) } -> convertible_to<const tuple_element_t<0, _Tp> &>;
    { get<1>(__t) } -> convertible_to<const tuple_element_t<1, _Tp> &>;
  };

  template <typename _Tp, typename _Up, typename _Vp>
  concept __pair_like_convertible_from =
      !range<_Tp> && __pair_like<_Tp> && constructible_from<_Tp, _Up, _Vp> &&
      __convertible_to_non_slicing<_Up, tuple_element_t<0, _Tp>> &&
      convertible_to<_Vp, tuple_element_t<1, _Tp>>;

  } // namespace __detail

  namespace views {
  struct _Drop;
  }

  enum class subrange_kind : bool { unsized, sized };

  template <input_or_output_iterator _It, sentinel_for<_It> _Sent = _It,
            subrange_kind _Kind = sized_sentinel_for<_Sent, _It>
                                      ? subrange_kind::sized
                                      : subrange_kind::unsized>
    requires(_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _It>)
  class subrange : public view_interface<subrange<_It, _Sent, _Kind>> {
  private:
    static constexpr bool _S_store_size =
        _Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _It>;

    friend struct views::_Drop;

    _It _M_begin = _It();
    [[no_unique_address]] _Sent _M_end = _Sent();

    using __size_type =
        __detail::__make_unsigned_like_t<iter_difference_t<_It>>;

    template <typename _Tp, bool = _S_store_size> struct _Size {
      [[__gnu__::__always_inline__]]
      constexpr _Size(_Tp = {}) {}
    };

    template <typename _Tp> struct _Size<_Tp, true> {
      [[__gnu__::__always_inline__]]
      constexpr _Size(_Tp __s = {})
          : _M_size(__s) {}

      _Tp _M_size;
    };

    [[no_unique_address]] _Size<__size_type> _M_size = {};

  public:
    subrange()
      requires default_initializable<_It>
    = default;

    constexpr subrange(
        __detail::__convertible_to_non_slicing<_It> auto __i,
        _Sent __s) noexcept(is_nothrow_constructible_v<_It, decltype(__i)> &&
                            is_nothrow_constructible_v<_Sent, _Sent &>)
      requires(!_S_store_size)
        : _M_begin(std::move(__i)), _M_end(__s) {}

    constexpr subrange(
        __detail::__convertible_to_non_slicing<_It> auto __i, _Sent __s,
        __size_type
            __n) noexcept(is_nothrow_constructible_v<_It, decltype(__i)> &&
                          is_nothrow_constructible_v<_Sent, _Sent &>)
      requires(_Kind == subrange_kind::sized)
        : _M_begin(std::move(__i)), _M_end(__s), _M_size(__n) {}

    template <__detail::__different_from<subrange> _Rng>
      requires borrowed_range<_Rng> &&
               __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It> &&
               convertible_to<sentinel_t<_Rng>, _Sent>
               constexpr subrange(_Rng &&__r) noexcept(
                   noexcept(subrange(__r, ranges::size(__r))))
                 requires _S_store_size && sized_range<_Rng>
        : subrange(__r, ranges::size(__r)) {}

    template <__detail::__different_from<subrange> _Rng>
      requires borrowed_range<_Rng> &&
               __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It> &&
               convertible_to<sentinel_t<_Rng>, _Sent>
               constexpr subrange(_Rng &&__r) noexcept(
                   noexcept(subrange(ranges::begin(__r), ranges::end(__r))))
                 requires(!_S_store_size)
        : subrange(ranges::begin(__r), ranges::end(__r)) {}

    template <borrowed_range _Rng>
      requires __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It> &&
               convertible_to<sentinel_t<_Rng>, _Sent>
               constexpr subrange(_Rng &&__r, __size_type __n) noexcept(
                   noexcept(subrange(ranges::begin(__r), ranges::end(__r),
                                     __n)))
                 requires(_Kind == subrange_kind::sized)
        : subrange{ranges::begin(__r), ranges::end(__r), __n} {}

    template <__detail::__different_from<subrange> _PairLike>
      requires __detail::__pair_like_convertible_from<_PairLike, const _It &,
                                                      const _Sent &>
    constexpr operator _PairLike() const {
      return _PairLike(_M_begin, _M_end);
    }

    constexpr _It begin() const
      requires copyable<_It>
    {
      return _M_begin;
    }

    [[nodiscard]] constexpr _It begin()
      requires(!copyable<_It>)
    {
      return std::move(_M_begin);
    }

    constexpr _Sent end() const { return _M_end; }

    constexpr bool empty() const { return _M_begin == _M_end; }

    constexpr __size_type size() const
      requires(_Kind == subrange_kind::sized)
    {
      if constexpr (_S_store_size)
        return _M_size._M_size;
      else
        return __detail::__to_unsigned_like(_M_end - _M_begin);
    }

    [[nodiscard]] constexpr subrange
    next(iter_difference_t<_It> __n = 1) const &
      requires forward_iterator<_It>
    {
      auto __tmp = *this;
      __tmp.advance(__n);
      return __tmp;
    }

    [[nodiscard]] constexpr subrange next(iter_difference_t<_It> __n = 1) && {
      advance(__n);
      return std::move(*this);
    }

    [[nodiscard]] constexpr subrange prev(iter_difference_t<_It> __n = 1) const
      requires bidirectional_iterator<_It>
    {
      auto __tmp = *this;
      __tmp.advance(-__n);
      return __tmp;
    }

    constexpr subrange &advance(iter_difference_t<_It> __n) {

      if constexpr (bidirectional_iterator<_It>)
        if (__n < 0) {
          ranges::advance(_M_begin, __n);
          if constexpr (_S_store_size)
            _M_size._M_size += __detail::__to_unsigned_like(-__n);
          return *this;
        }

      do {
        if (std::__is_constant_evaluated() && !bool(__n >= 0))
          __builtin_unreachable();
      } while (false);
      auto __d = __n - ranges::advance(_M_begin, __n, _M_end);
      if constexpr (_S_store_size)
        _M_size._M_size -= __detail::__to_unsigned_like(__d);
      return *this;
    }
  };

  template <input_or_output_iterator _It, sentinel_for<_It> _Sent>
  subrange(_It, _Sent) -> subrange<_It, _Sent>;

  template <input_or_output_iterator _It, sentinel_for<_It> _Sent>
  subrange(_It, _Sent, __detail::__make_unsigned_like_t<iter_difference_t<_It>>)
      -> subrange<_It, _Sent, subrange_kind::sized>;

  template <borrowed_range _Rng>
  subrange(_Rng &&)
      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,
                  (sized_range<_Rng> ||
                   sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>)
                      ? subrange_kind::sized
                      : subrange_kind::unsized>;

  template <borrowed_range _Rng>
  subrange(_Rng &&, __detail::__make_unsigned_like_t<range_difference_t<_Rng>>)
      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;

  template <size_t _Num, class _It, class _Sent, subrange_kind _Kind>
    requires(_Num < 2)
  constexpr auto get(const subrange<_It, _Sent, _Kind> &__r) {
    if constexpr (_Num == 0)
      return __r.begin();
    else
      return __r.end();
  }

  template <size_t _Num, class _It, class _Sent, subrange_kind _Kind>
    requires(_Num < 2)
  constexpr auto get(subrange<_It, _Sent, _Kind> &&__r) {
    if constexpr (_Num == 0)
      return __r.begin();
    else
      return __r.end();
  }

  template <typename _It, typename _Sent, subrange_kind _Kind>
  inline constexpr bool enable_borrowed_range<subrange<_It, _Sent, _Kind>> =
      true;

  template <range _Range>
  using borrowed_subrange_t =
      __conditional_t<borrowed_range<_Range>, subrange<iterator_t<_Range>>,
                      dangling>;
  } // namespace ranges

  namespace ranges {
  struct __find_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,
              typename _Proj = identity>
      requires indirect_binary_predicate<ranges::equal_to,
                                         projected<_Iter, _Proj>, const _Tp *>
    constexpr _Iter operator()(_Iter __first, _Sent __last, const _Tp &__value,
                               _Proj __proj = {}) const {
      while (__first != __last && !(std::__invoke(__proj, *__first) == __value))
        ++__first;
      return __first;
    }

    template <input_range _Range, typename _Tp, typename _Proj = identity>
      requires indirect_binary_predicate<
          ranges::equal_to, projected<iterator_t<_Range>, _Proj>, const _Tp *>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r, const _Tp &__value, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), __value,
                     std::move(__proj));
    }
  };

  inline constexpr __find_fn find{};

  struct __find_if_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    constexpr _Iter operator()(_Iter __first, _Sent __last, _Pred __pred,
                               _Proj __proj = {}) const {
      while (__first != __last &&
             !(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
        ++__first;
      return __first;
    }

    template <
        input_range _Range, typename _Proj = identity,
        indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    constexpr borrowed_iterator_t<_Range> operator()(_Range &&__r, _Pred __pred,
                                                     _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred),
                     std::move(__proj));
    }
  };

  inline constexpr __find_if_fn find_if{};

  struct __find_if_not_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    constexpr _Iter operator()(_Iter __first, _Sent __last, _Pred __pred,
                               _Proj __proj = {}) const {
      while (__first != __last &&
             (bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
        ++__first;
      return __first;
    }

    template <
        input_range _Range, typename _Proj = identity,
        indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    constexpr borrowed_iterator_t<_Range> operator()(_Range &&__r, _Pred __pred,
                                                     _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred),
                     std::move(__proj));
    }
  };

  inline constexpr __find_if_not_fn find_if_not{};

  template <typename _Iter1, typename _Iter2> struct in_in_result {
    [[no_unique_address]] _Iter1 in1;
    [[no_unique_address]] _Iter2 in2;

    template <typename _IIter1, typename _IIter2>
      requires convertible_to<const _Iter1 &, _IIter1> &&
               convertible_to<const _Iter2 &, _IIter2>
    constexpr operator in_in_result<_IIter1, _IIter2>() const & {
      return {in1, in2};
    }

    template <typename _IIter1, typename _IIter2>
      requires convertible_to<_Iter1, _IIter1> &&
               convertible_to<_Iter2, _IIter2>
    constexpr operator in_in_result<_IIter1, _IIter2>() && {
      return {std::move(in1), std::move(in2)};
    }
  };

  template <typename _Iter1, typename _Iter2>
  using mismatch_result = in_in_result<_Iter1, _Iter2>;

  struct __mismatch_fn {
    template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
              typename _Pred = ranges::equal_to, typename _Proj1 = identity,
              typename _Proj2 = identity>
      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
    constexpr mismatch_result<_Iter1, _Iter2>
    operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
               _Pred __pred = {}, _Proj1 __proj1 = {},
               _Proj2 __proj2 = {}) const {
      while (__first1 != __last1 && __first2 != __last2 &&
             (bool)std::__invoke(__pred, std::__invoke(__proj1, *__first1),
                                 std::__invoke(__proj2, *__first2))) {
        ++__first1;
        ++__first2;
      }
      return {std::move(__first1), std::move(__first2)};
    }

    template <input_range _Range1, input_range _Range2,
              typename _Pred = ranges::equal_to, typename _Proj1 = identity,
              typename _Proj2 = identity>
      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
                                     _Pred, _Proj1, _Proj2>
    constexpr mismatch_result<iterator_t<_Range1>, iterator_t<_Range2>>
    operator()(_Range1 &&__r1, _Range2 &&__r2, _Pred __pred = {},
               _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      return (*this)(ranges::begin(__r1), ranges::end(__r1),
                     ranges::begin(__r2), ranges::end(__r2), std::move(__pred),
                     std::move(__proj1), std::move(__proj2));
    }
  };

  inline constexpr __mismatch_fn mismatch{};

  struct __search_fn {
    template <forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
              typename _Pred = ranges::equal_to, typename _Proj1 = identity,
              typename _Proj2 = identity>
      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
    constexpr subrange<_Iter1>
    operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
               _Pred __pred = {}, _Proj1 __proj1 = {},
               _Proj2 __proj2 = {}) const {
      if (__first1 == __last1 || __first2 == __last2)
        return {__first1, __first1};

      for (;;) {
        for (;;) {
          if (__first1 == __last1)
            return {__first1, __first1};
          if (std::__invoke(__pred, std::__invoke(__proj1, *__first1),
                            std::__invoke(__proj2, *__first2)))
            break;
          ++__first1;
        }
        auto __cur1 = __first1;
        auto __cur2 = __first2;
        for (;;) {
          if (++__cur2 == __last2)
            return {__first1, ++__cur1};
          if (++__cur1 == __last1)
            return {__cur1, __cur1};
          if (!(bool)std::__invoke(__pred, std::__invoke(__proj1, *__cur1),
                                   std::__invoke(__proj2, *__cur2))) {
            ++__first1;
            break;
          }
        }
      }
    }

    template <forward_range _Range1, forward_range _Range2,
              typename _Pred = ranges::equal_to, typename _Proj1 = identity,
              typename _Proj2 = identity>
      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
                                     _Pred, _Proj1, _Proj2>
    constexpr borrowed_subrange_t<_Range1>
    operator()(_Range1 &&__r1, _Range2 &&__r2, _Pred __pred = {},
               _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      return (*this)(ranges::begin(__r1), ranges::end(__r1),
                     ranges::begin(__r2), ranges::end(__r2), std::move(__pred),
                     std::move(__proj1), std::move(__proj2));
    }
  };

  inline constexpr __search_fn search{};

  struct __min_fn {
    template <typename _Tp, typename _Proj = identity,
              indirect_strict_weak_order<projected<const _Tp *, _Proj>> _Comp =
                  ranges::less>
    constexpr const _Tp &operator()(const _Tp &__a, const _Tp &__b,
                                    _Comp __comp = {},
                                    _Proj __proj = {}) const {
      if (std::__invoke(__comp, std::__invoke(__proj, __b),
                        std::__invoke(__proj, __a)))
        return __b;
      else
        return __a;
    }

    template <input_range _Range, typename _Proj = identity,
              indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
                  _Comp = ranges::less>
      requires indirectly_copyable_storable<iterator_t<_Range>,
                                            range_value_t<_Range> *>
    constexpr range_value_t<_Range> operator()(_Range &&__r, _Comp __comp = {},
                                               _Proj __proj = {}) const {
      auto __first = ranges::begin(__r);
      auto __last = ranges::end(__r);
      do {
        if (std::__is_constant_evaluated() && !bool(__first != __last))
          __builtin_unreachable();
      } while (false);
      auto __result = *__first;
      while (++__first != __last) {
        auto __tmp = *__first;
        if (std::__invoke(__comp, std::__invoke(__proj, __tmp),
                          std::__invoke(__proj, __result)))
          __result = std::move(__tmp);
      }
      return __result;
    }

    template <copyable _Tp, typename _Proj = identity,
              indirect_strict_weak_order<projected<const _Tp *, _Proj>> _Comp =
                  ranges::less>
    constexpr _Tp operator()(initializer_list<_Tp> __r, _Comp __comp = {},
                             _Proj __proj = {}) const {
      return (*this)(ranges::subrange(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __min_fn min{};

  struct __adjacent_find_fn {
    template <forward_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_binary_predicate<projected<_Iter, _Proj>,
                                        projected<_Iter, _Proj>>
                  _Pred = ranges::equal_to>
    constexpr _Iter operator()(_Iter __first, _Sent __last, _Pred __pred = {},
                               _Proj __proj = {}) const {
      if (__first == __last)
        return __first;
      auto __next = __first;
      for (; ++__next != __last; __first = __next) {
        if (std::__invoke(__pred, std::__invoke(__proj, *__first),
                          std::__invoke(__proj, *__next)))
          return __first;
      }
      return __next;
    }

    template <forward_range _Range, typename _Proj = identity,
              indirect_binary_predicate<projected<iterator_t<_Range>, _Proj>,
                                        projected<iterator_t<_Range>, _Proj>>
                  _Pred = ranges::equal_to>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r, _Pred __pred = {}, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred),
                     std::move(__proj));
    }
  };

  inline constexpr __adjacent_find_fn adjacent_find{};

  } // namespace ranges

  using ranges::get;

  template <typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
  struct tuple_size<ranges::subrange<_Iter, _Sent, _Kind>>
      : integral_constant<size_t, 2> {};

  template <typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
  struct tuple_element<0, ranges::subrange<_Iter, _Sent, _Kind>> {
    using type = _Iter;
  };

  template <typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
  struct tuple_element<1, ranges::subrange<_Iter, _Sent, _Kind>> {
    using type = _Sent;
  };

  template <typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
  struct tuple_element<0, const ranges::subrange<_Iter, _Sent, _Kind>> {
    using type = _Iter;
  };

  template <typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
  struct tuple_element<1, const ranges::subrange<_Iter, _Sent, _Kind>> {
    using type = _Sent;
  };

} // namespace std
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 2 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename... _Elements> class tuple;

  template <typename _Tp> struct __is_empty_non_tuple : is_empty<_Tp> {};

  template <typename _El0, typename... _El>
  struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type {};

  template <typename _Tp>
  using __empty_not_final =
      __conditional_t<__is_final(_Tp), false_type, __is_empty_non_tuple<_Tp>>;

  template <size_t _Idx, typename _Head, bool = __empty_not_final<_Head>::value>
  struct _Head_base;

  template <size_t _Idx, typename _Head> struct _Head_base<_Idx, _Head, true> {
    constexpr _Head_base() : _M_head_impl() {}

    constexpr _Head_base(const _Head &__h) : _M_head_impl(__h) {}

    constexpr _Head_base(const _Head_base &) = default;
    constexpr _Head_base(_Head_base &&) = default;

    template <typename _UHead>
    constexpr _Head_base(_UHead &&__h)
        : _M_head_impl(std::forward<_UHead>(__h)) {}

    constexpr _Head_base(allocator_arg_t, __uses_alloc0) : _M_head_impl() {}

    template <typename _Alloc>
    constexpr _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
        : _M_head_impl(allocator_arg, *__a._M_a) {}

    template <typename _Alloc>
    constexpr _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
        : _M_head_impl(*__a._M_a) {}

    template <typename _UHead>
    constexpr _Head_base(__uses_alloc0, _UHead &&__uhead)
        : _M_head_impl(std::forward<_UHead>(__uhead)) {}

    template <typename _Alloc, typename _UHead>
    constexpr _Head_base(__uses_alloc1<_Alloc> __a, _UHead &&__uhead)
        : _M_head_impl(allocator_arg, *__a._M_a,
                       std::forward<_UHead>(__uhead)) {}

    template <typename _Alloc, typename _UHead>
    constexpr _Head_base(__uses_alloc2<_Alloc> __a, _UHead &&__uhead)
        : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) {}

    static constexpr _Head &_M_head(_Head_base &__b) noexcept {
      return __b._M_head_impl;
    }

    static constexpr const _Head &_M_head(const _Head_base &__b) noexcept {
      return __b._M_head_impl;
    }

    [[__no_unique_address__]] _Head _M_head_impl;
  };
# 187 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
  template <size_t _Idx, typename _Head> struct _Head_base<_Idx, _Head, false> {
    constexpr _Head_base() : _M_head_impl() {}

    constexpr _Head_base(const _Head &__h) : _M_head_impl(__h) {}

    constexpr _Head_base(const _Head_base &) = default;
    constexpr _Head_base(_Head_base &&) = default;

    template <typename _UHead>
    constexpr _Head_base(_UHead &&__h)
        : _M_head_impl(std::forward<_UHead>(__h)) {}

    constexpr _Head_base(allocator_arg_t, __uses_alloc0) : _M_head_impl() {}

    template <typename _Alloc>
    constexpr _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
        : _M_head_impl(allocator_arg, *__a._M_a) {}

    template <typename _Alloc>
    constexpr _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
        : _M_head_impl(*__a._M_a) {}

    template <typename _UHead>
    constexpr _Head_base(__uses_alloc0, _UHead &&__uhead)
        : _M_head_impl(std::forward<_UHead>(__uhead)) {}

    template <typename _Alloc, typename _UHead>
    constexpr _Head_base(__uses_alloc1<_Alloc> __a, _UHead &&__uhead)
        : _M_head_impl(allocator_arg, *__a._M_a,
                       std::forward<_UHead>(__uhead)) {}

    template <typename _Alloc, typename _UHead>
    constexpr _Head_base(__uses_alloc2<_Alloc> __a, _UHead &&__uhead)
        : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) {}

    static constexpr _Head &_M_head(_Head_base &__b) noexcept {
      return __b._M_head_impl;
    }

    static constexpr const _Head &_M_head(const _Head_base &__b) noexcept {
      return __b._M_head_impl;
    }

    _Head _M_head_impl;
  };
# 250 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
  template <size_t _Idx, typename... _Elements> struct _Tuple_impl;

  template <size_t _Idx, typename _Head, typename... _Tail>
  struct _Tuple_impl<_Idx, _Head, _Tail...>
      : public _Tuple_impl<_Idx + 1, _Tail...>,
        private _Head_base<_Idx, _Head> {
    template <size_t, typename...> friend struct _Tuple_impl;

    typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
    typedef _Head_base<_Idx, _Head> _Base;

    static constexpr _Head &_M_head(_Tuple_impl &__t) noexcept {
      return _Base::_M_head(__t);
    }

    static constexpr const _Head &_M_head(const _Tuple_impl &__t) noexcept {
      return _Base::_M_head(__t);
    }

    static constexpr _Inherited &_M_tail(_Tuple_impl &__t) noexcept {
      return __t;
    }

    static constexpr const _Inherited &
    _M_tail(const _Tuple_impl &__t) noexcept {
      return __t;
    }

    constexpr _Tuple_impl() : _Inherited(), _Base() {}

    explicit constexpr _Tuple_impl(const _Head &__head, const _Tail &...__tail)
        : _Inherited(__tail...), _Base(__head) {}

    template <typename _UHead, typename... _UTail,
              typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>>
    explicit constexpr _Tuple_impl(_UHead &&__head, _UTail &&...__tail)
        : _Inherited(std::forward<_UTail>(__tail)...),
          _Base(std::forward<_UHead>(__head)) {}

    constexpr _Tuple_impl(const _Tuple_impl &) = default;

    _Tuple_impl &operator=(const _Tuple_impl &) = delete;

    _Tuple_impl(_Tuple_impl &&) = default;

    template <typename... _UElements>
    constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...> &__in)
        : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
          _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) {}

    template <typename _UHead, typename... _UTails>
    constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...> &&__in)
        : _Inherited(
              std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
          _Base(std::forward<_UHead>(
              _Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) {}
# 338 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
    template <typename _Alloc>
    constexpr _Tuple_impl(allocator_arg_t __tag, const _Alloc &__a)
        : _Inherited(__tag, __a), _Base(__tag, __use_alloc<_Head>(__a)) {}

    template <typename _Alloc>
    constexpr _Tuple_impl(allocator_arg_t __tag, const _Alloc &__a,
                          const _Head &__head, const _Tail &...__tail)
        : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) {}

    template <typename _Alloc, typename _UHead, typename... _UTail,
              typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>>
    constexpr _Tuple_impl(allocator_arg_t __tag, const _Alloc &__a,
                          _UHead &&__head, _UTail &&...__tail)
        : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(__head)) {}

    template <typename _Alloc>
    constexpr _Tuple_impl(allocator_arg_t __tag, const _Alloc &__a,
                          const _Tuple_impl &__in)
        : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) {}

    template <typename _Alloc>
    constexpr _Tuple_impl(allocator_arg_t __tag, const _Alloc &__a,
                          _Tuple_impl &&__in)
        : _Inherited(__tag, __a, std::move(_M_tail(__in))),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
                std::forward<_Head>(_M_head(__in))) {}

    template <typename _Alloc, typename _UHead, typename... _UTails>
    constexpr _Tuple_impl(allocator_arg_t __tag, const _Alloc &__a,
                          const _Tuple_impl<_Idx, _UHead, _UTails...> &__in)
        : _Inherited(__tag, __a,
                     _Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, const _UHead &>(__a),
                _Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)) {}

    template <typename _Alloc, typename _UHead, typename... _UTails>
    constexpr _Tuple_impl(allocator_arg_t __tag, const _Alloc &__a,
                          _Tuple_impl<_Idx, _UHead, _UTails...> &&__in)
        : _Inherited(
              __tag, __a,
              std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(
                    _Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) {}
# 424 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
    template <typename... _UElements>
    constexpr void _M_assign(const _Tuple_impl<_Idx, _UElements...> &__in) {
      _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
      _M_tail(*this)._M_assign(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
    }

    template <typename _UHead, typename... _UTails>
    constexpr void _M_assign(_Tuple_impl<_Idx, _UHead, _UTails...> &&__in) {
      _M_head(*this) = std::forward<_UHead>(
          _Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
      _M_tail(*this)._M_assign(
          std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
    }
# 466 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
  protected:
    constexpr void _M_swap(_Tuple_impl &__in) {
      using std::swap;
      swap(_M_head(*this), _M_head(__in));
      _Inherited::_M_swap(_M_tail(__in));
    }
# 485 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
  };

  template <size_t _Idx, typename _Head>
  struct _Tuple_impl<_Idx, _Head> : private _Head_base<_Idx, _Head> {
    template <size_t, typename...> friend struct _Tuple_impl;

    typedef _Head_base<_Idx, _Head> _Base;

    static constexpr _Head &_M_head(_Tuple_impl &__t) noexcept {
      return _Base::_M_head(__t);
    }

    static constexpr const _Head &_M_head(const _Tuple_impl &__t) noexcept {
      return _Base::_M_head(__t);
    }

    constexpr _Tuple_impl() : _Base() {}

    explicit constexpr _Tuple_impl(const _Head &__head) : _Base(__head) {}

    template <typename _UHead>
    explicit constexpr _Tuple_impl(_UHead &&__head)
        : _Base(std::forward<_UHead>(__head)) {}

    constexpr _Tuple_impl(const _Tuple_impl &) = default;

    _Tuple_impl &operator=(const _Tuple_impl &) = delete;

    constexpr _Tuple_impl(_Tuple_impl &&__in) noexcept(
        is_nothrow_move_constructible<_Head>::value)
        : _Base(static_cast<_Base &&>(__in)) {}

    template <typename _UHead>
    constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead> &__in)
        : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) {}

    template <typename _UHead>
    constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead> &&__in)
        : _Base(
              std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in))) {}
# 559 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
    template <typename _Alloc>
    constexpr _Tuple_impl(allocator_arg_t __tag, const _Alloc &__a)
        : _Base(__tag, __use_alloc<_Head>(__a)) {}

    template <typename _Alloc>
    constexpr _Tuple_impl(allocator_arg_t, const _Alloc &__a,
                          const _Head &__head)
        : _Base(__use_alloc<_Head, _Alloc, const _Head &>(__a), __head) {}

    template <typename _Alloc, typename _UHead>
    constexpr _Tuple_impl(allocator_arg_t, const _Alloc &__a, _UHead &&__head)
        : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(__head)) {}

    template <typename _Alloc>
    constexpr _Tuple_impl(allocator_arg_t, const _Alloc &__a,
                          const _Tuple_impl &__in)
        : _Base(__use_alloc<_Head, _Alloc, const _Head &>(__a), _M_head(__in)) {
    }

    template <typename _Alloc>
    constexpr _Tuple_impl(allocator_arg_t, const _Alloc &__a,
                          _Tuple_impl &&__in)
        : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
                std::forward<_Head>(_M_head(__in))) {}

    template <typename _Alloc, typename _UHead>
    constexpr _Tuple_impl(allocator_arg_t, const _Alloc &__a,
                          const _Tuple_impl<_Idx, _UHead> &__in)
        : _Base(__use_alloc<_Head, _Alloc, const _UHead &>(__a),
                _Tuple_impl<_Idx, _UHead>::_M_head(__in)) {}

    template <typename _Alloc, typename _UHead>
    constexpr _Tuple_impl(allocator_arg_t, const _Alloc &__a,
                          _Tuple_impl<_Idx, _UHead> &&__in)
        : _Base(
              __use_alloc<_Head, _Alloc, _UHead>(__a),
              std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in))) {}
# 629 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
    template <typename _UHead>
    constexpr void _M_assign(const _Tuple_impl<_Idx, _UHead> &__in) {
      _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
    }

    template <typename _UHead>
    constexpr void _M_assign(_Tuple_impl<_Idx, _UHead> &&__in) {
      _M_head(*this) =
          std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
    }
# 663 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
  protected:
    constexpr void _M_swap(_Tuple_impl &__in) {
      using std::swap;
      swap(_M_head(*this), _M_head(__in));
    }
# 680 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
  };

  template <bool, typename... _Types> struct _TupleConstraints {
    template <typename... _UTypes>
    using __constructible = __and_<is_constructible<_Types, _UTypes>...>;

    template <typename... _UTypes>
    using __convertible = __and_<is_convertible<_UTypes, _Types>...>;

    template <typename... _UTypes>
    static constexpr bool __is_implicitly_constructible() {
      return __and_<__constructible<_UTypes...>,
                    __convertible<_UTypes...>>::value;
    }

    template <typename... _UTypes>
    static constexpr bool __is_explicitly_constructible() {
      return __and_<__constructible<_UTypes...>,
                    __not_<__convertible<_UTypes...>>>::value;
    }

    static constexpr bool __is_implicitly_default_constructible() {
      return __and_<
          std::__is_implicitly_default_constructible<_Types>...>::value;
    }

    static constexpr bool __is_explicitly_default_constructible() {
      return __and_<is_default_constructible<_Types>...,
                    __not_<__and_<std::__is_implicitly_default_constructible<
                        _Types>...>>>::value;
    }
  };

  template <typename... _Types> struct _TupleConstraints<false, _Types...> {
    template <typename... _UTypes>
    static constexpr bool __is_implicitly_constructible() {
      return false;
    }

    template <typename... _UTypes>
    static constexpr bool __is_explicitly_constructible() {
      return false;
    }
  };

  template <typename... _Elements>
  class tuple : public _Tuple_impl<0, _Elements...> {
    typedef _Tuple_impl<0, _Elements...> _Inherited;

    template <bool _Cond> using _TCC = _TupleConstraints<_Cond, _Elements...>;

    template <bool _Dummy>
    using _ImplicitDefaultCtor =
        __enable_if_t<_TCC<_Dummy>::__is_implicitly_default_constructible(),
                      bool>;

    template <bool _Dummy>
    using _ExplicitDefaultCtor =
        __enable_if_t<_TCC<_Dummy>::__is_explicitly_default_constructible(),
                      bool>;

    template <bool _Cond, typename... _Args>
    using _ImplicitCtor = __enable_if_t<
        _TCC<_Cond>::template __is_implicitly_constructible<_Args...>(), bool>;

    template <bool _Cond, typename... _Args>
    using _ExplicitCtor = __enable_if_t<
        _TCC<_Cond>::template __is_explicitly_constructible<_Args...>(), bool>;

    template <typename... _UElements>
    static constexpr __enable_if_t<
        sizeof...(_UElements) == sizeof...(_Elements), bool>
    __assignable() {
      return __and_<is_assignable<_Elements &, _UElements>...>::value;
    }

    template <typename... _UElements>
    static constexpr bool __nothrow_assignable() {
      return __and_<is_nothrow_assignable<_Elements &, _UElements>...>::value;
    }

    template <typename... _UElements>
    static constexpr bool __nothrow_constructible() {
      return __and_<is_nothrow_constructible<_Elements, _UElements>...>::value;
    }

    template <typename _Up> static constexpr bool __valid_args() {
      return sizeof...(_Elements) == 1 &&
             !is_same<tuple, __remove_cvref_t<_Up>>::value;
    }

    template <typename, typename, typename... _Tail>
    static constexpr bool __valid_args() {
      return (sizeof...(_Tail) + 2) == sizeof...(_Elements);
    }
# 821 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
    template <typename _Tuple, typename = tuple,
              typename = __remove_cvref_t<_Tuple>>
    struct _UseOtherCtor : false_type {};

    template <typename _Tuple, typename _Tp, typename _Up>
    struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Up>>
        : __or_<is_convertible<_Tuple, _Tp>,
                is_constructible<_Tp, _Tuple>>::type {};

    template <typename _Tuple, typename _Tp>
    struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Tp>> : true_type {};

    template <typename _Tuple> static constexpr bool __use_other_ctor() {
      return _UseOtherCtor<_Tuple>::value;
    }
# 856 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
  public:
    template <typename _Dummy = void,
              _ImplicitDefaultCtor<is_void<_Dummy>::value> = true>
    constexpr tuple() noexcept(
        __and_<is_nothrow_default_constructible<_Elements>...>::value)
        : _Inherited() {}

    template <typename _Dummy = void,
              _ExplicitDefaultCtor<is_void<_Dummy>::value> = false>
    explicit constexpr tuple() noexcept(
        __and_<is_nothrow_default_constructible<_Elements>...>::value)
        : _Inherited() {}

    template <bool _NotEmpty = (sizeof...(_Elements) >= 1),
              _ImplicitCtor<_NotEmpty, const _Elements &...> = true>
    constexpr tuple(const _Elements &...__elements) noexcept(
        __nothrow_constructible<const _Elements &...>())
        : _Inherited(__elements...) {}

    template <bool _NotEmpty = (sizeof...(_Elements) >= 1),
              _ExplicitCtor<_NotEmpty, const _Elements &...> = false>
    explicit constexpr tuple(const _Elements &...__elements) noexcept(
        __nothrow_constructible<const _Elements &...>())
        : _Inherited(__elements...) {}

    template <typename... _UElements,
              bool _Valid = __valid_args<_UElements...>(),
              _ImplicitCtor<_Valid, _UElements...> = true>
    constexpr tuple(_UElements &&...__elements) noexcept(
        __nothrow_constructible<_UElements...>())
        : _Inherited(std::forward<_UElements>(__elements)...) {}

    template <typename... _UElements,
              bool _Valid = __valid_args<_UElements...>(),
              _ExplicitCtor<_Valid, _UElements...> = false>
    explicit constexpr tuple(_UElements &&...__elements) noexcept(
        __nothrow_constructible<_UElements...>())
        : _Inherited(std::forward<_UElements>(__elements)...) {}

    constexpr tuple(const tuple &) = default;

    constexpr tuple(tuple &&) = default;

    template <typename... _UElements,
              bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) &&
                            !__use_other_ctor<const tuple<_UElements...> &>(),
              _ImplicitCtor<_Valid, const _UElements &...> = true>
    constexpr tuple(const tuple<_UElements...> &__in) noexcept(
        __nothrow_constructible<const _UElements &...>())
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...> &>(__in)) {
    }

    template <typename... _UElements,
              bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) &&
                            !__use_other_ctor<const tuple<_UElements...> &>(),
              _ExplicitCtor<_Valid, const _UElements &...> = false>
    explicit constexpr tuple(const tuple<_UElements...> &__in) noexcept(
        __nothrow_constructible<const _UElements &...>())
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...> &>(__in)) {
    }

    template <typename... _UElements,
              bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) &&
                            !__use_other_ctor<tuple<_UElements...> &&>(),
              _ImplicitCtor<_Valid, _UElements...> = true>
    constexpr tuple(tuple<_UElements...> &&__in) noexcept(
        __nothrow_constructible<_UElements...>())
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...> &&>(__in)) {}

    template <typename... _UElements,
              bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) &&
                            !__use_other_ctor<tuple<_UElements...> &&>(),
              _ExplicitCtor<_Valid, _UElements...> = false>
    explicit constexpr tuple(tuple<_UElements...> &&__in) noexcept(
        __nothrow_constructible<_UElements...>())
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...> &&>(__in)) {}
# 968 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
    template <typename _Alloc,
              _ImplicitDefaultCtor<is_object<_Alloc>::value> = true>
    constexpr tuple(allocator_arg_t __tag, const _Alloc &__a)
        : _Inherited(__tag, __a) {}

    template <typename _Alloc,
              _ExplicitDefaultCtor<is_object<_Alloc>::value> = false>
    constexpr explicit tuple(allocator_arg_t __tag, const _Alloc &__a)
        : _Inherited(__tag, __a) {}

    template <typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1),
              _ImplicitCtor<_NotEmpty, const _Elements &...> = true>
    constexpr tuple(allocator_arg_t __tag, const _Alloc &__a,
                    const _Elements &...__elements)
        : _Inherited(__tag, __a, __elements...) {}

    template <typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1),
              _ExplicitCtor<_NotEmpty, const _Elements &...> = false>
    constexpr explicit tuple(allocator_arg_t __tag, const _Alloc &__a,
                             const _Elements &...__elements)
        : _Inherited(__tag, __a, __elements...) {}

    template <typename _Alloc, typename... _UElements,
              bool _Valid = __valid_args<_UElements...>(),
              _ImplicitCtor<_Valid, _UElements...> = true>
    constexpr tuple(allocator_arg_t __tag, const _Alloc &__a,
                    _UElements &&...__elements)
        : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...) {}

    template <typename _Alloc, typename... _UElements,
              bool _Valid = __valid_args<_UElements...>(),
              _ExplicitCtor<_Valid, _UElements...> = false>
    constexpr explicit tuple(allocator_arg_t __tag, const _Alloc &__a,
                             _UElements &&...__elements)
        : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...) {}

    template <typename _Alloc>
    constexpr tuple(allocator_arg_t __tag, const _Alloc &__a, const tuple &__in)
        : _Inherited(__tag, __a, static_cast<const _Inherited &>(__in)) {}

    template <typename _Alloc>
    constexpr tuple(allocator_arg_t __tag, const _Alloc &__a, tuple &&__in)
        : _Inherited(__tag, __a, static_cast<_Inherited &&>(__in)) {}

    template <typename _Alloc, typename... _UElements,
              bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) &&
                            !__use_other_ctor<const tuple<_UElements...> &>(),
              _ImplicitCtor<_Valid, const _UElements &...> = true>
    constexpr tuple(allocator_arg_t __tag, const _Alloc &__a,
                    const tuple<_UElements...> &__in)
        : _Inherited(__tag, __a,
                     static_cast<const _Tuple_impl<0, _UElements...> &>(__in)) {
    }

    template <typename _Alloc, typename... _UElements,
              bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) &&
                            !__use_other_ctor<const tuple<_UElements...> &>(),
              _ExplicitCtor<_Valid, const _UElements &...> = false>
    constexpr explicit tuple(allocator_arg_t __tag, const _Alloc &__a,
                             const tuple<_UElements...> &__in)
        : _Inherited(__tag, __a,
                     static_cast<const _Tuple_impl<0, _UElements...> &>(__in)) {
    }

    template <typename _Alloc, typename... _UElements,
              bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) &&
                            !__use_other_ctor<tuple<_UElements...> &&>(),
              _ImplicitCtor<_Valid, _UElements...> = true>
    constexpr tuple(allocator_arg_t __tag, const _Alloc &__a,
                    tuple<_UElements...> &&__in)
        : _Inherited(__tag, __a,
                     static_cast<_Tuple_impl<0, _UElements...> &&>(__in)) {}

    template <typename _Alloc, typename... _UElements,
              bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements)) &&
                            !__use_other_ctor<tuple<_UElements...> &&>(),
              _ExplicitCtor<_Valid, _UElements...> = false>
    constexpr explicit tuple(allocator_arg_t __tag, const _Alloc &__a,
                             tuple<_UElements...> &&__in)
        : _Inherited(__tag, __a,
                     static_cast<_Tuple_impl<0, _UElements...> &&>(__in)) {}
# 1099 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
    constexpr tuple &
    operator=(__conditional_t<__assignable<const _Elements &...>(),
                              const tuple &, const __nonesuch &>
                  __in) noexcept(__nothrow_assignable<const _Elements &...>()) {
      this->_M_assign(__in);
      return *this;
    }

    constexpr tuple &operator=(
        __conditional_t<__assignable<_Elements...>(), tuple &&, __nonesuch &&>
            __in) noexcept(__nothrow_assignable<_Elements...>()) {
      this->_M_assign(std::move(__in));
      return *this;
    }

    template <typename... _UElements>
    constexpr __enable_if_t<__assignable<const _UElements &...>(), tuple &>
    operator=(const tuple<_UElements...> &__in) noexcept(
        __nothrow_assignable<const _UElements &...>()) {
      this->_M_assign(__in);
      return *this;
    }

    template <typename... _UElements>
    constexpr __enable_if_t<__assignable<_UElements...>(), tuple &>
    operator=(tuple<_UElements...> &&__in) noexcept(
        __nothrow_assignable<_UElements...>()) {
      this->_M_assign(std::move(__in));
      return *this;
    }
# 1180 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
    constexpr void swap(tuple &__in) noexcept(
        __and_<__is_nothrow_swappable<_Elements>...>::value) {
      _Inherited::_M_swap(__in);
    }
# 1199 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
  };

  template <typename... _UTypes> tuple(_UTypes...) -> tuple<_UTypes...>;
  template <typename _T1, typename _T2>
  tuple(pair<_T1, _T2>) -> tuple<_T1, _T2>;
  template <typename _Alloc, typename... _UTypes>
  tuple(allocator_arg_t, _Alloc, _UTypes...) -> tuple<_UTypes...>;
  template <typename _Alloc, typename _T1, typename _T2>
  tuple(allocator_arg_t, _Alloc, pair<_T1, _T2>) -> tuple<_T1, _T2>;
  template <typename _Alloc, typename... _UTypes>
  tuple(allocator_arg_t, _Alloc, tuple<_UTypes...>) -> tuple<_UTypes...>;

  template <> class tuple<> {
  public:
    constexpr void swap(tuple &) noexcept {}

    tuple() = default;

    template <typename _Alloc>
    constexpr tuple(allocator_arg_t, const _Alloc &) noexcept {}
    template <typename _Alloc>
    constexpr tuple(allocator_arg_t, const _Alloc &, const tuple &) noexcept {}
  };

  template <typename _T1, typename _T2>
  class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2> {
    typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    template <bool _Dummy, typename _U1, typename _U2>
    using _ImplicitDefaultCtor =
        __enable_if_t<_TupleConstraints<_Dummy, _U1, _U2>::
                          __is_implicitly_default_constructible(),
                      bool>;

    template <bool _Dummy, typename _U1, typename _U2>
    using _ExplicitDefaultCtor =
        __enable_if_t<_TupleConstraints<_Dummy, _U1, _U2>::
                          __is_explicitly_default_constructible(),
                      bool>;

    template <bool _Dummy> using _TCC = _TupleConstraints<_Dummy, _T1, _T2>;

    template <bool _Cond, typename _U1, typename _U2>
    using _ImplicitCtor = __enable_if_t<
        _TCC<_Cond>::template __is_implicitly_constructible<_U1, _U2>(), bool>;

    template <bool _Cond, typename _U1, typename _U2>
    using _ExplicitCtor = __enable_if_t<
        _TCC<_Cond>::template __is_explicitly_constructible<_U1, _U2>(), bool>;

    template <typename _U1, typename _U2> static constexpr bool __assignable() {
      return __and_<is_assignable<_T1 &, _U1>,
                    is_assignable<_T2 &, _U2>>::value;
    }

    template <typename _U1, typename _U2>
    static constexpr bool __nothrow_assignable() {
      return __and_<is_nothrow_assignable<_T1 &, _U1>,
                    is_nothrow_assignable<_T2 &, _U2>>::value;
    }

    template <typename _U1, typename _U2>
    static constexpr bool __nothrow_constructible() {
      return __and_<is_nothrow_constructible<_T1, _U1>,
                    is_nothrow_constructible<_T2, _U2>>::value;
    }

    static constexpr bool __nothrow_default_constructible() {
      return __and_<is_nothrow_default_constructible<_T1>,
                    is_nothrow_default_constructible<_T2>>::value;
    }

    template <typename _U1> static constexpr bool __is_alloc_arg() {
      return is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value;
    }
# 1313 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
  public:
    template <bool _Dummy = true, _ImplicitDefaultCtor<_Dummy, _T1, _T2> = true>
    constexpr tuple() noexcept(__nothrow_default_constructible())
        : _Inherited() {}

    template <bool _Dummy = true,
              _ExplicitDefaultCtor<_Dummy, _T1, _T2> = false>
    explicit constexpr tuple() noexcept(__nothrow_default_constructible())
        : _Inherited() {}

    template <bool _Dummy = true,
              _ImplicitCtor<_Dummy, const _T1 &, const _T2 &> = true>
    constexpr tuple(const _T1 &__a1, const _T2 &__a2) noexcept(
        __nothrow_constructible<const _T1 &, const _T2 &>())
        : _Inherited(__a1, __a2) {}

    template <bool _Dummy = true,
              _ExplicitCtor<_Dummy, const _T1 &, const _T2 &> = false>
    explicit constexpr tuple(const _T1 &__a1, const _T2 &__a2) noexcept(
        __nothrow_constructible<const _T1 &, const _T2 &>())
        : _Inherited(__a1, __a2) {}

    template <typename _U1, typename _U2,
              _ImplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = true>
    constexpr tuple(_U1 &&__a1,
                    _U2 &&__a2) noexcept(__nothrow_constructible<_U1, _U2>())
        : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) {}

    template <typename _U1, typename _U2,
              _ExplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = false>
    explicit constexpr tuple(_U1 &&__a1, _U2 &&__a2) noexcept(
        __nothrow_constructible<_U1, _U2>())
        : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) {}

    constexpr tuple(const tuple &) = default;

    constexpr tuple(tuple &&) = default;

    template <typename _U1, typename _U2,
              _ImplicitCtor<true, const _U1 &, const _U2 &> = true>
    constexpr tuple(const tuple<_U1, _U2> &__in) noexcept(
        __nothrow_constructible<const _U1 &, const _U2 &>())
        : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2> &>(__in)) {}

    template <typename _U1, typename _U2,
              _ExplicitCtor<true, const _U1 &, const _U2 &> = false>
    explicit constexpr tuple(const tuple<_U1, _U2> &__in) noexcept(
        __nothrow_constructible<const _U1 &, const _U2 &>())
        : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2> &>(__in)) {}

    template <typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true>
    constexpr tuple(tuple<_U1, _U2> &&__in) noexcept(
        __nothrow_constructible<_U1, _U2>())
        : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2> &&>(__in)) {}

    template <typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false>
    explicit constexpr tuple(tuple<_U1, _U2> &&__in) noexcept(
        __nothrow_constructible<_U1, _U2>())
        : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2> &&>(__in)) {}
# 1406 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
    template <typename _U1, typename _U2,
              _ImplicitCtor<true, const _U1 &, const _U2 &> = true>
    constexpr tuple(const pair<_U1, _U2> &__in) noexcept(
        __nothrow_constructible<const _U1 &, const _U2 &>())
        : _Inherited(__in.first, __in.second) {}

    template <typename _U1, typename _U2,
              _ExplicitCtor<true, const _U1 &, const _U2 &> = false>
    explicit constexpr tuple(const pair<_U1, _U2> &__in) noexcept(
        __nothrow_constructible<const _U1 &, const _U2 &>())
        : _Inherited(__in.first, __in.second) {}

    template <typename _U1, typename _U2, _ImplicitCtor<true, _U1, _U2> = true>
    constexpr tuple(pair<_U1, _U2> &&__in) noexcept(
        __nothrow_constructible<_U1, _U2>())
        : _Inherited(std::forward<_U1>(__in.first),
                     std::forward<_U2>(__in.second)) {}

    template <typename _U1, typename _U2, _ExplicitCtor<true, _U1, _U2> = false>
    explicit constexpr tuple(pair<_U1, _U2> &&__in) noexcept(
        __nothrow_constructible<_U1, _U2>())
        : _Inherited(std::forward<_U1>(__in.first),
                     std::forward<_U2>(__in.second)) {}
# 1457 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
    template <typename _Alloc,
              _ImplicitDefaultCtor<is_object<_Alloc>::value, _T1, _T2> = true>
    constexpr tuple(allocator_arg_t __tag, const _Alloc &__a)
        : _Inherited(__tag, __a) {}

    template <typename _Alloc,
              _ExplicitDefaultCtor<is_object<_Alloc>::value, _T1, _T2> = false>
    constexpr explicit tuple(allocator_arg_t __tag, const _Alloc &__a)
        : _Inherited(__tag, __a) {}

    template <typename _Alloc, bool _Dummy = true,
              _ImplicitCtor<_Dummy, const _T1 &, const _T2 &> = true>
    constexpr tuple(allocator_arg_t __tag, const _Alloc &__a, const _T1 &__a1,
                    const _T2 &__a2)
        : _Inherited(__tag, __a, __a1, __a2) {}

    template <typename _Alloc, bool _Dummy = true,
              _ExplicitCtor<_Dummy, const _T1 &, const _T2 &> = false>
    explicit constexpr tuple(allocator_arg_t __tag, const _Alloc &__a,
                             const _T1 &__a1, const _T2 &__a2)
        : _Inherited(__tag, __a, __a1, __a2) {}

    template <typename _Alloc, typename _U1, typename _U2,
              _ImplicitCtor<true, _U1, _U2> = true>
    constexpr tuple(allocator_arg_t __tag, const _Alloc &__a, _U1 &&__a1,
                    _U2 &&__a2)
        : _Inherited(__tag, __a, std::forward<_U1>(__a1),
                     std::forward<_U2>(__a2)) {}

    template <typename _Alloc, typename _U1, typename _U2,
              _ExplicitCtor<true, _U1, _U2> = false>
    explicit constexpr tuple(allocator_arg_t __tag, const _Alloc &__a,
                             _U1 &&__a1, _U2 &&__a2)
        : _Inherited(__tag, __a, std::forward<_U1>(__a1),
                     std::forward<_U2>(__a2)) {}

    template <typename _Alloc>
    constexpr tuple(allocator_arg_t __tag, const _Alloc &__a, const tuple &__in)
        : _Inherited(__tag, __a, static_cast<const _Inherited &>(__in)) {}

    template <typename _Alloc>
    constexpr tuple(allocator_arg_t __tag, const _Alloc &__a, tuple &&__in)
        : _Inherited(__tag, __a, static_cast<_Inherited &&>(__in)) {}

    template <typename _Alloc, typename _U1, typename _U2,
              _ImplicitCtor<true, const _U1 &, const _U2 &> = true>
    constexpr tuple(allocator_arg_t __tag, const _Alloc &__a,
                    const tuple<_U1, _U2> &__in)
        : _Inherited(__tag, __a,
                     static_cast<const _Tuple_impl<0, _U1, _U2> &>(__in)) {}

    template <typename _Alloc, typename _U1, typename _U2,
              _ExplicitCtor<true, const _U1 &, const _U2 &> = false>
    explicit constexpr tuple(allocator_arg_t __tag, const _Alloc &__a,
                             const tuple<_U1, _U2> &__in)
        : _Inherited(__tag, __a,
                     static_cast<const _Tuple_impl<0, _U1, _U2> &>(__in)) {}

    template <typename _Alloc, typename _U1, typename _U2,
              _ImplicitCtor<true, _U1, _U2> = true>
    constexpr tuple(allocator_arg_t __tag, const _Alloc &__a,
                    tuple<_U1, _U2> &&__in)
        : _Inherited(__tag, __a,
                     static_cast<_Tuple_impl<0, _U1, _U2> &&>(__in)) {}

    template <typename _Alloc, typename _U1, typename _U2,
              _ExplicitCtor<true, _U1, _U2> = false>
    explicit constexpr tuple(allocator_arg_t __tag, const _Alloc &__a,
                             tuple<_U1, _U2> &&__in)
        : _Inherited(__tag, __a,
                     static_cast<_Tuple_impl<0, _U1, _U2> &&>(__in)) {}
# 1567 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
    template <typename _Alloc, typename _U1, typename _U2,
              _ImplicitCtor<true, const _U1 &, const _U2 &> = true>
    constexpr tuple(allocator_arg_t __tag, const _Alloc &__a,
                    const pair<_U1, _U2> &__in)
        : _Inherited(__tag, __a, __in.first, __in.second) {}

    template <typename _Alloc, typename _U1, typename _U2,
              _ExplicitCtor<true, const _U1 &, const _U2 &> = false>
    explicit constexpr tuple(allocator_arg_t __tag, const _Alloc &__a,
                             const pair<_U1, _U2> &__in)
        : _Inherited(__tag, __a, __in.first, __in.second) {}

    template <typename _Alloc, typename _U1, typename _U2,
              _ImplicitCtor<true, _U1, _U2> = true>
    constexpr tuple(allocator_arg_t __tag, const _Alloc &__a,
                    pair<_U1, _U2> &&__in)
        : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
                     std::forward<_U2>(__in.second)) {}

    template <typename _Alloc, typename _U1, typename _U2,
              _ExplicitCtor<true, _U1, _U2> = false>
    explicit constexpr tuple(allocator_arg_t __tag, const _Alloc &__a,
                             pair<_U1, _U2> &&__in)
        : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
                     std::forward<_U2>(__in.second)) {}
# 1617 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
    constexpr tuple &operator=(
        __conditional_t<__assignable<const _T1 &, const _T2 &>(), const tuple &,
                        const __nonesuch &>
            __in) noexcept(__nothrow_assignable<const _T1 &, const _T2 &>()) {
      this->_M_assign(__in);
      return *this;
    }

    constexpr tuple &
    operator=(__conditional_t<__assignable<_T1, _T2>(), tuple &&, __nonesuch &&>
                  __in) noexcept(__nothrow_assignable<_T1, _T2>()) {
      this->_M_assign(std::move(__in));
      return *this;
    }

    template <typename _U1, typename _U2>
    constexpr __enable_if_t<__assignable<const _U1 &, const _U2 &>(), tuple &>
    operator=(const tuple<_U1, _U2> &__in) noexcept(
        __nothrow_assignable<const _U1 &, const _U2 &>()) {
      this->_M_assign(__in);
      return *this;
    }

    template <typename _U1, typename _U2>
    constexpr __enable_if_t<__assignable<_U1, _U2>(), tuple &> operator=(
        tuple<_U1, _U2> &&__in) noexcept(__nothrow_assignable<_U1, _U2>()) {
      this->_M_assign(std::move(__in));
      return *this;
    }
# 1697 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
    template <typename _U1, typename _U2>
    constexpr __enable_if_t<__assignable<const _U1 &, const _U2 &>(), tuple &>
    operator=(const pair<_U1, _U2> &__in) noexcept(
        __nothrow_assignable<const _U1 &, const _U2 &>()) {
      this->_M_head(*this) = __in.first;
      this->_M_tail(*this)._M_head(*this) = __in.second;
      return *this;
    }

    template <typename _U1, typename _U2>
    constexpr __enable_if_t<__assignable<_U1, _U2>(), tuple &> operator=(
        pair<_U1, _U2> &&__in) noexcept(__nothrow_assignable<_U1, _U2>()) {
      this->_M_head(*this) = std::forward<_U1>(__in.first);
      this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
      return *this;
    }
# 1743 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
    constexpr void
    swap(tuple &__in) noexcept(__and_<__is_nothrow_swappable<_T1>,
                                      __is_nothrow_swappable<_T2>>::value) {
      _Inherited::_M_swap(__in);
    }
# 1758 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
  };

  template <typename... _Elements>
  struct tuple_size<tuple<_Elements...>>
      : public integral_constant<size_t, sizeof...(_Elements)> {};

  template <typename... _Types>
  inline constexpr size_t tuple_size_v<tuple<_Types...>> = sizeof...(_Types);

  template <typename... _Types>
  inline constexpr size_t tuple_size_v<const tuple<_Types...>> =
      sizeof...(_Types);

  template <size_t __i, typename... _Types>
  struct tuple_element<__i, tuple<_Types...>> {
    static_assert(__i < sizeof...(_Types), "tuple index must be in range");

    using type = typename _Nth_type<__i, _Types...>::type;
  };

  template <size_t __i, typename _Head, typename... _Tail>
  constexpr _Head &__get_helper(_Tuple_impl<__i, _Head, _Tail...> &
                                __t) noexcept {
    return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t);
  }

  template <size_t __i, typename _Head, typename... _Tail>
  constexpr const _Head &__get_helper(
      const _Tuple_impl<__i, _Head, _Tail...> &__t) noexcept {
    return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t);
  }

  template <size_t __i, typename... _Types>
  __enable_if_t<(__i >= sizeof...(_Types))> __get_helper(
      const tuple<_Types...> &) = delete;

  template <size_t __i, typename... _Elements>
  constexpr __tuple_element_t<__i, tuple<_Elements...>> &get(
      tuple<_Elements...> & __t) noexcept {
    return std::__get_helper<__i>(__t);
  }

  template <size_t __i, typename... _Elements>
  constexpr const __tuple_element_t<__i, tuple<_Elements...>> &get(
      const tuple<_Elements...> &__t) noexcept {
    return std::__get_helper<__i>(__t);
  }

  template <size_t __i, typename... _Elements>
  constexpr __tuple_element_t<__i, tuple<_Elements...>> &&get(
      tuple<_Elements...> && __t) noexcept {
    typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
    return std::forward<__element_type>(std::__get_helper<__i>(__t));
  }

  template <size_t __i, typename... _Elements>
  constexpr const __tuple_element_t<__i, tuple<_Elements...>> &&get(
      const tuple<_Elements...> &&__t) noexcept {
    typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
    return std::forward<const __element_type>(std::__get_helper<__i>(__t));
  }

  template <size_t __i, typename... _Elements>
  constexpr __enable_if_t<(__i >= sizeof...(_Elements))> get(
      const tuple<_Elements...> &) = delete;

  template <typename _Tp, typename... _Types>
  constexpr _Tp &get(tuple<_Types...> & __t) noexcept {
    constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
    static_assert(
        __idx < sizeof...(_Types),
        "the type T in std::get<T> must occur exactly once in the tuple");
    return std::__get_helper<__idx>(__t);
  }

  template <typename _Tp, typename... _Types>
  constexpr _Tp &&get(tuple<_Types...> && __t) noexcept {
    constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
    static_assert(
        __idx < sizeof...(_Types),
        "the type T in std::get<T> must occur exactly once in the tuple");
    return std::forward<_Tp>(std::__get_helper<__idx>(__t));
  }

  template <typename _Tp, typename... _Types>
  constexpr const _Tp &get(const tuple<_Types...> &__t) noexcept {
    constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
    static_assert(
        __idx < sizeof...(_Types),
        "the type T in std::get<T> must occur exactly once in the tuple");
    return std::__get_helper<__idx>(__t);
  }

  template <typename _Tp, typename... _Types>
  constexpr const _Tp &&get(const tuple<_Types...> &&__t) noexcept {
    constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
    static_assert(
        __idx < sizeof...(_Types),
        "the type T in std::get<T> must occur exactly once in the tuple");
    return std::forward<const _Tp>(std::__get_helper<__idx>(__t));
  }

  template <typename _Tp, typename _Up, size_t __i, size_t __size>
  struct __tuple_compare {
    static constexpr bool __eq(const _Tp &__t, const _Up &__u) {
      return bool(std::get<__i>(__t) == std::get<__i>(__u)) &&
             __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
    }

    static constexpr bool __less(const _Tp &__t, const _Up &__u) {
      return bool(std::get<__i>(__t) < std::get<__i>(__u)) ||
             (!bool(std::get<__i>(__u) < std::get<__i>(__t)) &&
              __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
    }
  };

  template <typename _Tp, typename _Up, size_t __size>
  struct __tuple_compare<_Tp, _Up, __size, __size> {
    static constexpr bool __eq(const _Tp &, const _Up &) { return true; }

    static constexpr bool __less(const _Tp &, const _Up &) { return false; }
  };

  template <typename... _TElements, typename... _UElements>
  constexpr bool operator==(const tuple<_TElements...> &__t,
                            const tuple<_UElements...> &__u) {
    static_assert(
        sizeof...(_TElements) == sizeof...(_UElements),
        "tuple objects can only be compared if they have equal sizes.");
    using __compare =
        __tuple_compare<tuple<_TElements...>, tuple<_UElements...>, 0,
                        sizeof...(_TElements)>;
    return __compare::__eq(__t, __u);
  }

  template <typename _Cat, typename _Tp, typename _Up>
  constexpr _Cat __tuple_cmp(const _Tp &, const _Up &, index_sequence<>) {
    return _Cat::equivalent;
  }

  template <typename _Cat, typename _Tp, typename _Up, size_t _Idx0,
            size_t... _Idxs>
  constexpr _Cat __tuple_cmp(const _Tp &__t, const _Up &__u,
                             index_sequence<_Idx0, _Idxs...>) {
    auto __c =
        __detail::__synth3way(std::get<_Idx0>(__t), std::get<_Idx0>(__u));
    if (__c != 0)
      return __c;
    return std::__tuple_cmp<_Cat>(__t, __u, index_sequence<_Idxs...>());
  }

  template <typename... _Tps, typename... _Ups>
  constexpr common_comparison_category_t<__detail::__synth3way_t<_Tps, _Ups>...>
  operator<=>(const tuple<_Tps...> &__t, const tuple<_Ups...> &__u) {
    using _Cat =
        common_comparison_category_t<__detail::__synth3way_t<_Tps, _Ups>...>;
    return std::__tuple_cmp<_Cat>(__t, __u, index_sequence_for<_Tps...>());
  }
# 1999 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
  template <typename... _Elements>
  constexpr tuple<typename __decay_and_strip<_Elements>::__type...> make_tuple(
      _Elements && ...__args) {
    typedef tuple<typename __decay_and_strip<_Elements>::__type...>
        __result_type;
    return __result_type(std::forward<_Elements>(__args)...);
  }

  template <typename... _Elements>
  constexpr tuple<_Elements &&...> forward_as_tuple(_Elements &&
                                                    ...__args) noexcept {
    return tuple<_Elements &&...>(std::forward<_Elements>(__args)...);
  }

  template <typename _Tp, size_t _Nm> struct array;

  template <size_t _Int, typename _Tp, size_t _Nm>
  constexpr _Tp &get(array<_Tp, _Nm> &) noexcept;

  template <size_t _Int, typename _Tp, size_t _Nm>
  constexpr _Tp &&get(array<_Tp, _Nm> &&) noexcept;

  template <size_t _Int, typename _Tp, size_t _Nm>
  constexpr const _Tp &get(const array<_Tp, _Nm> &) noexcept;

  template <size_t _Int, typename _Tp, size_t _Nm>
  constexpr const _Tp &&get(const array<_Tp, _Nm> &&) noexcept;

  template <size_t, typename, typename, size_t> struct __make_tuple_impl;

  template <size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
  struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
      : __make_tuple_impl<_Idx + 1,
                          tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
                          _Tuple, _Nm> {};

  template <size_t _Nm, typename _Tuple, typename... _Tp>
  struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm> {
    typedef tuple<_Tp...> __type;
  };

  template <typename _Tuple>
  struct __do_make_tuple
      : __make_tuple_impl<0, tuple<>, _Tuple, tuple_size<_Tuple>::value> {};

  template <typename _Tuple>
  struct __make_tuple : public __do_make_tuple<__remove_cvref_t<_Tuple>> {};

  template <typename...> struct __combine_tuples;

  template <> struct __combine_tuples<> {
    typedef tuple<> __type;
  };

  template <typename... _Ts> struct __combine_tuples<tuple<_Ts...>> {
    typedef tuple<_Ts...> __type;
  };

  template <typename... _T1s, typename... _T2s, typename... _Rem>
  struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...> {
    typedef typename __combine_tuples<tuple<_T1s..., _T2s...>, _Rem...>::__type
        __type;
  };

  template <typename... _Tpls> struct __tuple_cat_result {
    typedef typename __combine_tuples<
        typename __make_tuple<_Tpls>::__type...>::__type __type;
  };

  template <typename...> struct __make_1st_indices;

  template <> struct __make_1st_indices<> {
    typedef _Index_tuple<> __type;
  };

  template <typename _Tp, typename... _Tpls>
  struct __make_1st_indices<_Tp, _Tpls...> {
    typedef typename _Build_index_tuple<
        tuple_size<typename remove_reference<_Tp>::type>::value>::__type __type;
  };

  template <typename _Ret, typename _Indices, typename... _Tpls>
  struct __tuple_concater;

  template <typename _Ret, size_t... _Is, typename _Tp, typename... _Tpls>
  struct __tuple_concater<_Ret, _Index_tuple<_Is...>, _Tp, _Tpls...> {
    template <typename... _Us>
    static constexpr _Ret _S_do(_Tp &&__tp, _Tpls &&...__tps, _Us &&...__us) {
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
      return __next::_S_do(std::forward<_Tpls>(__tps)...,
                           std::forward<_Us>(__us)...,
                           std::get<_Is>(std::forward<_Tp>(__tp))...);
    }
  };

  template <typename _Ret> struct __tuple_concater<_Ret, _Index_tuple<>> {
    template <typename... _Us> static constexpr _Ret _S_do(_Us &&...__us) {
      return _Ret(std::forward<_Us>(__us)...);
    }
  };

  template <typename... _Tps>
  struct __is_tuple_like_impl<tuple<_Tps...>> : true_type {};

  template <typename... _Tpls, typename = typename enable_if<__and_<
                                   __is_tuple_like<_Tpls>...>::value>::type>
  constexpr auto tuple_cat(_Tpls && ...__tpls) ->
      typename __tuple_cat_result<_Tpls...>::__type {
    typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
    typedef typename __make_1st_indices<_Tpls...>::__type __idx;
    typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
    return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
  }

  template <typename... _Elements>
  constexpr tuple<_Elements &...> tie(_Elements & ...__args) noexcept {
    return tuple<_Elements &...>(__args...);
  }

  template <typename... _Elements>
  constexpr inline

      typename enable_if<__and_<__is_swappable<_Elements>...>::value>::type

      swap(tuple<_Elements...> & __x,
           tuple<_Elements...> & __y) noexcept(noexcept(__x.swap(__y))) {
    __x.swap(__y);
  }
# 2198 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
  template <typename... _Elements>
  constexpr
      typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type
      swap(tuple<_Elements...> &, tuple<_Elements...> &) = delete;

  struct _Swallow_assign {
    template <class _Tp>
    constexpr const _Swallow_assign &operator=(const _Tp &) const {
      return *this;
    }
  };
# 2233 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
  inline constexpr _Swallow_assign ignore{};

  template <typename... _Types, typename _Alloc>
  struct uses_allocator<tuple<_Types...>, _Alloc> : true_type {};
# 2248 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
  template <class _T1, class _T2>
  template <typename... _Args1, typename... _Args2>
  constexpr inline pair<_T1, _T2>::pair(piecewise_construct_t,
                                        tuple<_Args1...> __first,
                                        tuple<_Args2...> __second)
      : pair(__first, __second,
             typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
             typename _Build_index_tuple<sizeof...(_Args2)>::__type()) {}

  template <class _T1, class _T2>
  template <typename... _Args1, size_t... _Indexes1, typename... _Args2,
            size_t... _Indexes2>
  constexpr inline pair<_T1, _T2>::pair(
      tuple<_Args1...> & __tuple1, tuple<_Args2...> & __tuple2,
      _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...) {}

  template <template <typename...> class _Trait, typename _Tp, typename _Tuple>
  inline constexpr bool __unpack_std_tuple = false;

  template <template <typename...> class _Trait, typename _Tp, typename... _Up>
  inline constexpr bool __unpack_std_tuple<_Trait, _Tp, tuple<_Up...>> =
      _Trait<_Tp, _Up...>::value;

  template <template <typename...> class _Trait, typename _Tp, typename... _Up>
  inline constexpr bool __unpack_std_tuple<_Trait, _Tp, tuple<_Up...> &> =
      _Trait<_Tp, _Up &...>::value;

  template <template <typename...> class _Trait, typename _Tp, typename... _Up>
  inline constexpr bool __unpack_std_tuple<_Trait, _Tp, const tuple<_Up...>> =
      _Trait<_Tp, const _Up...>::value;

  template <template <typename...> class _Trait, typename _Tp, typename... _Up>
  inline constexpr bool __unpack_std_tuple<_Trait, _Tp, const tuple<_Up...> &> =
      _Trait<_Tp, const _Up &...>::value;

  template <typename _Fn, typename _Tuple, size_t... _Idx>
  constexpr decltype(auto) __apply_impl(_Fn && __f, _Tuple && __t,
                                        index_sequence<_Idx...>) {
    return std::__invoke(std::forward<_Fn>(__f),
                         std::get<_Idx>(std::forward<_Tuple>(__t))...);
  }

  template <typename _Fn, typename _Tuple>
  constexpr decltype(auto) apply(_Fn && __f, _Tuple && __t) noexcept(
      __unpack_std_tuple<is_nothrow_invocable, _Fn, _Tuple>) {
    using _Indices =
        make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>;
    return std::__apply_impl(std::forward<_Fn>(__f), std::forward<_Tuple>(__t),
                             _Indices{});
  }

  template <typename _Tp, typename _Tuple, size_t... _Idx>
  constexpr _Tp __make_from_tuple_impl(_Tuple && __t, index_sequence<_Idx...>) {
    return _Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...);
  }

  template <typename _Tp, typename _Tuple>
  constexpr _Tp make_from_tuple(_Tuple && __t) noexcept(
      __unpack_std_tuple<is_nothrow_constructible, _Tp, _Tuple>) {
    constexpr size_t __n = tuple_size_v<remove_reference_t<_Tuple>>;

    if constexpr (__n == 1) {
      using _Elt = decltype(std::get<0>(std::declval<_Tuple>()));
      static_assert(!__reference_constructs_from_temporary(_Tp, _Elt));
    }

    return __make_from_tuple_impl<_Tp>(std::forward<_Tuple>(__t),
                                       make_index_sequence<__n>{});
  }
# 2359 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tuple" 3
} // namespace std
# 39 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/uses_allocator_args.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _Tp>
  concept _Std_pair = __is_pair<remove_cv_t<_Tp>>;
# 56 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/uses_allocator_args.h" 3
  template <typename _Tp, typename _Alloc, typename... _Args>
  constexpr auto uses_allocator_construction_args(const _Alloc &__a,
                                                  _Args &&...__args) noexcept
    requires(!_Std_pair<_Tp>)
  {
    if constexpr (uses_allocator_v<remove_cv_t<_Tp>, _Alloc>) {
      if constexpr (is_constructible_v<_Tp, allocator_arg_t, const _Alloc &,
                                       _Args...>) {
        return tuple<allocator_arg_t, const _Alloc &, _Args &&...>(
            allocator_arg, __a, std::forward<_Args>(__args)...);
      } else {
        static_assert(is_constructible_v<_Tp, _Args..., const _Alloc &>,
                      "construction with an allocator must be possible"
                      " if uses_allocator is true");

        return tuple<_Args &&..., const _Alloc &>(
            std::forward<_Args>(__args)..., __a);
      }
    } else {
      static_assert(is_constructible_v<_Tp, _Args...>);

      return tuple<_Args &&...>(std::forward<_Args>(__args)...);
    }
  }

  template <_Std_pair _Tp, typename _Alloc, typename _Tuple1, typename _Tuple2>
  constexpr auto uses_allocator_construction_args(
      const _Alloc &__a, piecewise_construct_t, _Tuple1 &&__x,
      _Tuple2 &&__y) noexcept;

  template <_Std_pair _Tp, typename _Alloc>
  constexpr auto uses_allocator_construction_args(const _Alloc &) noexcept;

  template <_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
  constexpr auto uses_allocator_construction_args(const _Alloc &, _Up &&,
                                                  _Vp &&) noexcept;

  template <_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
  constexpr auto uses_allocator_construction_args(
      const _Alloc &, const pair<_Up, _Vp> &) noexcept;

  template <_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
  constexpr auto uses_allocator_construction_args(const _Alloc &,
                                                  pair<_Up, _Vp> &&) noexcept;
# 121 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/uses_allocator_args.h" 3
  template <_Std_pair _Tp, typename _Alloc, typename _Tuple1, typename _Tuple2>
  constexpr auto uses_allocator_construction_args(
      const _Alloc &__a, piecewise_construct_t, _Tuple1 &&__x,
      _Tuple2 &&__y) noexcept {
    using _Tp1 = typename _Tp::first_type;
    using _Tp2 = typename _Tp::second_type;

    return std::make_tuple(
        piecewise_construct,
        std::apply(
            [&__a](auto &&...__args1) {
              return std::uses_allocator_construction_args<_Tp1>(
                  __a, std::forward<decltype(__args1)>(__args1)...);
            },
            std::forward<_Tuple1>(__x)),
        std::apply(
            [&__a](auto &&...__args2) {
              return std::uses_allocator_construction_args<_Tp2>(
                  __a, std::forward<decltype(__args2)>(__args2)...);
            },
            std::forward<_Tuple2>(__y)));
  }

  template <_Std_pair _Tp, typename _Alloc>
  constexpr auto uses_allocator_construction_args(const _Alloc &__a) noexcept {
    using _Tp1 = typename _Tp::first_type;
    using _Tp2 = typename _Tp::second_type;

    return std::make_tuple(piecewise_construct,
                           std::uses_allocator_construction_args<_Tp1>(__a),
                           std::uses_allocator_construction_args<_Tp2>(__a));
  }

  template <_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
  constexpr auto uses_allocator_construction_args(const _Alloc &__a, _Up &&__u,
                                                  _Vp &&__v) noexcept {
    using _Tp1 = typename _Tp::first_type;
    using _Tp2 = typename _Tp::second_type;

    return std::make_tuple(piecewise_construct,
                           std::uses_allocator_construction_args<_Tp1>(
                               __a, std::forward<_Up>(__u)),
                           std::uses_allocator_construction_args<_Tp2>(
                               __a, std::forward<_Vp>(__v)));
  }

  template <_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
  constexpr auto uses_allocator_construction_args(
      const _Alloc &__a, const pair<_Up, _Vp> &__pr) noexcept {
    using _Tp1 = typename _Tp::first_type;
    using _Tp2 = typename _Tp::second_type;

    return std::make_tuple(
        piecewise_construct,
        std::uses_allocator_construction_args<_Tp1>(__a, __pr.first),
        std::uses_allocator_construction_args<_Tp2>(__a, __pr.second));
  }

  template <_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
  constexpr auto uses_allocator_construction_args(
      const _Alloc &__a, pair<_Up, _Vp> &&__pr) noexcept {
    using _Tp1 = typename _Tp::first_type;
    using _Tp2 = typename _Tp::second_type;

    return std::make_tuple(piecewise_construct,
                           std::uses_allocator_construction_args<_Tp1>(
                               __a, std::get<0>(std::move(__pr))),
                           std::uses_allocator_construction_args<_Tp2>(
                               __a, std::get<1>(std::move(__pr))));
  }
# 228 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/uses_allocator_args.h" 3
  template <typename _Tp, typename _Alloc, typename... _Args>
  constexpr _Tp make_obj_using_allocator(const _Alloc &__a, _Args &&...__args) {
    return std::make_from_tuple<_Tp>(std::uses_allocator_construction_args<_Tp>(
        __a, std::forward<_Args>(__args)...));
  }

  template <typename _Tp, typename _Alloc, typename... _Args>
  constexpr _Tp *uninitialized_construct_using_allocator(
      _Tp * __p, const _Alloc &__a, _Args &&...__args) {
    return std::apply(
        [&](auto &&...__xs) {
          return std::construct_at(__p, std::forward<decltype(__xs)>(__xs)...);
        },
        std::uses_allocator_construction_args<_Tp>(
            __a, std::forward<_Args>(__args)...));
  }

} // namespace std
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memory_resource.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  namespace pmr {

  class memory_resource {
    static constexpr size_t _S_max_align = alignof(max_align_t);

  public:
    memory_resource() = default;
    memory_resource(const memory_resource &) = default;
    virtual ~memory_resource();

    memory_resource &operator=(const memory_resource &) = default;

    [[nodiscard]]
    void *allocate(size_t __bytes, size_t __alignment = _S_max_align)
        __attribute__((__returns_nonnull__, __alloc_size__(2),
                       __alloc_align__(3))) {
      return ::operator new(__bytes, do_allocate(__bytes, __alignment));
    }

    void deallocate(void *__p, size_t __bytes,
                    size_t __alignment = _S_max_align)
        __attribute__((__nonnull__)) {
      return do_deallocate(__p, __bytes, __alignment);
    }

    [[nodiscard]]
    bool is_equal(const memory_resource &__other) const noexcept {
      return do_is_equal(__other);
    }

  private:
    virtual void *do_allocate(size_t __bytes, size_t __alignment) = 0;

    virtual void do_deallocate(void *__p, size_t __bytes,
                               size_t __alignment) = 0;

    virtual bool do_is_equal(const memory_resource &__other) const noexcept = 0;
  };

  [[nodiscard]]
  inline bool operator==(const memory_resource &__a,
                         const memory_resource &__b) noexcept {
    return &__a == &__b || __a.is_equal(__b);
  }
# 119 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memory_resource.h" 3
  template <typename _Tp> class polymorphic_allocator {

    template <typename _Up> struct __not_pair {
      using type = void;
    };

    template <typename _Up1, typename _Up2>
    struct __not_pair<pair<_Up1, _Up2>> {};

  public:
    using value_type = _Tp;

    polymorphic_allocator() noexcept {
      extern memory_resource *get_default_resource() noexcept
          __attribute__((__returns_nonnull__));
      _M_resource = get_default_resource();
    }

    polymorphic_allocator(memory_resource *__r) noexcept
        __attribute__((__nonnull__))
        : _M_resource(__r) {
      ;
    }

    polymorphic_allocator(const polymorphic_allocator &__other) = default;

    template <typename _Up>
    polymorphic_allocator(const polymorphic_allocator<_Up> &__x) noexcept
        : _M_resource(__x.resource()) {}

    polymorphic_allocator &operator=(const polymorphic_allocator &) = delete;

    [[nodiscard]]
    _Tp *allocate(size_t __n) __attribute__((__returns_nonnull__)) {
      if ((__gnu_cxx::__int_traits<size_t>::__max / sizeof(_Tp)) < __n)
        std::__throw_bad_array_new_length();
      return static_cast<_Tp *>(
          _M_resource->allocate(__n * sizeof(_Tp), alignof(_Tp)));
    }

    void deallocate(_Tp *__p, size_t __n) noexcept
        __attribute__((__nonnull__)) {
      _M_resource->deallocate(__p, __n * sizeof(_Tp), alignof(_Tp));
    }

    [[nodiscard]] void *
    allocate_bytes(size_t __nbytes, size_t __alignment = alignof(max_align_t)) {
      return _M_resource->allocate(__nbytes, __alignment);
    }

    void deallocate_bytes(void *__p, size_t __nbytes,
                          size_t __alignment = alignof(max_align_t)) {
      _M_resource->deallocate(__p, __nbytes, __alignment);
    }

    template <typename _Up> [[nodiscard]] _Up *allocate_object(size_t __n = 1) {
      if ((__gnu_cxx::__int_traits<size_t>::__max / sizeof(_Up)) < __n)
        std::__throw_bad_array_new_length();
      return static_cast<_Up *>(
          allocate_bytes(__n * sizeof(_Up), alignof(_Up)));
    }

    template <typename _Up> void deallocate_object(_Up *__p, size_t __n = 1) {
      deallocate_bytes(__p, __n * sizeof(_Up), alignof(_Up));
    }

    template <typename _Up, typename... _CtorArgs>
    [[nodiscard]] _Up *new_object(_CtorArgs &&...__ctor_args) {
      _Up *__p = allocate_object<_Up>();
      try {
        construct(__p, std::forward<_CtorArgs>(__ctor_args)...);
      } catch (...) {
        deallocate_object(__p);
        throw;
      }
      return __p;
    }

    template <typename _Up> void delete_object(_Up *__p) {
      __p->~_Up();
      deallocate_object(__p);
    }
# 297 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memory_resource.h" 3
    template <typename _Tp1, typename... _Args>
    __attribute__((__nonnull__)) void construct(_Tp1 *__p, _Args &&...__args) {
      std::uninitialized_construct_using_allocator(
          __p, *this, std::forward<_Args>(__args)...);
    }

    template <typename _Up>
    __attribute__((__deprecated__("use '"
                                  "allocator_traits::destroy"
                                  "' instead")))
    __attribute__((__nonnull__)) void
    destroy(_Up *__p) {
      __p->~_Up();
    }

    polymorphic_allocator
    select_on_container_copy_construction() const noexcept {
      return polymorphic_allocator();
    }

    memory_resource *resource() const noexcept
        __attribute__((__returns_nonnull__)) {
      return _M_resource;
    }

    [[nodiscard]]
    friend bool operator==(const polymorphic_allocator &__a,
                           const polymorphic_allocator &__b) noexcept {
      return *__a.resource() == *__b.resource();
    }
# 339 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memory_resource.h" 3
  private:
# 366 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memory_resource.h" 3
    memory_resource *_M_resource;
  };

  template <typename _Tp1, typename _Tp2>
  [[nodiscard]]
  inline bool operator==(const polymorphic_allocator<_Tp1> &__a,
                         const polymorphic_allocator<_Tp2> &__b) noexcept {
    return *__a.resource() == *__b.resource();
  }
# 385 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memory_resource.h" 3
  } // namespace pmr

  template <typename _Alloc> struct allocator_traits;

  template <typename _Tp>
  struct allocator_traits<pmr::polymorphic_allocator<_Tp>> {

    using allocator_type = pmr::polymorphic_allocator<_Tp>;

    using value_type = _Tp;

    using pointer = _Tp *;

    using const_pointer = const _Tp *;

    using void_pointer = void *;

    using const_void_pointer = const void *;

    using difference_type = std::ptrdiff_t;

    using size_type = std::size_t;

    using propagate_on_container_copy_assignment = false_type;
    using propagate_on_container_move_assignment = false_type;
    using propagate_on_container_swap = false_type;

    static allocator_type
    select_on_container_copy_construction(const allocator_type &) noexcept {
      return allocator_type();
    }

    using is_always_equal = false_type;

    template <typename _Up>
    using rebind_alloc = pmr::polymorphic_allocator<_Up>;

    template <typename _Up>
    using rebind_traits = allocator_traits<pmr::polymorphic_allocator<_Up>>;
# 446 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memory_resource.h" 3
    [[nodiscard]] static pointer allocate(allocator_type &__a, size_type __n) {
      return __a.allocate(__n);
    }
# 461 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memory_resource.h" 3
    [[nodiscard]] static pointer allocate(allocator_type &__a, size_type __n,
                                          const_void_pointer) {
      return __a.allocate(__n);
    }
# 473 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memory_resource.h" 3
    static void deallocate(allocator_type &__a, pointer __p, size_type __n) {
      __a.deallocate(__p, __n);
    }
# 488 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memory_resource.h" 3
    template <typename _Up, typename... _Args>
    static void construct(allocator_type &__a, _Up *__p, _Args &&...__args) {
      __a.construct(__p, std::forward<_Args>(__args)...);
    }
# 500 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/memory_resource.h" 3
    template <typename _Up>
    static constexpr void
    destroy(allocator_type &,
            _Up *__p) noexcept(is_nothrow_destructible<_Up>::value) {
      __p->~_Up();
    }

    static constexpr size_type max_size(const allocator_type &) noexcept {
      return size_t(-1) / sizeof(value_type);
    }
  };

} // namespace std
# 59 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/string" 2 3
namespace std __attribute__((__visibility__("default"))) {

  namespace pmr {
  template <typename _CharT, typename _Traits = char_traits<_CharT>>
  using basic_string =
      std::basic_string<_CharT, _Traits, polymorphic_allocator<_CharT>>;
  using string = basic_string<char>;

  using u8string = basic_string<char8_t>;

  using u16string = basic_string<char16_t>;
  using u32string = basic_string<char32_t>;
  using wstring = basic_string<wchar_t>;
  } // namespace pmr

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

  template <typename _CharT, typename _Traits, typename _Alloc,
            typename _Predicate>
  constexpr inline typename basic_string<_CharT, _Traits, _Alloc>::size_type
  erase_if(basic_string<_CharT, _Traits, _Alloc> & __cont, _Predicate __pred) {
    using namespace __gnu_cxx;
    const auto __osz = __cont.size();
    const auto __end = __cont.end();
    auto __removed = std::__remove_if(__cont.begin(), __end,
                                      __ops::__pred_iter(std::ref(__pred)));
    __cont.erase(__removed, __end);
    return __osz - __cont.size();
  }

  template <typename _CharT, typename _Traits, typename _Alloc, typename _Up>
  constexpr inline typename basic_string<_CharT, _Traits, _Alloc>::size_type
  erase(basic_string<_CharT, _Traits, _Alloc> & __cont, const _Up &__value) {
    using namespace __gnu_cxx;
    const auto __osz = __cont.size();
    const auto __end = __cont.end();
    auto __removed = std::__remove_if(__cont.begin(), __end,
                                      __ops::__iter_equals_val(__value));
    __cont.erase(__removed, __end);
    return __osz - __cont.size();
  }

} // namespace std
# 41 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 62 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
  class locale {
  public:
    typedef int category;

    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template <typename _Facet> friend bool has_facet(const locale &) throw();

    template <typename _Facet> friend const _Facet &use_facet(const locale &);

    template <typename _Facet>
    friend const _Facet *__try_use_facet(const locale &) noexcept;

    template <typename _Cache> friend struct __use_cache;
# 102 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all =
        (ctype | numeric | collate | time | monetary | messages);
# 121 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    locale() throw();
# 130 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    locale(const locale &__other) throw();
# 140 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    explicit locale(const char *__s);
# 155 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    locale(const locale &__base, const char *__s, category __cat);
# 166 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    explicit locale(const std::string &__s) : locale(__s.c_str()) {}
# 181 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    locale(const locale &__base, const std::string &__s, category __cat)
        : locale(__base, __s.c_str(), __cat) {}
# 196 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    locale(const locale &__base, const locale &__add, category __cat);
# 209 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    template <typename _Facet> locale(const locale &__other, _Facet *__f);

    ~locale() throw();
# 223 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    const locale &operator=(const locale &__other) throw();
# 238 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    template <typename _Facet> locale combine(const locale &__other) const;

    __attribute((__abi_tag__("cxx11"))) string name() const;
# 258 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    bool operator==(const locale &__other) const throw();
# 288 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    template <typename _Char, typename _Traits, typename _Alloc>
    bool operator()(const basic_string<_Char, _Traits, _Alloc> &__s1,
                    const basic_string<_Char, _Traits, _Alloc> &__s2) const;
# 304 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    static locale global(const locale &__loc);

    static const locale &classic();

  private:
    _Impl *_M_impl;

    static _Impl *_S_classic;

    static _Impl *_S_global;

    static const char *const *const _S_categories;
# 339 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };

    static __gthread_once_t _S_once;

    explicit locale(_Impl *) throw();

    static void _S_initialize();

    static void _S_initialize_once() throw();

    static category _S_normalize_category(category);

    void _M_coalesce(const locale &__base, const locale &__add, category __cat);

    static const id *const _S_twinned_facets[];
  };
# 377 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
  class locale::facet {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;

    static __c_locale _S_c_locale;

    static const char _S_c_name[2];

    static __gthread_once_t _S_once;

    static void _S_initialize_once();

  protected:
# 408 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    explicit facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0) {}

    virtual ~facet();

    static void _S_create_c_locale(__c_locale &__cloc, const char *__s,
                                   __c_locale __old = 0);

    static __c_locale _S_clone_c_locale(__c_locale &__cloc) throw();

    static void _S_destroy_c_locale(__c_locale &__cloc);

    static __c_locale _S_lc_ctype_c_locale(__c_locale __cloc, const char *__s);

    static __c_locale _S_get_c_locale();

    __attribute__((__const__)) static const char *_S_get_c_name() throw();
# 444 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    facet(const facet &) = delete;

    facet &operator=(const facet &) = delete;

  private:
    void _M_add_reference() const throw() {
      __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1);
    }

    void _M_remove_reference() const throw() {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1) {
        ;
        try {
          delete this;
        } catch (...) {
        }
      }
    }

    const facet *_M_sso_shim(const id *) const;
    const facet *_M_cow_shim(const id *) const;

  protected:
    class __shim;
  };
# 489 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
  class locale::id {
  private:
    friend class locale;
    friend class locale::_Impl;

    template <typename _Facet> friend const _Facet &use_facet(const locale &);

    template <typename _Facet> friend bool has_facet(const locale &) throw();

    template <typename _Facet>
    friend const _Facet *__try_use_facet(const locale &) noexcept;

    mutable size_t _M_index;

    static _Atomic_word _S_refcount;

    void operator=(const id &);

    id(const id &);

  public:
    id() {}

    size_t _M_id() const throw();
  };

  class locale::_Impl {
  public:
    friend class locale;
    friend class locale::facet;

    template <typename _Facet> friend bool has_facet(const locale &) throw();

    template <typename _Facet> friend const _Facet &use_facet(const locale &);

    template <typename _Facet>
    friend const _Facet *__try_use_facet(const locale &) noexcept;

    template <typename _Cache> friend struct __use_cache;

  private:
    _Atomic_word _M_refcount;
    const facet **_M_facets;
    size_t _M_facets_size;
    const facet **_M_caches;
    char **_M_names;
    static const locale::id *const _S_id_ctype[];
    static const locale::id *const _S_id_numeric[];
    static const locale::id *const _S_id_collate[];
    static const locale::id *const _S_id_time[];
    static const locale::id *const _S_id_monetary[];
    static const locale::id *const _S_id_messages[];
    static const locale::id *const *const _S_facet_categories[];

    void _M_add_reference() throw() {
      __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1);
    }

    void _M_remove_reference() throw() {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1) {
        ;
        try {
          delete this;
        } catch (...) {
        }
      }
    }

    _Impl(const _Impl &, size_t);
    _Impl(const char *, size_t);
    _Impl(size_t) throw();

    ~_Impl() throw();

    _Impl(const _Impl &);

    void operator=(const _Impl &);

    bool _M_check_same_name() {
      bool __ret = true;
      if (_M_names[1])

        for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
          __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void _M_replace_categories(const _Impl *, category);

    void _M_replace_category(const _Impl *, const locale::id *const *);

    void _M_replace_facet(const _Impl *, const locale::id *);

    void _M_install_facet(const locale::id *, const facet *);

    template <typename _Facet> void _M_init_facet(_Facet *__facet) {
      _M_install_facet(&_Facet::id, __facet);
    }

    template <typename _Facet> void _M_init_facet_unchecked(_Facet *__facet) {
      __facet->_M_add_reference();
      _M_facets[_Facet::id._M_id()] = __facet;
    }

    void _M_install_cache(const facet *, size_t);

    void _M_init_extra(facet **);
    void _M_init_extra(void *, void *, const char *, const char *);
  };
# 659 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
  template <typename _CharT> class __cxx11::collate : public locale::facet {
  public:
    typedef _CharT char_type;
    typedef basic_string<_CharT> string_type;

  protected:
    __c_locale _M_c_locale_collate;

  public:
    static locale::id id;
# 686 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    explicit collate(size_t __refs = 0)
        : facet(__refs), _M_c_locale_collate(_S_get_c_locale()) {}
# 700 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    explicit collate(__c_locale __cloc, size_t __refs = 0)
        : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc)) {}
# 717 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    int compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2,
                const _CharT *__hi2) const {
      return this->do_compare(__lo1, __hi1, __lo2, __hi2);
    }
# 736 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    string_type transform(const _CharT *__lo, const _CharT *__hi) const {
      return this->do_transform(__lo, __hi);
    }
# 750 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    long hash(const _CharT *__lo, const _CharT *__hi) const {
      return this->do_hash(__lo, __hi);
    }

    int _M_compare(const _CharT *, const _CharT *) const throw();

    size_t _M_transform(_CharT *, const _CharT *, size_t) const throw();

  protected:
    virtual ~collate() { _S_destroy_c_locale(_M_c_locale_collate); }
# 779 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    virtual int do_compare(const _CharT *__lo1, const _CharT *__hi1,
                           const _CharT *__lo2, const _CharT *__hi2) const;
# 793 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    virtual string_type do_transform(const _CharT *__lo,
                                     const _CharT *__hi) const;
# 806 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 3
    virtual long do_hash(const _CharT *__lo, const _CharT *__hi) const;
  };

  template <typename _CharT> locale::id collate<_CharT>::id;

  template <>
  int collate<char>::_M_compare(const char *, const char *) const throw();

  template <>
  size_t collate<char>::_M_transform(char *, const char *, size_t)
      const throw();

  template <>
  int collate<wchar_t>::_M_compare(const wchar_t *, const wchar_t *)
      const throw();

  template <>
  size_t collate<wchar_t>::_M_transform(wchar_t *, const wchar_t *, size_t)
      const throw();

  template <typename _CharT>
  class __cxx11::collate_byname : public collate<_CharT> {
  public:
    typedef _CharT char_type;
    typedef basic_string<_CharT> string_type;

    explicit collate_byname(const char *__s, size_t __refs = 0)
        : collate<_CharT>(__refs) {
      if (__builtin_strcmp(__s, "C") != 0 &&
          __builtin_strcmp(__s, "POSIX") != 0) {
        this->_S_destroy_c_locale(this->_M_c_locale_collate);
        this->_S_create_c_locale(this->_M_c_locale_collate, __s);
      }
    }

    explicit collate_byname(const string &__s, size_t __refs = 0)
        : collate_byname(__s.c_str(), __refs) {}

  protected:
    virtual ~collate_byname() {}
  };

} // namespace std

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.tcc" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.tcc" 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _Facet>
  locale::locale(const locale &__other, _Facet *__f) {
    _M_impl = new _Impl(*__other._M_impl, 1);

    try {
      _M_impl->_M_install_facet(&_Facet::id, __f);
    } catch (...) {
      _M_impl->_M_remove_reference();
      throw;
    }
    delete[] _M_impl->_M_names[0];
    _M_impl->_M_names[0] = 0;
  }

  template <typename _Facet>
  locale locale::combine(const locale &__other) const {
    _Impl *__tmp = new _Impl(*_M_impl, 1);
    try {
      __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
    } catch (...) {
      __tmp->_M_remove_reference();
      throw;
    }
    return locale(__tmp);
  }

  template <typename _CharT, typename _Traits, typename _Alloc>
  bool locale::operator()(const basic_string<_CharT, _Traits, _Alloc> &__s1,
                          const basic_string<_CharT, _Traits, _Alloc> &__s2)
      const {
    typedef std::collate<_CharT> __collate_type;
    const __collate_type &__collate = use_facet<__collate_type>(*this);
    return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
                              __s2.data(), __s2.data() + __s2.length()) < 0);
  }

  template <typename _Facet>
  inline const _Facet *__try_use_facet(const locale &__loc) noexcept {
    const size_t __i = _Facet::id._M_id();
    const locale::facet **__facets = __loc._M_impl->_M_facets;

    if constexpr (__is_same(_Facet, ctype<char>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, num_get<char>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, num_put<char>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, codecvt<char, char, mbstate_t>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, collate<char>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, moneypunct<char>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, moneypunct<char, true>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, money_get<char>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, money_put<char>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, numpunct<char>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, time_get<char>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, time_put<char>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, messages<char>))
      return static_cast<const _Facet *>(__facets[__i]);

    if constexpr (__is_same(_Facet, ctype<wchar_t>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, num_get<wchar_t>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, num_put<wchar_t>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, codecvt<wchar_t, char, mbstate_t>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, collate<wchar_t>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, moneypunct<wchar_t>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, moneypunct<wchar_t, true>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, money_get<wchar_t>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, money_put<wchar_t>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, numpunct<wchar_t>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, time_get<wchar_t>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, time_put<wchar_t>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, messages<wchar_t>))
      return static_cast<const _Facet *>(__facets[__i]);

    if constexpr (__is_same(_Facet, codecvt<char16_t, char, mbstate_t>))
      return static_cast<const _Facet *>(__facets[__i]);
    if constexpr (__is_same(_Facet, codecvt<char32_t, char, mbstate_t>))
      return static_cast<const _Facet *>(__facets[__i]);

    if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
      return 0;

    return dynamic_cast<const _Facet *>(__facets[__i]);
  }
# 161 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.tcc" 3
  template <typename _Facet>
  inline bool has_facet(const locale &__loc) throw() {

    static_assert(__is_base_of(locale::facet, _Facet),
                  "template argument must be derived from locale::facet");

    return std::__try_use_facet<_Facet>(__loc) != 0;
  }
# 188 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.tcc" 3
#pragma GCC diagnostic push

  template <typename _Facet>
  inline const _Facet &use_facet(const locale &__loc) {

    static_assert(__is_base_of(locale::facet, _Facet),
                  "template argument must be derived from locale::facet");

    if (const _Facet *__f = std::__try_use_facet<_Facet>(__loc))
      return *__f;
    __throw_bad_cast();
  }
#pragma GCC diagnostic pop

  template <typename _CharT>
  int collate<_CharT>::_M_compare(const _CharT *, const _CharT *)
      const throw() {
    return 0;
  }

  template <typename _CharT>
  size_t collate<_CharT>::_M_transform(_CharT *, const _CharT *, size_t)
      const throw() {
    return 0;
  }

  template <typename _CharT>
  int collate<_CharT>::do_compare(const _CharT *__lo1, const _CharT *__hi1,
                                  const _CharT *__lo2, const _CharT *__hi2)
      const {

    const string_type __one(__lo1, __hi1);
    const string_type __two(__lo2, __hi2);

    const _CharT *__p = __one.c_str();
    const _CharT *__pend = __one.data() + __one.length();
    const _CharT *__q = __two.c_str();
    const _CharT *__qend = __two.data() + __two.length();

    for (;;) {
      const int __res = _M_compare(__p, __q);
      if (__res)
        return __res;

      __p += char_traits<_CharT>::length(__p);
      __q += char_traits<_CharT>::length(__q);
      if (__p == __pend && __q == __qend)
        return 0;
      else if (__p == __pend)
        return -1;
      else if (__q == __qend)
        return 1;

      __p++;
      __q++;
    }
  }

  template <typename _CharT>
  typename collate<_CharT>::string_type collate<_CharT>::do_transform(
      const _CharT *__lo, const _CharT *__hi) const {
    string_type __ret;

    const string_type __str(__lo, __hi);

    const _CharT *__p = __str.c_str();
    const _CharT *__pend = __str.data() + __str.length();

    size_t __len = (__hi - __lo) * 2;

    _CharT *__c = new _CharT[__len];

    try {

      for (;;) {

        size_t __res = _M_transform(__c, __p, __len);

        if (__res >= __len) {
          __len = __res + 1;
          delete[] __c, __c = 0;
          __c = new _CharT[__len];
          __res = _M_transform(__c, __p, __len);
        }

        __ret.append(__c, __res);
        __p += char_traits<_CharT>::length(__p);
        if (__p == __pend)
          break;

        __p++;
        __ret.push_back(_CharT());
      }
    } catch (...) {
      delete[] __c;
      throw;
    }

    delete[] __c;

    return __ret;
  }

  template <typename _CharT>
  long collate<_CharT>::do_hash(const _CharT *__lo, const _CharT *__hi) const {
    unsigned long __val = 0;
    for (; __lo < __hi; ++__lo)
      __val = *__lo +
              ((__val << 7) |
               (__val >>
                (__gnu_cxx::__numeric_traits<unsigned long>::__digits - 7)));
    return static_cast<long>(__val);
  }

  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template const collate<char> *__try_use_facet<collate<char>>(
      const locale &) noexcept;

  extern template const collate<char> &use_facet<collate<char>>(const locale &);

  extern template bool has_facet<collate<char>>(const locale &);

  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template const collate<wchar_t> *__try_use_facet<collate<wchar_t>>(
      const locale &) noexcept;

  extern template const collate<wchar_t> &use_facet<collate<wchar_t>>(
      const locale &);

  extern template bool has_facet<collate<wchar_t>>(const locale &);

} // namespace std
# 870 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_classes.h" 2 3
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/error_constants.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/error_constants.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cerrno" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cerrno" 3
# 35 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/error_constants.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  enum class errc {
    address_family_not_supported = 97,
    address_in_use = 98,
    address_not_available = 99,
    already_connected = 106,
    argument_list_too_long = 7,
    argument_out_of_domain = 33,
    bad_address = 14,
    bad_file_descriptor = 9,

    bad_message = 74,

    broken_pipe = 32,
    connection_aborted = 103,
    connection_already_in_progress = 114,
    connection_refused = 111,
    connection_reset = 104,
    cross_device_link = 18,
    destination_address_required = 89,
    device_or_resource_busy = 16,
    directory_not_empty = 39,
    executable_format_error = 8,
    file_exists = 17,
    file_too_large = 27,
    filename_too_long = 36,
    function_not_supported = 38,
    host_unreachable = 113,

    identifier_removed = 43,

    illegal_byte_sequence = 84,
    inappropriate_io_control_operation = 25,
    interrupted = 4,
    invalid_argument = 22,
    invalid_seek = 29,
    io_error = 5,
    is_a_directory = 21,
    message_size = 90,
    network_down = 100,
    network_reset = 102,
    network_unreachable = 101,
    no_buffer_space = 105,
    no_child_process = 10,

    no_link = 67,

    no_lock_available = 37,

    no_message_available = 61,

    no_message = 42,
    no_protocol_option = 92,
    no_space_on_device = 28,

    no_stream_resources = 63,

    no_such_device_or_address = 6,
    no_such_device = 19,
    no_such_file_or_directory = 2,
    no_such_process = 3,
    not_a_directory = 20,
    not_a_socket = 88,

    not_a_stream = 60,

    not_connected = 107,
    not_enough_memory = 12,

    not_supported = 95,

    operation_canceled = 125,

    operation_in_progress = 115,
    operation_not_permitted = 1,
    operation_not_supported = 95,
    operation_would_block = 11,

    owner_dead = 130,

    permission_denied = 13,

    protocol_error = 71,

    protocol_not_supported = 93,
    read_only_file_system = 30,
    resource_deadlock_would_occur = 35,
    resource_unavailable_try_again = 11,
    result_out_of_range = 34,

    state_not_recoverable = 131,

    stream_timeout = 62,

    text_file_busy = 26,

    timed_out = 110,
    too_many_files_open_in_system = 23,
    too_many_files_open = 24,
    too_many_links = 31,
    too_many_symbolic_link_levels = 40,

    value_too_large = 75,

    wrong_protocol_type = 91
  };

}
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/stdexcept" 1 3
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/stdexcept" 3

namespace std __attribute__((__visibility__("default"))) {

  struct __cow_string {
    union {
      const char *_M_p;
      char _M_bytes[sizeof(const char *)];
    };

    __cow_string();
    __cow_string(const std::string &);
    __cow_string(const char *, size_t);
    __cow_string(const __cow_string &) noexcept;
    __cow_string &operator=(const __cow_string &) noexcept;
    ~__cow_string();

    __cow_string(__cow_string &&) noexcept;
    __cow_string &operator=(__cow_string &&) noexcept;
  };

  typedef basic_string<char> __sso_string;
# 113 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/stdexcept" 3
  class logic_error : public exception {
    __cow_string _M_msg;

  public:
    explicit logic_error(const string &__arg);

    explicit logic_error(const char *);

    logic_error(logic_error &&) noexcept;
    logic_error &operator=(logic_error &&) noexcept;

    logic_error(const logic_error &) noexcept;
    logic_error &operator=(const logic_error &) noexcept;

    virtual ~logic_error() noexcept;

    virtual const char *what() const noexcept;
  };

  class domain_error : public logic_error {
  public:
    explicit domain_error(const string &__arg);

    explicit domain_error(const char *);
    domain_error(const domain_error &) = default;
    domain_error &operator=(const domain_error &) = default;
    domain_error(domain_error &&) = default;
    domain_error &operator=(domain_error &&) = default;

    virtual ~domain_error() noexcept;
  };

  class invalid_argument : public logic_error {
  public:
    explicit invalid_argument(const string &__arg);

    explicit invalid_argument(const char *);
    invalid_argument(const invalid_argument &) = default;
    invalid_argument &operator=(const invalid_argument &) = default;
    invalid_argument(invalid_argument &&) = default;
    invalid_argument &operator=(invalid_argument &&) = default;

    virtual ~invalid_argument() noexcept;
  };

  class length_error : public logic_error {
  public:
    explicit length_error(const string &__arg);

    explicit length_error(const char *);
    length_error(const length_error &) = default;
    length_error &operator=(const length_error &) = default;
    length_error(length_error &&) = default;
    length_error &operator=(length_error &&) = default;

    virtual ~length_error() noexcept;
  };

  class out_of_range : public logic_error {
  public:
    explicit out_of_range(const string &__arg);

    explicit out_of_range(const char *);
    out_of_range(const out_of_range &) = default;
    out_of_range &operator=(const out_of_range &) = default;
    out_of_range(out_of_range &&) = default;
    out_of_range &operator=(out_of_range &&) = default;

    virtual ~out_of_range() noexcept;
  };

  class runtime_error : public exception {
    __cow_string _M_msg;

  public:
    explicit runtime_error(const string &__arg);

    explicit runtime_error(const char *);

    runtime_error(runtime_error &&) noexcept;
    runtime_error &operator=(runtime_error &&) noexcept;

    runtime_error(const runtime_error &) noexcept;
    runtime_error &operator=(const runtime_error &) noexcept;

    virtual ~runtime_error() noexcept;

    virtual const char *what() const noexcept;
  };

  class range_error : public runtime_error {
  public:
    explicit range_error(const string &__arg);

    explicit range_error(const char *);
    range_error(const range_error &) = default;
    range_error &operator=(const range_error &) = default;
    range_error(range_error &&) = default;
    range_error &operator=(range_error &&) = default;

    virtual ~range_error() noexcept;
  };

  class overflow_error : public runtime_error {
  public:
    explicit overflow_error(const string &__arg);

    explicit overflow_error(const char *);
    overflow_error(const overflow_error &) = default;
    overflow_error &operator=(const overflow_error &) = default;
    overflow_error(overflow_error &&) = default;
    overflow_error &operator=(overflow_error &&) = default;

    virtual ~overflow_error() noexcept;
  };

  class underflow_error : public runtime_error {
  public:
    explicit underflow_error(const string &__arg);

    explicit underflow_error(const char *);
    underflow_error(const underflow_error &) = default;
    underflow_error &operator=(const underflow_error &) = default;
    underflow_error(underflow_error &&) = default;
    underflow_error &operator=(underflow_error &&) = default;

    virtual ~underflow_error() noexcept;
  };

} // namespace std
# 44 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 2 3

namespace std __attribute__((__visibility__("default"))) {

  class error_code;
  class error_condition;
  class system_error;

  template <typename _Tp> struct is_error_code_enum : public false_type {};

  template <typename _Tp> struct is_error_condition_enum : public false_type {};

  template <> struct is_error_condition_enum<errc> : public true_type {};

  template <typename _Tp>
  inline constexpr bool is_error_code_enum_v = is_error_code_enum<_Tp>::value;
  template <typename _Tp>
  inline constexpr bool is_error_condition_enum_v =
      is_error_condition_enum<_Tp>::value;

  inline namespace _V2 {
# 106 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 3
  class error_category {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category &) = delete;
    error_category &operator=(const error_category &) = delete;

    virtual const char *name() const noexcept = 0;

  private:
    __attribute((__abi_tag__("cxx11"))) virtual __cow_string
    _M_message(int) const;

  public:
    __attribute((__abi_tag__("cxx11"))) virtual string message(int) const = 0;
# 144 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 3
  public:
    virtual error_condition default_error_condition(int __i) const noexcept;

    virtual bool equivalent(int __i,
                            const error_condition &__cond) const noexcept;

    virtual bool equivalent(const error_code &__code, int __i) const noexcept;

    [[__nodiscard__]]
    bool operator==(const error_category &__other) const noexcept {
      return this == &__other;
    }

    [[nodiscard]]
    strong_ordering operator<=>(const error_category &__rhs) const noexcept {
      return std::compare_three_way()(this, &__rhs);
    }
# 178 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 3
  };

  [[__nodiscard__, __gnu__::__const__]]
  const error_category &generic_category() noexcept;

  [[__nodiscard__, __gnu__::__const__]]
  const error_category &system_category() noexcept;

  } // namespace _V2

  namespace __adl_only {
  void make_error_code() = delete;
  void make_error_condition() = delete;
  } // namespace __adl_only
# 223 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 3
  class error_code {
    template <typename _ErrorCodeEnum>
    using _Check = __enable_if_t<is_error_code_enum<_ErrorCodeEnum>::value>;

  public:
    error_code() noexcept : _M_value(0), _M_cat(&system_category()) {}

    error_code(int __v, const error_category &__cat) noexcept
        : _M_value(__v), _M_cat(&__cat) {}

    template <typename _ErrorCodeEnum, typename = _Check<_ErrorCodeEnum>>
    error_code(_ErrorCodeEnum __e) noexcept {
      using __adl_only::make_error_code;
      *this = make_error_code(__e);
    }

    error_code(const error_code &) = default;
    error_code &operator=(const error_code &) = default;

    void assign(int __v, const error_category &__cat) noexcept {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void clear() noexcept { assign(0, system_category()); }

    [[__nodiscard__]]
    int value() const noexcept {
      return _M_value;
    }

    [[__nodiscard__]]
    const error_category &category() const noexcept {
      return *_M_cat;
    }

    error_condition default_error_condition() const noexcept;

    __attribute((__abi_tag__("cxx11"))) string message() const {
      return category().message(value());
    }

    [[__nodiscard__]]
    explicit operator bool() const noexcept {
      return _M_value != 0;
    }

  private:
    int _M_value;
    const error_category *_M_cat;
  };
# 300 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 3
  [[__nodiscard__]]
  inline error_code make_error_code(errc __e) noexcept {
    return error_code(static_cast<int>(__e), generic_category());
  }
# 314 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 3
  [[nodiscard]]
  inline strong_ordering operator<=>(const error_code &__lhs,
                                     const error_code &__rhs) noexcept {
    if (auto __c = __lhs.category() <=> __rhs.category(); __c != 0)
      return __c;
    return __lhs.value() <=> __rhs.value();
  }
# 337 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 3
  template <typename _CharT, typename _Traits>
  basic_ostream<_CharT, _Traits> &operator<<(
      basic_ostream<_CharT, _Traits> &__os, const error_code &__e) {
    return (__os << __e.category().name() << ':' << __e.value());
  }
# 354 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 3
  class error_condition {
    template <typename _ErrorConditionEnum>
    using _Check =
        __enable_if_t<is_error_condition_enum<_ErrorConditionEnum>::value>;

  public:
    error_condition() noexcept : _M_value(0), _M_cat(&generic_category()) {}

    error_condition(int __v, const error_category &__cat) noexcept
        : _M_value(__v), _M_cat(&__cat) {}

    template <typename _ErrorConditionEnum,
              typename = _Check<_ErrorConditionEnum>>
    error_condition(_ErrorConditionEnum __e) noexcept {
      using __adl_only::make_error_condition;
      *this = make_error_condition(__e);
    }

    error_condition(const error_condition &) = default;
    error_condition &operator=(const error_condition &) = default;

    void assign(int __v, const error_category &__cat) noexcept {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void clear() noexcept { assign(0, generic_category()); }

    [[__nodiscard__]]
    int value() const noexcept {
      return _M_value;
    }

    [[__nodiscard__]]
    const error_category &category() const noexcept {
      return *_M_cat;
    }

    __attribute((__abi_tag__("cxx11"))) string message() const {
      return category().message(value());
    }

    [[__nodiscard__]]
    explicit operator bool() const noexcept {
      return _M_value != 0;
    }

  private:
    int _M_value;
    const error_category *_M_cat;
  };
# 433 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 3
  [[__nodiscard__]]
  inline error_condition make_error_condition(errc __e) noexcept {
    return error_condition(static_cast<int>(__e), generic_category());
  }
# 447 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 3
  [[__nodiscard__]]
  inline bool operator==(const error_code &__lhs,
                         const error_code &__rhs) noexcept {
    return __lhs.category() == __rhs.category() &&
           __lhs.value() == __rhs.value();
  }
# 463 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 3
  [[__nodiscard__]]
  inline bool operator==(const error_code &__lhs,
                         const error_condition &__rhs) noexcept {
    return __lhs.category().equivalent(__lhs.value(), __rhs) ||
           __rhs.category().equivalent(__lhs, __rhs.value());
  }
# 478 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 3
  [[__nodiscard__]]
  inline bool operator==(const error_condition &__lhs,
                         const error_condition &__rhs) noexcept {
    return __lhs.category() == __rhs.category() &&
           __lhs.value() == __rhs.value();
  }
# 496 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 3
  [[nodiscard]]
  inline strong_ordering operator<=>(const error_condition &__lhs,
                                     const error_condition &__rhs) noexcept {
    if (auto __c = __lhs.category() <=> __rhs.category(); __c != 0)
      return __c;
    return __lhs.value() <=> __rhs.value();
  }
# 556 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/system_error" 3
  class system_error : public std::runtime_error {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
        : runtime_error(__ec.message()), _M_code(__ec) {}

    system_error(error_code __ec, const string &__what)
        : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) {}

    system_error(error_code __ec, const char *__what)
        : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) {}

    system_error(int __v, const error_category &__ecat, const char *__what)
        : system_error(error_code(__v, __ecat), __what) {}

    system_error(int __v, const error_category &__ecat)
        : runtime_error(error_code(__v, __ecat).message()),
          _M_code(__v, __ecat) {}

    system_error(int __v, const error_category &__ecat, const string &__what)
        : runtime_error(__what + (": " + error_code(__v, __ecat).message())),
          _M_code(__v, __ecat) {}

    system_error(const system_error &) = default;
    system_error &operator=(const system_error &) = default;

    virtual ~system_error() noexcept;

    const error_code &code() const noexcept { return _M_code; }
  };

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

  template <> struct hash<error_code> : public __hash_base<size_t, error_code> {
    size_t operator()(const error_code &__e) const noexcept {
      const size_t __tmp = std::_Hash_impl::hash(__e.value());
      return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
    }
  };

  template <>
  struct hash<error_condition> : public __hash_base<size_t, error_condition> {
    size_t operator()(const error_condition &__e) const noexcept {
      const size_t __tmp = std::_Hash_impl::hash(__e.value());
      return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
    }
  };

} // namespace std
# 47 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  enum _Ios_Fmtflags {
    _S_boolalpha = 1L << 0,
    _S_dec = 1L << 1,
    _S_fixed = 1L << 2,
    _S_hex = 1L << 3,
    _S_internal = 1L << 4,
    _S_left = 1L << 5,
    _S_oct = 1L << 6,
    _S_right = 1L << 7,
    _S_scientific = 1L << 8,
    _S_showbase = 1L << 9,
    _S_showpoint = 1L << 10,
    _S_showpos = 1L << 11,
    _S_skipws = 1L << 12,
    _S_unitbuf = 1L << 13,
    _S_uppercase = 1L << 14,
    _S_adjustfield = _S_left | _S_right | _S_internal,
    _S_basefield = _S_dec | _S_oct | _S_hex,
    _S_floatfield = _S_scientific | _S_fixed,
    _S_ios_fmtflags_end = 1L << 16,
    _S_ios_fmtflags_max = 2147483647,
    _S_ios_fmtflags_min = ~2147483647
  };

  inline constexpr _Ios_Fmtflags operator&(_Ios_Fmtflags __a,
                                           _Ios_Fmtflags __b) {
    return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b));
  }

  inline constexpr _Ios_Fmtflags operator|(_Ios_Fmtflags __a,
                                           _Ios_Fmtflags __b) {
    return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b));
  }

  inline constexpr _Ios_Fmtflags operator^(_Ios_Fmtflags __a,
                                           _Ios_Fmtflags __b) {
    return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b));
  }

  inline constexpr _Ios_Fmtflags operator~(_Ios_Fmtflags __a) {
    return _Ios_Fmtflags(~static_cast<int>(__a));
  }

  inline const _Ios_Fmtflags &operator|=(_Ios_Fmtflags &__a,
                                         _Ios_Fmtflags __b) {
    return __a = __a | __b;
  }

  inline const _Ios_Fmtflags &operator&=(_Ios_Fmtflags &__a,
                                         _Ios_Fmtflags __b) {
    return __a = __a & __b;
  }

  inline const _Ios_Fmtflags &operator^=(_Ios_Fmtflags &__a,
                                         _Ios_Fmtflags __b) {
    return __a = __a ^ __b;
  }

  enum _Ios_Openmode {
    _S_app = 1L << 0,
    _S_ate = 1L << 1,
    _S_bin = 1L << 2,
    _S_in = 1L << 3,
    _S_out = 1L << 4,
    _S_trunc = 1L << 5,
    _S_noreplace = 1L << 6,
    _S_ios_openmode_end = 1L << 16,
    _S_ios_openmode_max = 2147483647,
    _S_ios_openmode_min = ~2147483647
  };

  inline constexpr _Ios_Openmode operator&(_Ios_Openmode __a,
                                           _Ios_Openmode __b) {
    return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b));
  }

  inline constexpr _Ios_Openmode operator|(_Ios_Openmode __a,
                                           _Ios_Openmode __b) {
    return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b));
  }

  inline constexpr _Ios_Openmode operator^(_Ios_Openmode __a,
                                           _Ios_Openmode __b) {
    return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b));
  }

  inline constexpr _Ios_Openmode operator~(_Ios_Openmode __a) {
    return _Ios_Openmode(~static_cast<int>(__a));
  }

  inline const _Ios_Openmode &operator|=(_Ios_Openmode &__a,
                                         _Ios_Openmode __b) {
    return __a = __a | __b;
  }

  inline const _Ios_Openmode &operator&=(_Ios_Openmode &__a,
                                         _Ios_Openmode __b) {
    return __a = __a & __b;
  }

  inline const _Ios_Openmode &operator^=(_Ios_Openmode &__a,
                                         _Ios_Openmode __b) {
    return __a = __a ^ __b;
  }

  enum _Ios_Iostate {
    _S_goodbit = 0,
    _S_badbit = 1L << 0,
    _S_eofbit = 1L << 1,
    _S_failbit = 1L << 2,
    _S_ios_iostate_end = 1L << 16,
    _S_ios_iostate_max = 2147483647,
    _S_ios_iostate_min = ~2147483647
  };

  inline constexpr _Ios_Iostate operator&(_Ios_Iostate __a, _Ios_Iostate __b) {
    return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b));
  }

  inline constexpr _Ios_Iostate operator|(_Ios_Iostate __a, _Ios_Iostate __b) {
    return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b));
  }

  inline constexpr _Ios_Iostate operator^(_Ios_Iostate __a, _Ios_Iostate __b) {
    return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b));
  }

  inline constexpr _Ios_Iostate operator~(_Ios_Iostate __a) {
    return _Ios_Iostate(~static_cast<int>(__a));
  }

  inline const _Ios_Iostate &operator|=(_Ios_Iostate &__a, _Ios_Iostate __b) {
    return __a = __a | __b;
  }

  inline const _Ios_Iostate &operator&=(_Ios_Iostate &__a, _Ios_Iostate __b) {
    return __a = __a & __b;
  }

  inline const _Ios_Iostate &operator^=(_Ios_Iostate &__a, _Ios_Iostate __b) {
    return __a = __a ^ __b;
  }

  enum _Ios_Seekdir {
    _S_beg = 0,
    _S_cur = 1,
    _S_end = 2,
    _S_ios_seekdir_end = 1L << 16
  };

  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type {};

  [[__nodiscard__, __gnu__::__const__]]
  const error_category &iostream_category() noexcept;

  [[__nodiscard__]]
  inline error_code make_error_code(io_errc __e) noexcept {
    return error_code(static_cast<int>(__e), iostream_category());
  }

  [[__nodiscard__]]
  inline error_condition make_error_condition(io_errc __e) noexcept {
    return error_condition(static_cast<int>(__e), iostream_category());
  }
# 233 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
  class ios_base {
# 251 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
  public:
# 260 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    class __attribute((__abi_tag__("cxx11"))) failure : public system_error {
    public:
      explicit failure(const string &__str);

      explicit failure(const string &, const error_code &);

      explicit failure(const char *, const error_code & = io_errc::stream);

      virtual ~failure() throw();

      virtual const char *what() const throw();
    };
# 346 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;

    static const fmtflags boolalpha = _S_boolalpha;

    static const fmtflags dec = _S_dec;

    static const fmtflags fixed = _S_fixed;

    static const fmtflags hex = _S_hex;

    static const fmtflags internal = _S_internal;

    static const fmtflags left = _S_left;

    static const fmtflags oct = _S_oct;

    static const fmtflags right = _S_right;

    static const fmtflags scientific = _S_scientific;

    static const fmtflags showbase = _S_showbase;

    static const fmtflags showpoint = _S_showpoint;

    static const fmtflags showpos = _S_showpos;

    static const fmtflags skipws = _S_skipws;

    static const fmtflags unitbuf = _S_unitbuf;

    static const fmtflags uppercase = _S_uppercase;

    static const fmtflags adjustfield = _S_adjustfield;

    static const fmtflags basefield = _S_basefield;

    static const fmtflags floatfield = _S_floatfield;
# 421 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;

    static const iostate badbit = _S_badbit;

    static const iostate eofbit = _S_eofbit;

    static const iostate failbit = _S_failbit;

    static const iostate goodbit = _S_goodbit;
# 452 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;

    static const openmode app = _S_app;

    static const openmode ate = _S_ate;

    static const openmode binary = _S_bin;

    static const openmode in = _S_in;

    static const openmode out = _S_out;

    static const openmode trunc = _S_trunc;

    static const openmode __noreplace = _S_noreplace;
# 492 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;

    static const seekdir beg = _S_beg;

    static const seekdir cur = _S_cur;

    static const seekdir end = _S_end;
# 525 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    enum event { erase_event, imbue_event, copyfmt_event };
# 542 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    typedef void (*event_callback)(event __e, ios_base &__b, int __i);
# 554 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    void register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;

    struct _Callback_list {

      _Callback_list *_M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
                     _Callback_list *__cb)
          : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) {}

      void _M_add_reference() {
        __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1);
      }

      int _M_remove_reference() {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0) {
          ;
        }
        return __res;
      }
    };

    _Callback_list *_M_callbacks;

    void _M_call_callbacks(event __ev) throw();

    void _M_dispose_callbacks(void) throw();

    struct _Words {
      void *_M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) {}
    };

    _Words _M_word_zero;

    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];

    int _M_word_size;
    _Words *_M_word;

    _Words &_M_grow_words(int __index, bool __iword);

    locale _M_ios_locale;

    void _M_init() throw();

  public:
    class Init {
      friend class ios_base;

    public:
      Init();
      ~Init();

      Init(const Init &) = default;
      Init &operator=(const Init &) = default;

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };

    fmtflags flags() const { return _M_flags; }
# 672 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    fmtflags flags(fmtflags __fmtfl) {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 688 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    fmtflags setf(fmtflags __fmtfl) {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 705 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    fmtflags setf(fmtflags __fmtfl, fmtflags __mask) {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }

    void unsetf(fmtflags __mask) { _M_flags &= ~__mask; }
# 731 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    streamsize precision() const { return _M_precision; }

    streamsize precision(streamsize __prec) {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }

    streamsize width() const { return _M_width; }

    streamsize width(streamsize __wide) {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 782 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    static bool sync_with_stdio(bool __sync = true);
# 794 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    locale imbue(const locale &__loc) throw();
# 805 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    locale getloc() const { return _M_ios_locale; }
# 816 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    const locale &_M_getloc() const { return _M_ios_locale; }
# 835 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    static int xalloc() throw();
# 851 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    long &iword(int __ix) {
      _Words &__word = ((unsigned)__ix < (unsigned)_M_word_size)
                           ? _M_word[__ix]
                           : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 872 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    void *&pword(int __ix) {
      _Words &__word = ((unsigned)__ix < (unsigned)_M_word_size)
                           ? _M_word[__ix]
                           : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 889 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw();
# 903 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ios_base.h" 3
  public:
    ios_base(const ios_base &) = delete;

    ios_base &operator=(const ios_base &) = delete;

  protected:
    void _M_move(ios_base &) noexcept;

    void _M_swap(ios_base &__rhs) noexcept;
  };

  inline ios_base &boolalpha(ios_base & __base) {
    __base.setf(ios_base::boolalpha);
    return __base;
  }

  inline ios_base &noboolalpha(ios_base & __base) {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }

  inline ios_base &showbase(ios_base & __base) {
    __base.setf(ios_base::showbase);
    return __base;
  }

  inline ios_base &noshowbase(ios_base & __base) {
    __base.unsetf(ios_base::showbase);
    return __base;
  }

  inline ios_base &showpoint(ios_base & __base) {
    __base.setf(ios_base::showpoint);
    return __base;
  }

  inline ios_base &noshowpoint(ios_base & __base) {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }

  inline ios_base &showpos(ios_base & __base) {
    __base.setf(ios_base::showpos);
    return __base;
  }

  inline ios_base &noshowpos(ios_base & __base) {
    __base.unsetf(ios_base::showpos);
    return __base;
  }

  inline ios_base &skipws(ios_base & __base) {
    __base.setf(ios_base::skipws);
    return __base;
  }

  inline ios_base &noskipws(ios_base & __base) {
    __base.unsetf(ios_base::skipws);
    return __base;
  }

  inline ios_base &uppercase(ios_base & __base) {
    __base.setf(ios_base::uppercase);
    return __base;
  }

  inline ios_base &nouppercase(ios_base & __base) {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }

  inline ios_base &unitbuf(ios_base & __base) {
    __base.setf(ios_base::unitbuf);
    return __base;
  }

  inline ios_base &nounitbuf(ios_base & __base) {
    __base.unsetf(ios_base::unitbuf);
    return __base;
  }

  inline ios_base &internal(ios_base & __base) {
    __base.setf(ios_base::internal, ios_base::adjustfield);
    return __base;
  }

  inline ios_base &left(ios_base & __base) {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }

  inline ios_base &right(ios_base & __base) {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }

  inline ios_base &dec(ios_base & __base) {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }

  inline ios_base &hex(ios_base & __base) {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }

  inline ios_base &oct(ios_base & __base) {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }

  inline ios_base &fixed(ios_base & __base) {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }

  inline ios_base &scientific(ios_base & __base) {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }

  inline ios_base &hexfloat(ios_base & __base) {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }

  inline ios_base &defaultfloat(ios_base & __base) {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }

} // namespace std
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ios" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 1 3
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
# 47 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
namespace std __attribute__((__visibility__("default"))) {

  template <typename _CharT, typename _Traits>
  streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *,
                                   basic_streambuf<_CharT, _Traits> *, bool &);
# 123 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
  template <typename _CharT, typename _Traits> class basic_streambuf {
  public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    typedef basic_streambuf<char_type, traits_type> __streambuf_type;

    friend class basic_ios<char_type, traits_type>;
    friend class basic_istream<char_type, traits_type>;
    friend class basic_ostream<char_type, traits_type>;
    friend class istreambuf_iterator<char_type, traits_type>;
    friend class ostreambuf_iterator<char_type, traits_type>;

    friend streamsize __copy_streambufs_eof<>(basic_streambuf *,
                                              basic_streambuf *, bool &);

    template <bool _IsMove, typename _CharT2>
    friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                                           _CharT2 *>::__type
    __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
                   _CharT2 *);

    template <typename _CharT2>
    friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                                           istreambuf_iterator<_CharT2>>::__type
    find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
         const _CharT2 &);

    template <typename _CharT2, typename _Distance>
    friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                                           void>::__type
    advance(istreambuf_iterator<_CharT2> &, _Distance);

    friend void __istream_extract(istream &, char *, streamsize);

    template <typename _CharT2, typename _Traits2, typename _Alloc>
    friend basic_istream<_CharT2, _Traits2> &
    operator>>(basic_istream<_CharT2, _Traits2> &,
               basic_string<_CharT2, _Traits2, _Alloc> &);

    template <typename _CharT2, typename _Traits2, typename _Alloc>
    friend basic_istream<_CharT2, _Traits2> &
    getline(basic_istream<_CharT2, _Traits2> &,
            basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);

  protected:
    char_type *_M_in_beg;
    char_type *_M_in_cur;
    char_type *_M_in_end;
    char_type *_M_out_beg;
    char_type *_M_out_cur;
    char_type *_M_out_end;

    locale _M_buf_locale;

  public:
    virtual ~basic_streambuf() {}
# 215 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    locale pubimbue(const locale &__loc) {
      locale __tmp(this->getloc());
      this->imbue(__loc);
      _M_buf_locale = __loc;
      return __tmp;
    }
# 232 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    locale getloc() const { return _M_buf_locale; }
# 245 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    basic_streambuf *pubsetbuf(char_type *__s, streamsize __n) {
      return this->setbuf(__s, __n);
    }
# 257 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,
                        ios_base::openmode __mode = ios_base::in |
                                                    ios_base::out) {
      return this->seekoff(__off, __way, __mode);
    }
# 269 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    pos_type pubseekpos(pos_type __sp,
                        ios_base::openmode __mode = ios_base::in |
                                                    ios_base::out) {
      return this->seekpos(__sp, __mode);
    }

    int pubsync() { return this->sync(); }
# 290 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    streamsize in_avail() {
      const streamsize __ret = this->egptr() - this->gptr();
      return __ret ? __ret : this->showmanyc();
    }
# 304 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    int_type snextc() {
      int_type __ret = traits_type::eof();
      if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(), __ret),
                           true))
        __ret = this->sgetc();
      return __ret;
    }
# 322 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    int_type sbumpc() {
      int_type __ret;
      if (__builtin_expect(this->gptr() < this->egptr(), true)) {
        __ret = traits_type::to_int_type(*this->gptr());
        this->gbump(1);
      } else
        __ret = this->uflow();
      return __ret;
    }
# 344 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    int_type sgetc() {
      int_type __ret;
      if (__builtin_expect(this->gptr() < this->egptr(), true))
        __ret = traits_type::to_int_type(*this->gptr());
      else
        __ret = this->underflow();
      return __ret;
    }
# 363 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    streamsize sgetn(char_type *__s, streamsize __n) {
      return this->xsgetn(__s, __n);
    }
# 378 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    int_type sputbackc(char_type __c) {
      int_type __ret;
      const bool __testpos = this->eback() < this->gptr();
      if (__builtin_expect(
              !__testpos || !traits_type::eq(__c, this->gptr()[-1]), false))
        __ret = this->pbackfail(traits_type::to_int_type(__c));
      else {
        this->gbump(-1);
        __ret = traits_type::to_int_type(*this->gptr());
      }
      return __ret;
    }
# 403 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    int_type sungetc() {
      int_type __ret;
      if (__builtin_expect(this->eback() < this->gptr(), true)) {
        this->gbump(-1);
        __ret = traits_type::to_int_type(*this->gptr());
      } else
        __ret = this->pbackfail();
      return __ret;
    }
# 430 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    int_type sputc(char_type __c) {
      int_type __ret;
      if (__builtin_expect(this->pptr() < this->epptr(), true)) {
        *this->pptr() = __c;
        this->pbump(1);
        __ret = traits_type::to_int_type(__c);
      } else
        __ret = this->overflow(traits_type::to_int_type(__c));
      return __ret;
    }
# 456 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    streamsize sputn(const char_type *__s, streamsize __n) {
      return this->xsputn(__s, __n);
    }

  protected:
# 470 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    basic_streambuf()
        : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), _M_out_beg(0),
          _M_out_cur(0), _M_out_end(0), _M_buf_locale(locale()) {}
# 488 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    char_type *eback() const { return _M_in_beg; }

    char_type *gptr() const { return _M_in_cur; }

    char_type *egptr() const { return _M_in_end; }
# 504 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    void gbump(int __n) { _M_in_cur += __n; }
# 515 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend) {
      _M_in_beg = __gbeg;
      _M_in_cur = __gnext;
      _M_in_end = __gend;
    }
# 535 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    char_type *pbase() const { return _M_out_beg; }

    char_type *pptr() const { return _M_out_cur; }

    char_type *epptr() const { return _M_out_end; }
# 551 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    void pbump(int __n) { _M_out_cur += __n; }
# 561 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    void setp(char_type *__pbeg, char_type *__pend) {
      _M_out_beg = _M_out_cur = __pbeg;
      _M_out_end = __pend;
    }
# 582 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    virtual void imbue(const locale &__loc __attribute__((__unused__))) {}
# 597 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    virtual basic_streambuf<char_type, _Traits> *setbuf(char_type *,
                                                        streamsize) {
      return this;
    }
# 608 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    virtual pos_type seekoff(off_type, ios_base::seekdir,
                             ios_base::openmode = ios_base::in |
                                                  ios_base::out) {
      return pos_type(off_type(-1));
    }
# 620 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    virtual pos_type seekpos(pos_type, ios_base::openmode = ios_base::in |
                                                            ios_base::out) {
      return pos_type(off_type(-1));
    }
# 633 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    virtual int sync() { return 0; }
# 655 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    virtual streamsize showmanyc() { return 0; }
# 671 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    virtual streamsize xsgetn(char_type *__s, streamsize __n);
# 693 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    virtual int_type underflow() { return traits_type::eof(); }
# 706 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    virtual int_type uflow() {
      int_type __ret = traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(this->underflow(), __ret);
      if (!__testeof) {
        __ret = traits_type::to_int_type(*this->gptr());
        this->gbump(1);
      }
      return __ret;
    }
# 730 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    virtual int_type
    pbackfail(int_type __c __attribute__((__unused__)) = traits_type::eof()) {
      return traits_type::eof();
    }
# 748 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    virtual streamsize xsputn(const char_type *__s, streamsize __n);
# 774 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    virtual int_type
    overflow(int_type __c __attribute__((__unused__)) = traits_type::eof()) {
      return traits_type::eof();
    }
# 801 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 3
    void __safe_gbump(streamsize __n) { _M_in_cur += __n; }

    void __safe_pbump(streamsize __n) { _M_out_cur += __n; }

  protected:
    basic_streambuf(const basic_streambuf &);

    basic_streambuf &operator=(const basic_streambuf &);

    void swap(basic_streambuf &__sb) {
      std::swap(_M_in_beg, __sb._M_in_beg);
      std::swap(_M_in_cur, __sb._M_in_cur);
      std::swap(_M_in_end, __sb._M_in_end);
      std::swap(_M_out_beg, __sb._M_out_beg);
      std::swap(_M_out_cur, __sb._M_out_cur);
      std::swap(_M_out_end, __sb._M_out_end);
      std::swap(_M_buf_locale, __sb._M_buf_locale);
    }
  };

  template <typename _CharT, typename _Traits>
  std::basic_streambuf<_CharT, _Traits>::basic_streambuf(
      const basic_streambuf &) = default;

  template <typename _CharT, typename _Traits>
  std::basic_streambuf<_CharT, _Traits> &
  std::basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf &) =
      default;

  template <>
  streamsize __copy_streambufs_eof(basic_streambuf<char> * __sbin,
                                   basic_streambuf<char> * __sbout,
                                   bool &__ineof);

  template <>
  streamsize __copy_streambufs_eof(basic_streambuf<wchar_t> * __sbin,
                                   basic_streambuf<wchar_t> * __sbout,
                                   bool &__ineof);

} // namespace std

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/streambuf.tcc" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/streambuf.tcc" 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _CharT, typename _Traits>
  streamsize basic_streambuf<_CharT, _Traits>::xsgetn(char_type * __s,
                                                      streamsize __n) {
    streamsize __ret = 0;
    while (__ret < __n) {
      const streamsize __buf_len = this->egptr() - this->gptr();
      if (__buf_len) {
        const streamsize __remaining = __n - __ret;
        const streamsize __len = std::min(__buf_len, __remaining);
        traits_type::copy(__s, this->gptr(), __len);
        __ret += __len;
        __s += __len;
        this->__safe_gbump(__len);
      }

      if (__ret < __n) {
        const int_type __c = this->uflow();
        if (!traits_type::eq_int_type(__c, traits_type::eof())) {
          traits_type::assign(*__s++, traits_type::to_char_type(__c));
          ++__ret;
        } else
          break;
      }
    }
    return __ret;
  }

  template <typename _CharT, typename _Traits>
  streamsize basic_streambuf<_CharT, _Traits>::xsputn(const char_type *__s,
                                                      streamsize __n) {
    streamsize __ret = 0;
    while (__ret < __n) {
      const streamsize __buf_len = this->epptr() - this->pptr();
      if (__buf_len) {
        const streamsize __remaining = __n - __ret;
        const streamsize __len = std::min(__buf_len, __remaining);
        traits_type::copy(this->pptr(), __s, __len);
        __ret += __len;
        __s += __len;
        this->__safe_pbump(__len);
      }

      if (__ret < __n) {
        int_type __c = this->overflow(traits_type::to_int_type(*__s));
        if (!traits_type::eq_int_type(__c, traits_type::eof())) {
          ++__ret;
          ++__s;
        } else
          break;
      }
    }
    return __ret;
  }

  template <typename _CharT, typename _Traits>
  streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> * __sbin,
                                   basic_streambuf<_CharT, _Traits> * __sbout,
                                   bool &__ineof) {
    streamsize __ret = 0;
    __ineof = true;
    typename _Traits::int_type __c = __sbin->sgetc();
    while (!_Traits::eq_int_type(__c, _Traits::eof())) {
      __c = __sbout->sputc(_Traits::to_char_type(__c));
      if (_Traits::eq_int_type(__c, _Traits::eof())) {
        __ineof = false;
        break;
      }
      ++__ret;
      __c = __sbin->snextc();
    }
    return __ret;
  }

  template <typename _CharT, typename _Traits>
  inline streamsize __copy_streambufs(basic_streambuf<_CharT, _Traits> * __sbin,
                                      basic_streambuf<_CharT, _Traits> *
                                          __sbout) {
    bool __ineof;
    return __copy_streambufs_eof(__sbin, __sbout, __ineof);
  }

  extern template class basic_streambuf<char>;

  extern template streamsize __copy_streambufs(basic_streambuf<char> *,
                                               basic_streambuf<char> *);

  extern template class basic_streambuf<wchar_t>;

  extern template streamsize __copy_streambufs(basic_streambuf<wchar_t> *,
                                               basic_streambuf<wchar_t> *);

} // namespace std
# 861 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/streambuf" 2 3
# 46 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ios" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cwctype" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cwctype" 3
# 50 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 38 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
typedef unsigned long int wctype_t;
# 56 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
enum {
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper =
      ((__ISwupper) < 8
           ? (int)((1UL << (__ISwupper)) << 24)
           : ((__ISwupper) < 16
                  ? (int)((1UL << (__ISwupper)) << 8)
                  : ((__ISwupper) < 24 ? (int)((1UL << (__ISwupper)) >> 8)
                                       : (int)((1UL << (__ISwupper)) >> 24)))),
  _ISwlower =
      ((__ISwlower) < 8
           ? (int)((1UL << (__ISwlower)) << 24)
           : ((__ISwlower) < 16
                  ? (int)((1UL << (__ISwlower)) << 8)
                  : ((__ISwlower) < 24 ? (int)((1UL << (__ISwlower)) >> 8)
                                       : (int)((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha =
      ((__ISwalpha) < 8
           ? (int)((1UL << (__ISwalpha)) << 24)
           : ((__ISwalpha) < 16
                  ? (int)((1UL << (__ISwalpha)) << 8)
                  : ((__ISwalpha) < 24 ? (int)((1UL << (__ISwalpha)) >> 8)
                                       : (int)((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit =
      ((__ISwdigit) < 8
           ? (int)((1UL << (__ISwdigit)) << 24)
           : ((__ISwdigit) < 16
                  ? (int)((1UL << (__ISwdigit)) << 8)
                  : ((__ISwdigit) < 24 ? (int)((1UL << (__ISwdigit)) >> 8)
                                       : (int)((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit =
      ((__ISwxdigit) < 8 ? (int)((1UL << (__ISwxdigit)) << 24)
                         : ((__ISwxdigit) < 16
                                ? (int)((1UL << (__ISwxdigit)) << 8)
                                : ((__ISwxdigit) < 24
                                       ? (int)((1UL << (__ISwxdigit)) >> 8)
                                       : (int)((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace =
      ((__ISwspace) < 8
           ? (int)((1UL << (__ISwspace)) << 24)
           : ((__ISwspace) < 16
                  ? (int)((1UL << (__ISwspace)) << 8)
                  : ((__ISwspace) < 24 ? (int)((1UL << (__ISwspace)) >> 8)
                                       : (int)((1UL << (__ISwspace)) >> 24)))),
  _ISwprint =
      ((__ISwprint) < 8
           ? (int)((1UL << (__ISwprint)) << 24)
           : ((__ISwprint) < 16
                  ? (int)((1UL << (__ISwprint)) << 8)
                  : ((__ISwprint) < 24 ? (int)((1UL << (__ISwprint)) >> 8)
                                       : (int)((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph =
      ((__ISwgraph) < 8
           ? (int)((1UL << (__ISwgraph)) << 24)
           : ((__ISwgraph) < 16
                  ? (int)((1UL << (__ISwgraph)) << 8)
                  : ((__ISwgraph) < 24 ? (int)((1UL << (__ISwgraph)) >> 8)
                                       : (int)((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank =
      ((__ISwblank) < 8
           ? (int)((1UL << (__ISwblank)) << 24)
           : ((__ISwblank) < 16
                  ? (int)((1UL << (__ISwblank)) << 8)
                  : ((__ISwblank) < 24 ? (int)((1UL << (__ISwblank)) >> 8)
                                       : (int)((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl =
      ((__ISwcntrl) < 8
           ? (int)((1UL << (__ISwcntrl)) << 24)
           : ((__ISwcntrl) < 16
                  ? (int)((1UL << (__ISwcntrl)) << 8)
                  : ((__ISwcntrl) < 24 ? (int)((1UL << (__ISwcntrl)) >> 8)
                                       : (int)((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct =
      ((__ISwpunct) < 8
           ? (int)((1UL << (__ISwpunct)) << 24)
           : ((__ISwpunct) < 16
                  ? (int)((1UL << (__ISwpunct)) << 8)
                  : ((__ISwpunct) < 24 ? (int)((1UL << (__ISwpunct)) >> 8)
                                       : (int)((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum =
      ((__ISwalnum) < 8
           ? (int)((1UL << (__ISwalnum)) << 24)
           : ((__ISwalnum) < 16
                  ? (int)((1UL << (__ISwalnum)) << 8)
                  : ((__ISwalnum) < 24 ? (int)((1UL << (__ISwalnum)) >> 8)
                                       : (int)((1UL << (__ISwalnum)) >> 24))))
};

extern "C" {

extern int iswalnum(wint_t __wc) noexcept(true);

extern int iswalpha(wint_t __wc) noexcept(true);

extern int iswcntrl(wint_t __wc) noexcept(true);

extern int iswdigit(wint_t __wc) noexcept(true);

extern int iswgraph(wint_t __wc) noexcept(true);

extern int iswlower(wint_t __wc) noexcept(true);

extern int iswprint(wint_t __wc) noexcept(true);

extern int iswpunct(wint_t __wc) noexcept(true);

extern int iswspace(wint_t __wc) noexcept(true);

extern int iswupper(wint_t __wc) noexcept(true);

extern int iswxdigit(wint_t __wc) noexcept(true);

extern int iswblank(wint_t __wc) noexcept(true);
# 155 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
extern wctype_t wctype(const char *__property) noexcept(true);

extern int iswctype(wint_t __wc, wctype_t __desc) noexcept(true);

extern wint_t towlower(wint_t __wc) noexcept(true);

extern wint_t towupper(wint_t __wc) noexcept(true);
}
# 39 "/usr/include/wctype.h" 2 3 4

extern "C" {

typedef const __int32_t *wctrans_t;

extern wctrans_t wctrans(const char *__property) noexcept(true);

extern wint_t towctrans(wint_t __wc, wctrans_t __desc) noexcept(true);

extern int iswalnum_l(wint_t __wc, locale_t __locale) noexcept(true);

extern int iswalpha_l(wint_t __wc, locale_t __locale) noexcept(true);

extern int iswcntrl_l(wint_t __wc, locale_t __locale) noexcept(true);

extern int iswdigit_l(wint_t __wc, locale_t __locale) noexcept(true);

extern int iswgraph_l(wint_t __wc, locale_t __locale) noexcept(true);

extern int iswlower_l(wint_t __wc, locale_t __locale) noexcept(true);

extern int iswprint_l(wint_t __wc, locale_t __locale) noexcept(true);

extern int iswpunct_l(wint_t __wc, locale_t __locale) noexcept(true);

extern int iswspace_l(wint_t __wc, locale_t __locale) noexcept(true);

extern int iswupper_l(wint_t __wc, locale_t __locale) noexcept(true);

extern int iswxdigit_l(wint_t __wc, locale_t __locale) noexcept(true);

extern int iswblank_l(wint_t __wc, locale_t __locale) noexcept(true);

extern wctype_t wctype_l(const char *__property,
                         locale_t __locale) noexcept(true);

extern int iswctype_l(wint_t __wc, wctype_t __desc,
                      locale_t __locale) noexcept(true);

extern wint_t towlower_l(wint_t __wc, locale_t __locale) noexcept(true);

extern wint_t towupper_l(wint_t __wc, locale_t __locale) noexcept(true);

extern wctrans_t wctrans_l(const char *__property,
                           locale_t __locale) noexcept(true);

extern wint_t towctrans_l(wint_t __wc, wctrans_t __desc,
                          locale_t __locale) noexcept(true);
}
# 51 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cwctype" 2 3
# 80 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cwctype" 3
namespace std {
using ::wctrans_t;
using ::wctype_t;
using ::wint_t;

using ::iswalnum;
using ::iswalpha;

using ::iswblank;

using ::iswcntrl;
using ::iswctype;
using ::iswdigit;
using ::iswgraph;
using ::iswlower;
using ::iswprint;
using ::iswpunct;
using ::iswspace;
using ::iswupper;
using ::iswxdigit;
using ::towctrans;
using ::towlower;
using ::towupper;
using ::wctrans;
using ::wctype;
} // namespace std
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cctype" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cctype" 3
# 41 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/ctype_base.h" 1 3
# 36 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/ctype_base.h" 3
namespace std __attribute__((__visibility__("default"))) {

  struct ctype_base {

    typedef const int *__to_type;

    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;

    static const mask blank = _ISblank;
  };

} // namespace std
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/streambuf_iterator.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/streambuf_iterator.h" 3

namespace std __attribute__((__visibility__("default"))) {

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

  template <typename _CharT, typename _Traits>
  class istreambuf_iterator
      : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                        _CharT *, _CharT> {
  public:
# 67 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/streambuf_iterator.h" 3
    using pointer = void;

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename _Traits::int_type int_type;
    typedef basic_streambuf<_CharT, _Traits> streambuf_type;
    typedef basic_istream<_CharT, _Traits> istream_type;

    template <typename _CharT2>
    friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                                           ostreambuf_iterator<_CharT2>>::__type
        copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
             ostreambuf_iterator<_CharT2>);

    template <bool _IsMove, typename _CharT2>
    friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                                           _CharT2 *>::__type
    __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
                   _CharT2 *);

    template <typename _CharT2, typename _Size>
    friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                                           _CharT2 *>::__type
    __copy_n_a(istreambuf_iterator<_CharT2>, _Size, _CharT2 *, bool);

    template <typename _CharT2>
    friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                                           istreambuf_iterator<_CharT2>>::__type
    find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
         const _CharT2 &);

    template <typename _CharT2, typename _Distance>
    friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                                           void>::__type
    advance(istreambuf_iterator<_CharT2> &, _Distance);

  private:
    mutable streambuf_type *_M_sbuf;
    int_type _M_c;

  public:
    constexpr istreambuf_iterator() noexcept
        : _M_sbuf(0), _M_c(traits_type::eof()) {}

    constexpr istreambuf_iterator(default_sentinel_t) noexcept
        : istreambuf_iterator() {}

    istreambuf_iterator(const istreambuf_iterator &) noexcept = default;

    ~istreambuf_iterator() = default;

    istreambuf_iterator(istream_type &__s) noexcept
        : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) {}

    istreambuf_iterator(streambuf_type *__s) noexcept
        : _M_sbuf(__s), _M_c(traits_type::eof()) {}

    istreambuf_iterator &
    operator=(const istreambuf_iterator &) noexcept = default;

    [[__nodiscard__]]
    char_type operator*() const {
      int_type __c = _M_get();
# 161 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/streambuf_iterator.h" 3
      return traits_type::to_char_type(__c);
    }

    istreambuf_iterator &operator++() {

      ;

      _M_sbuf->sbumpc();
      _M_c = traits_type::eof();
      return *this;
    }

    istreambuf_iterator operator++(int) {

      ;

      istreambuf_iterator __old = *this;
      __old._M_c = _M_sbuf->sbumpc();
      _M_c = traits_type::eof();
      return __old;
    }

    [[__nodiscard__]]
    bool equal(const istreambuf_iterator &__b) const {
      return _M_at_eof() == __b._M_at_eof();
    }

  private:
    int_type _M_get() const {
      int_type __ret = _M_c;
      if (_M_sbuf && _S_is_eof(__ret) && _S_is_eof(__ret = _M_sbuf->sgetc()))
        _M_sbuf = 0;
      return __ret;
    }

    bool _M_at_eof() const { return _S_is_eof(_M_get()); }

    static bool _S_is_eof(int_type __c) {
      const int_type __eof = traits_type::eof();
      return traits_type::eq_int_type(__c, __eof);
    }

    [[nodiscard]]
    friend bool operator==(const istreambuf_iterator &__i, default_sentinel_t) {
      return __i._M_at_eof();
    }
  };

  template <typename _CharT, typename _Traits>
  [[__nodiscard__]]
  inline bool operator==(const istreambuf_iterator<_CharT, _Traits> &__a,
                         const istreambuf_iterator<_CharT, _Traits> &__b) {
    return __a.equal(__b);
  }
# 248 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/streambuf_iterator.h" 3
  template <typename _CharT, typename _Traits>
  class ostreambuf_iterator
      : public iterator<output_iterator_tag, void, void, void, void> {
  public:
    using difference_type = ptrdiff_t;

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT, _Traits> streambuf_type;
    typedef basic_ostream<_CharT, _Traits> ostream_type;

    template <typename _CharT2>
    friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                                           ostreambuf_iterator<_CharT2>>::__type
        copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
             ostreambuf_iterator<_CharT2>);

  private:
    streambuf_type *_M_sbuf;
    bool _M_failed;

  public:
    constexpr ostreambuf_iterator() noexcept
        : _M_sbuf(nullptr), _M_failed(true) {}

    ostreambuf_iterator(ostream_type &__s) noexcept
        : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) {}

    ostreambuf_iterator(streambuf_type *__s) noexcept
        : _M_sbuf(__s), _M_failed(!_M_sbuf) {}

    ostreambuf_iterator &operator=(_CharT __c) {
      if (!_M_failed &&
          _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
        _M_failed = true;
      return *this;
    }

    [[__nodiscard__]]
    ostreambuf_iterator &operator*() {
      return *this;
    }

    ostreambuf_iterator &operator++(int) { return *this; }

    ostreambuf_iterator &operator++() { return *this; }

    [[__nodiscard__]]
    bool failed() const noexcept {
      return _M_failed;
    }

    ostreambuf_iterator &_M_put(const _CharT *__ws, streamsize __len) {
      if (__builtin_expect(!_M_failed, true) &&
          __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len, false))
        _M_failed = true;
      return *this;
    }
  };
#pragma GCC diagnostic pop

  template <typename _CharT>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                                  ostreambuf_iterator<_CharT>>::__type
  copy(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last,
       ostreambuf_iterator<_CharT> __result) {
    if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed) {
      bool __ineof;
      __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
      if (!__ineof)
        __result._M_failed = true;
    }
    return __result;
  }

  template <bool _IsMove, typename _CharT>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                                  ostreambuf_iterator<_CharT>>::__type
  __copy_move_a2(_CharT * __first, _CharT * __last,
                 ostreambuf_iterator<_CharT> __result) {
    const streamsize __num = __last - __first;
    if (__num > 0)
      __result._M_put(__first, __num);
    return __result;
  }

  template <bool _IsMove, typename _CharT>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                                  ostreambuf_iterator<_CharT>>::__type
  __copy_move_a2(const _CharT *__first, const _CharT *__last,
                 ostreambuf_iterator<_CharT> __result) {
    const streamsize __num = __last - __first;
    if (__num > 0)
      __result._M_put(__first, __num);
    return __result;
  }

  template <bool _IsMove, typename _CharT>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type
  __copy_move_a2(istreambuf_iterator<_CharT> __first,
                 istreambuf_iterator<_CharT> __last, _CharT * __result) {
    typedef istreambuf_iterator<_CharT> __is_iterator_type;
    typedef typename __is_iterator_type::traits_type traits_type;
    typedef typename __is_iterator_type::streambuf_type streambuf_type;
    typedef typename traits_type::int_type int_type;

    if (__first._M_sbuf && !__last._M_sbuf) {
      streambuf_type *__sb = __first._M_sbuf;
      int_type __c = __sb->sgetc();
      while (!traits_type::eq_int_type(__c, traits_type::eof())) {
        const streamsize __n = __sb->egptr() - __sb->gptr();
        if (__n > 1) {
          traits_type::copy(__result, __sb->gptr(), __n);
          __sb->__safe_gbump(__n);
          __result += __n;
          __c = __sb->underflow();
        } else {
          *__result++ = traits_type::to_char_type(__c);
          __c = __sb->snextc();
        }
      }
    }
    return __result;
  }

  template <typename _CharT, typename _Size>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type
  __copy_n_a(istreambuf_iterator<_CharT> __it, _Size __n, _CharT * __result,
             bool __strict __attribute__((__unused__))) {
    if (__n == 0)
      return __result;

    ;
    _CharT *__beg = __result;
    __result += __it._M_sbuf->sgetn(__beg, __n);

    ;
    return __result;
  }

  template <typename _CharT>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                                  istreambuf_iterator<_CharT>>::__type
  find(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last,
       const _CharT &__val) {
    typedef istreambuf_iterator<_CharT> __is_iterator_type;
    typedef typename __is_iterator_type::traits_type traits_type;
    typedef typename __is_iterator_type::streambuf_type streambuf_type;
    typedef typename traits_type::int_type int_type;
    const int_type __eof = traits_type::eof();

    if (__first._M_sbuf && !__last._M_sbuf) {
      const int_type __ival = traits_type::to_int_type(__val);
      streambuf_type *__sb = __first._M_sbuf;
      int_type __c = __sb->sgetc();
      while (!traits_type::eq_int_type(__c, __eof) &&
             !traits_type::eq_int_type(__c, __ival)) {
        streamsize __n = __sb->egptr() - __sb->gptr();
        if (__n > 1) {
          const _CharT *__p = traits_type::find(__sb->gptr(), __n, __val);
          if (__p)
            __n = __p - __sb->gptr();
          __sb->__safe_gbump(__n);
          __c = __sb->sgetc();
        } else
          __c = __sb->snextc();
      }

      __first._M_c = __eof;
    }

    return __first;
  }

  template <typename _CharT, typename _Distance>
  typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, void>::__type
  advance(istreambuf_iterator<_CharT> & __i, _Distance __n) {
    if (__n == 0)
      return;

    do {
      if (std::__is_constant_evaluated() && !bool(__n > 0))
        __builtin_unreachable();
    } while (false);

    ;

    typedef istreambuf_iterator<_CharT> __is_iterator_type;
    typedef typename __is_iterator_type::traits_type traits_type;
    typedef typename __is_iterator_type::streambuf_type streambuf_type;
    typedef typename traits_type::int_type int_type;
    const int_type __eof = traits_type::eof();

    streambuf_type *__sb = __i._M_sbuf;
    while (__n > 0) {
      streamsize __size = __sb->egptr() - __sb->gptr();
      if (__size > __n) {
        __sb->__safe_gbump(__n);
        break;
      }

      __sb->__safe_gbump(__size);
      __n -= __size;
      if (traits_type::eq_int_type(__sb->underflow(), __eof)) {

        ;
        break;
      }
    }

    __i._M_c = __eof;
  }

} // namespace std
# 49 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 74 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
  template <typename _Tp>
  void __convert_to_v(const char *, _Tp &, ios_base::iostate &,
                      const __c_locale &) throw();

  template <>
  void __convert_to_v(const char *, float &, ios_base::iostate &,
                      const __c_locale &) throw();

  template <>
  void __convert_to_v(const char *, double &, ios_base::iostate &,
                      const __c_locale &) throw();

  template <>
  void __convert_to_v(const char *, long double &, ios_base::iostate &,
                      const __c_locale &) throw();

  template <typename _CharT, typename _Traits> struct __pad {
    static void _S_pad(ios_base &__io, _CharT __fill, _CharT *__news,
                       const _CharT *__olds, streamsize __newlen,
                       streamsize __oldlen);
  };

  template <typename _CharT>
  _CharT *__add_grouping(_CharT * __s, _CharT __sep, const char *__gbeg,
                         size_t __gsize, const _CharT *__first,
                         const _CharT *__last);

  template <typename _CharT>
  inline ostreambuf_iterator<_CharT> __write(ostreambuf_iterator<_CharT> __s,
                                             const _CharT *__ws, int __len) {
    __s._M_put(__ws, __len);
    return __s;
  }

  template <typename _CharT, typename _OutIter>
  inline _OutIter __write(_OutIter __s, const _CharT *__ws, int __len) {
    for (int __j = 0; __j < __len; __j++, ++__s)
      *__s = __ws[__j];
    return __s;
  }
# 152 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
  template <typename _CharT>
  class __ctype_abstract_base : public locale::facet, public ctype_base {
  public:
    typedef _CharT char_type;
# 171 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    bool is(mask __m, char_type __c) const { return this->do_is(__m, __c); }
# 188 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    const char_type *is(const char_type *__lo, const char_type *__hi,
                        mask *__vec) const {
      return this->do_is(__lo, __hi, __vec);
    }
# 204 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    const char_type *scan_is(mask __m, const char_type *__lo,
                             const char_type *__hi) const {
      return this->do_scan_is(__m, __lo, __hi);
    }
# 220 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    const char_type *scan_not(mask __m, const char_type *__lo,
                              const char_type *__hi) const {
      return this->do_scan_not(__m, __lo, __hi);
    }
# 234 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    char_type toupper(char_type __c) const { return this->do_toupper(__c); }
# 249 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    const char_type *toupper(char_type *__lo, const char_type *__hi) const {
      return this->do_toupper(__lo, __hi);
    }
# 263 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    char_type tolower(char_type __c) const { return this->do_tolower(__c); }
# 278 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    const char_type *tolower(char_type *__lo, const char_type *__hi) const {
      return this->do_tolower(__lo, __hi);
    }
# 295 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    char_type widen(char __c) const { return this->do_widen(__c); }
# 314 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    const char *widen(const char *__lo, const char *__hi,
                      char_type *__to) const {
      return this->do_widen(__lo, __hi, __to);
    }
# 333 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    char narrow(char_type __c, char __dfault) const {
      return this->do_narrow(__c, __dfault);
    }
# 355 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    const char_type *narrow(const char_type *__lo, const char_type *__hi,
                            char __dfault, char *__to) const {
      return this->do_narrow(__lo, __hi, __dfault, __to);
    }

  protected:
    explicit __ctype_abstract_base(size_t __refs = 0) : facet(__refs) {}

    virtual ~__ctype_abstract_base() {}
# 380 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual bool do_is(mask __m, char_type __c) const = 0;
# 399 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char_type *do_is(const char_type *__lo, const char_type *__hi,
                                   mask *__vec) const = 0;
# 418 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char_type *do_scan_is(mask __m, const char_type *__lo,
                                        const char_type *__hi) const = 0;
# 437 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char_type *do_scan_not(mask __m, const char_type *__lo,
                                         const char_type *__hi) const = 0;
# 455 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual char_type do_toupper(char_type __c) const = 0;
# 472 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char_type *do_toupper(char_type *__lo,
                                        const char_type *__hi) const = 0;
# 488 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual char_type do_tolower(char_type __c) const = 0;
# 505 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char_type *do_tolower(char_type *__lo,
                                        const char_type *__hi) const = 0;
# 524 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual char_type do_widen(char __c) const = 0;
# 545 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char *do_widen(const char *__lo, const char *__hi,
                                 char_type *__to) const = 0;
# 566 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual char do_narrow(char_type __c, char __dfault) const = 0;
# 591 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char_type *do_narrow(const char_type *__lo,
                                       const char_type *__hi, char __dfault,
                                       char *__to) const = 0;
  };
# 614 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
  template <typename _CharT>
  class ctype : public __ctype_abstract_base<_CharT> {
  public:
    typedef _CharT char_type;
    typedef typename __ctype_abstract_base<_CharT>::mask mask;

    static locale::id id;

    explicit ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) {}

  protected:
    virtual ~ctype();

    virtual bool do_is(mask __m, char_type __c) const;

    virtual const char_type *do_is(const char_type *__lo, const char_type *__hi,
                                   mask *__vec) const;

    virtual const char_type *do_scan_is(mask __m, const char_type *__lo,
                                        const char_type *__hi) const;

    virtual const char_type *do_scan_not(mask __m, const char_type *__lo,
                                         const char_type *__hi) const;

    virtual char_type do_toupper(char_type __c) const;

    virtual const char_type *do_toupper(char_type *__lo,
                                        const char_type *__hi) const;

    virtual char_type do_tolower(char_type __c) const;

    virtual const char_type *do_tolower(char_type *__lo,
                                        const char_type *__hi) const;

    virtual char_type do_widen(char __c) const;

    virtual const char *do_widen(const char *__lo, const char *__hi,
                                 char_type *__dest) const;

    virtual char do_narrow(char_type, char __dfault) const;

    virtual const char_type *do_narrow(const char_type *__lo,
                                       const char_type *__hi, char __dfault,
                                       char *__to) const;
  };

  template <typename _CharT> locale::id ctype<_CharT>::id;

  template <typename _CharT, typename _Traits, typename _Alloc>
  class ctype<basic_string<_CharT, _Traits, _Alloc>>;
# 688 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
  template <> class ctype<char> : public locale::facet, public ctype_base {
  public:
    typedef char char_type;

  protected:
    __c_locale _M_c_locale_ctype;
    bool _M_del;
    __to_type _M_toupper;
    __to_type _M_tolower;
    const mask *_M_table;
    mutable char _M_widen_ok;
    mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
    mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
    mutable char _M_narrow_ok;

  public:
    static locale::id id;

    static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 725 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    explicit ctype(const mask *__table = 0, bool __del = false,
                   size_t __refs = 0);
# 738 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    explicit ctype(__c_locale __cloc, const mask *__table = 0,
                   bool __del = false, size_t __refs = 0);
# 751 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    inline bool is(mask __m, char __c) const;
# 766 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    inline const char *is(const char *__lo, const char *__hi,
                          mask *__vec) const;
# 780 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    inline const char *scan_is(mask __m, const char *__lo,
                               const char *__hi) const;
# 794 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    inline const char *scan_not(mask __m, const char *__lo,
                                const char *__hi) const;
# 809 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    char_type toupper(char_type __c) const { return this->do_toupper(__c); }
# 826 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    const char_type *toupper(char_type *__lo, const char_type *__hi) const {
      return this->do_toupper(__lo, __hi);
    }
# 842 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    char_type tolower(char_type __c) const { return this->do_tolower(__c); }
# 859 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    const char_type *tolower(char_type *__lo, const char_type *__hi) const {
      return this->do_tolower(__lo, __hi);
    }
# 879 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    char_type widen(char __c) const {
      if (_M_widen_ok)
        return _M_widen[static_cast<unsigned char>(__c)];
      this->_M_widen_init();
      return this->do_widen(__c);
    }
# 906 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    const char *widen(const char *__lo, const char *__hi,
                      char_type *__to) const {
      if (_M_widen_ok == 1) {
        if (__builtin_expect(__hi != __lo, true))
          __builtin_memcpy(__to, __lo, __hi - __lo);
        return __hi;
      }
      if (!_M_widen_ok)
        _M_widen_init();
      return this->do_widen(__lo, __hi, __to);
    }
# 938 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    char narrow(char_type __c, char __dfault) const {
      if (_M_narrow[static_cast<unsigned char>(__c)])
        return _M_narrow[static_cast<unsigned char>(__c)];
      const char __t = do_narrow(__c, __dfault);
      if (__t != __dfault)
        _M_narrow[static_cast<unsigned char>(__c)] = __t;
      return __t;
    }
# 971 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    const char_type *narrow(const char_type *__lo, const char_type *__hi,
                            char __dfault, char *__to) const {
      if (__builtin_expect(_M_narrow_ok == 1, true)) {
        if (__builtin_expect(__hi != __lo, true))
          __builtin_memcpy(__to, __lo, __hi - __lo);
        return __hi;
      }
      if (!_M_narrow_ok)
        _M_narrow_init();
      return this->do_narrow(__lo, __hi, __dfault, __to);
    }

    const mask *table() const throw() { return _M_table; }

    static const mask *classic_table() throw();

  protected:
    virtual ~ctype();
# 1021 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual char_type do_toupper(char_type __c) const;
# 1038 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char_type *do_toupper(char_type *__lo,
                                        const char_type *__hi) const;
# 1054 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual char_type do_tolower(char_type __c) const;
# 1071 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char_type *do_tolower(char_type *__lo,
                                        const char_type *__hi) const;
# 1091 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual char_type do_widen(char __c) const { return __c; }
# 1114 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char *do_widen(const char *__lo, const char *__hi,
                                 char_type *__to) const {
      if (__builtin_expect(__hi != __lo, true))
        __builtin_memcpy(__to, __lo, __hi - __lo);
      return __hi;
    }
# 1141 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual char do_narrow(char_type __c,
                           char __dfault __attribute__((__unused__))) const {
      return __c;
    }
# 1167 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char_type *
    do_narrow(const char_type *__lo, const char_type *__hi,
              char __dfault __attribute__((__unused__)), char *__to) const {
      if (__builtin_expect(__hi != __lo, true))
        __builtin_memcpy(__to, __lo, __hi - __lo);
      return __hi;
    }

  private:
    void _M_narrow_init() const;
    void _M_widen_init() const;
  };
# 1193 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
  template <> class ctype<wchar_t> : public __ctype_abstract_base<wchar_t> {
  public:
    typedef wchar_t char_type;
    typedef wctype_t __wmask_type;

  protected:
    __c_locale _M_c_locale_ctype;

    bool _M_narrow_ok;
    char _M_narrow[128];
    wint_t _M_widen[1 + static_cast<unsigned char>(-1)];

    mask _M_bit[16];
    __wmask_type _M_wmask[16];

  public:
    static locale::id id;
# 1226 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    explicit ctype(size_t __refs = 0);
# 1237 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    explicit ctype(__c_locale __cloc, size_t __refs = 0);

  protected:
    __wmask_type _M_convert_to_wmask(const mask __m) const throw();

    virtual ~ctype();
# 1261 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual bool do_is(mask __m, char_type __c) const;
# 1280 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char_type *do_is(const char_type *__lo, const char_type *__hi,
                                   mask *__vec) const;
# 1298 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char_type *do_scan_is(mask __m, const char_type *__lo,
                                        const char_type *__hi) const;
# 1316 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char_type *do_scan_not(mask __m, const char_type *__lo,
                                         const char_type *__hi) const;
# 1333 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual char_type do_toupper(char_type __c) const;
# 1350 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char_type *do_toupper(char_type *__lo,
                                        const char_type *__hi) const;
# 1366 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual char_type do_tolower(char_type __c) const;
# 1383 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char_type *do_tolower(char_type *__lo,
                                        const char_type *__hi) const;
# 1403 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual char_type do_widen(char __c) const;
# 1425 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char *do_widen(const char *__lo, const char *__hi,
                                 char_type *__to) const;
# 1448 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual char do_narrow(char_type __c, char __dfault) const;
# 1474 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual const char_type *do_narrow(const char_type *__lo,
                                       const char_type *__hi, char __dfault,
                                       char *__to) const;

    void _M_initialize_ctype() throw();
  };

  template <typename _CharT> class ctype_byname : public ctype<_CharT> {
  public:
    typedef typename ctype<_CharT>::mask mask;

    explicit ctype_byname(const char *__s, size_t __refs = 0);

    explicit ctype_byname(const string &__s, size_t __refs = 0)
        : ctype_byname(__s.c_str(), __refs) {}

  protected:
    virtual ~ctype_byname() {}
  };

  template <> class ctype_byname<char> : public ctype<char> {
  public:
    explicit ctype_byname(const char *__s, size_t __refs = 0);

    explicit ctype_byname(const string &__s, size_t __refs = 0);

  protected:
    virtual ~ctype_byname();
  };

  template <> class ctype_byname<wchar_t> : public ctype<wchar_t> {
  public:
    explicit ctype_byname(const char *__s, size_t __refs = 0);

    explicit ctype_byname(const string &__s, size_t __refs = 0);

  protected:
    virtual ~ctype_byname();
  };

} // namespace std

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h" 1 3
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h" 3
namespace std __attribute__((__visibility__("default"))) {

  bool ctype<char>::is(mask __m, char __c) const {
    return _M_table[static_cast<unsigned char>(__c)] & __m;
  }

  const char *ctype<char>::is(const char *__low, const char *__high,
                              mask *__vec) const {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char *ctype<char>::scan_is(mask __m, const char *__low,
                                   const char *__high) const {
    while (__low < __high &&
           !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char *ctype<char>::scan_not(mask __m, const char *__low,
                                    const char *__high) const {
    while (__low < __high &&
           (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }

} // namespace std
# 1547 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  class __num_base {
  public:
    enum {
      _S_ominus,
      _S_oplus,
      _S_ox,
      _S_oX,
      _S_odigits,
      _S_odigits_end = _S_odigits + 16,
      _S_oudigits = _S_odigits_end,
      _S_oudigits_end = _S_oudigits + 16,
      _S_oe = _S_odigits + 14,
      _S_oE = _S_oudigits + 14,
      _S_oend = _S_oudigits_end
    };

    static const char *_S_atoms_out;

    static const char *_S_atoms_in;

    enum {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };

    static void _S_format_float(const ios_base &__io, char *__fptr,
                                char __mod) throw();
  };

  template <typename _CharT> struct __numpunct_cache : public locale::facet {
    const char *_M_grouping;
    size_t _M_grouping_size;
    bool _M_use_grouping;
    const _CharT *_M_truename;
    size_t _M_truename_size;
    const _CharT *_M_falsename;
    size_t _M_falsename_size;
    _CharT _M_decimal_point;
    _CharT _M_thousands_sep;

    _CharT _M_atoms_out[__num_base::_S_oend];

    _CharT _M_atoms_in[__num_base::_S_iend];

    bool _M_allocated;

    __numpunct_cache(size_t __refs = 0)
        : facet(__refs), _M_grouping(0), _M_grouping_size(0),
          _M_use_grouping(false), _M_truename(0), _M_truename_size(0),
          _M_falsename(0), _M_falsename_size(0), _M_decimal_point(_CharT()),
          _M_thousands_sep(_CharT()), _M_allocated(false) {}

    ~__numpunct_cache();

    void _M_cache(const locale &__loc);

  private:
    __numpunct_cache &operator=(const __numpunct_cache &);

    explicit __numpunct_cache(const __numpunct_cache &);
  };

  template <typename _CharT> __numpunct_cache<_CharT>::~__numpunct_cache() {
    if (_M_allocated) {
      delete[] _M_grouping;
      delete[] _M_truename;
      delete[] _M_falsename;
    }
  }

  namespace __cxx11 {
# 1677 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
  template <typename _CharT> class numpunct : public locale::facet {
  public:
    typedef _CharT char_type;
    typedef basic_string<_CharT> string_type;

    typedef __numpunct_cache<_CharT> __cache_type;

  protected:
    __cache_type *_M_data;

  public:
    static locale::id id;

    explicit numpunct(size_t __refs = 0) : facet(__refs), _M_data(0) {
      _M_initialize_numpunct();
    }
# 1715 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    explicit numpunct(__cache_type *__cache, size_t __refs = 0)
        : facet(__refs), _M_data(__cache) {
      _M_initialize_numpunct();
    }
# 1729 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    explicit numpunct(__c_locale __cloc, size_t __refs = 0)
        : facet(__refs), _M_data(0) {
      _M_initialize_numpunct(__cloc);
    }
# 1743 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    char_type decimal_point() const { return this->do_decimal_point(); }
# 1756 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    char_type thousands_sep() const { return this->do_thousands_sep(); }
# 1787 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    string grouping() const { return this->do_grouping(); }
# 1800 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    string_type truename() const { return this->do_truename(); }
# 1813 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    string_type falsename() const { return this->do_falsename(); }

  protected:
    virtual ~numpunct();
# 1830 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual char_type do_decimal_point() const {
      return _M_data->_M_decimal_point;
    }
# 1842 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual char_type do_thousands_sep() const {
      return _M_data->_M_thousands_sep;
    }
# 1855 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual string do_grouping() const { return _M_data->_M_grouping; }
# 1868 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual string_type do_truename() const { return _M_data->_M_truename; }
# 1881 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual string_type do_falsename() const { return _M_data->_M_falsename; }

    void _M_initialize_numpunct(__c_locale __cloc = 0);
  };

  template <typename _CharT> locale::id numpunct<_CharT>::id;

  template <> numpunct<char>::~numpunct();

  template <> void numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);

  template <> numpunct<wchar_t>::~numpunct();

  template <> void numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);

  template <typename _CharT> class numpunct_byname : public numpunct<_CharT> {
  public:
    typedef _CharT char_type;
    typedef basic_string<_CharT> string_type;

    explicit numpunct_byname(const char *__s, size_t __refs = 0)
        : numpunct<_CharT>(__refs) {
      if (__builtin_strcmp(__s, "C") != 0 &&
          __builtin_strcmp(__s, "POSIX") != 0) {
        __c_locale __tmp;
        this->_S_create_c_locale(__tmp, __s);
        this->_M_initialize_numpunct(__tmp);
        this->_S_destroy_c_locale(__tmp);
      }
    }

    explicit numpunct_byname(const string &__s, size_t __refs = 0)
        : numpunct_byname(__s.c_str(), __refs) {}

  protected:
    virtual ~numpunct_byname() {}
  };

  } // namespace __cxx11
# 1959 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
  template <typename _CharT, typename _InIter>
  class num_get : public locale::facet {
  public:
    typedef _CharT char_type;
    typedef _InIter iter_type;

    static locale::id id;
# 1980 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    explicit num_get(size_t __refs = 0) : facet(__refs) {}
# 2006 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    iter_type get(iter_type __in, iter_type __end, ios_base &__io,
                  ios_base::iostate &__err, bool &__v) const {
      return this->do_get(__in, __end, __io, __err, __v);
    }
# 2043 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    iter_type get(iter_type __in, iter_type __end, ios_base &__io,
                  ios_base::iostate &__err, long &__v) const {
      return this->do_get(__in, __end, __io, __err, __v);
    }

    iter_type get(iter_type __in, iter_type __end, ios_base &__io,
                  ios_base::iostate &__err, unsigned short &__v) const {
      return this->do_get(__in, __end, __io, __err, __v);
    }

    iter_type get(iter_type __in, iter_type __end, ios_base &__io,
                  ios_base::iostate &__err, unsigned int &__v) const {
      return this->do_get(__in, __end, __io, __err, __v);
    }

    iter_type get(iter_type __in, iter_type __end, ios_base &__io,
                  ios_base::iostate &__err, unsigned long &__v) const {
      return this->do_get(__in, __end, __io, __err, __v);
    }

    iter_type get(iter_type __in, iter_type __end, ios_base &__io,
                  ios_base::iostate &__err, long long &__v) const {
      return this->do_get(__in, __end, __io, __err, __v);
    }

    iter_type get(iter_type __in, iter_type __end, ios_base &__io,
                  ios_base::iostate &__err, unsigned long long &__v) const {
      return this->do_get(__in, __end, __io, __err, __v);
    }
# 2103 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    iter_type get(iter_type __in, iter_type __end, ios_base &__io,
                  ios_base::iostate &__err, float &__v) const {
      return this->do_get(__in, __end, __io, __err, __v);
    }

    iter_type get(iter_type __in, iter_type __end, ios_base &__io,
                  ios_base::iostate &__err, double &__v) const {
      return this->do_get(__in, __end, __io, __err, __v);
    }

    iter_type get(iter_type __in, iter_type __end, ios_base &__io,
                  ios_base::iostate &__err, long double &__v) const {
      return this->do_get(__in, __end, __io, __err, __v);
    }
# 2146 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    iter_type get(iter_type __in, iter_type __end, ios_base &__io,
                  ios_base::iostate &__err, void *&__v) const {
      return this->do_get(__in, __end, __io, __err, __v);
    }

  protected:
    virtual ~num_get() {}

    __attribute((__abi_tag__("cxx11"))) iter_type _M_extract_float(
        iter_type, iter_type, ios_base &, ios_base::iostate &, string &) const;

    template <typename _ValueT>
    __attribute((__abi_tag__("cxx11"))) iter_type _M_extract_int(
        iter_type, iter_type, ios_base &, ios_base::iostate &, _ValueT &) const;

    template <typename _CharT2>
    typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
    _M_find(const _CharT2 *, size_t __len, _CharT2 __c) const {
      int __ret = -1;
      if (__len <= 10) {
        if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
          __ret = __c - _CharT2('0');
      } else {
        if (__c >= _CharT2('0') && __c <= _CharT2('9'))
          __ret = __c - _CharT2('0');
        else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
          __ret = 10 + (__c - _CharT2('a'));
        else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
          __ret = 10 + (__c - _CharT2('A'));
      }
      return __ret;
    }

    template <typename _CharT2>
    typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type
    _M_find(const _CharT2 *__zero, size_t __len, _CharT2 __c) const {
      int __ret = -1;
      const char_type *__q = char_traits<_CharT2>::find(__zero, __len, __c);
      if (__q) {
        __ret = __q - __zero;
        if (__ret > 15)
          __ret -= 6;
      }
      return __ret;
    }
# 2219 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual iter_type do_get(iter_type, iter_type, ios_base &,
                             ios_base::iostate &, bool &) const;

    virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io,
                             ios_base::iostate &__err, long &__v) const {
      return _M_extract_int(__beg, __end, __io, __err, __v);
    }

    virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io,
                             ios_base::iostate &__err,
                             unsigned short &__v) const {
      return _M_extract_int(__beg, __end, __io, __err, __v);
    }

    virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io,
                             ios_base::iostate &__err,
                             unsigned int &__v) const {
      return _M_extract_int(__beg, __end, __io, __err, __v);
    }

    virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io,
                             ios_base::iostate &__err,
                             unsigned long &__v) const {
      return _M_extract_int(__beg, __end, __io, __err, __v);
    }

    virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io,
                             ios_base::iostate &__err, long long &__v) const {
      return _M_extract_int(__beg, __end, __io, __err, __v);
    }

    virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io,
                             ios_base::iostate &__err,
                             unsigned long long &__v) const {
      return _M_extract_int(__beg, __end, __io, __err, __v);
    }

    virtual iter_type do_get(iter_type, iter_type, ios_base &,
                             ios_base::iostate &, float &) const;

    virtual iter_type do_get(iter_type, iter_type, ios_base &,
                             ios_base::iostate &, double &) const;
# 2271 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual iter_type do_get(iter_type, iter_type, ios_base &,
                             ios_base::iostate &, long double &) const;

    virtual iter_type do_get(iter_type, iter_type, ios_base &,
                             ios_base::iostate &, void *&) const;
# 2299 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
  };

  template <typename _CharT, typename _InIter>
  locale::id num_get<_CharT, _InIter>::id;
# 2317 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
  template <typename _CharT, typename _OutIter>
  class num_put : public locale::facet {
  public:
    typedef _CharT char_type;
    typedef _OutIter iter_type;

    static locale::id id;
# 2338 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    explicit num_put(size_t __refs = 0) : facet(__refs) {}
# 2356 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    iter_type put(iter_type __s, ios_base &__io, char_type __fill,
                  bool __v) const {
      return this->do_put(__s, __io, __fill, __v);
    }
# 2398 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    iter_type put(iter_type __s, ios_base &__io, char_type __fill,
                  long __v) const {
      return this->do_put(__s, __io, __fill, __v);
    }

    iter_type put(iter_type __s, ios_base &__io, char_type __fill,
                  unsigned long __v) const {
      return this->do_put(__s, __io, __fill, __v);
    }

    iter_type put(iter_type __s, ios_base &__io, char_type __fill,
                  long long __v) const {
      return this->do_put(__s, __io, __fill, __v);
    }

    iter_type put(iter_type __s, ios_base &__io, char_type __fill,
                  unsigned long long __v) const {
      return this->do_put(__s, __io, __fill, __v);
    }
# 2461 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    iter_type put(iter_type __s, ios_base &__io, char_type __fill,
                  double __v) const {
      return this->do_put(__s, __io, __fill, __v);
    }

    iter_type put(iter_type __s, ios_base &__io, char_type __fill,
                  long double __v) const {
      return this->do_put(__s, __io, __fill, __v);
    }
# 2486 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    iter_type put(iter_type __s, ios_base &__io, char_type __fill,
                  const void *__v) const {
      return this->do_put(__s, __io, __fill, __v);
    }

  protected:
    template <typename _ValueT>
    iter_type _M_insert_float(iter_type, ios_base &__io, char_type __fill,
                              char __mod, _ValueT __v) const;

    void _M_group_float(const char *__grouping, size_t __grouping_size,
                        char_type __sep, const char_type *__p, char_type *__new,
                        char_type *__cs, int &__len) const;

    template <typename _ValueT>
    iter_type _M_insert_int(iter_type, ios_base &__io, char_type __fill,
                            _ValueT __v) const;

    void _M_group_int(const char *__grouping, size_t __grouping_size,
                      char_type __sep, ios_base &__io, char_type *__new,
                      char_type *__cs, int &__len) const;

    void _M_pad(char_type __fill, streamsize __w, ios_base &__io,
                char_type *__new, const char_type *__cs, int &__len) const;

    virtual ~num_put() {}
# 2534 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
    virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill,
                             bool __v) const;

    virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill,
                             long __v) const {
      return _M_insert_int(__s, __io, __fill, __v);
    }

    virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill,
                             unsigned long __v) const {
      return _M_insert_int(__s, __io, __fill, __v);
    }

    virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill,
                             long long __v) const {
      return _M_insert_int(__s, __io, __fill, __v);
    }

    virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill,
                             unsigned long long __v) const {
      return _M_insert_int(__s, __io, __fill, __v);
    }

    virtual iter_type do_put(iter_type, ios_base &, char_type, double) const;

    virtual iter_type do_put(iter_type, ios_base &, char_type,
                             long double) const;

    virtual iter_type do_put(iter_type, ios_base &, char_type,
                             const void *) const;
# 2586 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
  };

  template <typename _CharT, typename _OutIter>
  locale::id num_put<_CharT, _OutIter>::id;
# 2599 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 3
  template <typename _CharT>
  inline bool isspace(_CharT __c, const locale &__loc) {
    return use_facet<ctype<_CharT>>(__loc).is(ctype_base::space, __c);
  }

  template <typename _CharT>
  inline bool isprint(_CharT __c, const locale &__loc) {
    return use_facet<ctype<_CharT>>(__loc).is(ctype_base::print, __c);
  }

  template <typename _CharT>
  inline bool iscntrl(_CharT __c, const locale &__loc) {
    return use_facet<ctype<_CharT>>(__loc).is(ctype_base::cntrl, __c);
  }

  template <typename _CharT>
  inline bool isupper(_CharT __c, const locale &__loc) {
    return use_facet<ctype<_CharT>>(__loc).is(ctype_base::upper, __c);
  }

  template <typename _CharT>
  inline bool islower(_CharT __c, const locale &__loc) {
    return use_facet<ctype<_CharT>>(__loc).is(ctype_base::lower, __c);
  }

  template <typename _CharT>
  inline bool isalpha(_CharT __c, const locale &__loc) {
    return use_facet<ctype<_CharT>>(__loc).is(ctype_base::alpha, __c);
  }

  template <typename _CharT>
  inline bool isdigit(_CharT __c, const locale &__loc) {
    return use_facet<ctype<_CharT>>(__loc).is(ctype_base::digit, __c);
  }

  template <typename _CharT>
  inline bool ispunct(_CharT __c, const locale &__loc) {
    return use_facet<ctype<_CharT>>(__loc).is(ctype_base::punct, __c);
  }

  template <typename _CharT>
  inline bool isxdigit(_CharT __c, const locale &__loc) {
    return use_facet<ctype<_CharT>>(__loc).is(ctype_base::xdigit, __c);
  }

  template <typename _CharT>
  inline bool isalnum(_CharT __c, const locale &__loc) {
    return use_facet<ctype<_CharT>>(__loc).is(ctype_base::alnum, __c);
  }

  template <typename _CharT>
  inline bool isgraph(_CharT __c, const locale &__loc) {
    return use_facet<ctype<_CharT>>(__loc).is(ctype_base::graph, __c);
  }

  template <typename _CharT>
  inline bool isblank(_CharT __c, const locale &__loc) {
    return use_facet<ctype<_CharT>>(__loc).is(ctype_base::blank, __c);
  }

  template <typename _CharT>
  inline _CharT toupper(_CharT __c, const locale &__loc) {
    return use_facet<ctype<_CharT>>(__loc).toupper(__c);
  }

  template <typename _CharT>
  inline _CharT tolower(_CharT __c, const locale &__loc) {
    return use_facet<ctype<_CharT>>(__loc).tolower(__c);
  }

} // namespace std

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.tcc" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.tcc" 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _Facet> struct __use_cache {
    const _Facet *operator()(const locale &__loc) const;
  };

  template <typename _CharT> struct __use_cache<__numpunct_cache<_CharT>> {
    const __numpunct_cache<_CharT> *operator()(const locale &__loc) const {
      const size_t __i = numpunct<_CharT>::id._M_id();
      const locale::facet **__caches = __loc._M_impl->_M_caches;
      if (!__caches[__i]) {
        __numpunct_cache<_CharT> *__tmp = 0;
        try {
          __tmp = new __numpunct_cache<_CharT>;
          __tmp->_M_cache(__loc);
        } catch (...) {
          delete __tmp;
          throw;
        }
        __loc._M_impl->_M_install_cache(__tmp, __i);
      }
      return static_cast<const __numpunct_cache<_CharT> *>(__caches[__i]);
    }
  };

  template <typename _CharT>
  void __numpunct_cache<_CharT>::_M_cache(const locale &__loc) {
    const numpunct<_CharT> &__np = use_facet<numpunct<_CharT>>(__loc);

    char *__grouping = 0;
    _CharT *__truename = 0;
    _CharT *__falsename = 0;
    try {
      const string &__g = __np.grouping();
      _M_grouping_size = __g.size();
      __grouping = new char[_M_grouping_size];
      __g.copy(__grouping, _M_grouping_size);
      _M_use_grouping =
          (_M_grouping_size && static_cast<signed char>(__grouping[0]) > 0 &&
           (__grouping[0] != __gnu_cxx::__numeric_traits<char>::__max));

      const basic_string<_CharT> &__tn = __np.truename();
      _M_truename_size = __tn.size();
      __truename = new _CharT[_M_truename_size];
      __tn.copy(__truename, _M_truename_size);

      const basic_string<_CharT> &__fn = __np.falsename();
      _M_falsename_size = __fn.size();
      __falsename = new _CharT[_M_falsename_size];
      __fn.copy(__falsename, _M_falsename_size);

      _M_decimal_point = __np.decimal_point();
      _M_thousands_sep = __np.thousands_sep();

      const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__loc);
      __ct.widen(__num_base::_S_atoms_out,
                 __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);
      __ct.widen(__num_base::_S_atoms_in,
                 __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);

      _M_grouping = __grouping;
      _M_truename = __truename;
      _M_falsename = __falsename;
      _M_allocated = true;
    } catch (...) {
      delete[] __grouping;
      delete[] __truename;
      delete[] __falsename;
      throw;
    }
  }
# 139 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.tcc" 3
  __attribute__((__pure__)) bool __verify_grouping(
      const char *__grouping, size_t __grouping_size,
      const string &__grouping_tmp) throw();

  template <typename _CharT, typename _InIter>
  __attribute((__abi_tag__("cxx11"))) _InIter
  num_get<_CharT, _InIter>::_M_extract_float(
      _InIter __beg, _InIter __end, ios_base & __io, ios_base::iostate & __err,
      string & __xtrc) const {
    typedef char_traits<_CharT> __traits_type;
    typedef __numpunct_cache<_CharT> __cache_type;
    __use_cache<__cache_type> __uc;
    const locale &__loc = __io._M_getloc();
    const __cache_type *__lc = __uc(__loc);
    const _CharT *__lit = __lc->_M_atoms_in;
    char_type __c = char_type();

    bool __testeof = __beg == __end;

    if (!__testeof) {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if ((__plus || __c == __lit[__num_base::_S_iminus]) &&
          !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) &&
          !(__c == __lc->_M_decimal_point)) {
        __xtrc += __plus ? '+' : '-';
        if (++__beg != __end)
          __c = *__beg;
        else
          __testeof = true;
      }
    }

    bool __found_mantissa = false;
    int __sep_pos = 0;
    while (!__testeof) {
      if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) ||
          __c == __lc->_M_decimal_point)
        break;
      else if (__c == __lit[__num_base::_S_izero]) {
        if (!__found_mantissa) {
          __xtrc += '0';
          __found_mantissa = true;
        }
        ++__sep_pos;

        if (++__beg != __end)
          __c = *__beg;
        else
          __testeof = true;
      } else
        break;
    }

    bool __found_dec = false;
    bool __found_sci = false;
    string __found_grouping;
    if (__lc->_M_use_grouping)
      __found_grouping.reserve(32);
    const char_type *__lit_zero = __lit + __num_base::_S_izero;

    if (!__lc->_M_allocated)

      while (!__testeof) {
        const int __digit = _M_find(__lit_zero, 10, __c);
        if (__digit != -1) {
          __xtrc += '0' + __digit;
          __found_mantissa = true;
        } else if (__c == __lc->_M_decimal_point && !__found_dec &&
                   !__found_sci) {
          __xtrc += '.';
          __found_dec = true;
        } else if ((__c == __lit[__num_base::_S_ie] ||
                    __c == __lit[__num_base::_S_iE]) &&
                   !__found_sci && __found_mantissa) {

          __xtrc += 'e';
          __found_sci = true;

          if (++__beg != __end) {
            __c = *__beg;
            const bool __plus = __c == __lit[__num_base::_S_iplus];
            if (__plus || __c == __lit[__num_base::_S_iminus])
              __xtrc += __plus ? '+' : '-';
            else
              continue;
          } else {
            __testeof = true;
            break;
          }
        } else
          break;

        if (++__beg != __end)
          __c = *__beg;
        else
          __testeof = true;
      }
    else
      while (!__testeof) {

        if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) {
          if (!__found_dec && !__found_sci) {

            if (__sep_pos) {
              __found_grouping += static_cast<char>(__sep_pos);
              __sep_pos = 0;
            } else {

              __xtrc.clear();
              break;
            }
          } else
            break;
        } else if (__c == __lc->_M_decimal_point) {
          if (!__found_dec && !__found_sci) {

            if (__found_grouping.size())
              __found_grouping += static_cast<char>(__sep_pos);
            __xtrc += '.';
            __found_dec = true;
          } else
            break;
        } else {
          const char_type *__q = __traits_type::find(__lit_zero, 10, __c);
          if (__q) {
            __xtrc += '0' + (__q - __lit_zero);
            __found_mantissa = true;
            ++__sep_pos;
          } else if ((__c == __lit[__num_base::_S_ie] ||
                      __c == __lit[__num_base::_S_iE]) &&
                     !__found_sci && __found_mantissa) {

            if (__found_grouping.size() && !__found_dec)
              __found_grouping += static_cast<char>(__sep_pos);
            __xtrc += 'e';
            __found_sci = true;

            if (++__beg != __end) {
              __c = *__beg;
              const bool __plus = __c == __lit[__num_base::_S_iplus];
              if ((__plus || __c == __lit[__num_base::_S_iminus]) &&
                  !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) &&
                  !(__c == __lc->_M_decimal_point))
                __xtrc += __plus ? '+' : '-';
              else
                continue;
            } else {
              __testeof = true;
              break;
            }
          } else
            break;
        }

        if (++__beg != __end)
          __c = *__beg;
        else
          __testeof = true;
      }

    if (__found_grouping.size()) {

      if (!__found_dec && !__found_sci)
        __found_grouping += static_cast<char>(__sep_pos);

      if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size,
                                  __found_grouping))
        __err = ios_base::failbit;
    }

    return __beg;
  }

  template <typename _CharT, typename _InIter>
  template <typename _ValueT>
  __attribute((__abi_tag__("cxx11"))) _InIter
  num_get<_CharT, _InIter>::_M_extract_int(
      _InIter __beg, _InIter __end, ios_base & __io, ios_base::iostate & __err,
      _ValueT & __v) const {
    typedef char_traits<_CharT> __traits_type;
    using __gnu_cxx::__add_unsigned;
    typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
    typedef __numpunct_cache<_CharT> __cache_type;
    __use_cache<__cache_type> __uc;
    const locale &__loc = __io._M_getloc();
    const __cache_type *__lc = __uc(__loc);
    const _CharT *__lit = __lc->_M_atoms_in;
    char_type __c = char_type();

    const ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;
    const bool __oct = __basefield == ios_base::oct;
    int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);

    bool __testeof = __beg == __end;

    bool __negative = false;
    if (!__testeof) {
      __c = *__beg;
      __negative = __c == __lit[__num_base::_S_iminus];
      if ((__negative || __c == __lit[__num_base::_S_iplus]) &&
          !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) &&
          !(__c == __lc->_M_decimal_point)) {
        if (++__beg != __end)
          __c = *__beg;
        else
          __testeof = true;
      }
    }

    bool __found_zero = false;
    int __sep_pos = 0;
    while (!__testeof) {
      if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) ||
          __c == __lc->_M_decimal_point)
        break;
      else if (__c == __lit[__num_base::_S_izero] &&
               (!__found_zero || __base == 10)) {
        __found_zero = true;
        ++__sep_pos;
        if (__basefield == 0)
          __base = 8;
        if (__base == 8)
          __sep_pos = 0;
      } else if (__found_zero && (__c == __lit[__num_base::_S_ix] ||
                                  __c == __lit[__num_base::_S_iX])) {
        if (__basefield == 0)
          __base = 16;
        if (__base == 16) {
          __found_zero = false;
          __sep_pos = 0;
        } else
          break;
      } else
        break;

      if (++__beg != __end) {
        __c = *__beg;
        if (!__found_zero)
          break;
      } else
        __testeof = true;
    }

    const size_t __len =
        (__base == 16 ? __num_base::_S_iend - __num_base::_S_izero : __base);

    typedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;
    string __found_grouping;
    if (__lc->_M_use_grouping)
      __found_grouping.reserve(32);
    bool __testfail = false;
    bool __testoverflow = false;
    const __unsigned_type __max =
        (__negative && __num_traits::__is_signed)
            ? -static_cast<__unsigned_type>(__num_traits::__min)
            : __num_traits::__max;
    const __unsigned_type __smax = __max / __base;
    __unsigned_type __result = 0;
    int __digit = 0;
    const char_type *__lit_zero = __lit + __num_base::_S_izero;

    if (!__lc->_M_allocated)

      while (!__testeof) {
        __digit = _M_find(__lit_zero, __len, __c);
        if (__digit == -1)
          break;

        if (__result > __smax)
          __testoverflow = true;
        else {
          __result *= __base;
          __testoverflow |= __result > __max - __digit;
          __result += __digit;
          ++__sep_pos;
        }

        if (++__beg != __end)
          __c = *__beg;
        else
          __testeof = true;
      }
    else
      while (!__testeof) {

        if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) {

          if (__sep_pos) {
            __found_grouping += static_cast<char>(__sep_pos);
            __sep_pos = 0;
          } else {
            __testfail = true;
            break;
          }
        } else if (__c == __lc->_M_decimal_point)
          break;
        else {
          const char_type *__q = __traits_type::find(__lit_zero, __len, __c);
          if (!__q)
            break;

          __digit = __q - __lit_zero;
          if (__digit > 15)
            __digit -= 6;
          if (__result > __smax)
            __testoverflow = true;
          else {
            __result *= __base;
            __testoverflow |= __result > __max - __digit;
            __result += __digit;
            ++__sep_pos;
          }
        }

        if (++__beg != __end)
          __c = *__beg;
        else
          __testeof = true;
      }

    if (__found_grouping.size()) {

      __found_grouping += static_cast<char>(__sep_pos);

      if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size,
                                  __found_grouping))
        __err = ios_base::failbit;
    }

    if ((!__sep_pos && !__found_zero && !__found_grouping.size()) ||
        __testfail) {
      __v = 0;
      __err = ios_base::failbit;
    } else if (__testoverflow) {
      if (__negative && __num_traits::__is_signed)
        __v = __num_traits::__min;
      else
        __v = __num_traits::__max;
      __err = ios_base::failbit;
    } else
      __v = __negative ? -__result : __result;

    if (__testeof)
      __err |= ios_base::eofbit;
    return __beg;
  }

  template <typename _CharT, typename _InIter>
  _InIter num_get<_CharT, _InIter>::do_get(iter_type __beg, iter_type __end,
                                           ios_base & __io,
                                           ios_base::iostate & __err, bool &__v)
      const {
    if (!(__io.flags() & ios_base::boolalpha)) {

      long __l = -1;
      __beg = _M_extract_int(__beg, __end, __io, __err, __l);
      if (__l == 0 || __l == 1)
        __v = bool(__l);
      else {

        __v = true;
        __err = ios_base::failbit;
        if (__beg == __end)
          __err |= ios_base::eofbit;
      }
    } else {

      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale &__loc = __io._M_getloc();
      const __cache_type *__lc = __uc(__loc);

      bool __testf = true;
      bool __testt = true;
      bool __donef = __lc->_M_falsename_size == 0;
      bool __donet = __lc->_M_truename_size == 0;
      bool __testeof = false;
      size_t __n = 0;
      while (!__donef || !__donet) {
        if (__beg == __end) {
          __testeof = true;
          break;
        }

        const char_type __c = *__beg;

        if (!__donef)
          __testf = __c == __lc->_M_falsename[__n];

        if (!__testf && __donet)
          break;

        if (!__donet)
          __testt = __c == __lc->_M_truename[__n];

        if (!__testt && __donef)
          break;

        if (!__testt && !__testf)
          break;

        ++__n;
        ++__beg;

        __donef = !__testf || __n >= __lc->_M_falsename_size;
        __donet = !__testt || __n >= __lc->_M_truename_size;
      }
      if (__testf && __n == __lc->_M_falsename_size && __n) {
        __v = false;
        if (__testt && __n == __lc->_M_truename_size)
          __err = ios_base::failbit;
        else
          __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
      } else if (__testt && __n == __lc->_M_truename_size && __n) {
        __v = true;
        __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
      } else {

        __v = false;
        __err = ios_base::failbit;
        if (__testeof)
          __err |= ios_base::eofbit;
      }
    }
    return __beg;
  }

  template <typename _CharT, typename _InIter>
  _InIter num_get<_CharT, _InIter>::do_get(
      iter_type __beg, iter_type __end, ios_base & __io,
      ios_base::iostate & __err, float &__v) const {
    string __xtrc;
    __xtrc.reserve(32);
    __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
    std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
    if (__beg == __end)
      __err |= ios_base::eofbit;
    return __beg;
  }

  template <typename _CharT, typename _InIter>
  _InIter num_get<_CharT, _InIter>::do_get(
      iter_type __beg, iter_type __end, ios_base & __io,
      ios_base::iostate & __err, double &__v) const {
    string __xtrc;
    __xtrc.reserve(32);
    __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
    std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
    if (__beg == __end)
      __err |= ios_base::eofbit;
    return __beg;
  }
# 735 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.tcc" 3
  template <typename _CharT, typename _InIter>
  _InIter num_get<_CharT, _InIter>::do_get(
      iter_type __beg, iter_type __end, ios_base & __io,
      ios_base::iostate & __err, long double &__v) const {
    string __xtrc;
    __xtrc.reserve(32);
    __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
    std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
    if (__beg == __end)
      __err |= ios_base::eofbit;
    return __beg;
  }

  template <typename _CharT, typename _InIter>
  _InIter num_get<_CharT, _InIter>::do_get(
      iter_type __beg, iter_type __end, ios_base & __io,
      ios_base::iostate & __err, void *&__v) const {

    typedef ios_base::fmtflags fmtflags;
    const fmtflags __fmt = __io.flags();
    __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

    typedef __gnu_cxx::__conditional_type<
        (sizeof(void *) <= sizeof(unsigned long)), unsigned long,
        unsigned long long>::__type _UIntPtrType;

    _UIntPtrType __ul;
    __beg = _M_extract_int(__beg, __end, __io, __err, __ul);

    __io.flags(__fmt);

    __v = reinterpret_cast<void *>(__ul);
    return __beg;
  }
# 795 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.tcc" 3
  template <typename _CharT, typename _OutIter>
  void num_put<_CharT, _OutIter>::_M_pad(_CharT __fill, streamsize __w,
                                         ios_base & __io, _CharT * __new,
                                         const _CharT *__cs, int &__len) const {

    __pad<_CharT, char_traits<_CharT>>::_S_pad(__io, __fill, __new, __cs, __w,
                                               __len);
    __len = static_cast<int>(__w);
  }

  template <typename _CharT, typename _ValueT>
  int __int_to_char(_CharT * __bufend, _ValueT __v, const _CharT *__lit,
                    ios_base::fmtflags __flags, bool __dec) {
    _CharT *__buf = __bufend;
    if (__builtin_expect(__dec, true)) {

      do {
        *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
        __v /= 10;
      } while (__v != 0);
    } else if ((__flags & ios_base::basefield) == ios_base::oct) {

      do {
        *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
        __v >>= 3;
      } while (__v != 0);
    } else {

      const bool __uppercase = __flags & ios_base::uppercase;
      const int __case_offset =
          __uppercase ? __num_base::_S_oudigits : __num_base::_S_odigits;
      do {
        *--__buf = __lit[(__v & 0xf) + __case_offset];
        __v >>= 4;
      } while (__v != 0);
    }
    return __bufend - __buf;
  }

  template <typename _CharT, typename _OutIter>
  void num_put<_CharT, _OutIter>::_M_group_int(
      const char *__grouping, size_t __grouping_size, _CharT __sep, ios_base &,
      _CharT *__new, _CharT *__cs, int &__len) const {
    _CharT *__p = std::__add_grouping(__new, __sep, __grouping, __grouping_size,
                                      __cs, __cs + __len);
    __len = __p - __new;
  }

  template <typename _CharT, typename _OutIter>
  template <typename _ValueT>
  _OutIter num_put<_CharT, _OutIter>::_M_insert_int(
      _OutIter __s, ios_base & __io, _CharT __fill, _ValueT __v) const {
    using __gnu_cxx::__add_unsigned;
    typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
    typedef __numpunct_cache<_CharT> __cache_type;
    __use_cache<__cache_type> __uc;
    const locale &__loc = __io._M_getloc();
    const __cache_type *__lc = __uc(__loc);
    const _CharT *__lit = __lc->_M_atoms_out;
    const ios_base::fmtflags __flags = __io.flags();

    const int __ilen = 5 * sizeof(_ValueT);
    _CharT *__cs =
        static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __ilen));

    const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
    const bool __dec =
        (__basefield != ios_base::oct && __basefield != ios_base::hex);
    const __unsigned_type __u =
        ((__v > 0 || !__dec) ? __unsigned_type(__v) : -__unsigned_type(__v));
    int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
    __cs += __ilen - __len;

    if (__lc->_M_use_grouping) {

      _CharT *__cs2 = static_cast<_CharT *>(
          __builtin_alloca(sizeof(_CharT) * (__len + 1) * 2));
      _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
                   __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
      __cs = __cs2 + 2;
    }

    if (__builtin_expect(__dec, true)) {

      if (__v >= 0) {
        if (bool(__flags & ios_base::showpos) &&
            __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
          *--__cs = __lit[__num_base::_S_oplus], ++__len;
      } else
        *--__cs = __lit[__num_base::_S_ominus], ++__len;
    } else if (bool(__flags & ios_base::showbase) && __v) {
      if (__basefield == ios_base::oct)
        *--__cs = __lit[__num_base::_S_odigits], ++__len;
      else {

        const bool __uppercase = __flags & ios_base::uppercase;
        *--__cs = __lit[__num_base::_S_ox + __uppercase];

        *--__cs = __lit[__num_base::_S_odigits];
        __len += 2;
      }
    }

    const streamsize __w = __io.width();
    if (__w > static_cast<streamsize>(__len)) {
      _CharT *__cs3 =
          static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
      _M_pad(__fill, __w, __io, __cs3, __cs, __len);
      __cs = __cs3;
    }
    __io.width(0);

    return std::__write(__s, __cs, __len);
  }

  template <typename _CharT, typename _OutIter>
  void num_put<_CharT, _OutIter>::_M_group_float(
      const char *__grouping, size_t __grouping_size, _CharT __sep,
      const _CharT *__p, _CharT *__new, _CharT *__cs, int &__len) const {

    const int __declen = __p ? __p - __cs : __len;
    _CharT *__p2 = std::__add_grouping(__new, __sep, __grouping,
                                       __grouping_size, __cs, __cs + __declen);

    int __newlen = __p2 - __new;
    if (__p) {
      char_traits<_CharT>::copy(__p2, __p, __len - __declen);
      __newlen += __len - __declen;
    }
    __len = __newlen;
  }
# 989 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.tcc" 3
  template <typename _CharT, typename _OutIter>
  template <typename _ValueT>
  _OutIter num_put<_CharT, _OutIter>::_M_insert_float(
      _OutIter __s, ios_base & __io, _CharT __fill, char __mod, _ValueT __v)
      const {
    typedef __numpunct_cache<_CharT> __cache_type;
    __use_cache<__cache_type> __uc;
    const locale &__loc = __io._M_getloc();
    const __cache_type *__lc = __uc(__loc);

    const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

    const int __max_digits = __gnu_cxx::__numeric_traits<_ValueT>::__digits10;

    int __len;

    char __fbuf[16];
    __num_base::_S_format_float(__io, __fbuf, __mod);

    const bool __use_prec =
        (__io.flags() & ios_base::floatfield) != ios_base::floatfield;

    int __cs_size = __max_digits * 3;
    char *__cs = static_cast<char *>(__builtin_alloca(__cs_size));
    if (__use_prec)
      __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf,
                                    __prec, __v);
    else
      __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf,
                                    __v);

    if (__len >= __cs_size) {
      __cs_size = __len + 1;
      __cs = static_cast<char *>(__builtin_alloca(__cs_size));
      if (__use_prec)
        __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
                                      __fbuf, __prec, __v);
      else
        __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
                                      __fbuf, __v);
    }
# 1062 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.tcc" 3
    const ctype<_CharT> &__ctype = use_facet<ctype<_CharT>>(__loc);

    _CharT *__ws =
        static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len));
    __ctype.widen(__cs, __cs + __len, __ws);

    _CharT *__wp = 0;
    const char *__p = char_traits<char>::find(__cs, __len, '.');
    if (__p) {
      __wp = __ws + (__p - __cs);
      *__wp = __lc->_M_decimal_point;
    }

    if (__lc->_M_use_grouping && (__wp || __len < 3 ||
                                  (__cs[1] <= '9' && __cs[2] <= '9' &&
                                   __cs[1] >= '0' && __cs[2] >= '0'))) {

      _CharT *__ws2 =
          static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len * 2));

      streamsize __off = 0;
      if (__cs[0] == '-' || __cs[0] == '+') {
        __off = 1;
        __ws2[0] = __ws[0];
        __len -= 1;
      }

      _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
                     __lc->_M_thousands_sep, __wp, __ws2 + __off, __ws + __off,
                     __len);
      __len += __off;

      __ws = __ws2;
    }

    const streamsize __w = __io.width();
    if (__w > static_cast<streamsize>(__len)) {
      _CharT *__ws3 =
          static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
      _M_pad(__fill, __w, __io, __ws3, __ws, __len);
      __ws = __ws3;
    }
    __io.width(0);

    return std::__write(__s, __ws, __len);
  }

  template <typename _CharT, typename _OutIter>
  _OutIter num_put<_CharT, _OutIter>::do_put(iter_type __s, ios_base & __io,
                                             char_type __fill, bool __v) const {
    const ios_base::fmtflags __flags = __io.flags();
    if ((__flags & ios_base::boolalpha) == 0) {
      const long __l = __v;
      __s = _M_insert_int(__s, __io, __fill, __l);
    } else {
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale &__loc = __io._M_getloc();
      const __cache_type *__lc = __uc(__loc);

      const _CharT *__name = __v ? __lc->_M_truename : __lc->_M_falsename;
      int __len = __v ? __lc->_M_truename_size : __lc->_M_falsename_size;

      const streamsize __w = __io.width();
      if (__w > static_cast<streamsize>(__len)) {
        const streamsize __plen = __w - __len;
        _CharT *__ps =
            static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __plen));

        char_traits<_CharT>::assign(__ps, __plen, __fill);
        __io.width(0);

        if ((__flags & ios_base::adjustfield) == ios_base::left) {
          __s = std::__write(__s, __name, __len);
          __s = std::__write(__s, __ps, __plen);
        } else {
          __s = std::__write(__s, __ps, __plen);
          __s = std::__write(__s, __name, __len);
        }
        return __s;
      }
      __io.width(0);
      __s = std::__write(__s, __name, __len);
    }
    return __s;
  }

  template <typename _CharT, typename _OutIter>
  _OutIter num_put<_CharT, _OutIter>::do_put(
      iter_type __s, ios_base & __io, char_type __fill, double __v) const {
    return _M_insert_float(__s, __io, __fill, char(), __v);
  }
# 1187 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.tcc" 3
  template <typename _CharT, typename _OutIter>
  _OutIter num_put<_CharT, _OutIter>::do_put(
      iter_type __s, ios_base & __io, char_type __fill, long double __v) const {
    return _M_insert_float(__s, __io, __fill, 'L', __v);
  }

  template <typename _CharT, typename _OutIter>
  _OutIter num_put<_CharT, _OutIter>::do_put(
      iter_type __s, ios_base & __io, char_type __fill, const void *__v) const {
    const ios_base::fmtflags __flags = __io.flags();
    const ios_base::fmtflags __fmt =
        ~(ios_base::basefield | ios_base::uppercase);
    __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

    typedef __gnu_cxx::__conditional_type<
        (sizeof(const void *) <= sizeof(unsigned long)), unsigned long,
        unsigned long long>::__type _UIntPtrType;

    __s = _M_insert_int(__s, __io, __fill, reinterpret_cast<_UIntPtrType>(__v));
    __io.flags(__flags);
    return __s;
  }
# 1233 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.tcc" 3
  template <typename _CharT, typename _Traits>
  void __pad<_CharT, _Traits>::_S_pad(
      ios_base & __io, _CharT __fill, _CharT * __news, const _CharT *__olds,
      streamsize __newlen, streamsize __oldlen) {
    const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
    const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;

    if (__adjust == ios_base::left) {
      _Traits::copy(__news, __olds, __oldlen);
      _Traits::assign(__news + __oldlen, __plen, __fill);
      return;
    }

    size_t __mod = 0;
    if (__adjust == ios_base::internal) {

      const locale &__loc = __io._M_getloc();
      const ctype<_CharT> &__ctype = use_facet<ctype<_CharT>>(__loc);

      if (__ctype.widen('-') == __olds[0] || __ctype.widen('+') == __olds[0]) {
        __news[0] = __olds[0];
        __mod = 1;
        ++__news;
      } else if (__ctype.widen('0') == __olds[0] && __oldlen > 1 &&
                 (__ctype.widen('x') == __olds[1] ||
                  __ctype.widen('X') == __olds[1])) {
        __news[0] = __olds[0];
        __news[1] = __olds[1];
        __mod = 2;
        __news += 2;
      }
    }
    _Traits::assign(__news, __plen, __fill);
    _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
  }

  template <typename _CharT>
  _CharT *__add_grouping(_CharT * __s, _CharT __sep, const char *__gbeg,
                         size_t __gsize, const _CharT *__first,
                         const _CharT *__last) {
    size_t __idx = 0;
    size_t __ctr = 0;

    while (__last - __first > __gbeg[__idx] &&
           static_cast<signed char>(__gbeg[__idx]) > 0 &&
           __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max) {
      __last -= __gbeg[__idx];
      __idx < __gsize - 1 ? ++__idx : ++__ctr;
    }

    while (__first != __last)
      *__s++ = *__first++;

    while (__ctr--) {
      *__s++ = __sep;
      for (char __i = __gbeg[__idx]; __i > 0; --__i)
        *__s++ = *__first++;
    }

    while (__idx--) {
      *__s++ = __sep;
      for (char __i = __gbeg[__idx]; __i > 0; --__i)
        *__s++ = *__first++;
    }

    return __s;
  }

  extern template class __cxx11::numpunct<char>;
  extern template class __cxx11::numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template const ctype<char> *__try_use_facet<ctype<char>>(
      const locale &) noexcept;

  extern template const numpunct<char> *__try_use_facet<numpunct<char>>(
      const locale &) noexcept;

  extern template const num_put<char> *__try_use_facet<num_put<char>>(
      const locale &) noexcept;

  extern template const num_get<char> *__try_use_facet<num_get<char>>(
      const locale &) noexcept;

  extern template const ctype<char> &use_facet<ctype<char>>(const locale &);

  extern template const numpunct<char> &use_facet<numpunct<char>>(
      const locale &);

  extern template const num_put<char> &use_facet<num_put<char>>(const locale &);

  extern template const num_get<char> &use_facet<num_get<char>>(const locale &);

  extern template bool has_facet<ctype<char>>(const locale &);

  extern template bool has_facet<numpunct<char>>(const locale &);

  extern template bool has_facet<num_put<char>>(const locale &);

  extern template bool has_facet<num_get<char>>(const locale &);

  extern template class __cxx11::numpunct<wchar_t>;
  extern template class __cxx11::numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template const ctype<wchar_t> *__try_use_facet<ctype<wchar_t>>(
      const locale &) noexcept;

  extern template const numpunct<wchar_t> *__try_use_facet<numpunct<wchar_t>>(
      const locale &) noexcept;

  extern template const num_put<wchar_t> *__try_use_facet<num_put<wchar_t>>(
      const locale &) noexcept;

  extern template const num_get<wchar_t> *__try_use_facet<num_get<wchar_t>>(
      const locale &) noexcept;

  extern template const ctype<wchar_t> &use_facet<ctype<wchar_t>>(
      const locale &);

  extern template const numpunct<wchar_t> &use_facet<numpunct<wchar_t>>(
      const locale &);

  extern template const num_put<wchar_t> &use_facet<num_put<wchar_t>>(
      const locale &);

  extern template const num_get<wchar_t> &use_facet<num_get<wchar_t>>(
      const locale &);

  extern template bool has_facet<ctype<wchar_t>>(const locale &);

  extern template bool has_facet<numpunct<wchar_t>>(const locale &);

  extern template bool has_facet<num_put<wchar_t>>(const locale &);

  extern template bool has_facet<num_get<wchar_t>>(const locale &);

} // namespace std
# 2688 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/locale_facets.h" 2 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _Facet>
  inline const _Facet &__check_facet(const _Facet *__f) {
    if (!__f)
      __throw_bad_cast();
    return *__f;
  }
# 66 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 3
  template <typename _CharT, typename _Traits>
  class basic_ios : public ios_base {
  public:
    typedef _CharT char_type;
    typedef typename _Traits::int_type int_type;
    typedef typename _Traits::pos_type pos_type;
    typedef typename _Traits::off_type off_type;
    typedef _Traits traits_type;

    typedef ctype<_CharT> __ctype_type;
    typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits>>
        __num_put_type;
    typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits>>
        __num_get_type;

  protected:
    basic_ostream<_CharT, _Traits> *_M_tie;
    mutable char_type _M_fill;
    mutable bool _M_fill_init;
    basic_streambuf<_CharT, _Traits> *_M_streambuf;

    const __ctype_type *_M_ctype;

    const __num_put_type *_M_num_put;

    const __num_get_type *_M_num_get;

  public:
# 117 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 3
    explicit operator bool() const { return !this->fail(); }

    bool operator!() const { return this->fail(); }
# 136 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 3
    iostate rdstate() const { return _M_streambuf_state; }
# 147 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 3
    void clear(iostate __state = goodbit);

    void setstate(iostate __state) { this->clear(this->rdstate() | __state); }

    void _M_setstate(iostate __state) {

      _M_streambuf_state |= __state;
      if (this->exceptions() & __state)
        throw;
    }

    bool good() const { return this->rdstate() == 0; }

    bool eof() const { return (this->rdstate() & eofbit) != 0; }
# 200 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 3
    bool fail() const { return (this->rdstate() & (badbit | failbit)) != 0; }

    bool bad() const { return (this->rdstate() & badbit) != 0; }
# 221 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 3
    iostate exceptions() const { return _M_exception; }
# 256 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 3
    void exceptions(iostate __except) {
      _M_exception = __except;
      this->clear(_M_streambuf_state);
    }

    explicit basic_ios(basic_streambuf<_CharT, _Traits> *__sb)
        : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false),
          _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0) {
      this->init(__sb);
    }

    virtual ~basic_ios() {}
# 294 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 3
    basic_ostream<_CharT, _Traits> *tie() const { return _M_tie; }
# 306 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 3
    basic_ostream<_CharT, _Traits> *
    tie(basic_ostream<_CharT, _Traits> *__tiestr) {
      basic_ostream<_CharT, _Traits> *__old = _M_tie;
      _M_tie = __tiestr;
      return __old;
    }

    basic_streambuf<_CharT, _Traits> *rdbuf() const { return _M_streambuf; }
# 346 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 3
    basic_streambuf<_CharT, _Traits> *
    rdbuf(basic_streambuf<_CharT, _Traits> *__sb);
# 360 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 3
    basic_ios &copyfmt(const basic_ios &__rhs);

    char_type fill() const {
      if (!_M_fill_init) {
        _M_fill = this->widen(' ');
        _M_fill_init = true;
      }
      return _M_fill;
    }
# 389 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 3
    char_type fill(char_type __ch) {
      char_type __old = this->fill();
      _M_fill = __ch;
      return __old;
    }
# 409 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 3
    locale imbue(const locale &__loc);
# 429 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 3
    char narrow(char_type __c, char __dfault) const {
      return __check_facet(_M_ctype).narrow(__c, __dfault);
    }
# 448 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 3
    char_type widen(char __c) const {
      return __check_facet(_M_ctype).widen(__c);
    }

  protected:
    basic_ios()
        : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
          _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0) {}

    void init(basic_streambuf<_CharT, _Traits> *__sb);

    basic_ios(const basic_ios &) = delete;
    basic_ios &operator=(const basic_ios &) = delete;

    void move(basic_ios &__rhs) {
      ios_base::_M_move(__rhs);
      _M_cache_locale(_M_ios_locale);
      this->tie(__rhs.tie(nullptr));
      _M_fill = __rhs._M_fill;
      _M_fill_init = __rhs._M_fill_init;
      _M_streambuf = nullptr;
    }

    void move(basic_ios &&__rhs) { this->move(__rhs); }

    void swap(basic_ios &__rhs) noexcept {
      ios_base::_M_swap(__rhs);
      _M_cache_locale(_M_ios_locale);
      __rhs._M_cache_locale(__rhs._M_ios_locale);
      std::swap(_M_tie, __rhs._M_tie);
      std::swap(_M_fill, __rhs._M_fill);
      std::swap(_M_fill_init, __rhs._M_fill_init);
    }

    void set_rdbuf(basic_streambuf<_CharT, _Traits> *__sb) {
      _M_streambuf = __sb;
    }

    void _M_cache_locale(const locale &__loc);
  };

} // namespace std

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.tcc" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.tcc" 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _CharT, typename _Traits>
  void basic_ios<_CharT, _Traits>::clear(iostate __state) {
    if (this->rdbuf())
      _M_streambuf_state = __state;
    else
      _M_streambuf_state = __state | badbit;
    if (this->exceptions() & this->rdstate())
      __throw_ios_failure(("basic_ios::clear"));
  }

  template <typename _CharT, typename _Traits>
  basic_streambuf<_CharT, _Traits> *basic_ios<_CharT, _Traits>::rdbuf(
      basic_streambuf<_CharT, _Traits> * __sb) {
    basic_streambuf<_CharT, _Traits> *__old = _M_streambuf;
    _M_streambuf = __sb;
    this->clear();
    return __old;
  }

  template <typename _CharT, typename _Traits>
  basic_ios<_CharT, _Traits> &basic_ios<_CharT, _Traits>::copyfmt(
      const basic_ios &__rhs) {

    if (this != std::__addressof(__rhs)) {

      _Words *__words = (__rhs._M_word_size <= _S_local_word_size)
                            ? _M_local_word
                            : new _Words[__rhs._M_word_size];

      _Callback_list *__cb = __rhs._M_callbacks;
      if (__cb)
        __cb->_M_add_reference();
      _M_call_callbacks(erase_event);
      if (_M_word != _M_local_word) {
        delete[] _M_word;
        _M_word = 0;
      }
      _M_dispose_callbacks();

      _M_callbacks = __cb;
      for (int __i = 0; __i < __rhs._M_word_size; ++__i)
        __words[__i] = __rhs._M_word[__i];
      _M_word = __words;
      _M_word_size = __rhs._M_word_size;

      this->flags(__rhs.flags());
      this->width(__rhs.width());
      this->precision(__rhs.precision());
      this->tie(__rhs.tie());
      this->fill(__rhs.fill());
      _M_ios_locale = __rhs.getloc();
      _M_cache_locale(_M_ios_locale);

      _M_call_callbacks(copyfmt_event);

      this->exceptions(__rhs.exceptions());
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  locale basic_ios<_CharT, _Traits>::imbue(const locale &__loc) {
    locale __old(this->getloc());
    ios_base::imbue(__loc);
    _M_cache_locale(__loc);
    if (this->rdbuf() != 0)
      this->rdbuf()->pubimbue(__loc);
    return __old;
  }

  template <typename _CharT, typename _Traits>
  void basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits> *
                                        __sb) {

    ios_base::_M_init();

    _M_cache_locale(_M_ios_locale);
# 146 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.tcc" 3
    _M_fill = _CharT();
    _M_fill_init = false;

    _M_tie = 0;
    _M_exception = goodbit;
    _M_streambuf = __sb;
    _M_streambuf_state = __sb ? goodbit : badbit;
  }

  template <typename _CharT, typename _Traits>
  void basic_ios<_CharT, _Traits>::_M_cache_locale(const locale &__loc) {
    _M_ctype = std::__try_use_facet<__ctype_type>(__loc);
    _M_num_put = std::__try_use_facet<__num_put_type>(__loc);
    _M_num_get = std::__try_use_facet<__num_get_type>(__loc);
  }

  extern template class basic_ios<char>;

  extern template class basic_ios<wchar_t>;

} // namespace std
# 517 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/basic_ios.h" 2 3
# 47 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ios" 2 3
# 41 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 1 3
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3

namespace std __attribute__((__visibility__("default"))) {
# 59 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
  template <typename _CharT, typename _Traits>
  class basic_ostream : virtual public basic_ios<_CharT, _Traits> {
  public:
    typedef _CharT char_type;
    typedef typename _Traits::int_type int_type;
    typedef typename _Traits::pos_type pos_type;
    typedef typename _Traits::off_type off_type;
    typedef _Traits traits_type;

    typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
    typedef basic_ios<_CharT, _Traits> __ios_type;
    typedef basic_ostream<_CharT, _Traits> __ostream_type;
    typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits>>
        __num_put_type;
    typedef ctype<_CharT> __ctype_type;
# 85 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
    explicit basic_ostream(__streambuf_type *__sb) { this->init(__sb); }

    virtual ~basic_ostream() {}

    class sentry;
    friend class sentry;
# 109 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
    __ostream_type &operator<<(__ostream_type &(*__pf)(__ostream_type &)) {

      return __pf(*this);
    }

    __ostream_type &operator<<(__ios_type &(*__pf)(__ios_type &)) {

      __pf(*this);
      return *this;
    }

    __ostream_type &operator<<(ios_base &(*__pf)(ios_base &)) {

      __pf(*this);
      return *this;
    }
# 167 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
    __ostream_type &operator<<(long __n) { return _M_insert(__n); }

    __ostream_type &operator<<(unsigned long __n) { return _M_insert(__n); }

    __ostream_type &operator<<(bool __n) { return _M_insert(__n); }

    __ostream_type &operator<<(short __n);

    __ostream_type &operator<<(unsigned short __n) {

      return _M_insert(static_cast<unsigned long>(__n));
    }

    __ostream_type &operator<<(int __n);

    __ostream_type &operator<<(unsigned int __n) {

      return _M_insert(static_cast<unsigned long>(__n));
    }

    __ostream_type &operator<<(long long __n) { return _M_insert(__n); }

    __ostream_type &operator<<(unsigned long long __n) {
      return _M_insert(__n);
    }
# 221 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
    __ostream_type &operator<<(double __f) { return _M_insert(__f); }

    __ostream_type &operator<<(float __f) {

      return _M_insert(static_cast<double>(__f));
    }

    __ostream_type &operator<<(long double __f) { return _M_insert(__f); }
# 291 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
    __ostream_type &operator<<(const void *__p) { return _M_insert(__p); }

    __ostream_type &operator<<(nullptr_t) { return *this << "nullptr"; }
# 329 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
    __ostream_type &operator<<(__streambuf_type *__sb);
# 362 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
    __ostream_type &put(char_type __c);
# 381 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
    __ostream_type &write(const char_type *__s, streamsize __n);
# 394 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
    __ostream_type &flush();
# 404 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
    pos_type tellp();
# 415 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
    __ostream_type &seekp(pos_type);
# 427 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
    __ostream_type &seekp(off_type, ios_base::seekdir);

  protected:
    basic_ostream() { this->init(0); }

    basic_ostream(basic_iostream<_CharT, _Traits> &) {}

    basic_ostream(const basic_ostream &) = delete;

    basic_ostream(basic_ostream &&__rhs) : __ios_type() {
      __ios_type::move(__rhs);
    }

    basic_ostream &operator=(const basic_ostream &) = delete;

    basic_ostream &operator=(basic_ostream &&__rhs) {
      swap(__rhs);
      return *this;
    }

    void swap(basic_ostream &__rhs) { __ios_type::swap(__rhs); }

    template <typename _ValueT> __ostream_type &_M_insert(_ValueT __v);

  private:
    void _M_write(const char_type *__s, streamsize __n) {
      std::__ostream_insert(*this, __s, __n);
    }
  };
# 479 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
  template <typename _CharT, typename _Traits>
  class basic_ostream<_CharT, _Traits>::sentry {

    bool _M_ok;
    basic_ostream<_CharT, _Traits> &_M_os;

  public:
# 498 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
    explicit sentry(basic_ostream<_CharT, _Traits> &__os);

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

    ~sentry() {

      if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception()) {

        if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
          _M_os.setstate(ios_base::badbit);
      }
    }
#pragma GCC diagnostic pop
# 530 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
    explicit

    operator bool() const {
      return _M_ok;
    }
  };
# 552 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
  template <typename _CharT, typename _Traits>
  inline basic_ostream<_CharT, _Traits> &operator<<(
      basic_ostream<_CharT, _Traits> &__out, _CharT __c) {
    if (__out.width() != 0)
      return __ostream_insert(__out, &__c, 1);
    __out.put(__c);
    return __out;
  }

  template <typename _CharT, typename _Traits>
  inline basic_ostream<_CharT, _Traits> &operator<<(
      basic_ostream<_CharT, _Traits> &__out, char __c) {
    return (__out << __out.widen(__c));
  }

  template <typename _Traits>
  inline basic_ostream<char, _Traits> &operator<<(
      basic_ostream<char, _Traits> &__out, char __c) {
    if (__out.width() != 0)
      return __ostream_insert(__out, &__c, 1);
    __out.put(__c);
    return __out;
  }

  template <typename _Traits>
  inline basic_ostream<char, _Traits> &operator<<(
      basic_ostream<char, _Traits> &__out, signed char __c) {
    return (__out << static_cast<char>(__c));
  }

  template <typename _Traits>
  inline basic_ostream<char, _Traits> &operator<<(
      basic_ostream<char, _Traits> &__out, unsigned char __c) {
    return (__out << static_cast<char>(__c));
  }

  template <typename _Traits>
  basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &,
                                           wchar_t) = delete;

  template <typename _Traits>
  basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &,
                                           char8_t) = delete;

  template <typename _Traits>
  basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &,
                                           char16_t) = delete;

  template <typename _Traits>
  basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &,
                                           char32_t) = delete;

  template <typename _Traits>
  basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &,
                                              char8_t) = delete;

  template <typename _Traits>
  basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &,
                                              char16_t) = delete;

  template <typename _Traits>
  basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &,
                                              char32_t) = delete;
# 643 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
  template <typename _CharT, typename _Traits>
  inline basic_ostream<_CharT, _Traits> &operator<<(
      basic_ostream<_CharT, _Traits> &__out, const _CharT *__s) {
    if (!__s)
      __out.setstate(ios_base::badbit);
    else
      __ostream_insert(__out, __s,
                       static_cast<streamsize>(_Traits::length(__s)));
    return __out;
  }

  template <typename _CharT, typename _Traits>
  basic_ostream<_CharT, _Traits> &operator<<(
      basic_ostream<_CharT, _Traits> &__out, const char *__s);

  template <typename _Traits>
  inline basic_ostream<char, _Traits> &operator<<(
      basic_ostream<char, _Traits> &__out, const char *__s) {
    if (!__s)
      __out.setstate(ios_base::badbit);
    else
      __ostream_insert(__out, __s,
                       static_cast<streamsize>(_Traits::length(__s)));
    return __out;
  }

  template <typename _Traits>
  inline basic_ostream<char, _Traits> &operator<<(
      basic_ostream<char, _Traits> &__out, const signed char *__s) {
    return (__out << reinterpret_cast<const char *>(__s));
  }

  template <typename _Traits>
  inline basic_ostream<char, _Traits> &operator<<(
      basic_ostream<char, _Traits> &__out, const unsigned char *__s) {
    return (__out << reinterpret_cast<const char *>(__s));
  }

  template <typename _Traits>
  basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &,
                                           const wchar_t *) = delete;

  template <typename _Traits>
  basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &,
                                           const char8_t *) = delete;

  template <typename _Traits>
  basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &,
                                           const char16_t *) = delete;

  template <typename _Traits>
  basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &,
                                           const char32_t *) = delete;

  template <typename _Traits>
  basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &,
                                              const char8_t *) = delete;

  template <typename _Traits>
  basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &,
                                              const char16_t *) = delete;

  template <typename _Traits>
  basic_ostream<wchar_t, _Traits> &operator<<(basic_ostream<wchar_t, _Traits> &,
                                              const char32_t *) = delete;
# 733 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
  template <typename _CharT, typename _Traits>
  inline basic_ostream<_CharT, _Traits> &endl(basic_ostream<_CharT, _Traits> &
                                              __os) {
    return flush(__os.put(__os.widen('\n')));
  }
# 745 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
  template <typename _CharT, typename _Traits>
  inline basic_ostream<_CharT, _Traits> &ends(basic_ostream<_CharT, _Traits> &
                                              __os) {
    return __os.put(_CharT());
  }

  template <typename _CharT, typename _Traits>
  inline basic_ostream<_CharT, _Traits> &flush(basic_ostream<_CharT, _Traits> &
                                               __os) {
    return __os.flush();
  }
# 767 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
  template <typename _Tp>
  concept __derived_from_ios_base =
      is_class_v<_Tp> && (!is_same_v<_Tp, ios_base>) &&
      requires(_Tp *__t, ios_base *__b) { __b = __t; };

  template <typename _Os, typename _Tp>
    requires __derived_from_ios_base<_Os> &&
                 requires(_Os &__os, const _Tp &__t) { __os << __t; }
  using __rvalue_stream_insertion_t = _Os &&;
# 799 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 3
  template <typename _Ostream, typename _Tp>
  inline __rvalue_stream_insertion_t<_Ostream, _Tp> operator<<(_Ostream &&__os,
                                                               const _Tp &__x) {
    __os << __x;
    return std::move(__os);
  }

  template <typename _CharT, typename _Traits>
  class __syncbuf_base : public basic_streambuf<_CharT, _Traits> {
  public:
    static bool *_S_get(basic_streambuf<_CharT, _Traits> *__buf
                        [[maybe_unused]]) noexcept {

      if (auto __p = dynamic_cast<__syncbuf_base *>(__buf))
        return &__p->_M_emit_on_sync;

      return nullptr;
    }

  protected:
    __syncbuf_base(basic_streambuf<_CharT, _Traits> *__w = nullptr)
        : _M_wrapped(__w) {}

    basic_streambuf<_CharT, _Traits> *_M_wrapped = nullptr;
    bool _M_emit_on_sync = false;
    bool _M_needs_sync = false;
  };

  template <typename _CharT, typename _Traits>
  inline basic_ostream<_CharT, _Traits> &emit_on_flush(
      basic_ostream<_CharT, _Traits> & __os) {
    if (bool *__flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf()))
      *__flag = true;
    return __os;
  }

  template <typename _CharT, typename _Traits>
  inline basic_ostream<_CharT, _Traits> &noemit_on_flush(
      basic_ostream<_CharT, _Traits> & __os) {
    if (bool *__flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf()))
      *__flag = false;
    return __os;
  }

  template <typename _CharT, typename _Traits>
  inline basic_ostream<_CharT, _Traits> &flush_emit(
      basic_ostream<_CharT, _Traits> & __os) {
    struct _Restore {
      ~_Restore() { *_M_flag = _M_prev; }

      bool _M_prev = false;
      bool *_M_flag = &_M_prev;
    } __restore;

    if (bool *__flag = __syncbuf_base<_CharT, _Traits>::_S_get(__os.rdbuf())) {
      __restore._M_prev = *__flag;
      __restore._M_flag = __flag;
      *__flag = true;
    }

    __os.flush();
    return __os;
  }

} // namespace std

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ostream.tcc" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ostream.tcc" 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _CharT, typename _Traits>
  basic_ostream<_CharT, _Traits>::sentry::sentry(
      basic_ostream<_CharT, _Traits> & __os)
      : _M_ok(false), _M_os(__os) {

    if (__os.tie() && __os.good())
      __os.tie()->flush();

    if (__os.good())
      _M_ok = true;
    else if (__os.bad())
      __os.setstate(ios_base::failbit);
  }

  template <typename _CharT, typename _Traits>
  template <typename _ValueT>
  basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::_M_insert(
      _ValueT __v) {
    sentry __cerb(*this);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {

        const __num_put_type &__np = __check_facet(this->_M_num_put);

        if (__np.put(*this, *this, this->fill(), __v).failed())
          __err |= ios_base::badbit;
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(__err);
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(
      short __n) {

    const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
    if (__fmt == ios_base::oct || __fmt == ios_base::hex)
      return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
    else
      return _M_insert(static_cast<long>(__n));
  }

  template <typename _CharT, typename _Traits>
  basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(
      int __n) {

    const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
    if (__fmt == ios_base::oct || __fmt == ios_base::hex)
      return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
    else
      return _M_insert(static_cast<long>(__n));
  }

  template <typename _CharT, typename _Traits>
  basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(
      __streambuf_type *__sbin) {
    ios_base::iostate __err = ios_base::goodbit;
    sentry __cerb(*this);
    if (__cerb && __sbin) {
      try {
        if (!__copy_streambufs(__sbin, this->rdbuf()))
          __err |= ios_base::failbit;
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::failbit);
      }
    } else if (!__sbin)
      __err |= ios_base::badbit;
    if (__err)
      this->setstate(__err);
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::put(
      char_type __c) {

    sentry __cerb(*this);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {
        const int_type __put = this->rdbuf()->sputc(__c);
        if (traits_type::eq_int_type(__put, traits_type::eof()))
          __err |= ios_base::badbit;
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(__err);
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::write(
      const _CharT *__s, streamsize __n) {

    sentry __cerb(*this);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {
        if (this->rdbuf()->sputn(__s, __n) != __n)
          __err = ios_base::badbit;
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(ios_base::badbit);
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::flush() {

    if (__streambuf_type *__buf = this->rdbuf()) {
      sentry __cerb(*this);
      if (__cerb) {
        ios_base::iostate __err = ios_base::goodbit;
        try {
          if (this->rdbuf()->pubsync() == -1)
            __err |= ios_base::badbit;
        } catch (__cxxabiv1::__forced_unwind &) {
          this->_M_setstate(ios_base::badbit);
          throw;
        } catch (...) {
          this->_M_setstate(ios_base::badbit);
        }
        if (__err)
          this->setstate(__err);
      }
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  typename basic_ostream<_CharT, _Traits>::pos_type
  basic_ostream<_CharT, _Traits>::tellp() {
    sentry __cerb(*this);
    pos_type __ret = pos_type(-1);
    if (!this->fail())
      __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
    return __ret;
  }

  template <typename _CharT, typename _Traits>
  basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::seekp(
      pos_type __pos) {
    sentry __cerb(*this);
    if (!this->fail()) {

      const pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::out);

      if (__p == pos_type(off_type(-1)))
        this->setstate(ios_base::failbit);
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::seekp(
      off_type __off, ios_base::seekdir __dir) {
    sentry __cerb(*this);
    if (!this->fail()) {

      const pos_type __p =
          this->rdbuf()->pubseekoff(__off, __dir, ios_base::out);

      if (__p == pos_type(off_type(-1)))
        this->setstate(ios_base::failbit);
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_ostream<_CharT, _Traits> &operator<<(
      basic_ostream<_CharT, _Traits> &__out, const char *__s) {
    if (!__s)
      __out.setstate(ios_base::badbit);
    else {

      const size_t __clen = char_traits<char>::length(__s);
      try {
        struct __ptr_guard {
          _CharT *__p;
          __ptr_guard(_CharT *__ip) : __p(__ip) {}
          ~__ptr_guard() { delete[] __p; }
          _CharT *__get() { return __p; }
        } __pg(new _CharT[__clen]);

        _CharT *__ws = __pg.__get();
        for (size_t __i = 0; __i < __clen; ++__i)
          __ws[__i] = __out.widen(__s[__i]);
        __ostream_insert(__out, __ws, __clen);
      } catch (__cxxabiv1::__forced_unwind &) {
        __out._M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        __out._M_setstate(ios_base::badbit);
      }
    }
    return __out;
  }

  extern template class basic_ostream<char>;
  extern template ostream &endl(ostream &);
  extern template ostream &ends(ostream &);
  extern template ostream &flush(ostream &);
  extern template ostream &operator<<(ostream &, char);
  extern template ostream &operator<<(ostream &, unsigned char);
  extern template ostream &operator<<(ostream &, signed char);
  extern template ostream &operator<<(ostream &, const char *);
  extern template ostream &operator<<(ostream &, const unsigned char *);
  extern template ostream &operator<<(ostream &, const signed char *);

  extern template ostream &ostream::_M_insert(long);
  extern template ostream &ostream::_M_insert(unsigned long);
  extern template ostream &ostream::_M_insert(bool);

  extern template ostream &ostream::_M_insert(long long);
  extern template ostream &ostream::_M_insert(unsigned long long);

  extern template ostream &ostream::_M_insert(double);
  extern template ostream &ostream::_M_insert(long double);
  extern template ostream &ostream::_M_insert(const void *);

  extern template class basic_ostream<wchar_t>;
  extern template wostream &endl(wostream &);
  extern template wostream &ends(wostream &);
  extern template wostream &flush(wostream &);
  extern template wostream &operator<<(wostream &, wchar_t);
  extern template wostream &operator<<(wostream &, char);
  extern template wostream &operator<<(wostream &, const wchar_t *);
  extern template wostream &operator<<(wostream &, const char *);

  extern template wostream &wostream::_M_insert(long);
  extern template wostream &wostream::_M_insert(unsigned long);
  extern template wostream &wostream::_M_insert(bool);

  extern template wostream &wostream::_M_insert(long long);
  extern template wostream &wostream::_M_insert(unsigned long long);

  extern template wostream &wostream::_M_insert(double);
  extern template wostream &wostream::_M_insert(long double);
  extern template wostream &wostream::_M_insert(const void *);

} // namespace std
# 881 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ostream" 2 3
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 59 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
  template <typename _CharT, typename _Traits>
  class basic_istream : virtual public basic_ios<_CharT, _Traits> {
  public:
    typedef _CharT char_type;
    typedef typename _Traits::int_type int_type;
    typedef typename _Traits::pos_type pos_type;
    typedef typename _Traits::off_type off_type;
    typedef _Traits traits_type;

    typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
    typedef basic_ios<_CharT, _Traits> __ios_type;
    typedef basic_istream<_CharT, _Traits> __istream_type;
    typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits>>
        __num_get_type;
    typedef ctype<_CharT> __ctype_type;

  protected:
    streamsize _M_gcount;

  public:
    explicit basic_istream(__streambuf_type *__sb) : _M_gcount(streamsize(0)) {
      this->init(__sb);
    }

    virtual ~basic_istream() { _M_gcount = streamsize(0); }

    class sentry;
    friend class sentry;
# 121 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &operator>>(__istream_type &(*__pf)(__istream_type &)) {
      return __pf(*this);
    }

    __istream_type &operator>>(__ios_type &(*__pf)(__ios_type &)) {
      __pf(*this);
      return *this;
    }

    __istream_type &operator>>(ios_base &(*__pf)(ios_base &)) {
      __pf(*this);
      return *this;
    }
# 169 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &operator>>(bool &__n) { return _M_extract(__n); }

    __istream_type &operator>>(short &__n);

    __istream_type &operator>>(unsigned short &__n) { return _M_extract(__n); }

    __istream_type &operator>>(int &__n);

    __istream_type &operator>>(unsigned int &__n) { return _M_extract(__n); }

    __istream_type &operator>>(long &__n) { return _M_extract(__n); }

    __istream_type &operator>>(unsigned long &__n) { return _M_extract(__n); }

    __istream_type &operator>>(long long &__n) { return _M_extract(__n); }

    __istream_type &operator>>(unsigned long long &__n) {
      return _M_extract(__n);
    }
# 215 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &operator>>(float &__f) { return _M_extract(__f); }

    __istream_type &operator>>(double &__f) { return _M_extract(__f); }

    __istream_type &operator>>(long double &__f) { return _M_extract(__f); }
# 324 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &operator>>(void *&__p) { return _M_extract(__p); }
# 348 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &operator>>(__streambuf_type *__sb);
# 358 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    streamsize gcount() const { return _M_gcount; }
# 391 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    int_type get();
# 405 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &get(char_type &__c);
# 432 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &get(char_type *__s, streamsize __n, char_type __delim);
# 443 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &get(char_type *__s, streamsize __n) {
      return this->get(__s, __n, this->widen('\n'));
    }
# 466 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &get(__streambuf_type &__sb, char_type __delim);
# 476 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &get(__streambuf_type &__sb) {
      return this->get(__sb, this->widen('\n'));
    }
# 505 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &getline(char_type *__s, streamsize __n, char_type __delim);
# 516 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &getline(char_type *__s, streamsize __n) {
      return this->getline(__s, __n, this->widen('\n'));
    }
# 540 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &ignore(streamsize __n, int_type __delim);

    __istream_type &ignore(streamsize __n);

    __istream_type &ignore();
# 557 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    int_type peek();
# 575 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &read(char_type *__s, streamsize __n);
# 594 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    streamsize readsome(char_type *__s, streamsize __n);
# 611 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &putback(char_type __c);
# 627 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &unget();
# 645 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    int sync();
# 660 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    pos_type tellg();
# 675 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &seekg(pos_type);
# 691 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    __istream_type &seekg(off_type, ios_base::seekdir);

  protected:
    basic_istream() : _M_gcount(streamsize(0)) { this->init(0); }

    basic_istream(const basic_istream &) = delete;

    basic_istream(basic_istream &&__rhs)
        : __ios_type(), _M_gcount(__rhs._M_gcount) {
      __ios_type::move(__rhs);
      __rhs._M_gcount = 0;
    }

    basic_istream &operator=(const basic_istream &) = delete;

    basic_istream &operator=(basic_istream &&__rhs) {
      swap(__rhs);
      return *this;
    }

    void swap(basic_istream &__rhs) {
      __ios_type::swap(__rhs);
      std::swap(_M_gcount, __rhs._M_gcount);
    }

    template <typename _ValueT> __istream_type &_M_extract(_ValueT &__v);
  };

  template <>
  basic_istream<char> &basic_istream<char>::getline(
      char_type * __s, streamsize __n, char_type __delim);

  template <> basic_istream<char> &basic_istream<char>::ignore(streamsize __n);

  template <>
  basic_istream<char> &basic_istream<char>::ignore(streamsize __n,
                                                   int_type __delim);

  template <>
  basic_istream<wchar_t> &basic_istream<wchar_t>::getline(
      char_type * __s, streamsize __n, char_type __delim);

  template <>
  basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(streamsize __n);

  template <>
  basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(streamsize __n,
                                                         int_type __delim);
# 775 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
  template <typename _CharT, typename _Traits>
  class basic_istream<_CharT, _Traits>::sentry {

    bool _M_ok;

  public:
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
    typedef basic_istream<_CharT, _Traits> __istream_type;
    typedef typename __istream_type::__ctype_type __ctype_type;
    typedef typename _Traits::int_type __int_type;
# 811 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    explicit sentry(basic_istream<_CharT, _Traits> &__is,
                    bool __noskipws = false);
# 822 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
    explicit

    operator bool() const {
      return _M_ok;
    }
  };
# 840 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &operator>>(
      basic_istream<_CharT, _Traits> &__in, _CharT &__c);

  template <class _Traits>
  inline basic_istream<char, _Traits> &operator>>(
      basic_istream<char, _Traits> &__in, unsigned char &__c) {
    return (__in >> reinterpret_cast<char &>(__c));
  }

  template <class _Traits>
  inline basic_istream<char, _Traits> &operator>>(
      basic_istream<char, _Traits> &__in, signed char &__c) {
    return (__in >> reinterpret_cast<char &>(__c));
  }

  template <typename _CharT, typename _Traits>
  void __istream_extract(basic_istream<_CharT, _Traits> &, _CharT *,
                         streamsize);

  void __istream_extract(istream &, char *, streamsize);
# 947 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
  template <typename _CharT, typename _Traits, size_t _Num>
  inline basic_istream<_CharT, _Traits> &operator>>(
      basic_istream<_CharT, _Traits> &__in, _CharT(&__s)[_Num]) {
    static_assert(_Num <= __gnu_cxx::__numeric_traits<streamsize>::__max);
    std::__istream_extract(__in, __s, _Num);
    return __in;
  }

  template <class _Traits, size_t _Num>
  inline basic_istream<char, _Traits> &operator>>(
      basic_istream<char, _Traits> &__in, unsigned char(&__s)[_Num]) {
    return __in >> reinterpret_cast<char(&)[_Num]>(__s);
  }

  template <class _Traits, size_t _Num>
  inline basic_istream<char, _Traits> &operator>>(
      basic_istream<char, _Traits> &__in, signed char(&__s)[_Num]) {
    return __in >> reinterpret_cast<char(&)[_Num]>(__s);
  }
# 979 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
  template <typename _CharT, typename _Traits>
  class basic_iostream : public basic_istream<_CharT, _Traits>,
                         public basic_ostream<_CharT, _Traits> {
  public:
    typedef _CharT char_type;
    typedef typename _Traits::int_type int_type;
    typedef typename _Traits::pos_type pos_type;
    typedef typename _Traits::off_type off_type;
    typedef _Traits traits_type;

    typedef basic_istream<_CharT, _Traits> __istream_type;
    typedef basic_ostream<_CharT, _Traits> __ostream_type;

    explicit basic_iostream(basic_streambuf<_CharT, _Traits> *__sb)
        : __istream_type(__sb), __ostream_type(__sb) {}

    virtual ~basic_iostream() {}

  protected:
    basic_iostream() : __istream_type(), __ostream_type() {}

    basic_iostream(const basic_iostream &) = delete;

    basic_iostream(basic_iostream &&__rhs)
        : __istream_type(std::move(__rhs)), __ostream_type(*this) {}

    basic_iostream &operator=(const basic_iostream &) = delete;

    basic_iostream &operator=(basic_iostream &&__rhs) {
      swap(__rhs);
      return *this;
    }

    void swap(basic_iostream &__rhs) { __istream_type::swap(__rhs); }
  };
# 1062 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> & __is);
# 1073 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
  template <typename _Is, typename _Tp>
    requires __derived_from_ios_base<_Is> && requires(_Is &__is, _Tp &&__t) {
      __is >> std::forward<_Tp>(__t);
    }
  using __rvalue_stream_extraction_t = _Is &&;
# 1094 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 3
  template <typename _Istream, typename _Tp>
  inline __rvalue_stream_extraction_t<_Istream, _Tp> operator>>(_Istream &&__is,
                                                                _Tp &&__x) {
    __is >> std::forward<_Tp>(__x);
    return std::move(__is);
  }

} // namespace std

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/istream.tcc" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/istream.tcc" 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits>::sentry::sentry(
      basic_istream<_CharT, _Traits> & __in, bool __noskip)
      : _M_ok(false) {
    ios_base::iostate __err = ios_base::goodbit;
    if (__in.good()) {
      try {
        if (__in.tie())
          __in.tie()->flush();
        if (!__noskip && bool(__in.flags() & ios_base::skipws)) {
          const __int_type __eof = traits_type::eof();
          __streambuf_type *__sb = __in.rdbuf();
          __int_type __c = __sb->sgetc();

          const __ctype_type &__ct = __check_facet(__in._M_ctype);
          while (!traits_type::eq_int_type(__c, __eof) &&
                 __ct.is(ctype_base::space, traits_type::to_char_type(__c)))
            __c = __sb->snextc();

          if (traits_type::eq_int_type(__c, __eof))
            __err |= ios_base::eofbit;
        }
      } catch (__cxxabiv1::__forced_unwind &) {
        __in._M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        __in._M_setstate(ios_base::badbit);
      }
    }

    if (__in.good() && __err == ios_base::goodbit)
      _M_ok = true;
    else {
      __err |= ios_base::failbit;
      __in.setstate(__err);
    }
  }

  template <typename _CharT, typename _Traits>
  template <typename _ValueT>
  basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::_M_extract(
      _ValueT & __v) {
    sentry __cerb(*this, false);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {

        const __num_get_type &__ng = __check_facet(this->_M_num_get);

        __ng.get(*this, 0, *this, __err, __v);
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(__err);
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(
      short &__n) {

    sentry __cerb(*this, false);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {
        long __l;

        const __num_get_type &__ng = __check_facet(this->_M_num_get);

        __ng.get(*this, 0, *this, __err, __l);

        if (__l < __gnu_cxx::__numeric_traits<short>::__min) {
          __err |= ios_base::failbit;
          __n = __gnu_cxx::__numeric_traits<short>::__min;
        } else if (__l > __gnu_cxx::__numeric_traits<short>::__max) {
          __err |= ios_base::failbit;
          __n = __gnu_cxx::__numeric_traits<short>::__max;
        } else
          __n = short(__l);
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(__err);
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(
      int &__n) {

    sentry __cerb(*this, false);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {
        long __l;

        const __num_get_type &__ng = __check_facet(this->_M_num_get);

        __ng.get(*this, 0, *this, __err, __l);

        if (__l < __gnu_cxx::__numeric_traits<int>::__min) {
          __err |= ios_base::failbit;
          __n = __gnu_cxx::__numeric_traits<int>::__min;
        } else if (__l > __gnu_cxx::__numeric_traits<int>::__max) {
          __err |= ios_base::failbit;
          __n = __gnu_cxx::__numeric_traits<int>::__max;
        } else
          __n = int(__l);
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(__err);
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(
      __streambuf_type *__sbout) {
    ios_base::iostate __err = ios_base::goodbit;
    sentry __cerb(*this, false);
    if (__cerb && __sbout) {
      try {
        bool __ineof;
        if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
          __err |= ios_base::failbit;
        if (__ineof)
          __err |= ios_base::eofbit;
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::failbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::failbit);
      }
    } else if (!__sbout)
      __err |= ios_base::failbit;
    if (__err)
      this->setstate(__err);
    return *this;
  }

  template <typename _CharT, typename _Traits>
  typename basic_istream<_CharT, _Traits>::int_type
  basic_istream<_CharT, _Traits>::get(void) {
    const int_type __eof = traits_type::eof();
    int_type __c = __eof;
    _M_gcount = 0;
    ios_base::iostate __err = ios_base::goodbit;
    sentry __cerb(*this, true);
    if (__cerb) {
      try {
        __c = this->rdbuf()->sbumpc();

        if (!traits_type::eq_int_type(__c, __eof))
          _M_gcount = 1;
        else
          __err |= ios_base::eofbit;
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
    }
    if (!_M_gcount)
      __err |= ios_base::failbit;
    if (__err)
      this->setstate(__err);
    return __c;
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(
      char_type & __c) {
    _M_gcount = 0;
    ios_base::iostate __err = ios_base::goodbit;
    sentry __cerb(*this, true);
    if (__cerb) {
      try {
        const int_type __cb = this->rdbuf()->sbumpc();

        if (!traits_type::eq_int_type(__cb, traits_type::eof())) {
          _M_gcount = 1;
          __c = traits_type::to_char_type(__cb);
        } else
          __err |= ios_base::eofbit;
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
    }
    if (!_M_gcount)
      __err |= ios_base::failbit;
    if (__err)
      this->setstate(__err);
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(
      char_type * __s, streamsize __n, char_type __delim) {
    _M_gcount = 0;
    ios_base::iostate __err = ios_base::goodbit;
    sentry __cerb(*this, true);
    if (__cerb) {
      try {
        const int_type __idelim = traits_type::to_int_type(__delim);
        const int_type __eof = traits_type::eof();
        __streambuf_type *__sb = this->rdbuf();
        int_type __c = __sb->sgetc();

        while (_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof) &&
               !traits_type::eq_int_type(__c, __idelim)) {
          *__s++ = traits_type::to_char_type(__c);
          ++_M_gcount;
          __c = __sb->snextc();
        }
        if (traits_type::eq_int_type(__c, __eof))
          __err |= ios_base::eofbit;
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
    }

    if (__n > 0)
      *__s = char_type();
    if (!_M_gcount)
      __err |= ios_base::failbit;
    if (__err)
      this->setstate(__err);
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(
      __streambuf_type & __sb, char_type __delim) {
    _M_gcount = 0;
    ios_base::iostate __err = ios_base::goodbit;
    sentry __cerb(*this, true);
    if (__cerb) {
      try {
        const int_type __idelim = traits_type::to_int_type(__delim);
        const int_type __eof = traits_type::eof();
        __streambuf_type *__this_sb = this->rdbuf();
        int_type __c = __this_sb->sgetc();
        char_type __c2 = traits_type::to_char_type(__c);
        unsigned long long __gcount = 0;

        while (!traits_type::eq_int_type(__c, __eof) &&
               !traits_type::eq_int_type(__c, __idelim) &&
               !traits_type::eq_int_type(__sb.sputc(__c2), __eof)) {
          ++__gcount;
          __c = __this_sb->snextc();
          __c2 = traits_type::to_char_type(__c);
        }
        if (traits_type::eq_int_type(__c, __eof))
          __err |= ios_base::eofbit;

        if (__gcount <= __gnu_cxx::__numeric_traits<streamsize>::__max)
          _M_gcount = __gcount;
        else
          _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
    }
    if (!_M_gcount)
      __err |= ios_base::failbit;
    if (__err)
      this->setstate(__err);
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::getline(
      char_type * __s, streamsize __n, char_type __delim) {
    _M_gcount = 0;
    ios_base::iostate __err = ios_base::goodbit;
    sentry __cerb(*this, true);
    if (__cerb) {
      try {
        const int_type __idelim = traits_type::to_int_type(__delim);
        const int_type __eof = traits_type::eof();
        __streambuf_type *__sb = this->rdbuf();
        int_type __c = __sb->sgetc();

        while (_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof) &&
               !traits_type::eq_int_type(__c, __idelim)) {
          *__s++ = traits_type::to_char_type(__c);
          __c = __sb->snextc();
          ++_M_gcount;
        }
        if (traits_type::eq_int_type(__c, __eof))
          __err |= ios_base::eofbit;
        else {
          if (traits_type::eq_int_type(__c, __idelim)) {
            __sb->sbumpc();
            ++_M_gcount;
          } else
            __err |= ios_base::failbit;
        }
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
    }

    if (__n > 0)
      *__s = char_type();
    if (!_M_gcount)
      __err |= ios_base::failbit;
    if (__err)
      this->setstate(__err);
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore(void) {
    _M_gcount = 0;
    sentry __cerb(*this, true);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {
        const int_type __eof = traits_type::eof();
        __streambuf_type *__sb = this->rdbuf();

        if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
          __err |= ios_base::eofbit;
        else
          _M_gcount = 1;
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(__err);
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore(
      streamsize __n) {
    _M_gcount = 0;
    sentry __cerb(*this, true);
    if (__cerb && __n > 0) {
      ios_base::iostate __err = ios_base::goodbit;
      try {
        const int_type __eof = traits_type::eof();
        __streambuf_type *__sb = this->rdbuf();
        int_type __c = __sb->sgetc();
# 545 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/istream.tcc" 3
        bool __large_ignore = false;
        while (true) {
          while (_M_gcount < __n && !traits_type::eq_int_type(__c, __eof)) {
            ++_M_gcount;
            __c = __sb->snextc();
          }
          if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max &&
              !traits_type::eq_int_type(__c, __eof)) {
            _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__min;
            __large_ignore = true;
          } else
            break;
        }

        if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max) {
          if (__large_ignore)
            _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

          if (traits_type::eq_int_type(__c, __eof))
            __err |= ios_base::eofbit;
        } else if (_M_gcount < __n) {
          if (traits_type::eq_int_type(__c, __eof))
            __err |= ios_base::eofbit;
        }
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(__err);
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore(
      streamsize __n, int_type __delim) {
    _M_gcount = 0;
    sentry __cerb(*this, true);
    if (__cerb && __n > 0) {
      ios_base::iostate __err = ios_base::goodbit;
      try {
        const int_type __eof = traits_type::eof();
        __streambuf_type *__sb = this->rdbuf();
        int_type __c = __sb->sgetc();

        bool __large_ignore = false;
        while (true) {
          while (_M_gcount < __n && !traits_type::eq_int_type(__c, __eof) &&
                 !traits_type::eq_int_type(__c, __delim)) {
            ++_M_gcount;
            __c = __sb->snextc();
          }
          if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max &&
              !traits_type::eq_int_type(__c, __eof) &&
              !traits_type::eq_int_type(__c, __delim)) {
            _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__min;
            __large_ignore = true;
          } else
            break;
        }

        if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max) {
          if (__large_ignore)
            _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

          if (traits_type::eq_int_type(__c, __eof))
            __err |= ios_base::eofbit;
          else {
            if (_M_gcount != __n)
              ++_M_gcount;
            __sb->sbumpc();
          }
        } else if (_M_gcount < __n) {
          if (traits_type::eq_int_type(__c, __eof))
            __err |= ios_base::eofbit;
          else {
            ++_M_gcount;
            __sb->sbumpc();
          }
        }
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(__err);
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  typename basic_istream<_CharT, _Traits>::int_type
  basic_istream<_CharT, _Traits>::peek(void) {
    int_type __c = traits_type::eof();
    _M_gcount = 0;
    sentry __cerb(*this, true);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {
        __c = this->rdbuf()->sgetc();
        if (traits_type::eq_int_type(__c, traits_type::eof()))
          __err |= ios_base::eofbit;
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(__err);
    }
    return __c;
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::read(
      char_type * __s, streamsize __n) {
    _M_gcount = 0;
    sentry __cerb(*this, true);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {
        _M_gcount = this->rdbuf()->sgetn(__s, __n);
        if (_M_gcount != __n)
          __err |= (ios_base::eofbit | ios_base::failbit);
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(__err);
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  streamsize basic_istream<_CharT, _Traits>::readsome(char_type * __s,
                                                      streamsize __n) {
    _M_gcount = 0;
    sentry __cerb(*this, true);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {

        const streamsize __num = this->rdbuf()->in_avail();
        if (__num > 0)
          _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
        else if (__num == -1)
          __err |= ios_base::eofbit;
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(__err);
    }
    return _M_gcount;
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::putback(
      char_type __c) {

    _M_gcount = 0;

    this->clear(this->rdstate() & ~ios_base::eofbit);
    sentry __cerb(*this, true);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {
        const int_type __eof = traits_type::eof();
        __streambuf_type *__sb = this->rdbuf();
        if (!__sb || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
          __err |= ios_base::badbit;
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(__err);
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::unget(void) {

    _M_gcount = 0;

    this->clear(this->rdstate() & ~ios_base::eofbit);
    sentry __cerb(*this, true);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {
        const int_type __eof = traits_type::eof();
        __streambuf_type *__sb = this->rdbuf();
        if (!__sb || traits_type::eq_int_type(__sb->sungetc(), __eof))
          __err |= ios_base::badbit;
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(__err);
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  int basic_istream<_CharT, _Traits>::sync(void) {

    int __ret = -1;
    sentry __cerb(*this, true);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {
        __streambuf_type *__sb = this->rdbuf();
        if (__sb) {
          if (__sb->pubsync() == -1)
            __err |= ios_base::badbit;
          else
            __ret = 0;
        }
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(__err);
    }
    return __ret;
  }

  template <typename _CharT, typename _Traits>
  typename basic_istream<_CharT, _Traits>::pos_type
  basic_istream<_CharT, _Traits>::tellg(void) {

    pos_type __ret = pos_type(-1);
    sentry __cerb(*this, true);
    if (__cerb) {
      try {
        if (!this->fail())
          __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
    }
    return __ret;
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::seekg(
      pos_type __pos) {

    this->clear(this->rdstate() & ~ios_base::eofbit);
    sentry __cerb(*this, true);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {
        if (!this->fail()) {

          const pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::in);

          if (__p == pos_type(off_type(-1)))
            __err |= ios_base::failbit;
        }
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(__err);
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::seekg(
      off_type __off, ios_base::seekdir __dir) {

    this->clear(this->rdstate() & ~ios_base::eofbit);
    sentry __cerb(*this, true);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {
        if (!this->fail()) {

          const pos_type __p =
              this->rdbuf()->pubseekoff(__off, __dir, ios_base::in);

          if (__p == pos_type(off_type(-1)))
            __err |= ios_base::failbit;
        }
      } catch (__cxxabiv1::__forced_unwind &) {
        this->_M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        this->_M_setstate(ios_base::badbit);
      }
      if (__err)
        this->setstate(__err);
    }
    return *this;
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &operator>>(
      basic_istream<_CharT, _Traits> &__in, _CharT &__c) {
    typedef basic_istream<_CharT, _Traits> __istream_type;
    typedef typename __istream_type::int_type __int_type;

    typename __istream_type::sentry __cerb(__in, false);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {
        const __int_type __cb = __in.rdbuf()->sbumpc();
        if (!_Traits::eq_int_type(__cb, _Traits::eof()))
          __c = _Traits::to_char_type(__cb);
        else
          __err |= (ios_base::eofbit | ios_base::failbit);
      } catch (__cxxabiv1::__forced_unwind &) {
        __in._M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        __in._M_setstate(ios_base::badbit);
      }
      if (__err)
        __in.setstate(__err);
    }
    return __in;
  }

  template <typename _CharT, typename _Traits>
  void __istream_extract(basic_istream<_CharT, _Traits> & __in, _CharT * __s,
                         streamsize __num) {
    typedef basic_istream<_CharT, _Traits> __istream_type;
    typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
    typedef typename _Traits::int_type int_type;
    typedef _CharT char_type;
    typedef ctype<_CharT> __ctype_type;

    streamsize __extracted = 0;
    ios_base::iostate __err = ios_base::goodbit;
    typename __istream_type::sentry __cerb(__in, false);
    if (__cerb) {
      try {

        streamsize __width = __in.width();
        if (0 < __width && __width < __num)
          __num = __width;

        const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());

        const int_type __eof = _Traits::eof();
        __streambuf_type *__sb = __in.rdbuf();
        int_type __c = __sb->sgetc();

        while (__extracted < __num - 1 && !_Traits::eq_int_type(__c, __eof) &&
               !__ct.is(ctype_base::space, _Traits::to_char_type(__c))) {
          *__s++ = _Traits::to_char_type(__c);
          ++__extracted;
          __c = __sb->snextc();
        }

        if (__extracted < __num - 1 && _Traits::eq_int_type(__c, __eof))
          __err |= ios_base::eofbit;

        *__s = char_type();
        __in.width(0);
      } catch (__cxxabiv1::__forced_unwind &) {
        __in._M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        __in._M_setstate(ios_base::badbit);
      }
    }
    if (!__extracted)
      __err |= ios_base::failbit;
    if (__err)
      __in.setstate(__err);
  }

  template <typename _CharT, typename _Traits>
  basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> & __in) {
    typedef basic_istream<_CharT, _Traits> __istream_type;
    typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
    typedef typename __istream_type::int_type __int_type;
    typedef ctype<_CharT> __ctype_type;

    typename __istream_type::sentry __cerb(__in, true);
    if (__cerb) {
      ios_base::iostate __err = ios_base::goodbit;
      try {
        const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
        const __int_type __eof = _Traits::eof();
        __streambuf_type *__sb = __in.rdbuf();
        __int_type __c = __sb->sgetc();

        while (true) {
          if (_Traits::eq_int_type(__c, __eof)) {
            __err = ios_base::eofbit;
            break;
          }
          if (!__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
            break;
          __c = __sb->snextc();
        }
      } catch (const __cxxabiv1::__forced_unwind &) {
        __in._M_setstate(ios_base::badbit);
        throw;
      } catch (...) {
        __in._M_setstate(ios_base::badbit);
      }
      if (__err)
        __in.setstate(__err);
    }
    return __in;
  }

  extern template class basic_istream<char>;
  extern template istream &ws(istream &);
  extern template istream &operator>>(istream &, char &);
  extern template istream &operator>>(istream &, unsigned char &);
  extern template istream &operator>>(istream &, signed char &);

  extern template istream &istream::_M_extract(unsigned short &);
  extern template istream &istream::_M_extract(unsigned int &);
  extern template istream &istream::_M_extract(long &);
  extern template istream &istream::_M_extract(unsigned long &);
  extern template istream &istream::_M_extract(bool &);

  extern template istream &istream::_M_extract(long long &);
  extern template istream &istream::_M_extract(unsigned long long &);

  extern template istream &istream::_M_extract(float &);
  extern template istream &istream::_M_extract(double &);
  extern template istream &istream::_M_extract(long double &);
  extern template istream &istream::_M_extract(void *&);

  extern template class basic_iostream<char>;

  extern template class basic_istream<wchar_t>;
  extern template wistream &ws(wistream &);
  extern template wistream &operator>>(wistream &, wchar_t &);
  extern template void __istream_extract(wistream &, wchar_t *, streamsize);

  extern template wistream &wistream::_M_extract(unsigned short &);
  extern template wistream &wistream::_M_extract(unsigned int &);
  extern template wistream &wistream::_M_extract(long &);
  extern template wistream &wistream::_M_extract(unsigned long &);
  extern template wistream &wistream::_M_extract(bool &);

  extern template wistream &wistream::_M_extract(long long &);
  extern template wistream &wistream::_M_extract(unsigned long long &);

  extern template wistream &wistream::_M_extract(float &);
  extern template wistream &wistream::_M_extract(double &);
  extern template wistream &wistream::_M_extract(long double &);
  extern template wistream &wistream::_M_extract(void *&);

  extern template class basic_iostream<wchar_t>;

} // namespace std
# 1107 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/istream" 2 3
# 41 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/codecvt.h" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/codecvt.h" 3

namespace std __attribute__((__visibility__("default"))) {

  class codecvt_base {
  public:
    enum result { ok, partial, error, noconv };
  };
# 70 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/codecvt.h" 3
  template <typename _InternT, typename _ExternT, typename _StateT>
  class __codecvt_abstract_base : public locale::facet, public codecvt_base {
  public:
    typedef codecvt_base::result result;
    typedef _InternT intern_type;
    typedef _ExternT extern_type;
    typedef _StateT state_type;
# 118 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/codecvt.h" 3
    result out(state_type &__state, const intern_type *__from,
               const intern_type *__from_end, const intern_type *&__from_next,
               extern_type *__to, extern_type *__to_end,
               extern_type *&__to_next) const {
      return this->do_out(__state, __from, __from_end, __from_next, __to,
                          __to_end, __to_next);
    }
# 157 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/codecvt.h" 3
    result unshift(state_type &__state, extern_type *__to,
                   extern_type *__to_end, extern_type *&__to_next) const {
      return this->do_unshift(__state, __to, __to_end, __to_next);
    }
# 198 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/codecvt.h" 3
    result in(state_type &__state, const extern_type *__from,
              const extern_type *__from_end, const extern_type *&__from_next,
              intern_type *__to, intern_type *__to_end,
              intern_type *&__to_next) const {
      return this->do_in(__state, __from, __from_end, __from_next, __to,
                         __to_end, __to_next);
    }

    int encoding() const throw() { return this->do_encoding(); }

    bool always_noconv() const throw() { return this->do_always_noconv(); }

    int length(state_type &__state, const extern_type *__from,
               const extern_type *__end, size_t __max) const {
      return this->do_length(__state, __from, __end, __max);
    }

    int max_length() const throw() { return this->do_max_length(); }

  protected:
    explicit __codecvt_abstract_base(size_t __refs = 0)
        : locale::facet(__refs) {}

    virtual ~__codecvt_abstract_base() {}
# 239 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/codecvt.h" 3
    virtual result do_out(state_type &__state, const intern_type *__from,
                          const intern_type *__from_end,
                          const intern_type *&__from_next, extern_type *__to,
                          extern_type *__to_end,
                          extern_type *&__to_next) const = 0;

    virtual result do_unshift(state_type &__state, extern_type *__to,
                              extern_type *__to_end,
                              extern_type *&__to_next) const = 0;

    virtual result do_in(state_type &__state, const extern_type *__from,
                         const extern_type *__from_end,
                         const extern_type *&__from_next, intern_type *__to,
                         intern_type *__to_end,
                         intern_type *&__to_next) const = 0;

    virtual int do_encoding() const throw() = 0;

    virtual bool do_always_noconv() const throw() = 0;

    virtual int do_length(state_type &, const extern_type *__from,
                          const extern_type *__end, size_t __max) const = 0;

    virtual int do_max_length() const throw() = 0;
  };
# 276 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/codecvt.h" 3
  template <typename _InternT, typename _ExternT, typename _StateT>
  class codecvt : public __codecvt_abstract_base<_InternT, _ExternT, _StateT> {
  public:
    typedef codecvt_base::result result;
    typedef _InternT intern_type;
    typedef _ExternT extern_type;
    typedef _StateT state_type;

  protected:
    __c_locale _M_c_locale_codecvt;

  public:
    static locale::id id;

    explicit codecvt(size_t __refs = 0)
        : __codecvt_abstract_base<_InternT, _ExternT, _StateT>(__refs),
          _M_c_locale_codecvt(0) {}

    explicit codecvt(__c_locale __cloc, size_t __refs = 0);

  protected:
    virtual ~codecvt() {}

    virtual result do_out(state_type &__state, const intern_type *__from,
                          const intern_type *__from_end,
                          const intern_type *&__from_next, extern_type *__to,
                          extern_type *__to_end, extern_type *&__to_next) const;

    virtual result do_unshift(state_type &__state, extern_type *__to,
                              extern_type *__to_end,
                              extern_type *&__to_next) const;

    virtual result do_in(state_type &__state, const extern_type *__from,
                         const extern_type *__from_end,
                         const extern_type *&__from_next, intern_type *__to,
                         intern_type *__to_end, intern_type *&__to_next) const;

    virtual int do_encoding() const throw();

    virtual bool do_always_noconv() const throw();

    virtual int do_length(state_type &, const extern_type *__from,
                          const extern_type *__end, size_t __max) const;

    virtual int do_max_length() const throw();
  };

  template <typename _InternT, typename _ExternT, typename _StateT>
  locale::id codecvt<_InternT, _ExternT, _StateT>::id;

  template <>
  class codecvt<char, char, mbstate_t>
      : public __codecvt_abstract_base<char, char, mbstate_t> {
    friend class messages<char>;

  public:
    typedef char intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

  protected:
    __c_locale _M_c_locale_codecvt;

  public:
    static locale::id id;

    explicit codecvt(size_t __refs = 0);

    explicit codecvt(__c_locale __cloc, size_t __refs = 0);

  protected:
    virtual ~codecvt();

    virtual result do_out(state_type &__state, const intern_type *__from,
                          const intern_type *__from_end,
                          const intern_type *&__from_next, extern_type *__to,
                          extern_type *__to_end, extern_type *&__to_next) const;

    virtual result do_unshift(state_type &__state, extern_type *__to,
                              extern_type *__to_end,
                              extern_type *&__to_next) const;

    virtual result do_in(state_type &__state, const extern_type *__from,
                         const extern_type *__from_end,
                         const extern_type *&__from_next, intern_type *__to,
                         intern_type *__to_end, intern_type *&__to_next) const;

    virtual int do_encoding() const throw();

    virtual bool do_always_noconv() const throw();

    virtual int do_length(state_type &, const extern_type *__from,
                          const extern_type *__end, size_t __max) const;

    virtual int do_max_length() const throw();
  };

  template <>
  class codecvt<wchar_t, char, mbstate_t>
      : public __codecvt_abstract_base<wchar_t, char, mbstate_t> {
    friend class messages<wchar_t>;

  public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

  protected:
    __c_locale _M_c_locale_codecvt;

  public:
    static locale::id id;

    explicit codecvt(size_t __refs = 0);

    explicit codecvt(__c_locale __cloc, size_t __refs = 0);

  protected:
    virtual ~codecvt();

    virtual result do_out(state_type &__state, const intern_type *__from,
                          const intern_type *__from_end,
                          const intern_type *&__from_next, extern_type *__to,
                          extern_type *__to_end, extern_type *&__to_next) const;

    virtual result do_unshift(state_type &__state, extern_type *__to,
                              extern_type *__to_end,
                              extern_type *&__to_next) const;

    virtual result do_in(state_type &__state, const extern_type *__from,
                         const extern_type *__from_end,
                         const extern_type *&__from_next, intern_type *__to,
                         intern_type *__to_end, intern_type *&__to_next) const;

    virtual int do_encoding() const throw();

    virtual bool do_always_noconv() const throw();

    virtual int do_length(state_type &, const extern_type *__from,
                          const extern_type *__end, size_t __max) const;

    virtual int do_max_length() const throw();
  };

  template <>
  class codecvt<char16_t, char, mbstate_t>
      : public __codecvt_abstract_base<char16_t, char, mbstate_t> {
  public:
    typedef char16_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

  public:
    static locale::id id;

    explicit codecvt(size_t __refs = 0)
        : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs) {}

  protected:
    virtual ~codecvt();

    virtual result do_out(state_type &__state, const intern_type *__from,
                          const intern_type *__from_end,
                          const intern_type *&__from_next, extern_type *__to,
                          extern_type *__to_end, extern_type *&__to_next) const;

    virtual result do_unshift(state_type &__state, extern_type *__to,
                              extern_type *__to_end,
                              extern_type *&__to_next) const;

    virtual result do_in(state_type &__state, const extern_type *__from,
                         const extern_type *__from_end,
                         const extern_type *&__from_next, intern_type *__to,
                         intern_type *__to_end, intern_type *&__to_next) const;

    virtual int do_encoding() const throw();

    virtual bool do_always_noconv() const throw();

    virtual int do_length(state_type &, const extern_type *__from,
                          const extern_type *__end, size_t __max) const;

    virtual int do_max_length() const throw();
  };

  template <>
  class codecvt<char32_t, char, mbstate_t>
      : public __codecvt_abstract_base<char32_t, char, mbstate_t> {
  public:
    typedef char32_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

  public:
    static locale::id id;

    explicit codecvt(size_t __refs = 0)
        : __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) {}

  protected:
    virtual ~codecvt();

    virtual result do_out(state_type &__state, const intern_type *__from,
                          const intern_type *__from_end,
                          const intern_type *&__from_next, extern_type *__to,
                          extern_type *__to_end, extern_type *&__to_next) const;

    virtual result do_unshift(state_type &__state, extern_type *__to,
                              extern_type *__to_end,
                              extern_type *&__to_next) const;

    virtual result do_in(state_type &__state, const extern_type *__from,
                         const extern_type *__from_end,
                         const extern_type *&__from_next, intern_type *__to,
                         intern_type *__to_end, intern_type *&__to_next) const;

    virtual int do_encoding() const throw();

    virtual bool do_always_noconv() const throw();

    virtual int do_length(state_type &, const extern_type *__from,
                          const extern_type *__end, size_t __max) const;

    virtual int do_max_length() const throw();
  };

  template <>
  class codecvt<char16_t, char8_t, mbstate_t>
      : public __codecvt_abstract_base<char16_t, char8_t, mbstate_t> {
  public:
    typedef char16_t intern_type;
    typedef char8_t extern_type;
    typedef mbstate_t state_type;

  public:
    static locale::id id;

    explicit codecvt(size_t __refs = 0)
        : __codecvt_abstract_base<char16_t, char8_t, mbstate_t>(__refs) {}

  protected:
    virtual ~codecvt();

    virtual result do_out(state_type &__state, const intern_type *__from,
                          const intern_type *__from_end,
                          const intern_type *&__from_next, extern_type *__to,
                          extern_type *__to_end, extern_type *&__to_next) const;

    virtual result do_unshift(state_type &__state, extern_type *__to,
                              extern_type *__to_end,
                              extern_type *&__to_next) const;

    virtual result do_in(state_type &__state, const extern_type *__from,
                         const extern_type *__from_end,
                         const extern_type *&__from_next, intern_type *__to,
                         intern_type *__to_end, intern_type *&__to_next) const;

    virtual int do_encoding() const throw();

    virtual bool do_always_noconv() const throw();

    virtual int do_length(state_type &, const extern_type *__from,
                          const extern_type *__end, size_t __max) const;

    virtual int do_max_length() const throw();
  };

  template <>
  class codecvt<char32_t, char8_t, mbstate_t>
      : public __codecvt_abstract_base<char32_t, char8_t, mbstate_t> {
  public:
    typedef char32_t intern_type;
    typedef char8_t extern_type;
    typedef mbstate_t state_type;

  public:
    static locale::id id;

    explicit codecvt(size_t __refs = 0)
        : __codecvt_abstract_base<char32_t, char8_t, mbstate_t>(__refs) {}

  protected:
    virtual ~codecvt();

    virtual result do_out(state_type &__state, const intern_type *__from,
                          const intern_type *__from_end,
                          const intern_type *&__from_next, extern_type *__to,
                          extern_type *__to_end, extern_type *&__to_next) const;

    virtual result do_unshift(state_type &__state, extern_type *__to,
                              extern_type *__to_end,
                              extern_type *&__to_next) const;

    virtual result do_in(state_type &__state, const extern_type *__from,
                         const extern_type *__from_end,
                         const extern_type *&__from_next, intern_type *__to,
                         intern_type *__to_end, intern_type *&__to_next) const;

    virtual int do_encoding() const throw();

    virtual bool do_always_noconv() const throw();

    virtual int do_length(state_type &, const extern_type *__from,
                          const extern_type *__end, size_t __max) const;

    virtual int do_max_length() const throw();
  };

  template <typename _InternT, typename _ExternT, typename _StateT>
  class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT> {
  public:
    explicit codecvt_byname(const char *__s, size_t __refs = 0)
        : codecvt<_InternT, _ExternT, _StateT>(__refs) {
      if (__builtin_strcmp(__s, "C") != 0 &&
          __builtin_strcmp(__s, "POSIX") != 0) {
        this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
        this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
      }
    }

    explicit codecvt_byname(const string &__s, size_t __refs = 0)
        : codecvt_byname(__s.c_str(), __refs) {}

  protected:
    virtual ~codecvt_byname() {}
  };

  template <>
  class codecvt_byname<char16_t, char, mbstate_t>
      : public codecvt<char16_t, char, mbstate_t> {
  public:
    explicit codecvt_byname(const char *, size_t __refs = 0)
        : codecvt<char16_t, char, mbstate_t>(__refs) {}

    explicit codecvt_byname(const string &__s, size_t __refs = 0)
        : codecvt_byname(__s.c_str(), __refs) {}

  protected:
    virtual ~codecvt_byname() {}
  };

  template <>
  class codecvt_byname<char32_t, char, mbstate_t>
      : public codecvt<char32_t, char, mbstate_t> {
  public:
    explicit codecvt_byname(const char *, size_t __refs = 0)
        : codecvt<char32_t, char, mbstate_t>(__refs) {}

    explicit codecvt_byname(const string &__s, size_t __refs = 0)
        : codecvt_byname(__s.c_str(), __refs) {}

  protected:
    virtual ~codecvt_byname() {}
  };

  template <>
  class codecvt_byname<char16_t, char8_t, mbstate_t>
      : public codecvt<char16_t, char8_t, mbstate_t> {
  public:
    explicit codecvt_byname(const char *, size_t __refs = 0)
        : codecvt<char16_t, char8_t, mbstate_t>(__refs) {}

    explicit codecvt_byname(const string &__s, size_t __refs = 0)
        : codecvt_byname(__s.c_str(), __refs) {}

  protected:
    virtual ~codecvt_byname() {}
  };

  template <>
  class codecvt_byname<char32_t, char8_t, mbstate_t>
      : public codecvt<char32_t, char8_t, mbstate_t> {
  public:
    explicit codecvt_byname(const char *, size_t __refs = 0)
        : codecvt<char32_t, char8_t, mbstate_t>(__refs) {}

    explicit codecvt_byname(const string &__s, size_t __refs = 0)
        : codecvt_byname(__s.c_str(), __refs) {}

  protected:
    virtual ~codecvt_byname() {}
  };

  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template const codecvt<char, char, mbstate_t> &
  use_facet<codecvt<char, char, mbstate_t>>(const locale &);

  extern template bool has_facet<codecvt<char, char, mbstate_t>>(
      const locale &);

  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template const codecvt<wchar_t, char, mbstate_t> &
  use_facet<codecvt<wchar_t, char, mbstate_t>>(const locale &);

  extern template bool has_facet<codecvt<wchar_t, char, mbstate_t>>(
      const locale &);

  extern template class codecvt_byname<char16_t, char, mbstate_t>;
  extern template class codecvt_byname<char32_t, char, mbstate_t>;

  extern template class codecvt_byname<char16_t, char8_t, mbstate_t>;
  extern template class codecvt_byname<char32_t, char8_t, mbstate_t>;

} // namespace std
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdio" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdio" 3
# 44 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/basic_file.h" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/basic_file.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++io.h" 1 3
# 35 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++io.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdio" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdio" 3
# 36 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++io.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 48 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/c++io.h" 3
  typedef __gthread_mutex_t __c_lock;

  typedef FILE __c_file;

} // namespace std
# 41 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/x86_64-linux-gnu/c++/13/bits/basic_file.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _CharT> class __basic_file;

  template <> class __basic_file<char> {

    __c_file *_M_cfile;

    bool _M_cfile_created;

  public:
    __basic_file(__c_lock *__lock = 0) throw();

    __basic_file(__basic_file &&__rv, __c_lock * = 0) noexcept
        : _M_cfile(__rv._M_cfile), _M_cfile_created(__rv._M_cfile_created) {
      __rv._M_cfile = nullptr;
      __rv._M_cfile_created = false;
    }

    __basic_file &operator=(const __basic_file &) = delete;
    __basic_file &operator=(__basic_file &&) = delete;

    void swap(__basic_file &__f) noexcept {
      std::swap(_M_cfile, __f._M_cfile);
      std::swap(_M_cfile_created, __f._M_cfile_created);
    }

    __basic_file *open(const char *__name, ios_base::openmode __mode,
                       int __prot = 0664);

    __basic_file *sys_open(__c_file *__file, ios_base::openmode);

    __basic_file *sys_open(int __fd, ios_base::openmode __mode) throw();

    __basic_file *close();

    __attribute__((__pure__)) bool is_open() const throw();

    __attribute__((__pure__)) int fd() throw();

    __attribute__((__pure__)) __c_file *file() throw();

    ~__basic_file();

    streamsize xsputn(const char *__s, streamsize __n);

    streamsize xsputn_2(const char *__s1, streamsize __n1, const char *__s2,
                        streamsize __n2);

    streamsize xsgetn(char *__s, streamsize __n);

    streamoff seekoff(streamoff __off, ios_base::seekdir __way) throw();

    int sync();

    streamsize showmanyc();
  };

} // namespace std
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 2 3
# 54 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
namespace std __attribute__((__visibility__("default"))) {

  template <typename _Path, typename _Result = _Path,
            typename _Path2 =
                decltype(std::declval<_Path &>().make_preferred().filename())>
  using _If_fs_path = enable_if_t<is_same_v<_Path, _Path2>, _Result>;
# 86 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
  template <typename _CharT, typename _Traits>
  class basic_filebuf : public basic_streambuf<_CharT, _Traits> {

    template <typename _Tp>
    using __chk_state =
        __and_<is_copy_assignable<_Tp>, is_copy_constructible<_Tp>,
               is_default_constructible<_Tp>>;

    static_assert(__chk_state<typename _Traits::state_type>::value,
                  "state_type must be CopyAssignable, CopyConstructible"
                  " and DefaultConstructible");

    static_assert(is_same<typename _Traits::pos_type,
                          fpos<typename _Traits::state_type>>::value,
                  "pos_type must be fpos<state_type>");

  public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    typedef basic_streambuf<char_type, traits_type> __streambuf_type;
    typedef basic_filebuf<char_type, traits_type> __filebuf_type;
    typedef __basic_file<char> __file_type;
    typedef typename traits_type::state_type __state_type;
    typedef codecvt<char_type, char, __state_type> __codecvt_type;

    friend class ios_base;

  protected:
    __c_lock _M_lock;

    __file_type _M_file;

    ios_base::openmode _M_mode;

    __state_type _M_state_beg;

    __state_type _M_state_cur;

    __state_type _M_state_last;

    char_type *_M_buf;

    size_t _M_buf_size;

    bool _M_buf_allocated;
# 162 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    bool _M_reading;
    bool _M_writing;

    char_type _M_pback;
    char_type *_M_pback_cur_save;
    char_type *_M_pback_end_save;
    bool _M_pback_init;

    const __codecvt_type *_M_codecvt;

    char *_M_ext_buf;

    streamsize _M_ext_buf_size;

    const char *_M_ext_next;
    char *_M_ext_end;

    void _M_create_pback() {
      if (!_M_pback_init) {
        _M_pback_cur_save = this->gptr();
        _M_pback_end_save = this->egptr();
        this->setg(&_M_pback, &_M_pback, &_M_pback + 1);
        _M_pback_init = true;
      }
    }

    void _M_destroy_pback() throw() {
      if (_M_pback_init) {

        _M_pback_cur_save += this->gptr() != this->eback();
        this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save);
        _M_pback_init = false;
      }
    }

  public:
    basic_filebuf();

    basic_filebuf(const basic_filebuf &) = delete;
    basic_filebuf(basic_filebuf &&);

    virtual ~basic_filebuf() {
      try {
        this->close();
      } catch (...) {
      }
    }

    basic_filebuf &operator=(const basic_filebuf &) = delete;
    basic_filebuf &operator=(basic_filebuf &&);
    void swap(basic_filebuf &);

    bool is_open() const throw() { return _M_file.is_open(); }
# 316 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    __filebuf_type *open(const char *__s, ios_base::openmode __mode);
# 337 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    __filebuf_type *open(const std::string &__s, ios_base::openmode __mode) {
      return open(__s.c_str(), __mode);
    }
# 348 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    template <typename _Path>
    _If_fs_path<_Path, __filebuf_type *> open(const _Path &__s,
                                              ios_base::openmode __mode) {
      return open(__s.c_str(), __mode);
    }
# 367 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    __filebuf_type *close();

  protected:
    void _M_allocate_internal_buffer();

    void _M_destroy_internal_buffer() throw();

    virtual streamsize showmanyc();

    virtual int_type underflow();

    virtual int_type pbackfail(int_type __c = _Traits::eof());
# 399 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    virtual int_type overflow(int_type __c = _Traits::eof());

    bool _M_convert_to_external(char_type *, streamsize);
# 419 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    virtual __streambuf_type *setbuf(char_type *__s, streamsize __n);

    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                             ios_base::openmode __mode = ios_base::in |
                                                         ios_base::out);

    virtual pos_type seekpos(pos_type __pos,
                             ios_base::openmode __mode = ios_base::in |
                                                         ios_base::out);

    pos_type _M_seek(off_type __off, ios_base::seekdir __way,
                     __state_type __state);

    int _M_get_ext_pos(__state_type &__state);

    virtual int sync();

    virtual void imbue(const locale &__loc);

    virtual streamsize xsgetn(char_type *__s, streamsize __n);

    virtual streamsize xsputn(const char_type *__s, streamsize __n);

    bool _M_terminate_output();
# 465 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    void _M_set_buffer(streamsize __off) {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout =
          (_M_mode & ios_base::out || _M_mode & ios_base::app);

      if (__testin && __off > 0)
        this->setg(_M_buf, _M_buf, _M_buf + __off);
      else
        this->setg(_M_buf, _M_buf, _M_buf);

      if (__testout && __off == 0 && _M_buf_size > 1)
        this->setp(_M_buf, _M_buf + _M_buf_size - 1);
      else
        this->setp(0, 0);
    }
  };
# 498 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
  template <typename _CharT, typename _Traits>
  class basic_ifstream : public basic_istream<_CharT, _Traits> {
  public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    typedef basic_filebuf<char_type, traits_type> __filebuf_type;
    typedef basic_istream<char_type, traits_type> __istream_type;

  private:
    __filebuf_type _M_filebuf;

  public:
# 525 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    basic_ifstream() : __istream_type(), _M_filebuf() {
      this->init(&_M_filebuf);
    }
# 535 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    explicit basic_ifstream(const char *__s,
                            ios_base::openmode __mode = ios_base::in)
        : __istream_type(), _M_filebuf() {
      this->init(&_M_filebuf);
      this->open(__s, __mode);
    }
# 568 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    explicit basic_ifstream(const std::string &__s,
                            ios_base::openmode __mode = ios_base::in)
        : __istream_type(), _M_filebuf() {
      this->init(&_M_filebuf);
      this->open(__s, __mode);
    }
# 585 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    template <typename _Path, typename _Require = _If_fs_path<_Path>>
    basic_ifstream(const _Path &__s, ios_base::openmode __mode = ios_base::in)
        : basic_ifstream(__s.c_str(), __mode) {}

    basic_ifstream(const basic_ifstream &) = delete;

    basic_ifstream(basic_ifstream &&__rhs)
        : __istream_type(std::move(__rhs)),
          _M_filebuf(std::move(__rhs._M_filebuf)) {
      __istream_type::set_rdbuf(&_M_filebuf);
    }
# 606 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    ~basic_ifstream() {}

    basic_ifstream &operator=(const basic_ifstream &) = delete;

    basic_ifstream &operator=(basic_ifstream &&__rhs) {
      __istream_type::operator=(std::move(__rhs));
      _M_filebuf = std::move(__rhs._M_filebuf);
      return *this;
    }

    void swap(basic_ifstream &__rhs) {
      __istream_type::swap(__rhs);
      _M_filebuf.swap(__rhs._M_filebuf);
    }
# 638 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    __filebuf_type *rdbuf() const {
      return const_cast<__filebuf_type *>(&_M_filebuf);
    }

    bool is_open() { return _M_filebuf.is_open(); }

    bool is_open() const { return _M_filebuf.is_open(); }
# 664 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    void open(const char *__s, ios_base::openmode __mode = ios_base::in) {
      if (!_M_filebuf.open(__s, __mode | ios_base::in))
        this->setstate(ios_base::failbit);
      else

        this->clear();
    }
# 703 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    void open(const std::string &__s,
              ios_base::openmode __mode = ios_base::in) {
      if (!_M_filebuf.open(__s, __mode | ios_base::in))
        this->setstate(ios_base::failbit);
      else

        this->clear();
    }
# 723 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    template <typename _Path>
    _If_fs_path<_Path, void> open(const _Path &__s,
                                  ios_base::openmode __mode = ios_base::in) {
      open(__s.c_str(), __mode);
    }
# 736 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    void close() {
      if (!_M_filebuf.close())
        this->setstate(ios_base::failbit);
    }
  };
# 759 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
  template <typename _CharT, typename _Traits>
  class basic_ofstream : public basic_ostream<_CharT, _Traits> {
  public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    typedef basic_filebuf<char_type, traits_type> __filebuf_type;
    typedef basic_ostream<char_type, traits_type> __ostream_type;

  private:
    __filebuf_type _M_filebuf;

  public:
# 786 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    basic_ofstream() : __ostream_type(), _M_filebuf() {
      this->init(&_M_filebuf);
    }
# 796 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    explicit basic_ofstream(const char *__s,
                            ios_base::openmode __mode = ios_base::out)
        : __ostream_type(), _M_filebuf() {
      this->init(&_M_filebuf);
      this->open(__s, __mode);
    }
# 831 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    explicit basic_ofstream(const std::string &__s,
                            ios_base::openmode __mode = ios_base::out)
        : __ostream_type(), _M_filebuf() {
      this->init(&_M_filebuf);
      this->open(__s, __mode);
    }
# 848 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    template <typename _Path, typename _Require = _If_fs_path<_Path>>
    basic_ofstream(const _Path &__s, ios_base::openmode __mode = ios_base::out)
        : basic_ofstream(__s.c_str(), __mode) {}

    basic_ofstream(const basic_ofstream &) = delete;

    basic_ofstream(basic_ofstream &&__rhs)
        : __ostream_type(std::move(__rhs)),
          _M_filebuf(std::move(__rhs._M_filebuf)) {
      __ostream_type::set_rdbuf(&_M_filebuf);
    }
# 869 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    ~basic_ofstream() {}

    basic_ofstream &operator=(const basic_ofstream &) = delete;

    basic_ofstream &operator=(basic_ofstream &&__rhs) {
      __ostream_type::operator=(std::move(__rhs));
      _M_filebuf = std::move(__rhs._M_filebuf);
      return *this;
    }

    void swap(basic_ofstream &__rhs) {
      __ostream_type::swap(__rhs);
      _M_filebuf.swap(__rhs._M_filebuf);
    }
# 901 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    __filebuf_type *rdbuf() const {
      return const_cast<__filebuf_type *>(&_M_filebuf);
    }

    bool is_open() { return _M_filebuf.is_open(); }

    bool is_open() const { return _M_filebuf.is_open(); }
# 927 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    void open(const char *__s, ios_base::openmode __mode = ios_base::out) {
      if (!_M_filebuf.open(__s, __mode | ios_base::out))
        this->setstate(ios_base::failbit);
      else

        this->clear();
    }
# 966 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    void open(const std::string &__s,
              ios_base::openmode __mode = ios_base::out) {
      if (!_M_filebuf.open(__s, __mode | ios_base::out))
        this->setstate(ios_base::failbit);
      else

        this->clear();
    }
# 986 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    template <typename _Path>
    _If_fs_path<_Path, void> open(const _Path &__s,
                                  ios_base::openmode __mode = ios_base::out) {
      open(__s.c_str(), __mode);
    }
# 999 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    void close() {
      if (!_M_filebuf.close())
        this->setstate(ios_base::failbit);
    }
  };
# 1022 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
  template <typename _CharT, typename _Traits>
  class basic_fstream : public basic_iostream<_CharT, _Traits> {
  public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    typedef basic_filebuf<char_type, traits_type> __filebuf_type;
    typedef basic_ios<char_type, traits_type> __ios_type;
    typedef basic_iostream<char_type, traits_type> __iostream_type;

  private:
    __filebuf_type _M_filebuf;

  public:
# 1050 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    basic_fstream() : __iostream_type(), _M_filebuf() {
      this->init(&_M_filebuf);
    }

    explicit basic_fstream(const char *__s,
                           ios_base::openmode __mode = ios_base::in |
                                                       ios_base::out)
        : __iostream_type(0), _M_filebuf() {
      this->init(&_M_filebuf);
      this->open(__s, __mode);
    }
# 1089 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    explicit basic_fstream(const std::string &__s,
                           ios_base::openmode __mode = ios_base::in |
                                                       ios_base::out)
        : __iostream_type(0), _M_filebuf() {
      this->init(&_M_filebuf);
      this->open(__s, __mode);
    }

    template <typename _Path, typename _Require = _If_fs_path<_Path>>
    basic_fstream(const _Path &__s,
                  ios_base::openmode __mode = ios_base::in | ios_base::out)
        : basic_fstream(__s.c_str(), __mode) {}

    basic_fstream(const basic_fstream &) = delete;

    basic_fstream(basic_fstream &&__rhs)
        : __iostream_type(std::move(__rhs)),
          _M_filebuf(std::move(__rhs._M_filebuf)) {
      __iostream_type::set_rdbuf(&_M_filebuf);
    }
# 1125 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    ~basic_fstream() {}

    basic_fstream &operator=(const basic_fstream &) = delete;

    basic_fstream &operator=(basic_fstream &&__rhs) {
      __iostream_type::operator=(std::move(__rhs));
      _M_filebuf = std::move(__rhs._M_filebuf);
      return *this;
    }

    void swap(basic_fstream &__rhs) {
      __iostream_type::swap(__rhs);
      _M_filebuf.swap(__rhs._M_filebuf);
    }
# 1157 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    __filebuf_type *rdbuf() const {
      return const_cast<__filebuf_type *>(&_M_filebuf);
    }

    bool is_open() { return _M_filebuf.is_open(); }

    bool is_open() const { return _M_filebuf.is_open(); }
# 1183 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    void open(const char *__s,
              ios_base::openmode __mode = ios_base::in | ios_base::out) {
      if (!_M_filebuf.open(__s, __mode))
        this->setstate(ios_base::failbit);
      else

        this->clear();
    }
# 1224 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    void open(const std::string &__s,
              ios_base::openmode __mode = ios_base::in | ios_base::out) {
      if (!_M_filebuf.open(__s, __mode))
        this->setstate(ios_base::failbit);
      else

        this->clear();
    }
# 1245 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    template <typename _Path>
    _If_fs_path<_Path, void> open(const _Path &__s,
                                  ios_base::openmode __mode = ios_base::in |
                                                              ios_base::out) {
      open(__s.c_str(), __mode);
    }
# 1259 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 3
    void close() {
      if (!_M_filebuf.close())
        this->setstate(ios_base::failbit);
    }
  };

  template <class _CharT, class _Traits>
  inline void swap(basic_filebuf<_CharT, _Traits> & __x,
                   basic_filebuf<_CharT, _Traits> & __y) {
    __x.swap(__y);
  }

  template <class _CharT, class _Traits>
  inline void swap(basic_ifstream<_CharT, _Traits> & __x,
                   basic_ifstream<_CharT, _Traits> & __y) {
    __x.swap(__y);
  }

  template <class _CharT, class _Traits>
  inline void swap(basic_ofstream<_CharT, _Traits> & __x,
                   basic_ofstream<_CharT, _Traits> & __y) {
    __x.swap(__y);
  }

  template <class _CharT, class _Traits>
  inline void swap(basic_fstream<_CharT, _Traits> & __x,
                   basic_fstream<_CharT, _Traits> & __y) {
    __x.swap(__y);
  }

} // namespace std

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/fstream.tcc" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/fstream.tcc" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cerrno" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cerrno" 3
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/fstream.tcc" 2 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _CharT, typename _Traits>
  void basic_filebuf<_CharT, _Traits>::_M_allocate_internal_buffer() {

    if (!_M_buf_allocated && !_M_buf) {
      _M_buf = new char_type[_M_buf_size];
      _M_buf_allocated = true;
    }
  }

  template <typename _CharT, typename _Traits>
  void basic_filebuf<_CharT, _Traits>::_M_destroy_internal_buffer() throw() {
    if (_M_buf_allocated) {
      delete[] _M_buf;
      _M_buf = 0;
      _M_buf_allocated = false;
    }
    delete[] _M_ext_buf;
    _M_ext_buf = 0;
    _M_ext_buf_size = 0;
    _M_ext_next = 0;
    _M_ext_end = 0;
  }

  template <typename _CharT, typename _Traits>
  basic_filebuf<_CharT, _Traits>::basic_filebuf()
      : __streambuf_type(), _M_lock(), _M_file(&_M_lock),
        _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),
        _M_state_last(), _M_buf(0), _M_buf_size(8192), _M_buf_allocated(false),
        _M_reading(false), _M_writing(false), _M_pback(), _M_pback_cur_save(0),
        _M_pback_end_save(0), _M_pback_init(false), _M_codecvt(0),
        _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0), _M_ext_end(0) {
    _M_codecvt = std::__try_use_facet<__codecvt_type>(this->_M_buf_locale);
  }

  template <typename _CharT, typename _Traits>
  basic_filebuf<_CharT, _Traits>::basic_filebuf(basic_filebuf && __rhs)
      : __streambuf_type(__rhs), _M_lock(),
        _M_file(std::move(__rhs._M_file), &_M_lock),
        _M_mode(std::__exchange(__rhs._M_mode, ios_base::openmode(0))),
        _M_state_beg(std::move(__rhs._M_state_beg)),
        _M_state_cur(std::move(__rhs._M_state_cur)),
        _M_state_last(std::move(__rhs._M_state_last)),
        _M_buf(std::__exchange(__rhs._M_buf, nullptr)),
        _M_buf_size(std::__exchange(__rhs._M_buf_size, 1)),
        _M_buf_allocated(std::__exchange(__rhs._M_buf_allocated, false)),
        _M_reading(std::__exchange(__rhs._M_reading, false)),
        _M_writing(std::__exchange(__rhs._M_writing, false)),
        _M_pback(__rhs._M_pback),
        _M_pback_cur_save(std::__exchange(__rhs._M_pback_cur_save, nullptr)),
        _M_pback_end_save(std::__exchange(__rhs._M_pback_end_save, nullptr)),
        _M_pback_init(std::__exchange(__rhs._M_pback_init, false)),
        _M_codecvt(__rhs._M_codecvt),
        _M_ext_buf(std::__exchange(__rhs._M_ext_buf, nullptr)),
        _M_ext_buf_size(std::__exchange(__rhs._M_ext_buf_size, 0)),
        _M_ext_next(std::__exchange(__rhs._M_ext_next, nullptr)),
        _M_ext_end(std::__exchange(__rhs._M_ext_end, nullptr)) {
    __rhs._M_set_buffer(-1);
    __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
  }

  template <typename _CharT, typename _Traits>
  basic_filebuf<_CharT, _Traits> &basic_filebuf<_CharT, _Traits>::operator=(
      basic_filebuf &&__rhs) {
    this->close();
    __streambuf_type::operator=(__rhs);
    _M_file.swap(__rhs._M_file);
    _M_mode = std::__exchange(__rhs._M_mode, ios_base::openmode(0));
    _M_state_beg = std::move(__rhs._M_state_beg);
    _M_state_cur = std::move(__rhs._M_state_cur);
    _M_state_last = std::move(__rhs._M_state_last);
    _M_buf = std::__exchange(__rhs._M_buf, nullptr);
    _M_buf_size = std::__exchange(__rhs._M_buf_size, 1);
    _M_buf_allocated = std::__exchange(__rhs._M_buf_allocated, false);
    _M_ext_buf = std::__exchange(__rhs._M_ext_buf, nullptr);
    _M_ext_buf_size = std::__exchange(__rhs._M_ext_buf_size, 0);
    _M_ext_next = std::__exchange(__rhs._M_ext_next, nullptr);
    _M_ext_end = std::__exchange(__rhs._M_ext_end, nullptr);
    _M_reading = std::__exchange(__rhs._M_reading, false);
    _M_writing = std::__exchange(__rhs._M_writing, false);
    _M_pback_cur_save = std::__exchange(__rhs._M_pback_cur_save, nullptr);
    _M_pback_end_save = std::__exchange(__rhs._M_pback_end_save, nullptr);
    _M_pback_init = std::__exchange(__rhs._M_pback_init, false);
    __rhs._M_set_buffer(-1);
    __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
    return *this;
  }

  template <typename _CharT, typename _Traits>
  void basic_filebuf<_CharT, _Traits>::swap(basic_filebuf & __rhs) {
    __streambuf_type::swap(__rhs);
    _M_file.swap(__rhs._M_file);
    std::swap(_M_mode, __rhs._M_mode);
    std::swap(_M_state_beg, __rhs._M_state_beg);
    std::swap(_M_state_cur, __rhs._M_state_cur);
    std::swap(_M_state_last, __rhs._M_state_last);
    std::swap(_M_buf, __rhs._M_buf);
    std::swap(_M_buf_size, __rhs._M_buf_size);
    std::swap(_M_buf_allocated, __rhs._M_buf_allocated);
    std::swap(_M_ext_buf, __rhs._M_ext_buf);
    std::swap(_M_ext_buf_size, __rhs._M_ext_buf_size);
    std::swap(_M_ext_next, __rhs._M_ext_next);
    std::swap(_M_ext_end, __rhs._M_ext_end);
    std::swap(_M_reading, __rhs._M_reading);
    std::swap(_M_writing, __rhs._M_writing);
    std::swap(_M_pback_cur_save, __rhs._M_pback_cur_save);
    std::swap(_M_pback_end_save, __rhs._M_pback_end_save);
    std::swap(_M_pback_init, __rhs._M_pback_init);
  }

  template <typename _CharT, typename _Traits>
  typename basic_filebuf<_CharT, _Traits>::__filebuf_type *
  basic_filebuf<_CharT, _Traits>::open(const char *__s,
                                       ios_base::openmode __mode) {
    __filebuf_type *__ret = 0;
    if (!this->is_open()) {
      _M_file.open(__s, __mode);
      if (this->is_open()) {
        _M_allocate_internal_buffer();
        _M_mode = __mode;

        _M_reading = false;
        _M_writing = false;
        _M_set_buffer(-1);

        _M_state_last = _M_state_cur = _M_state_beg;

        if ((__mode & ios_base::ate) &&
            this->seekoff(0, ios_base::end, __mode) == pos_type(off_type(-1)))
          this->close();
        else
          __ret = this;
      }
    }
    return __ret;
  }
# 246 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/fstream.tcc" 3
  template <typename _CharT, typename _Traits>
  typename basic_filebuf<_CharT, _Traits>::__filebuf_type *
  basic_filebuf<_CharT, _Traits>::close() {
    if (!this->is_open())
      return 0;

    bool __testfail = false;
    {

      struct __close_sentry {
        basic_filebuf *__fb;
        __close_sentry(basic_filebuf *__fbi) : __fb(__fbi) {}
        ~__close_sentry() {
          __fb->_M_mode = ios_base::openmode(0);
          __fb->_M_pback_init = false;
          __fb->_M_destroy_internal_buffer();
          __fb->_M_reading = false;
          __fb->_M_writing = false;
          __fb->_M_set_buffer(-1);
          __fb->_M_state_last = __fb->_M_state_cur = __fb->_M_state_beg;
        }
      } __cs(this);

      try {
        if (!_M_terminate_output())
          __testfail = true;
      } catch (...) {
        _M_file.close();
        throw;
      }
    }

    if (!_M_file.close())
      __testfail = true;

    if (__testfail)
      return 0;
    else
      return this;
  }

  template <typename _CharT, typename _Traits>
  streamsize basic_filebuf<_CharT, _Traits>::showmanyc() {
    streamsize __ret = -1;
    const bool __testin = _M_mode & ios_base::in;
    if (__testin && this->is_open()) {

      __ret = this->egptr() - this->gptr();

      if (__check_facet(_M_codecvt).encoding() >= 0)

        __ret += _M_file.showmanyc() / _M_codecvt->max_length();
    }
    return __ret;
  }

  template <typename _CharT, typename _Traits>
  typename basic_filebuf<_CharT, _Traits>::int_type
  basic_filebuf<_CharT, _Traits>::underflow() {
    int_type __ret = traits_type::eof();
    const bool __testin = _M_mode & ios_base::in;
    if (__testin) {
      if (_M_writing) {
        if (overflow() == traits_type::eof())
          return __ret;
        _M_set_buffer(-1);
        _M_writing = false;
      }

      _M_destroy_pback();

      if (this->gptr() < this->egptr())
        return traits_type::to_int_type(*this->gptr());

      const size_t __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;

      bool __got_eof = false;

      streamsize __ilen = 0;
      codecvt_base::result __r = codecvt_base::ok;
      if (__check_facet(_M_codecvt).always_noconv()) {
        __ilen =
            _M_file.xsgetn(reinterpret_cast<char *>(this->eback()), __buflen);
        if (__ilen == 0)
          __got_eof = true;
      } else {

        const int __enc = _M_codecvt->encoding();
        streamsize __blen;
        streamsize __rlen;
        if (__enc > 0)
          __blen = __rlen = __buflen * __enc;
        else {
          __blen = __buflen + _M_codecvt->max_length() - 1;
          __rlen = __buflen;
        }
        const streamsize __remainder = _M_ext_end - _M_ext_next;
        __rlen = __rlen > __remainder ? __rlen - __remainder : 0;

        if (_M_reading && this->egptr() == this->eback() && __remainder)
          __rlen = 0;

        if (_M_ext_buf_size < __blen) {
          char *__buf = new char[__blen];
          if (__remainder)
            __builtin_memcpy(__buf, _M_ext_next, __remainder);

          delete[] _M_ext_buf;
          _M_ext_buf = __buf;
          _M_ext_buf_size = __blen;
        } else if (__remainder)
          __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

        _M_ext_next = _M_ext_buf;
        _M_ext_end = _M_ext_buf + __remainder;
        _M_state_last = _M_state_cur;

        do {
          if (__rlen > 0) {

            if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size) {
              __throw_ios_failure(("basic_filebuf::underflow "
                                   "codecvt::max_length() "
                                   "is not valid"));
            }
            streamsize __elen = _M_file.xsgetn(_M_ext_end, __rlen);
            if (__elen == 0)
              __got_eof = true;
            else if (__elen == -1)
              break;
            _M_ext_end += __elen;
          }

          char_type *__iend = this->eback();
          if (_M_ext_next < _M_ext_end)
            __r = _M_codecvt->in(_M_state_cur, _M_ext_next, _M_ext_end,
                                 _M_ext_next, this->eback(),
                                 this->eback() + __buflen, __iend);
          if (__r == codecvt_base::noconv) {
            size_t __avail = _M_ext_end - _M_ext_buf;
            __ilen = std::min(__avail, __buflen);
            traits_type::copy(this->eback(),
                              reinterpret_cast<char_type *>(_M_ext_buf),
                              __ilen);
            _M_ext_next = _M_ext_buf + __ilen;
          } else
            __ilen = __iend - this->eback();

          if (__r == codecvt_base::error)
            break;

          __rlen = 1;
        } while (__ilen == 0 && !__got_eof);
      }

      if (__ilen > 0) {
        _M_set_buffer(__ilen);
        _M_reading = true;
        __ret = traits_type::to_int_type(*this->gptr());
      } else if (__got_eof) {

        _M_set_buffer(-1);
        _M_reading = false;

        if (__r == codecvt_base::partial)
          __throw_ios_failure(("basic_filebuf::underflow "
                               "incomplete character in file"));

      } else if (__r == codecvt_base::error)
        __throw_ios_failure(("basic_filebuf::underflow "
                             "invalid byte sequence in file"));

      else
        __throw_ios_failure(("basic_filebuf::underflow "
                             "error reading the file"),
                            (*__errno_location()));
    }
    return __ret;
  }

  template <typename _CharT, typename _Traits>
  typename basic_filebuf<_CharT, _Traits>::int_type
  basic_filebuf<_CharT, _Traits>::pbackfail(int_type __i) {
    int_type __ret = traits_type::eof();
    const bool __testin = _M_mode & ios_base::in;
    if (__testin) {
      if (_M_writing) {
        if (overflow() == traits_type::eof())
          return __ret;
        _M_set_buffer(-1);
        _M_writing = false;
      }

      const bool __testpb = _M_pback_init;
      const bool __testeof = traits_type::eq_int_type(__i, __ret);
      int_type __tmp;
      if (this->eback() < this->gptr()) {
        this->gbump(-1);
        __tmp = traits_type::to_int_type(*this->gptr());
      } else if (this->seekoff(-1, ios_base::cur) != pos_type(off_type(-1))) {
        __tmp = this->underflow();
        if (traits_type::eq_int_type(__tmp, __ret))
          return __ret;
      } else {

        return __ret;
      }

      if (!__testeof && traits_type::eq_int_type(__i, __tmp))
        __ret = __i;
      else if (__testeof)
        __ret = traits_type::not_eof(__i);
      else if (!__testpb) {
        _M_create_pback();
        _M_reading = true;
        *this->gptr() = traits_type::to_char_type(__i);
        __ret = __i;
      }
    }
    return __ret;
  }

  template <typename _CharT, typename _Traits>
  typename basic_filebuf<_CharT, _Traits>::int_type
  basic_filebuf<_CharT, _Traits>::overflow(int_type __c) {
    int_type __ret = traits_type::eof();
    const bool __testeof = traits_type::eq_int_type(__c, __ret);
    const bool __testout = (_M_mode & ios_base::out || _M_mode & ios_base::app);
    if (__testout) {
      if (_M_reading) {
        _M_destroy_pback();
        const int __gptr_off = _M_get_ext_pos(_M_state_last);
        if (_M_seek(__gptr_off, ios_base::cur, _M_state_last) ==
            pos_type(off_type(-1)))
          return __ret;
      }
      if (this->pbase() < this->pptr()) {

        if (!__testeof) {
          *this->pptr() = traits_type::to_char_type(__c);
          this->pbump(1);
        }

        if (_M_convert_to_external(this->pbase(),
                                   this->pptr() - this->pbase())) {
          _M_set_buffer(0);
          __ret = traits_type::not_eof(__c);
        }
      } else if (_M_buf_size > 1) {

        _M_set_buffer(0);
        _M_writing = true;
        if (!__testeof) {
          *this->pptr() = traits_type::to_char_type(__c);
          this->pbump(1);
        }
        __ret = traits_type::not_eof(__c);
      } else {

        char_type __conv = traits_type::to_char_type(__c);
        if (__testeof || _M_convert_to_external(&__conv, 1)) {
          _M_writing = true;
          __ret = traits_type::not_eof(__c);
        }
      }
    }
    return __ret;
  }

  template <typename _CharT, typename _Traits>
  bool basic_filebuf<_CharT, _Traits>::_M_convert_to_external(
      _CharT * __ibuf, streamsize __ilen) {

    streamsize __elen;
    streamsize __plen;
    if (__check_facet(_M_codecvt).always_noconv()) {
      __elen = _M_file.xsputn(reinterpret_cast<char *>(__ibuf), __ilen);
      __plen = __ilen;
    } else {

      streamsize __blen = __ilen * _M_codecvt->max_length();
      char *__buf = static_cast<char *>(__builtin_alloca(__blen));

      char *__bend;
      const char_type *__iend;
      codecvt_base::result __r;
      __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen, __iend,
                            __buf, __buf + __blen, __bend);

      if (__r == codecvt_base::ok || __r == codecvt_base::partial)
        __blen = __bend - __buf;
      else if (__r == codecvt_base::noconv) {

        __buf = reinterpret_cast<char *>(__ibuf);
        __blen = __ilen;
      } else
        __throw_ios_failure(("basic_filebuf::_M_convert_to_external "
                             "conversion error"));

      __elen = _M_file.xsputn(__buf, __blen);
      __plen = __blen;

      if (__r == codecvt_base::partial && __elen == __plen) {
        const char_type *__iresume = __iend;
        streamsize __rlen = this->pptr() - __iend;
        __r = _M_codecvt->out(_M_state_cur, __iresume, __iresume + __rlen,
                              __iend, __buf, __buf + __blen, __bend);
        if (__r != codecvt_base::error) {
          __rlen = __bend - __buf;
          __elen = _M_file.xsputn(__buf, __rlen);
          __plen = __rlen;
        } else
          __throw_ios_failure(("basic_filebuf::_M_convert_to_external "
                               "conversion error"));
      }
    }
    return __elen == __plen;
  }

  template <typename _CharT, typename _Traits>
  streamsize basic_filebuf<_CharT, _Traits>::xsgetn(_CharT * __s,
                                                    streamsize __n) {

    streamsize __ret = 0;
    if (_M_pback_init) {
      if (__n > 0 && this->gptr() == this->eback()) {
        *__s++ = *this->gptr();
        this->gbump(1);
        __ret = 1;
        --__n;
      }
      _M_destroy_pback();
    } else if (_M_writing) {
      if (overflow() == traits_type::eof())
        return __ret;
      _M_set_buffer(-1);
      _M_writing = false;
    }

    const bool __testin = _M_mode & ios_base::in;
    const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;

    if (__n > __buflen && __check_facet(_M_codecvt).always_noconv() &&
        __testin) {

      const streamsize __avail = this->egptr() - this->gptr();
      if (__avail != 0) {
        traits_type::copy(__s, this->gptr(), __avail);
        __s += __avail;
        this->setg(this->eback(), this->gptr() + __avail, this->egptr());
        __ret += __avail;
        __n -= __avail;
      }

      streamsize __len;
      for (;;) {
        __len = _M_file.xsgetn(reinterpret_cast<char *>(__s), __n);
        if (__len == -1)
          __throw_ios_failure(("basic_filebuf::xsgetn "
                               "error reading the file"),
                              (*__errno_location()));

        if (__len == 0)
          break;

        __n -= __len;
        __ret += __len;
        if (__n == 0)
          break;

        __s += __len;
      }

      if (__n == 0) {

        _M_reading = true;
      } else if (__len == 0) {

        _M_set_buffer(-1);
        _M_reading = false;
      }
    } else
      __ret += __streambuf_type::xsgetn(__s, __n);

    return __ret;
  }

  template <typename _CharT, typename _Traits>
  streamsize basic_filebuf<_CharT, _Traits>::xsputn(const _CharT *__s,
                                                    streamsize __n) {
    streamsize __ret = 0;

    const bool __testout = (_M_mode & ios_base::out || _M_mode & ios_base::app);
    if (__check_facet(_M_codecvt).always_noconv() && __testout && !_M_reading) {
      streamsize __bufavail = this->epptr() - this->pptr();

      if (!_M_writing && _M_buf_size > 1)
        __bufavail = _M_buf_size - 1;

      if (__n >= __bufavail) {
        const streamsize __buffill = this->pptr() - this->pbase();
        const char *__buf = reinterpret_cast<const char *>(this->pbase());
        __ret = _M_file.xsputn_2(__buf, __buffill,
                                 reinterpret_cast<const char *>(__s), __n);
        if (__ret == __buffill + __n) {
          _M_set_buffer(0);
          _M_writing = true;
        }
        if (__ret > __buffill)
          __ret -= __buffill;
        else
          __ret = 0;
      } else
        __ret = __streambuf_type::xsputn(__s, __n);
    } else
      __ret = __streambuf_type::xsputn(__s, __n);
    return __ret;
  }

  template <typename _CharT, typename _Traits>
  typename basic_filebuf<_CharT, _Traits>::__streambuf_type *
  basic_filebuf<_CharT, _Traits>::setbuf(char_type * __s, streamsize __n) {
    if (!this->is_open()) {
      if (__s == 0 && __n == 0)
        _M_buf_size = 1;
      else if (__s && __n > 0) {
# 816 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/fstream.tcc" 3
        _M_buf = __s;
        _M_buf_size = __n;
      }
    }
    return this;
  }

  template <typename _CharT, typename _Traits>
  typename basic_filebuf<_CharT, _Traits>::pos_type
  basic_filebuf<_CharT, _Traits>::seekoff(
      off_type __off, ios_base::seekdir __way, ios_base::openmode) {
    int __width = 0;
    if (_M_codecvt)
      __width = _M_codecvt->encoding();
    if (__width < 0)
      __width = 0;

    pos_type __ret = pos_type(off_type(-1));
    const bool __testfail = __off != 0 && __width <= 0;
    if (this->is_open() && !__testfail) {

      bool __no_movement = __way == ios_base::cur && __off == 0 &&
                           (!_M_writing || _M_codecvt->always_noconv());

      if (!__no_movement)
        _M_destroy_pback();

      __state_type __state = _M_state_beg;
      off_type __computed_off = __off * __width;
      if (_M_reading && __way == ios_base::cur) {
        __state = _M_state_last;
        __computed_off += _M_get_ext_pos(__state);
      }
      if (!__no_movement)
        __ret = _M_seek(__computed_off, __way, __state);
      else {
        if (_M_writing)
          __computed_off = this->pptr() - this->pbase();

        off_type __file_off = _M_file.seekoff(0, ios_base::cur);
        if (__file_off != off_type(-1)) {
          __ret = __file_off + __computed_off;
          __ret.state(__state);
        }
      }
    }
    return __ret;
  }

  template <typename _CharT, typename _Traits>
  typename basic_filebuf<_CharT, _Traits>::pos_type
  basic_filebuf<_CharT, _Traits>::seekpos(pos_type __pos, ios_base::openmode) {
    pos_type __ret = pos_type(off_type(-1));
    if (this->is_open()) {

      _M_destroy_pback();
      __ret = _M_seek(off_type(__pos), ios_base::beg, __pos.state());
    }
    return __ret;
  }

  template <typename _CharT, typename _Traits>
  typename basic_filebuf<_CharT, _Traits>::pos_type
  basic_filebuf<_CharT, _Traits>::_M_seek(
      off_type __off, ios_base::seekdir __way, __state_type __state) {
    pos_type __ret = pos_type(off_type(-1));
    if (_M_terminate_output()) {
      off_type __file_off = _M_file.seekoff(__off, __way);
      if (__file_off != off_type(-1)) {
        _M_reading = false;
        _M_writing = false;
        _M_ext_next = _M_ext_end = _M_ext_buf;
        _M_set_buffer(-1);
        _M_state_cur = __state;
        __ret = __file_off;
        __ret.state(_M_state_cur);
      }
    }
    return __ret;
  }

  template <typename _CharT, typename _Traits>
  int basic_filebuf<_CharT, _Traits>::_M_get_ext_pos(__state_type & __state) {
    if (_M_codecvt->always_noconv())
      return this->gptr() - this->egptr();
    else {

      const int __gptr_off = _M_codecvt->length(
          __state, _M_ext_buf, _M_ext_next, this->gptr() - this->eback());
      return _M_ext_buf + __gptr_off - _M_ext_end;
    }
  }

  template <typename _CharT, typename _Traits>
  bool basic_filebuf<_CharT, _Traits>::_M_terminate_output() {

    bool __testvalid = true;
    if (this->pbase() < this->pptr()) {
      const int_type __tmp = this->overflow();
      if (traits_type::eq_int_type(__tmp, traits_type::eof()))
        __testvalid = false;
    }

    if (_M_writing && !__check_facet(_M_codecvt).always_noconv() &&
        __testvalid) {

      const size_t __blen = 128;
      char __buf[__blen];
      codecvt_base::result __r;
      streamsize __ilen = 0;

      do {
        char *__next;
        __r = _M_codecvt->unshift(_M_state_cur, __buf, __buf + __blen, __next);
        if (__r == codecvt_base::error)
          __testvalid = false;
        else if (__r == codecvt_base::ok || __r == codecvt_base::partial) {
          __ilen = __next - __buf;
          if (__ilen > 0) {
            const streamsize __elen = _M_file.xsputn(__buf, __ilen);
            if (__elen != __ilen)
              __testvalid = false;
          }
        }
      } while (__r == codecvt_base::partial && __ilen > 0 && __testvalid);

      if (__testvalid) {

        const int_type __tmp = this->overflow();
        if (traits_type::eq_int_type(__tmp, traits_type::eof()))
          __testvalid = false;
      }
    }
    return __testvalid;
  }

  template <typename _CharT, typename _Traits>
  int basic_filebuf<_CharT, _Traits>::sync() {

    int __ret = 0;
    if (this->pbase() < this->pptr()) {
      const int_type __tmp = this->overflow();
      if (traits_type::eq_int_type(__tmp, traits_type::eof()))
        __ret = -1;
    }
    return __ret;
  }

  template <typename _CharT, typename _Traits>
  void basic_filebuf<_CharT, _Traits>::imbue(const locale &__loc) {
    bool __testvalid = true;

    const __codecvt_type *const _M_codecvt_tmp =
        __try_use_facet<__codecvt_type>(__loc);

    if (this->is_open()) {

      if ((_M_reading || _M_writing) &&
          __check_facet(_M_codecvt).encoding() == -1)
        __testvalid = false;
      else {
        if (_M_reading) {
          if (__check_facet(_M_codecvt).always_noconv()) {
            if (_M_codecvt_tmp &&
                !__check_facet(_M_codecvt_tmp).always_noconv())
              __testvalid = this->seekoff(0, ios_base::cur, _M_mode) !=
                            pos_type(off_type(-1));
          } else {

            _M_ext_next =
                _M_ext_buf + _M_codecvt->length(_M_state_last, _M_ext_buf,
                                                _M_ext_next,
                                                this->gptr() - this->eback());
            const streamsize __remainder = _M_ext_end - _M_ext_next;
            if (__remainder)
              __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

            _M_ext_next = _M_ext_buf;
            _M_ext_end = _M_ext_buf + __remainder;
            _M_set_buffer(-1);
            _M_state_last = _M_state_cur = _M_state_beg;
          }
        } else if (_M_writing && (__testvalid = _M_terminate_output()))
          _M_set_buffer(-1);
      }
    }

    if (__testvalid)
      _M_codecvt = _M_codecvt_tmp;
    else
      _M_codecvt = 0;
  }

  extern template class basic_filebuf<char>;
  extern template class basic_ifstream<char>;
  extern template class basic_ofstream<char>;
  extern template class basic_fstream<char>;

  extern template class basic_filebuf<wchar_t>;
  extern template class basic_ifstream<wchar_t>;
  extern template class basic_ofstream<wchar_t>;
  extern template class basic_fstream<wchar_t>;

} // namespace std
# 1301 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/fstream" 2 3
# 2 "CG_stdexec.hpp" 2
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cmath" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cmath" 3

# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4

extern "C" {

# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 152 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 153 "/usr/include/math.h" 2 3 4
# 163 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 204 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 205 "/usr/include/math.h" 2 3 4
# 247 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 248 "/usr/include/math.h" 2 3 4

enum {
  FP_INT_UPWARD =

      0,
  FP_INT_DOWNWARD =

      1,
  FP_INT_TOWARDZERO =

      2,
  FP_INT_TONEARESTFROMZERO =

      3,
  FP_INT_TONEAREST =

      4,
};
# 312 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify(double __value) noexcept(true)
    __attribute__((__const__));

extern int __signbit(double __value) noexcept(true) __attribute__((__const__));

extern int __isinf(double __value) noexcept(true) __attribute__((__const__));

extern int __finite(double __value) noexcept(true) __attribute__((__const__));

extern int __isnan(double __value) noexcept(true) __attribute__((__const__));

extern int __iseqsig(double __x, double __y) noexcept(true);

extern int __issignaling(double __value) noexcept(true)
    __attribute__((__const__));
# 313 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double acos(double __x) noexcept(true);
extern double __acos(double __x) noexcept(true);

extern double asin(double __x) noexcept(true);
extern double __asin(double __x) noexcept(true);

extern double atan(double __x) noexcept(true);
extern double __atan(double __x) noexcept(true);

extern double atan2(double __y, double __x) noexcept(true);
extern double __atan2(double __y, double __x) noexcept(true);

extern double cos(double __x) noexcept(true);
extern double __cos(double __x) noexcept(true);

extern double sin(double __x) noexcept(true);
extern double __sin(double __x) noexcept(true);

extern double tan(double __x) noexcept(true);
extern double __tan(double __x) noexcept(true);

extern double cosh(double __x) noexcept(true);
extern double __cosh(double __x) noexcept(true);

extern double sinh(double __x) noexcept(true);
extern double __sinh(double __x) noexcept(true);

extern double tanh(double __x) noexcept(true);
extern double __tanh(double __x) noexcept(true);

extern void sincos(double __x, double *__sinx, double *__cosx) noexcept(true);
extern void __sincos(double __x, double *__sinx, double *__cosx) noexcept(true);

extern double acosh(double __x) noexcept(true);
extern double __acosh(double __x) noexcept(true);

extern double asinh(double __x) noexcept(true);
extern double __asinh(double __x) noexcept(true);

extern double atanh(double __x) noexcept(true);
extern double __atanh(double __x) noexcept(true);

extern double exp(double __x) noexcept(true);
extern double __exp(double __x) noexcept(true);

extern double frexp(double __x, int *__exponent) noexcept(true);
extern double __frexp(double __x, int *__exponent) noexcept(true);

extern double ldexp(double __x, int __exponent) noexcept(true);
extern double __ldexp(double __x, int __exponent) noexcept(true);

extern double log(double __x) noexcept(true);
extern double __log(double __x) noexcept(true);

extern double log10(double __x) noexcept(true);
extern double __log10(double __x) noexcept(true);

extern double modf(double __x, double *__iptr) noexcept(true);
extern double __modf(double __x, double *__iptr) noexcept(true)
    __attribute__((__nonnull__(2)));

extern double exp10(double __x) noexcept(true);
extern double __exp10(double __x) noexcept(true);

extern double expm1(double __x) noexcept(true);
extern double __expm1(double __x) noexcept(true);

extern double log1p(double __x) noexcept(true);
extern double __log1p(double __x) noexcept(true);

extern double logb(double __x) noexcept(true);
extern double __logb(double __x) noexcept(true);

extern double exp2(double __x) noexcept(true);
extern double __exp2(double __x) noexcept(true);

extern double log2(double __x) noexcept(true);
extern double __log2(double __x) noexcept(true);

extern double pow(double __x, double __y) noexcept(true);
extern double __pow(double __x, double __y) noexcept(true);

extern double sqrt(double __x) noexcept(true);
extern double __sqrt(double __x) noexcept(true);

extern double hypot(double __x, double __y) noexcept(true);
extern double __hypot(double __x, double __y) noexcept(true);

extern double cbrt(double __x) noexcept(true);
extern double __cbrt(double __x) noexcept(true);

extern double ceil(double __x) noexcept(true) __attribute__((__const__));
extern double __ceil(double __x) noexcept(true) __attribute__((__const__));

extern double fabs(double __x) noexcept(true) __attribute__((__const__));
extern double __fabs(double __x) noexcept(true) __attribute__((__const__));

extern double floor(double __x) noexcept(true) __attribute__((__const__));
extern double __floor(double __x) noexcept(true) __attribute__((__const__));

extern double fmod(double __x, double __y) noexcept(true);
extern double __fmod(double __x, double __y) noexcept(true);
# 183 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int finite(double __value) noexcept(true) __attribute__((__const__));

extern double drem(double __x, double __y) noexcept(true);
extern double __drem(double __x, double __y) noexcept(true);

extern double significand(double __x) noexcept(true);
extern double __significand(double __x) noexcept(true);

extern double copysign(double __x, double __y) noexcept(true)
    __attribute__((__const__));
extern double __copysign(double __x, double __y) noexcept(true)
    __attribute__((__const__));

extern double nan(const char *__tagb) noexcept(true);
extern double __nan(const char *__tagb) noexcept(true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double j0(double) noexcept(true);
extern double __j0(double) noexcept(true);
extern double j1(double) noexcept(true);
extern double __j1(double) noexcept(true);
extern double jn(int, double) noexcept(true);
extern double __jn(int, double) noexcept(true);
extern double y0(double) noexcept(true);
extern double __y0(double) noexcept(true);
extern double y1(double) noexcept(true);
extern double __y1(double) noexcept(true);
extern double yn(int, double) noexcept(true);
extern double __yn(int, double) noexcept(true);

extern double erf(double) noexcept(true);
extern double __erf(double) noexcept(true);
extern double erfc(double) noexcept(true);
extern double __erfc(double) noexcept(true);
extern double lgamma(double) noexcept(true);
extern double __lgamma(double) noexcept(true);

extern double tgamma(double) noexcept(true);
extern double __tgamma(double) noexcept(true);

extern double gamma(double) noexcept(true);
extern double __gamma(double) noexcept(true);

extern double lgamma_r(double, int *__signgamp) noexcept(true);
extern double __lgamma_r(double, int *__signgamp) noexcept(true);

extern double rint(double __x) noexcept(true);
extern double __rint(double __x) noexcept(true);

extern double nextafter(double __x, double __y) noexcept(true);
extern double __nextafter(double __x, double __y) noexcept(true);

extern double nexttoward(double __x, long double __y) noexcept(true);
extern double __nexttoward(double __x, long double __y) noexcept(true);

extern double nextdown(double __x) noexcept(true);
extern double __nextdown(double __x) noexcept(true);

extern double nextup(double __x) noexcept(true);
extern double __nextup(double __x) noexcept(true);

extern double remainder(double __x, double __y) noexcept(true);
extern double __remainder(double __x, double __y) noexcept(true);

extern double scalbn(double __x, int __n) noexcept(true);
extern double __scalbn(double __x, int __n) noexcept(true);

extern int ilogb(double __x) noexcept(true);
extern int __ilogb(double __x) noexcept(true);

extern long int llogb(double __x) noexcept(true);
extern long int __llogb(double __x) noexcept(true);

extern double scalbln(double __x, long int __n) noexcept(true);
extern double __scalbln(double __x, long int __n) noexcept(true);

extern double nearbyint(double __x) noexcept(true);
extern double __nearbyint(double __x) noexcept(true);

extern double round(double __x) noexcept(true) __attribute__((__const__));
extern double __round(double __x) noexcept(true) __attribute__((__const__));

extern double trunc(double __x) noexcept(true) __attribute__((__const__));
extern double __trunc(double __x) noexcept(true) __attribute__((__const__));

extern double remquo(double __x, double __y, int *__quo) noexcept(true);
extern double __remquo(double __x, double __y, int *__quo) noexcept(true);

extern long int lrint(double __x) noexcept(true);
extern long int __lrint(double __x) noexcept(true);
__extension__ extern long long int llrint(double __x) noexcept(true);
extern long long int __llrint(double __x) noexcept(true);

extern long int lround(double __x) noexcept(true);
extern long int __lround(double __x) noexcept(true);
__extension__ extern long long int llround(double __x) noexcept(true);
extern long long int __llround(double __x) noexcept(true);

extern double fdim(double __x, double __y) noexcept(true);
extern double __fdim(double __x, double __y) noexcept(true);

extern double fmax(double __x, double __y) noexcept(true)
    __attribute__((__const__));
extern double __fmax(double __x, double __y) noexcept(true)
    __attribute__((__const__));

extern double fmin(double __x, double __y) noexcept(true)
    __attribute__((__const__));
extern double __fmin(double __x, double __y) noexcept(true)
    __attribute__((__const__));

extern double fma(double __x, double __y, double __z) noexcept(true);
extern double __fma(double __x, double __y, double __z) noexcept(true);

extern double roundeven(double __x) noexcept(true) __attribute__((__const__));
extern double __roundeven(double __x) noexcept(true) __attribute__((__const__));

extern __intmax_t fromfp(double __x, int __round,
                         unsigned int __width) noexcept(true);
extern __intmax_t __fromfp(double __x, int __round,
                           unsigned int __width) noexcept(true);

extern __uintmax_t ufromfp(double __x, int __round,
                           unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfp(double __x, int __round,
                             unsigned int __width) noexcept(true);

extern __intmax_t fromfpx(double __x, int __round,
                          unsigned int __width) noexcept(true);
extern __intmax_t __fromfpx(double __x, int __round,
                            unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpx(double __x, int __round,
                            unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpx(double __x, int __round,
                              unsigned int __width) noexcept(true);

extern int canonicalize(double *__cx, const double *__x) noexcept(true);

extern double fmaxmag(double __x, double __y) noexcept(true)
    __attribute__((__const__));
extern double __fmaxmag(double __x, double __y) noexcept(true)
    __attribute__((__const__));

extern double fminmag(double __x, double __y) noexcept(true)
    __attribute__((__const__));
extern double __fminmag(double __x, double __y) noexcept(true)
    __attribute__((__const__));

extern double fmaximum(double __x, double __y) noexcept(true)
    __attribute__((__const__));
extern double __fmaximum(double __x, double __y) noexcept(true)
    __attribute__((__const__));

extern double fminimum(double __x, double __y) noexcept(true)
    __attribute__((__const__));
extern double __fminimum(double __x, double __y) noexcept(true)
    __attribute__((__const__));

extern double fmaximum_num(double __x, double __y) noexcept(true)
    __attribute__((__const__));
extern double __fmaximum_num(double __x, double __y) noexcept(true)
    __attribute__((__const__));

extern double fminimum_num(double __x, double __y) noexcept(true)
    __attribute__((__const__));
extern double __fminimum_num(double __x, double __y) noexcept(true)
    __attribute__((__const__));

extern double fmaximum_mag(double __x, double __y) noexcept(true)
    __attribute__((__const__));
extern double __fmaximum_mag(double __x, double __y) noexcept(true)
    __attribute__((__const__));

extern double fminimum_mag(double __x, double __y) noexcept(true)
    __attribute__((__const__));
extern double __fminimum_mag(double __x, double __y) noexcept(true)
    __attribute__((__const__));

extern double fmaximum_mag_num(double __x, double __y) noexcept(true)
    __attribute__((__const__));
extern double __fmaximum_mag_num(double __x, double __y) noexcept(true)
    __attribute__((__const__));

extern double fminimum_mag_num(double __x, double __y) noexcept(true)
    __attribute__((__const__));
extern double __fminimum_mag_num(double __x, double __y) noexcept(true)
    __attribute__((__const__));

extern int totalorder(const double *__x, const double *__y) noexcept(true)

    __attribute__((__pure__));

extern int totalordermag(const double *__x, const double *__y) noexcept(true)

    __attribute__((__pure__));

extern double getpayload(const double *__x) noexcept(true);
extern double __getpayload(const double *__x) noexcept(true);

extern int setpayload(double *__x, double __payload) noexcept(true);

extern int setpayloadsig(double *__x, double __payload) noexcept(true);

extern double scalb(double __x, double __n) noexcept(true);
extern double __scalb(double __x, double __n) noexcept(true);
# 314 "/usr/include/math.h" 2 3 4
# 329 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf(float __value) noexcept(true)
    __attribute__((__const__));

extern int __signbitf(float __value) noexcept(true) __attribute__((__const__));

extern int __isinff(float __value) noexcept(true) __attribute__((__const__));

extern int __finitef(float __value) noexcept(true) __attribute__((__const__));

extern int __isnanf(float __value) noexcept(true) __attribute__((__const__));

extern int __iseqsigf(float __x, float __y) noexcept(true);

extern int __issignalingf(float __value) noexcept(true)
    __attribute__((__const__));
# 330 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float acosf(float __x) noexcept(true);
extern float __acosf(float __x) noexcept(true);

extern float asinf(float __x) noexcept(true);
extern float __asinf(float __x) noexcept(true);

extern float atanf(float __x) noexcept(true);
extern float __atanf(float __x) noexcept(true);

extern float atan2f(float __y, float __x) noexcept(true);
extern float __atan2f(float __y, float __x) noexcept(true);

extern float cosf(float __x) noexcept(true);
extern float __cosf(float __x) noexcept(true);

extern float sinf(float __x) noexcept(true);
extern float __sinf(float __x) noexcept(true);

extern float tanf(float __x) noexcept(true);
extern float __tanf(float __x) noexcept(true);

extern float coshf(float __x) noexcept(true);
extern float __coshf(float __x) noexcept(true);

extern float sinhf(float __x) noexcept(true);
extern float __sinhf(float __x) noexcept(true);

extern float tanhf(float __x) noexcept(true);
extern float __tanhf(float __x) noexcept(true);

extern void sincosf(float __x, float *__sinx, float *__cosx) noexcept(true);
extern void __sincosf(float __x, float *__sinx, float *__cosx) noexcept(true);

extern float acoshf(float __x) noexcept(true);
extern float __acoshf(float __x) noexcept(true);

extern float asinhf(float __x) noexcept(true);
extern float __asinhf(float __x) noexcept(true);

extern float atanhf(float __x) noexcept(true);
extern float __atanhf(float __x) noexcept(true);

extern float expf(float __x) noexcept(true);
extern float __expf(float __x) noexcept(true);

extern float frexpf(float __x, int *__exponent) noexcept(true);
extern float __frexpf(float __x, int *__exponent) noexcept(true);

extern float ldexpf(float __x, int __exponent) noexcept(true);
extern float __ldexpf(float __x, int __exponent) noexcept(true);

extern float logf(float __x) noexcept(true);
extern float __logf(float __x) noexcept(true);

extern float log10f(float __x) noexcept(true);
extern float __log10f(float __x) noexcept(true);

extern float modff(float __x, float *__iptr) noexcept(true);
extern float __modff(float __x, float *__iptr) noexcept(true)
    __attribute__((__nonnull__(2)));

extern float exp10f(float __x) noexcept(true);
extern float __exp10f(float __x) noexcept(true);

extern float expm1f(float __x) noexcept(true);
extern float __expm1f(float __x) noexcept(true);

extern float log1pf(float __x) noexcept(true);
extern float __log1pf(float __x) noexcept(true);

extern float logbf(float __x) noexcept(true);
extern float __logbf(float __x) noexcept(true);

extern float exp2f(float __x) noexcept(true);
extern float __exp2f(float __x) noexcept(true);

extern float log2f(float __x) noexcept(true);
extern float __log2f(float __x) noexcept(true);

extern float powf(float __x, float __y) noexcept(true);
extern float __powf(float __x, float __y) noexcept(true);

extern float sqrtf(float __x) noexcept(true);
extern float __sqrtf(float __x) noexcept(true);

extern float hypotf(float __x, float __y) noexcept(true);
extern float __hypotf(float __x, float __y) noexcept(true);

extern float cbrtf(float __x) noexcept(true);
extern float __cbrtf(float __x) noexcept(true);

extern float ceilf(float __x) noexcept(true) __attribute__((__const__));
extern float __ceilf(float __x) noexcept(true) __attribute__((__const__));

extern float fabsf(float __x) noexcept(true) __attribute__((__const__));
extern float __fabsf(float __x) noexcept(true) __attribute__((__const__));

extern float floorf(float __x) noexcept(true) __attribute__((__const__));
extern float __floorf(float __x) noexcept(true) __attribute__((__const__));

extern float fmodf(float __x, float __y) noexcept(true);
extern float __fmodf(float __x, float __y) noexcept(true);
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff(float __value) noexcept(true) __attribute__((__const__));

extern int finitef(float __value) noexcept(true) __attribute__((__const__));

extern float dremf(float __x, float __y) noexcept(true);
extern float __dremf(float __x, float __y) noexcept(true);

extern float significandf(float __x) noexcept(true);
extern float __significandf(float __x) noexcept(true);

extern float copysignf(float __x, float __y) noexcept(true)
    __attribute__((__const__));
extern float __copysignf(float __x, float __y) noexcept(true)
    __attribute__((__const__));

extern float nanf(const char *__tagb) noexcept(true);
extern float __nanf(const char *__tagb) noexcept(true);
# 213 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf(float __value) noexcept(true) __attribute__((__const__));

extern float j0f(float) noexcept(true);
extern float __j0f(float) noexcept(true);
extern float j1f(float) noexcept(true);
extern float __j1f(float) noexcept(true);
extern float jnf(int, float) noexcept(true);
extern float __jnf(int, float) noexcept(true);
extern float y0f(float) noexcept(true);
extern float __y0f(float) noexcept(true);
extern float y1f(float) noexcept(true);
extern float __y1f(float) noexcept(true);
extern float ynf(int, float) noexcept(true);
extern float __ynf(int, float) noexcept(true);

extern float erff(float) noexcept(true);
extern float __erff(float) noexcept(true);
extern float erfcf(float) noexcept(true);
extern float __erfcf(float) noexcept(true);
extern float lgammaf(float) noexcept(true);
extern float __lgammaf(float) noexcept(true);

extern float tgammaf(float) noexcept(true);
extern float __tgammaf(float) noexcept(true);

extern float gammaf(float) noexcept(true);
extern float __gammaf(float) noexcept(true);

extern float lgammaf_r(float, int *__signgamp) noexcept(true);
extern float __lgammaf_r(float, int *__signgamp) noexcept(true);

extern float rintf(float __x) noexcept(true);
extern float __rintf(float __x) noexcept(true);

extern float nextafterf(float __x, float __y) noexcept(true);
extern float __nextafterf(float __x, float __y) noexcept(true);

extern float nexttowardf(float __x, long double __y) noexcept(true);
extern float __nexttowardf(float __x, long double __y) noexcept(true);

extern float nextdownf(float __x) noexcept(true);
extern float __nextdownf(float __x) noexcept(true);

extern float nextupf(float __x) noexcept(true);
extern float __nextupf(float __x) noexcept(true);

extern float remainderf(float __x, float __y) noexcept(true);
extern float __remainderf(float __x, float __y) noexcept(true);

extern float scalbnf(float __x, int __n) noexcept(true);
extern float __scalbnf(float __x, int __n) noexcept(true);

extern int ilogbf(float __x) noexcept(true);
extern int __ilogbf(float __x) noexcept(true);

extern long int llogbf(float __x) noexcept(true);
extern long int __llogbf(float __x) noexcept(true);

extern float scalblnf(float __x, long int __n) noexcept(true);
extern float __scalblnf(float __x, long int __n) noexcept(true);

extern float nearbyintf(float __x) noexcept(true);
extern float __nearbyintf(float __x) noexcept(true);

extern float roundf(float __x) noexcept(true) __attribute__((__const__));
extern float __roundf(float __x) noexcept(true) __attribute__((__const__));

extern float truncf(float __x) noexcept(true) __attribute__((__const__));
extern float __truncf(float __x) noexcept(true) __attribute__((__const__));

extern float remquof(float __x, float __y, int *__quo) noexcept(true);
extern float __remquof(float __x, float __y, int *__quo) noexcept(true);

extern long int lrintf(float __x) noexcept(true);
extern long int __lrintf(float __x) noexcept(true);
__extension__ extern long long int llrintf(float __x) noexcept(true);
extern long long int __llrintf(float __x) noexcept(true);

extern long int lroundf(float __x) noexcept(true);
extern long int __lroundf(float __x) noexcept(true);
__extension__ extern long long int llroundf(float __x) noexcept(true);
extern long long int __llroundf(float __x) noexcept(true);

extern float fdimf(float __x, float __y) noexcept(true);
extern float __fdimf(float __x, float __y) noexcept(true);

extern float fmaxf(float __x, float __y) noexcept(true)
    __attribute__((__const__));
extern float __fmaxf(float __x, float __y) noexcept(true)
    __attribute__((__const__));

extern float fminf(float __x, float __y) noexcept(true)
    __attribute__((__const__));
extern float __fminf(float __x, float __y) noexcept(true)
    __attribute__((__const__));

extern float fmaf(float __x, float __y, float __z) noexcept(true);
extern float __fmaf(float __x, float __y, float __z) noexcept(true);

extern float roundevenf(float __x) noexcept(true) __attribute__((__const__));
extern float __roundevenf(float __x) noexcept(true) __attribute__((__const__));

extern __intmax_t fromfpf(float __x, int __round,
                          unsigned int __width) noexcept(true);
extern __intmax_t __fromfpf(float __x, int __round,
                            unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpf(float __x, int __round,
                            unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpf(float __x, int __round,
                              unsigned int __width) noexcept(true);

extern __intmax_t fromfpxf(float __x, int __round,
                           unsigned int __width) noexcept(true);
extern __intmax_t __fromfpxf(float __x, int __round,
                             unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpxf(float __x, int __round,
                             unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpxf(float __x, int __round,
                               unsigned int __width) noexcept(true);

extern int canonicalizef(float *__cx, const float *__x) noexcept(true);

extern float fmaxmagf(float __x, float __y) noexcept(true)
    __attribute__((__const__));
extern float __fmaxmagf(float __x, float __y) noexcept(true)
    __attribute__((__const__));

extern float fminmagf(float __x, float __y) noexcept(true)
    __attribute__((__const__));
extern float __fminmagf(float __x, float __y) noexcept(true)
    __attribute__((__const__));

extern float fmaximumf(float __x, float __y) noexcept(true)
    __attribute__((__const__));
extern float __fmaximumf(float __x, float __y) noexcept(true)
    __attribute__((__const__));

extern float fminimumf(float __x, float __y) noexcept(true)
    __attribute__((__const__));
extern float __fminimumf(float __x, float __y) noexcept(true)
    __attribute__((__const__));

extern float fmaximum_numf(float __x, float __y) noexcept(true)
    __attribute__((__const__));
extern float __fmaximum_numf(float __x, float __y) noexcept(true)
    __attribute__((__const__));

extern float fminimum_numf(float __x, float __y) noexcept(true)
    __attribute__((__const__));
extern float __fminimum_numf(float __x, float __y) noexcept(true)
    __attribute__((__const__));

extern float fmaximum_magf(float __x, float __y) noexcept(true)
    __attribute__((__const__));
extern float __fmaximum_magf(float __x, float __y) noexcept(true)
    __attribute__((__const__));

extern float fminimum_magf(float __x, float __y) noexcept(true)
    __attribute__((__const__));
extern float __fminimum_magf(float __x, float __y) noexcept(true)
    __attribute__((__const__));

extern float fmaximum_mag_numf(float __x, float __y) noexcept(true)
    __attribute__((__const__));
extern float __fmaximum_mag_numf(float __x, float __y) noexcept(true)
    __attribute__((__const__));

extern float fminimum_mag_numf(float __x, float __y) noexcept(true)
    __attribute__((__const__));
extern float __fminimum_mag_numf(float __x, float __y) noexcept(true)
    __attribute__((__const__));

extern int totalorderf(const float *__x, const float *__y) noexcept(true)

    __attribute__((__pure__));

extern int totalordermagf(const float *__x, const float *__y) noexcept(true)

    __attribute__((__pure__));

extern float getpayloadf(const float *__x) noexcept(true);
extern float __getpayloadf(const float *__x) noexcept(true);

extern int setpayloadf(float *__x, float __payload) noexcept(true);

extern int setpayloadsigf(float *__x, float __payload) noexcept(true);

extern float scalbf(float __x, float __n) noexcept(true);
extern float __scalbf(float __x, float __n) noexcept(true);
# 331 "/usr/include/math.h" 2 3 4
# 398 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl(long double __value) noexcept(true)
    __attribute__((__const__));

extern int __signbitl(long double __value) noexcept(true)
    __attribute__((__const__));

extern int __isinfl(long double __value) noexcept(true)
    __attribute__((__const__));

extern int __finitel(long double __value) noexcept(true)
    __attribute__((__const__));

extern int __isnanl(long double __value) noexcept(true)
    __attribute__((__const__));

extern int __iseqsigl(long double __x, long double __y) noexcept(true);

extern int __issignalingl(long double __value) noexcept(true)
    __attribute__((__const__));
# 399 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double acosl(long double __x) noexcept(true);
extern long double __acosl(long double __x) noexcept(true);

extern long double asinl(long double __x) noexcept(true);
extern long double __asinl(long double __x) noexcept(true);

extern long double atanl(long double __x) noexcept(true);
extern long double __atanl(long double __x) noexcept(true);

extern long double atan2l(long double __y, long double __x) noexcept(true);
extern long double __atan2l(long double __y, long double __x) noexcept(true);

extern long double cosl(long double __x) noexcept(true);
extern long double __cosl(long double __x) noexcept(true);

extern long double sinl(long double __x) noexcept(true);
extern long double __sinl(long double __x) noexcept(true);

extern long double tanl(long double __x) noexcept(true);
extern long double __tanl(long double __x) noexcept(true);

extern long double coshl(long double __x) noexcept(true);
extern long double __coshl(long double __x) noexcept(true);

extern long double sinhl(long double __x) noexcept(true);
extern long double __sinhl(long double __x) noexcept(true);

extern long double tanhl(long double __x) noexcept(true);
extern long double __tanhl(long double __x) noexcept(true);

extern void sincosl(long double __x, long double *__sinx,
                    long double *__cosx) noexcept(true);
extern void __sincosl(long double __x, long double *__sinx,
                      long double *__cosx) noexcept(true);

extern long double acoshl(long double __x) noexcept(true);
extern long double __acoshl(long double __x) noexcept(true);

extern long double asinhl(long double __x) noexcept(true);
extern long double __asinhl(long double __x) noexcept(true);

extern long double atanhl(long double __x) noexcept(true);
extern long double __atanhl(long double __x) noexcept(true);

extern long double expl(long double __x) noexcept(true);
extern long double __expl(long double __x) noexcept(true);

extern long double frexpl(long double __x, int *__exponent) noexcept(true);
extern long double __frexpl(long double __x, int *__exponent) noexcept(true);

extern long double ldexpl(long double __x, int __exponent) noexcept(true);
extern long double __ldexpl(long double __x, int __exponent) noexcept(true);

extern long double logl(long double __x) noexcept(true);
extern long double __logl(long double __x) noexcept(true);

extern long double log10l(long double __x) noexcept(true);
extern long double __log10l(long double __x) noexcept(true);

extern long double modfl(long double __x, long double *__iptr) noexcept(true);
extern long double __modfl(long double __x, long double *__iptr) noexcept(true)
    __attribute__((__nonnull__(2)));

extern long double exp10l(long double __x) noexcept(true);
extern long double __exp10l(long double __x) noexcept(true);

extern long double expm1l(long double __x) noexcept(true);
extern long double __expm1l(long double __x) noexcept(true);

extern long double log1pl(long double __x) noexcept(true);
extern long double __log1pl(long double __x) noexcept(true);

extern long double logbl(long double __x) noexcept(true);
extern long double __logbl(long double __x) noexcept(true);

extern long double exp2l(long double __x) noexcept(true);
extern long double __exp2l(long double __x) noexcept(true);

extern long double log2l(long double __x) noexcept(true);
extern long double __log2l(long double __x) noexcept(true);

extern long double powl(long double __x, long double __y) noexcept(true);
extern long double __powl(long double __x, long double __y) noexcept(true);

extern long double sqrtl(long double __x) noexcept(true);
extern long double __sqrtl(long double __x) noexcept(true);

extern long double hypotl(long double __x, long double __y) noexcept(true);
extern long double __hypotl(long double __x, long double __y) noexcept(true);

extern long double cbrtl(long double __x) noexcept(true);
extern long double __cbrtl(long double __x) noexcept(true);

extern long double ceill(long double __x) noexcept(true)
    __attribute__((__const__));
extern long double __ceill(long double __x) noexcept(true)
    __attribute__((__const__));

extern long double fabsl(long double __x) noexcept(true)
    __attribute__((__const__));
extern long double __fabsl(long double __x) noexcept(true)
    __attribute__((__const__));

extern long double floorl(long double __x) noexcept(true)
    __attribute__((__const__));
extern long double __floorl(long double __x) noexcept(true)
    __attribute__((__const__));

extern long double fmodl(long double __x, long double __y) noexcept(true);
extern long double __fmodl(long double __x, long double __y) noexcept(true);
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl(long double __value) noexcept(true)
    __attribute__((__const__));

extern int finitel(long double __value) noexcept(true)
    __attribute__((__const__));

extern long double dreml(long double __x, long double __y) noexcept(true);
extern long double __dreml(long double __x, long double __y) noexcept(true);

extern long double significandl(long double __x) noexcept(true);
extern long double __significandl(long double __x) noexcept(true);

extern long double copysignl(long double __x, long double __y) noexcept(true)
    __attribute__((__const__));
extern long double __copysignl(long double __x, long double __y) noexcept(true)
    __attribute__((__const__));

extern long double nanl(const char *__tagb) noexcept(true);
extern long double __nanl(const char *__tagb) noexcept(true);
# 213 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl(long double __value) noexcept(true)
    __attribute__((__const__));

extern long double j0l(long double) noexcept(true);
extern long double __j0l(long double) noexcept(true);
extern long double j1l(long double) noexcept(true);
extern long double __j1l(long double) noexcept(true);
extern long double jnl(int, long double) noexcept(true);
extern long double __jnl(int, long double) noexcept(true);
extern long double y0l(long double) noexcept(true);
extern long double __y0l(long double) noexcept(true);
extern long double y1l(long double) noexcept(true);
extern long double __y1l(long double) noexcept(true);
extern long double ynl(int, long double) noexcept(true);
extern long double __ynl(int, long double) noexcept(true);

extern long double erfl(long double) noexcept(true);
extern long double __erfl(long double) noexcept(true);
extern long double erfcl(long double) noexcept(true);
extern long double __erfcl(long double) noexcept(true);
extern long double lgammal(long double) noexcept(true);
extern long double __lgammal(long double) noexcept(true);

extern long double tgammal(long double) noexcept(true);
extern long double __tgammal(long double) noexcept(true);

extern long double gammal(long double) noexcept(true);
extern long double __gammal(long double) noexcept(true);

extern long double lgammal_r(long double, int *__signgamp) noexcept(true);
extern long double __lgammal_r(long double, int *__signgamp) noexcept(true);

extern long double rintl(long double __x) noexcept(true);
extern long double __rintl(long double __x) noexcept(true);

extern long double nextafterl(long double __x, long double __y) noexcept(true);
extern long double __nextafterl(long double __x,
                                long double __y) noexcept(true);

extern long double nexttowardl(long double __x, long double __y) noexcept(true);
extern long double __nexttowardl(long double __x,
                                 long double __y) noexcept(true);

extern long double nextdownl(long double __x) noexcept(true);
extern long double __nextdownl(long double __x) noexcept(true);

extern long double nextupl(long double __x) noexcept(true);
extern long double __nextupl(long double __x) noexcept(true);

extern long double remainderl(long double __x, long double __y) noexcept(true);
extern long double __remainderl(long double __x,
                                long double __y) noexcept(true);

extern long double scalbnl(long double __x, int __n) noexcept(true);
extern long double __scalbnl(long double __x, int __n) noexcept(true);

extern int ilogbl(long double __x) noexcept(true);
extern int __ilogbl(long double __x) noexcept(true);

extern long int llogbl(long double __x) noexcept(true);
extern long int __llogbl(long double __x) noexcept(true);

extern long double scalblnl(long double __x, long int __n) noexcept(true);
extern long double __scalblnl(long double __x, long int __n) noexcept(true);

extern long double nearbyintl(long double __x) noexcept(true);
extern long double __nearbyintl(long double __x) noexcept(true);

extern long double roundl(long double __x) noexcept(true)
    __attribute__((__const__));
extern long double __roundl(long double __x) noexcept(true)
    __attribute__((__const__));

extern long double truncl(long double __x) noexcept(true)
    __attribute__((__const__));
extern long double __truncl(long double __x) noexcept(true)
    __attribute__((__const__));

extern long double remquol(long double __x, long double __y,
                           int *__quo) noexcept(true);
extern long double __remquol(long double __x, long double __y,
                             int *__quo) noexcept(true);

extern long int lrintl(long double __x) noexcept(true);
extern long int __lrintl(long double __x) noexcept(true);
__extension__ extern long long int llrintl(long double __x) noexcept(true);
extern long long int __llrintl(long double __x) noexcept(true);

extern long int lroundl(long double __x) noexcept(true);
extern long int __lroundl(long double __x) noexcept(true);
__extension__ extern long long int llroundl(long double __x) noexcept(true);
extern long long int __llroundl(long double __x) noexcept(true);

extern long double fdiml(long double __x, long double __y) noexcept(true);
extern long double __fdiml(long double __x, long double __y) noexcept(true);

extern long double fmaxl(long double __x, long double __y) noexcept(true)
    __attribute__((__const__));
extern long double __fmaxl(long double __x, long double __y) noexcept(true)
    __attribute__((__const__));

extern long double fminl(long double __x, long double __y) noexcept(true)
    __attribute__((__const__));
extern long double __fminl(long double __x, long double __y) noexcept(true)
    __attribute__((__const__));

extern long double fmal(long double __x, long double __y,
                        long double __z) noexcept(true);
extern long double __fmal(long double __x, long double __y,
                          long double __z) noexcept(true);

extern long double roundevenl(long double __x) noexcept(true)
    __attribute__((__const__));
extern long double __roundevenl(long double __x) noexcept(true)
    __attribute__((__const__));

extern __intmax_t fromfpl(long double __x, int __round,
                          unsigned int __width) noexcept(true);
extern __intmax_t __fromfpl(long double __x, int __round,
                            unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpl(long double __x, int __round,
                            unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpl(long double __x, int __round,
                              unsigned int __width) noexcept(true);

extern __intmax_t fromfpxl(long double __x, int __round,
                           unsigned int __width) noexcept(true);
extern __intmax_t __fromfpxl(long double __x, int __round,
                             unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpxl(long double __x, int __round,
                             unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpxl(long double __x, int __round,
                               unsigned int __width) noexcept(true);

extern int canonicalizel(long double *__cx,
                         const long double *__x) noexcept(true);

extern long double fmaxmagl(long double __x, long double __y) noexcept(true)
    __attribute__((__const__));
extern long double __fmaxmagl(long double __x, long double __y) noexcept(true)
    __attribute__((__const__));

extern long double fminmagl(long double __x, long double __y) noexcept(true)
    __attribute__((__const__));
extern long double __fminmagl(long double __x, long double __y) noexcept(true)
    __attribute__((__const__));

extern long double fmaximuml(long double __x, long double __y) noexcept(true)
    __attribute__((__const__));
extern long double __fmaximuml(long double __x, long double __y) noexcept(true)
    __attribute__((__const__));

extern long double fminimuml(long double __x, long double __y) noexcept(true)
    __attribute__((__const__));
extern long double __fminimuml(long double __x, long double __y) noexcept(true)
    __attribute__((__const__));

extern long double fmaximum_numl(long double __x,
                                 long double __y) noexcept(true)
    __attribute__((__const__));
extern long double __fmaximum_numl(long double __x,
                                   long double __y) noexcept(true)
    __attribute__((__const__));

extern long double fminimum_numl(long double __x,
                                 long double __y) noexcept(true)
    __attribute__((__const__));
extern long double __fminimum_numl(long double __x,
                                   long double __y) noexcept(true)
    __attribute__((__const__));

extern long double fmaximum_magl(long double __x,
                                 long double __y) noexcept(true)
    __attribute__((__const__));
extern long double __fmaximum_magl(long double __x,
                                   long double __y) noexcept(true)
    __attribute__((__const__));

extern long double fminimum_magl(long double __x,
                                 long double __y) noexcept(true)
    __attribute__((__const__));
extern long double __fminimum_magl(long double __x,
                                   long double __y) noexcept(true)
    __attribute__((__const__));

extern long double fmaximum_mag_numl(long double __x,
                                     long double __y) noexcept(true)
    __attribute__((__const__));
extern long double __fmaximum_mag_numl(long double __x,
                                       long double __y) noexcept(true)
    __attribute__((__const__));

extern long double fminimum_mag_numl(long double __x,
                                     long double __y) noexcept(true)
    __attribute__((__const__));
extern long double __fminimum_mag_numl(long double __x,
                                       long double __y) noexcept(true)
    __attribute__((__const__));

extern int totalorderl(const long double *__x,
                       const long double *__y) noexcept(true)

    __attribute__((__pure__));

extern int totalordermagl(const long double *__x,
                          const long double *__y) noexcept(true)

    __attribute__((__pure__));

extern long double getpayloadl(const long double *__x) noexcept(true);
extern long double __getpayloadl(const long double *__x) noexcept(true);

extern int setpayloadl(long double *__x, long double __payload) noexcept(true);

extern int setpayloadsigl(long double *__x,
                          long double __payload) noexcept(true);

extern long double scalbl(long double __x, long double __n) noexcept(true);
extern long double __scalbl(long double __x, long double __n) noexcept(true);
# 400 "/usr/include/math.h" 2 3 4
# 450 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 acosf32(_Float32 __x) noexcept(true);
extern _Float32 __acosf32(_Float32 __x) noexcept(true);

extern _Float32 asinf32(_Float32 __x) noexcept(true);
extern _Float32 __asinf32(_Float32 __x) noexcept(true);

extern _Float32 atanf32(_Float32 __x) noexcept(true);
extern _Float32 __atanf32(_Float32 __x) noexcept(true);

extern _Float32 atan2f32(_Float32 __y, _Float32 __x) noexcept(true);
extern _Float32 __atan2f32(_Float32 __y, _Float32 __x) noexcept(true);

extern _Float32 cosf32(_Float32 __x) noexcept(true);
extern _Float32 __cosf32(_Float32 __x) noexcept(true);

extern _Float32 sinf32(_Float32 __x) noexcept(true);
extern _Float32 __sinf32(_Float32 __x) noexcept(true);

extern _Float32 tanf32(_Float32 __x) noexcept(true);
extern _Float32 __tanf32(_Float32 __x) noexcept(true);

extern _Float32 coshf32(_Float32 __x) noexcept(true);
extern _Float32 __coshf32(_Float32 __x) noexcept(true);

extern _Float32 sinhf32(_Float32 __x) noexcept(true);
extern _Float32 __sinhf32(_Float32 __x) noexcept(true);

extern _Float32 tanhf32(_Float32 __x) noexcept(true);
extern _Float32 __tanhf32(_Float32 __x) noexcept(true);

extern void sincosf32(_Float32 __x, _Float32 *__sinx,
                      _Float32 *__cosx) noexcept(true);
extern void __sincosf32(_Float32 __x, _Float32 *__sinx,
                        _Float32 *__cosx) noexcept(true);

extern _Float32 acoshf32(_Float32 __x) noexcept(true);
extern _Float32 __acoshf32(_Float32 __x) noexcept(true);

extern _Float32 asinhf32(_Float32 __x) noexcept(true);
extern _Float32 __asinhf32(_Float32 __x) noexcept(true);

extern _Float32 atanhf32(_Float32 __x) noexcept(true);
extern _Float32 __atanhf32(_Float32 __x) noexcept(true);

extern _Float32 expf32(_Float32 __x) noexcept(true);
extern _Float32 __expf32(_Float32 __x) noexcept(true);

extern _Float32 frexpf32(_Float32 __x, int *__exponent) noexcept(true);
extern _Float32 __frexpf32(_Float32 __x, int *__exponent) noexcept(true);

extern _Float32 ldexpf32(_Float32 __x, int __exponent) noexcept(true);
extern _Float32 __ldexpf32(_Float32 __x, int __exponent) noexcept(true);

extern _Float32 logf32(_Float32 __x) noexcept(true);
extern _Float32 __logf32(_Float32 __x) noexcept(true);

extern _Float32 log10f32(_Float32 __x) noexcept(true);
extern _Float32 __log10f32(_Float32 __x) noexcept(true);

extern _Float32 modff32(_Float32 __x, _Float32 *__iptr) noexcept(true);
extern _Float32 __modff32(_Float32 __x, _Float32 *__iptr) noexcept(true)
    __attribute__((__nonnull__(2)));

extern _Float32 exp10f32(_Float32 __x) noexcept(true);
extern _Float32 __exp10f32(_Float32 __x) noexcept(true);

extern _Float32 expm1f32(_Float32 __x) noexcept(true);
extern _Float32 __expm1f32(_Float32 __x) noexcept(true);

extern _Float32 log1pf32(_Float32 __x) noexcept(true);
extern _Float32 __log1pf32(_Float32 __x) noexcept(true);

extern _Float32 logbf32(_Float32 __x) noexcept(true);
extern _Float32 __logbf32(_Float32 __x) noexcept(true);

extern _Float32 exp2f32(_Float32 __x) noexcept(true);
extern _Float32 __exp2f32(_Float32 __x) noexcept(true);

extern _Float32 log2f32(_Float32 __x) noexcept(true);
extern _Float32 __log2f32(_Float32 __x) noexcept(true);

extern _Float32 powf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __powf32(_Float32 __x, _Float32 __y) noexcept(true);

extern _Float32 sqrtf32(_Float32 __x) noexcept(true);
extern _Float32 __sqrtf32(_Float32 __x) noexcept(true);

extern _Float32 hypotf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __hypotf32(_Float32 __x, _Float32 __y) noexcept(true);

extern _Float32 cbrtf32(_Float32 __x) noexcept(true);
extern _Float32 __cbrtf32(_Float32 __x) noexcept(true);

extern _Float32 ceilf32(_Float32 __x) noexcept(true) __attribute__((__const__));
extern _Float32 __ceilf32(_Float32 __x) noexcept(true)
    __attribute__((__const__));

extern _Float32 fabsf32(_Float32 __x) noexcept(true) __attribute__((__const__));
extern _Float32 __fabsf32(_Float32 __x) noexcept(true)
    __attribute__((__const__));

extern _Float32 floorf32(_Float32 __x) noexcept(true)
    __attribute__((__const__));
extern _Float32 __floorf32(_Float32 __x) noexcept(true)
    __attribute__((__const__));

extern _Float32 fmodf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __fmodf32(_Float32 __x, _Float32 __y) noexcept(true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 copysignf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));
extern _Float32 __copysignf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));

extern _Float32 nanf32(const char *__tagb) noexcept(true);
extern _Float32 __nanf32(const char *__tagb) noexcept(true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 j0f32(_Float32) noexcept(true);
extern _Float32 __j0f32(_Float32) noexcept(true);
extern _Float32 j1f32(_Float32) noexcept(true);
extern _Float32 __j1f32(_Float32) noexcept(true);
extern _Float32 jnf32(int, _Float32) noexcept(true);
extern _Float32 __jnf32(int, _Float32) noexcept(true);
extern _Float32 y0f32(_Float32) noexcept(true);
extern _Float32 __y0f32(_Float32) noexcept(true);
extern _Float32 y1f32(_Float32) noexcept(true);
extern _Float32 __y1f32(_Float32) noexcept(true);
extern _Float32 ynf32(int, _Float32) noexcept(true);
extern _Float32 __ynf32(int, _Float32) noexcept(true);

extern _Float32 erff32(_Float32) noexcept(true);
extern _Float32 __erff32(_Float32) noexcept(true);
extern _Float32 erfcf32(_Float32) noexcept(true);
extern _Float32 __erfcf32(_Float32) noexcept(true);
extern _Float32 lgammaf32(_Float32) noexcept(true);
extern _Float32 __lgammaf32(_Float32) noexcept(true);

extern _Float32 tgammaf32(_Float32) noexcept(true);
extern _Float32 __tgammaf32(_Float32) noexcept(true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r(_Float32, int *__signgamp) noexcept(true);
extern _Float32 __lgammaf32_r(_Float32, int *__signgamp) noexcept(true);

extern _Float32 rintf32(_Float32 __x) noexcept(true);
extern _Float32 __rintf32(_Float32 __x) noexcept(true);

extern _Float32 nextafterf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __nextafterf32(_Float32 __x, _Float32 __y) noexcept(true);

extern _Float32 nextdownf32(_Float32 __x) noexcept(true);
extern _Float32 __nextdownf32(_Float32 __x) noexcept(true);

extern _Float32 nextupf32(_Float32 __x) noexcept(true);
extern _Float32 __nextupf32(_Float32 __x) noexcept(true);

extern _Float32 remainderf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __remainderf32(_Float32 __x, _Float32 __y) noexcept(true);

extern _Float32 scalbnf32(_Float32 __x, int __n) noexcept(true);
extern _Float32 __scalbnf32(_Float32 __x, int __n) noexcept(true);

extern int ilogbf32(_Float32 __x) noexcept(true);
extern int __ilogbf32(_Float32 __x) noexcept(true);

extern long int llogbf32(_Float32 __x) noexcept(true);
extern long int __llogbf32(_Float32 __x) noexcept(true);

extern _Float32 scalblnf32(_Float32 __x, long int __n) noexcept(true);
extern _Float32 __scalblnf32(_Float32 __x, long int __n) noexcept(true);

extern _Float32 nearbyintf32(_Float32 __x) noexcept(true);
extern _Float32 __nearbyintf32(_Float32 __x) noexcept(true);

extern _Float32 roundf32(_Float32 __x) noexcept(true)
    __attribute__((__const__));
extern _Float32 __roundf32(_Float32 __x) noexcept(true)
    __attribute__((__const__));

extern _Float32 truncf32(_Float32 __x) noexcept(true)
    __attribute__((__const__));
extern _Float32 __truncf32(_Float32 __x) noexcept(true)
    __attribute__((__const__));

extern _Float32 remquof32(_Float32 __x, _Float32 __y,
                          int *__quo) noexcept(true);
extern _Float32 __remquof32(_Float32 __x, _Float32 __y,
                            int *__quo) noexcept(true);

extern long int lrintf32(_Float32 __x) noexcept(true);
extern long int __lrintf32(_Float32 __x) noexcept(true);
__extension__ extern long long int llrintf32(_Float32 __x) noexcept(true);
extern long long int __llrintf32(_Float32 __x) noexcept(true);

extern long int lroundf32(_Float32 __x) noexcept(true);
extern long int __lroundf32(_Float32 __x) noexcept(true);
__extension__ extern long long int llroundf32(_Float32 __x) noexcept(true);
extern long long int __llroundf32(_Float32 __x) noexcept(true);

extern _Float32 fdimf32(_Float32 __x, _Float32 __y) noexcept(true);
extern _Float32 __fdimf32(_Float32 __x, _Float32 __y) noexcept(true);

extern _Float32 fmaxf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));
extern _Float32 __fmaxf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));

extern _Float32 fminf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));
extern _Float32 __fminf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));

extern _Float32 fmaf32(_Float32 __x, _Float32 __y, _Float32 __z) noexcept(true);
extern _Float32 __fmaf32(_Float32 __x, _Float32 __y,
                         _Float32 __z) noexcept(true);

extern _Float32 roundevenf32(_Float32 __x) noexcept(true)
    __attribute__((__const__));
extern _Float32 __roundevenf32(_Float32 __x) noexcept(true)
    __attribute__((__const__));

extern __intmax_t fromfpf32(_Float32 __x, int __round,
                            unsigned int __width) noexcept(true);
extern __intmax_t __fromfpf32(_Float32 __x, int __round,
                              unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpf32(_Float32 __x, int __round,
                              unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpf32(_Float32 __x, int __round,
                                unsigned int __width) noexcept(true);

extern __intmax_t fromfpxf32(_Float32 __x, int __round,
                             unsigned int __width) noexcept(true);
extern __intmax_t __fromfpxf32(_Float32 __x, int __round,
                               unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpxf32(_Float32 __x, int __round,
                               unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpxf32(_Float32 __x, int __round,
                                 unsigned int __width) noexcept(true);

extern int canonicalizef32(_Float32 *__cx, const _Float32 *__x) noexcept(true);

extern _Float32 fmaxmagf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));
extern _Float32 __fmaxmagf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));

extern _Float32 fminmagf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));
extern _Float32 __fminmagf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));

extern _Float32 fmaximumf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));
extern _Float32 __fmaximumf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));

extern _Float32 fminimumf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));
extern _Float32 __fminimumf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));

extern _Float32 fmaximum_numf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));
extern _Float32 __fmaximum_numf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));

extern _Float32 fminimum_numf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));
extern _Float32 __fminimum_numf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));

extern _Float32 fmaximum_magf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));
extern _Float32 __fmaximum_magf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));

extern _Float32 fminimum_magf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));
extern _Float32 __fminimum_magf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));

extern _Float32 fmaximum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));
extern _Float32 __fmaximum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));

extern _Float32 fminimum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));
extern _Float32 __fminimum_mag_numf32(_Float32 __x, _Float32 __y) noexcept(true)
    __attribute__((__const__));

extern int totalorderf32(const _Float32 *__x,
                         const _Float32 *__y) noexcept(true)

    __attribute__((__pure__));

extern int totalordermagf32(const _Float32 *__x,
                            const _Float32 *__y) noexcept(true)

    __attribute__((__pure__));

extern _Float32 getpayloadf32(const _Float32 *__x) noexcept(true);
extern _Float32 __getpayloadf32(const _Float32 *__x) noexcept(true);

extern int setpayloadf32(_Float32 *__x, _Float32 __payload) noexcept(true);

extern int setpayloadsigf32(_Float32 *__x, _Float32 __payload) noexcept(true);
# 451 "/usr/include/math.h" 2 3 4
# 467 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 acosf64(_Float64 __x) noexcept(true);
extern _Float64 __acosf64(_Float64 __x) noexcept(true);

extern _Float64 asinf64(_Float64 __x) noexcept(true);
extern _Float64 __asinf64(_Float64 __x) noexcept(true);

extern _Float64 atanf64(_Float64 __x) noexcept(true);
extern _Float64 __atanf64(_Float64 __x) noexcept(true);

extern _Float64 atan2f64(_Float64 __y, _Float64 __x) noexcept(true);
extern _Float64 __atan2f64(_Float64 __y, _Float64 __x) noexcept(true);

extern _Float64 cosf64(_Float64 __x) noexcept(true);
extern _Float64 __cosf64(_Float64 __x) noexcept(true);

extern _Float64 sinf64(_Float64 __x) noexcept(true);
extern _Float64 __sinf64(_Float64 __x) noexcept(true);

extern _Float64 tanf64(_Float64 __x) noexcept(true);
extern _Float64 __tanf64(_Float64 __x) noexcept(true);

extern _Float64 coshf64(_Float64 __x) noexcept(true);
extern _Float64 __coshf64(_Float64 __x) noexcept(true);

extern _Float64 sinhf64(_Float64 __x) noexcept(true);
extern _Float64 __sinhf64(_Float64 __x) noexcept(true);

extern _Float64 tanhf64(_Float64 __x) noexcept(true);
extern _Float64 __tanhf64(_Float64 __x) noexcept(true);

extern void sincosf64(_Float64 __x, _Float64 *__sinx,
                      _Float64 *__cosx) noexcept(true);
extern void __sincosf64(_Float64 __x, _Float64 *__sinx,
                        _Float64 *__cosx) noexcept(true);

extern _Float64 acoshf64(_Float64 __x) noexcept(true);
extern _Float64 __acoshf64(_Float64 __x) noexcept(true);

extern _Float64 asinhf64(_Float64 __x) noexcept(true);
extern _Float64 __asinhf64(_Float64 __x) noexcept(true);

extern _Float64 atanhf64(_Float64 __x) noexcept(true);
extern _Float64 __atanhf64(_Float64 __x) noexcept(true);

extern _Float64 expf64(_Float64 __x) noexcept(true);
extern _Float64 __expf64(_Float64 __x) noexcept(true);

extern _Float64 frexpf64(_Float64 __x, int *__exponent) noexcept(true);
extern _Float64 __frexpf64(_Float64 __x, int *__exponent) noexcept(true);

extern _Float64 ldexpf64(_Float64 __x, int __exponent) noexcept(true);
extern _Float64 __ldexpf64(_Float64 __x, int __exponent) noexcept(true);

extern _Float64 logf64(_Float64 __x) noexcept(true);
extern _Float64 __logf64(_Float64 __x) noexcept(true);

extern _Float64 log10f64(_Float64 __x) noexcept(true);
extern _Float64 __log10f64(_Float64 __x) noexcept(true);

extern _Float64 modff64(_Float64 __x, _Float64 *__iptr) noexcept(true);
extern _Float64 __modff64(_Float64 __x, _Float64 *__iptr) noexcept(true)
    __attribute__((__nonnull__(2)));

extern _Float64 exp10f64(_Float64 __x) noexcept(true);
extern _Float64 __exp10f64(_Float64 __x) noexcept(true);

extern _Float64 expm1f64(_Float64 __x) noexcept(true);
extern _Float64 __expm1f64(_Float64 __x) noexcept(true);

extern _Float64 log1pf64(_Float64 __x) noexcept(true);
extern _Float64 __log1pf64(_Float64 __x) noexcept(true);

extern _Float64 logbf64(_Float64 __x) noexcept(true);
extern _Float64 __logbf64(_Float64 __x) noexcept(true);

extern _Float64 exp2f64(_Float64 __x) noexcept(true);
extern _Float64 __exp2f64(_Float64 __x) noexcept(true);

extern _Float64 log2f64(_Float64 __x) noexcept(true);
extern _Float64 __log2f64(_Float64 __x) noexcept(true);

extern _Float64 powf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __powf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float64 sqrtf64(_Float64 __x) noexcept(true);
extern _Float64 __sqrtf64(_Float64 __x) noexcept(true);

extern _Float64 hypotf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __hypotf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float64 cbrtf64(_Float64 __x) noexcept(true);
extern _Float64 __cbrtf64(_Float64 __x) noexcept(true);

extern _Float64 ceilf64(_Float64 __x) noexcept(true) __attribute__((__const__));
extern _Float64 __ceilf64(_Float64 __x) noexcept(true)
    __attribute__((__const__));

extern _Float64 fabsf64(_Float64 __x) noexcept(true) __attribute__((__const__));
extern _Float64 __fabsf64(_Float64 __x) noexcept(true)
    __attribute__((__const__));

extern _Float64 floorf64(_Float64 __x) noexcept(true)
    __attribute__((__const__));
extern _Float64 __floorf64(_Float64 __x) noexcept(true)
    __attribute__((__const__));

extern _Float64 fmodf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __fmodf64(_Float64 __x, _Float64 __y) noexcept(true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 copysignf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));
extern _Float64 __copysignf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));

extern _Float64 nanf64(const char *__tagb) noexcept(true);
extern _Float64 __nanf64(const char *__tagb) noexcept(true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 j0f64(_Float64) noexcept(true);
extern _Float64 __j0f64(_Float64) noexcept(true);
extern _Float64 j1f64(_Float64) noexcept(true);
extern _Float64 __j1f64(_Float64) noexcept(true);
extern _Float64 jnf64(int, _Float64) noexcept(true);
extern _Float64 __jnf64(int, _Float64) noexcept(true);
extern _Float64 y0f64(_Float64) noexcept(true);
extern _Float64 __y0f64(_Float64) noexcept(true);
extern _Float64 y1f64(_Float64) noexcept(true);
extern _Float64 __y1f64(_Float64) noexcept(true);
extern _Float64 ynf64(int, _Float64) noexcept(true);
extern _Float64 __ynf64(int, _Float64) noexcept(true);

extern _Float64 erff64(_Float64) noexcept(true);
extern _Float64 __erff64(_Float64) noexcept(true);
extern _Float64 erfcf64(_Float64) noexcept(true);
extern _Float64 __erfcf64(_Float64) noexcept(true);
extern _Float64 lgammaf64(_Float64) noexcept(true);
extern _Float64 __lgammaf64(_Float64) noexcept(true);

extern _Float64 tgammaf64(_Float64) noexcept(true);
extern _Float64 __tgammaf64(_Float64) noexcept(true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r(_Float64, int *__signgamp) noexcept(true);
extern _Float64 __lgammaf64_r(_Float64, int *__signgamp) noexcept(true);

extern _Float64 rintf64(_Float64 __x) noexcept(true);
extern _Float64 __rintf64(_Float64 __x) noexcept(true);

extern _Float64 nextafterf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __nextafterf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float64 nextdownf64(_Float64 __x) noexcept(true);
extern _Float64 __nextdownf64(_Float64 __x) noexcept(true);

extern _Float64 nextupf64(_Float64 __x) noexcept(true);
extern _Float64 __nextupf64(_Float64 __x) noexcept(true);

extern _Float64 remainderf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __remainderf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float64 scalbnf64(_Float64 __x, int __n) noexcept(true);
extern _Float64 __scalbnf64(_Float64 __x, int __n) noexcept(true);

extern int ilogbf64(_Float64 __x) noexcept(true);
extern int __ilogbf64(_Float64 __x) noexcept(true);

extern long int llogbf64(_Float64 __x) noexcept(true);
extern long int __llogbf64(_Float64 __x) noexcept(true);

extern _Float64 scalblnf64(_Float64 __x, long int __n) noexcept(true);
extern _Float64 __scalblnf64(_Float64 __x, long int __n) noexcept(true);

extern _Float64 nearbyintf64(_Float64 __x) noexcept(true);
extern _Float64 __nearbyintf64(_Float64 __x) noexcept(true);

extern _Float64 roundf64(_Float64 __x) noexcept(true)
    __attribute__((__const__));
extern _Float64 __roundf64(_Float64 __x) noexcept(true)
    __attribute__((__const__));

extern _Float64 truncf64(_Float64 __x) noexcept(true)
    __attribute__((__const__));
extern _Float64 __truncf64(_Float64 __x) noexcept(true)
    __attribute__((__const__));

extern _Float64 remquof64(_Float64 __x, _Float64 __y,
                          int *__quo) noexcept(true);
extern _Float64 __remquof64(_Float64 __x, _Float64 __y,
                            int *__quo) noexcept(true);

extern long int lrintf64(_Float64 __x) noexcept(true);
extern long int __lrintf64(_Float64 __x) noexcept(true);
__extension__ extern long long int llrintf64(_Float64 __x) noexcept(true);
extern long long int __llrintf64(_Float64 __x) noexcept(true);

extern long int lroundf64(_Float64 __x) noexcept(true);
extern long int __lroundf64(_Float64 __x) noexcept(true);
__extension__ extern long long int llroundf64(_Float64 __x) noexcept(true);
extern long long int __llroundf64(_Float64 __x) noexcept(true);

extern _Float64 fdimf64(_Float64 __x, _Float64 __y) noexcept(true);
extern _Float64 __fdimf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float64 fmaxf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));
extern _Float64 __fmaxf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));

extern _Float64 fminf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));
extern _Float64 __fminf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));

extern _Float64 fmaf64(_Float64 __x, _Float64 __y, _Float64 __z) noexcept(true);
extern _Float64 __fmaf64(_Float64 __x, _Float64 __y,
                         _Float64 __z) noexcept(true);

extern _Float64 roundevenf64(_Float64 __x) noexcept(true)
    __attribute__((__const__));
extern _Float64 __roundevenf64(_Float64 __x) noexcept(true)
    __attribute__((__const__));

extern __intmax_t fromfpf64(_Float64 __x, int __round,
                            unsigned int __width) noexcept(true);
extern __intmax_t __fromfpf64(_Float64 __x, int __round,
                              unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpf64(_Float64 __x, int __round,
                              unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpf64(_Float64 __x, int __round,
                                unsigned int __width) noexcept(true);

extern __intmax_t fromfpxf64(_Float64 __x, int __round,
                             unsigned int __width) noexcept(true);
extern __intmax_t __fromfpxf64(_Float64 __x, int __round,
                               unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpxf64(_Float64 __x, int __round,
                               unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpxf64(_Float64 __x, int __round,
                                 unsigned int __width) noexcept(true);

extern int canonicalizef64(_Float64 *__cx, const _Float64 *__x) noexcept(true);

extern _Float64 fmaxmagf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));
extern _Float64 __fmaxmagf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));

extern _Float64 fminmagf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));
extern _Float64 __fminmagf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));

extern _Float64 fmaximumf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));
extern _Float64 __fmaximumf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));

extern _Float64 fminimumf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));
extern _Float64 __fminimumf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));

extern _Float64 fmaximum_numf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));
extern _Float64 __fmaximum_numf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));

extern _Float64 fminimum_numf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));
extern _Float64 __fminimum_numf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));

extern _Float64 fmaximum_magf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));
extern _Float64 __fmaximum_magf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));

extern _Float64 fminimum_magf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));
extern _Float64 __fminimum_magf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));

extern _Float64 fmaximum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));
extern _Float64 __fmaximum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));

extern _Float64 fminimum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));
extern _Float64 __fminimum_mag_numf64(_Float64 __x, _Float64 __y) noexcept(true)
    __attribute__((__const__));

extern int totalorderf64(const _Float64 *__x,
                         const _Float64 *__y) noexcept(true)

    __attribute__((__pure__));

extern int totalordermagf64(const _Float64 *__x,
                            const _Float64 *__y) noexcept(true)

    __attribute__((__pure__));

extern _Float64 getpayloadf64(const _Float64 *__x) noexcept(true);
extern _Float64 __getpayloadf64(const _Float64 *__x) noexcept(true);

extern int setpayloadf64(_Float64 *__x, _Float64 __payload) noexcept(true);

extern int setpayloadsigf64(_Float64 *__x, _Float64 __payload) noexcept(true);
# 468 "/usr/include/math.h" 2 3 4
# 501 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x acosf32x(_Float32x __x) noexcept(true);
extern _Float32x __acosf32x(_Float32x __x) noexcept(true);

extern _Float32x asinf32x(_Float32x __x) noexcept(true);
extern _Float32x __asinf32x(_Float32x __x) noexcept(true);

extern _Float32x atanf32x(_Float32x __x) noexcept(true);
extern _Float32x __atanf32x(_Float32x __x) noexcept(true);

extern _Float32x atan2f32x(_Float32x __y, _Float32x __x) noexcept(true);
extern _Float32x __atan2f32x(_Float32x __y, _Float32x __x) noexcept(true);

extern _Float32x cosf32x(_Float32x __x) noexcept(true);
extern _Float32x __cosf32x(_Float32x __x) noexcept(true);

extern _Float32x sinf32x(_Float32x __x) noexcept(true);
extern _Float32x __sinf32x(_Float32x __x) noexcept(true);

extern _Float32x tanf32x(_Float32x __x) noexcept(true);
extern _Float32x __tanf32x(_Float32x __x) noexcept(true);

extern _Float32x coshf32x(_Float32x __x) noexcept(true);
extern _Float32x __coshf32x(_Float32x __x) noexcept(true);

extern _Float32x sinhf32x(_Float32x __x) noexcept(true);
extern _Float32x __sinhf32x(_Float32x __x) noexcept(true);

extern _Float32x tanhf32x(_Float32x __x) noexcept(true);
extern _Float32x __tanhf32x(_Float32x __x) noexcept(true);

extern void sincosf32x(_Float32x __x, _Float32x *__sinx,
                       _Float32x *__cosx) noexcept(true);
extern void __sincosf32x(_Float32x __x, _Float32x *__sinx,
                         _Float32x *__cosx) noexcept(true);

extern _Float32x acoshf32x(_Float32x __x) noexcept(true);
extern _Float32x __acoshf32x(_Float32x __x) noexcept(true);

extern _Float32x asinhf32x(_Float32x __x) noexcept(true);
extern _Float32x __asinhf32x(_Float32x __x) noexcept(true);

extern _Float32x atanhf32x(_Float32x __x) noexcept(true);
extern _Float32x __atanhf32x(_Float32x __x) noexcept(true);

extern _Float32x expf32x(_Float32x __x) noexcept(true);
extern _Float32x __expf32x(_Float32x __x) noexcept(true);

extern _Float32x frexpf32x(_Float32x __x, int *__exponent) noexcept(true);
extern _Float32x __frexpf32x(_Float32x __x, int *__exponent) noexcept(true);

extern _Float32x ldexpf32x(_Float32x __x, int __exponent) noexcept(true);
extern _Float32x __ldexpf32x(_Float32x __x, int __exponent) noexcept(true);

extern _Float32x logf32x(_Float32x __x) noexcept(true);
extern _Float32x __logf32x(_Float32x __x) noexcept(true);

extern _Float32x log10f32x(_Float32x __x) noexcept(true);
extern _Float32x __log10f32x(_Float32x __x) noexcept(true);

extern _Float32x modff32x(_Float32x __x, _Float32x *__iptr) noexcept(true);
extern _Float32x __modff32x(_Float32x __x, _Float32x *__iptr) noexcept(true)
    __attribute__((__nonnull__(2)));

extern _Float32x exp10f32x(_Float32x __x) noexcept(true);
extern _Float32x __exp10f32x(_Float32x __x) noexcept(true);

extern _Float32x expm1f32x(_Float32x __x) noexcept(true);
extern _Float32x __expm1f32x(_Float32x __x) noexcept(true);

extern _Float32x log1pf32x(_Float32x __x) noexcept(true);
extern _Float32x __log1pf32x(_Float32x __x) noexcept(true);

extern _Float32x logbf32x(_Float32x __x) noexcept(true);
extern _Float32x __logbf32x(_Float32x __x) noexcept(true);

extern _Float32x exp2f32x(_Float32x __x) noexcept(true);
extern _Float32x __exp2f32x(_Float32x __x) noexcept(true);

extern _Float32x log2f32x(_Float32x __x) noexcept(true);
extern _Float32x __log2f32x(_Float32x __x) noexcept(true);

extern _Float32x powf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __powf32x(_Float32x __x, _Float32x __y) noexcept(true);

extern _Float32x sqrtf32x(_Float32x __x) noexcept(true);
extern _Float32x __sqrtf32x(_Float32x __x) noexcept(true);

extern _Float32x hypotf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __hypotf32x(_Float32x __x, _Float32x __y) noexcept(true);

extern _Float32x cbrtf32x(_Float32x __x) noexcept(true);
extern _Float32x __cbrtf32x(_Float32x __x) noexcept(true);

extern _Float32x ceilf32x(_Float32x __x) noexcept(true)
    __attribute__((__const__));
extern _Float32x __ceilf32x(_Float32x __x) noexcept(true)
    __attribute__((__const__));

extern _Float32x fabsf32x(_Float32x __x) noexcept(true)
    __attribute__((__const__));
extern _Float32x __fabsf32x(_Float32x __x) noexcept(true)
    __attribute__((__const__));

extern _Float32x floorf32x(_Float32x __x) noexcept(true)
    __attribute__((__const__));
extern _Float32x __floorf32x(_Float32x __x) noexcept(true)
    __attribute__((__const__));

extern _Float32x fmodf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __fmodf32x(_Float32x __x, _Float32x __y) noexcept(true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));
extern _Float32x __copysignf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));

extern _Float32x nanf32x(const char *__tagb) noexcept(true);
extern _Float32x __nanf32x(const char *__tagb) noexcept(true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x j0f32x(_Float32x) noexcept(true);
extern _Float32x __j0f32x(_Float32x) noexcept(true);
extern _Float32x j1f32x(_Float32x) noexcept(true);
extern _Float32x __j1f32x(_Float32x) noexcept(true);
extern _Float32x jnf32x(int, _Float32x) noexcept(true);
extern _Float32x __jnf32x(int, _Float32x) noexcept(true);
extern _Float32x y0f32x(_Float32x) noexcept(true);
extern _Float32x __y0f32x(_Float32x) noexcept(true);
extern _Float32x y1f32x(_Float32x) noexcept(true);
extern _Float32x __y1f32x(_Float32x) noexcept(true);
extern _Float32x ynf32x(int, _Float32x) noexcept(true);
extern _Float32x __ynf32x(int, _Float32x) noexcept(true);

extern _Float32x erff32x(_Float32x) noexcept(true);
extern _Float32x __erff32x(_Float32x) noexcept(true);
extern _Float32x erfcf32x(_Float32x) noexcept(true);
extern _Float32x __erfcf32x(_Float32x) noexcept(true);
extern _Float32x lgammaf32x(_Float32x) noexcept(true);
extern _Float32x __lgammaf32x(_Float32x) noexcept(true);

extern _Float32x tgammaf32x(_Float32x) noexcept(true);
extern _Float32x __tgammaf32x(_Float32x) noexcept(true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r(_Float32x, int *__signgamp) noexcept(true);
extern _Float32x __lgammaf32x_r(_Float32x, int *__signgamp) noexcept(true);

extern _Float32x rintf32x(_Float32x __x) noexcept(true);
extern _Float32x __rintf32x(_Float32x __x) noexcept(true);

extern _Float32x nextafterf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __nextafterf32x(_Float32x __x, _Float32x __y) noexcept(true);

extern _Float32x nextdownf32x(_Float32x __x) noexcept(true);
extern _Float32x __nextdownf32x(_Float32x __x) noexcept(true);

extern _Float32x nextupf32x(_Float32x __x) noexcept(true);
extern _Float32x __nextupf32x(_Float32x __x) noexcept(true);

extern _Float32x remainderf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __remainderf32x(_Float32x __x, _Float32x __y) noexcept(true);

extern _Float32x scalbnf32x(_Float32x __x, int __n) noexcept(true);
extern _Float32x __scalbnf32x(_Float32x __x, int __n) noexcept(true);

extern int ilogbf32x(_Float32x __x) noexcept(true);
extern int __ilogbf32x(_Float32x __x) noexcept(true);

extern long int llogbf32x(_Float32x __x) noexcept(true);
extern long int __llogbf32x(_Float32x __x) noexcept(true);

extern _Float32x scalblnf32x(_Float32x __x, long int __n) noexcept(true);
extern _Float32x __scalblnf32x(_Float32x __x, long int __n) noexcept(true);

extern _Float32x nearbyintf32x(_Float32x __x) noexcept(true);
extern _Float32x __nearbyintf32x(_Float32x __x) noexcept(true);

extern _Float32x roundf32x(_Float32x __x) noexcept(true)
    __attribute__((__const__));
extern _Float32x __roundf32x(_Float32x __x) noexcept(true)
    __attribute__((__const__));

extern _Float32x truncf32x(_Float32x __x) noexcept(true)
    __attribute__((__const__));
extern _Float32x __truncf32x(_Float32x __x) noexcept(true)
    __attribute__((__const__));

extern _Float32x remquof32x(_Float32x __x, _Float32x __y,
                            int *__quo) noexcept(true);
extern _Float32x __remquof32x(_Float32x __x, _Float32x __y,
                              int *__quo) noexcept(true);

extern long int lrintf32x(_Float32x __x) noexcept(true);
extern long int __lrintf32x(_Float32x __x) noexcept(true);
__extension__ extern long long int llrintf32x(_Float32x __x) noexcept(true);
extern long long int __llrintf32x(_Float32x __x) noexcept(true);

extern long int lroundf32x(_Float32x __x) noexcept(true);
extern long int __lroundf32x(_Float32x __x) noexcept(true);
__extension__ extern long long int llroundf32x(_Float32x __x) noexcept(true);
extern long long int __llroundf32x(_Float32x __x) noexcept(true);

extern _Float32x fdimf32x(_Float32x __x, _Float32x __y) noexcept(true);
extern _Float32x __fdimf32x(_Float32x __x, _Float32x __y) noexcept(true);

extern _Float32x fmaxf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));
extern _Float32x __fmaxf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));

extern _Float32x fminf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));
extern _Float32x __fminf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));

extern _Float32x fmaf32x(_Float32x __x, _Float32x __y,
                         _Float32x __z) noexcept(true);
extern _Float32x __fmaf32x(_Float32x __x, _Float32x __y,
                           _Float32x __z) noexcept(true);

extern _Float32x roundevenf32x(_Float32x __x) noexcept(true)
    __attribute__((__const__));
extern _Float32x __roundevenf32x(_Float32x __x) noexcept(true)
    __attribute__((__const__));

extern __intmax_t fromfpf32x(_Float32x __x, int __round,
                             unsigned int __width) noexcept(true);
extern __intmax_t __fromfpf32x(_Float32x __x, int __round,
                               unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpf32x(_Float32x __x, int __round,
                               unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpf32x(_Float32x __x, int __round,
                                 unsigned int __width) noexcept(true);

extern __intmax_t fromfpxf32x(_Float32x __x, int __round,
                              unsigned int __width) noexcept(true);
extern __intmax_t __fromfpxf32x(_Float32x __x, int __round,
                                unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpxf32x(_Float32x __x, int __round,
                                unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpxf32x(_Float32x __x, int __round,
                                  unsigned int __width) noexcept(true);

extern int canonicalizef32x(_Float32x *__cx,
                            const _Float32x *__x) noexcept(true);

extern _Float32x fmaxmagf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));
extern _Float32x __fmaxmagf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));

extern _Float32x fminmagf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));
extern _Float32x __fminmagf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));

extern _Float32x fmaximumf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));
extern _Float32x __fmaximumf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));

extern _Float32x fminimumf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));
extern _Float32x __fminimumf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));

extern _Float32x fmaximum_numf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));
extern _Float32x __fmaximum_numf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));

extern _Float32x fminimum_numf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));
extern _Float32x __fminimum_numf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));

extern _Float32x fmaximum_magf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));
extern _Float32x __fmaximum_magf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));

extern _Float32x fminimum_magf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));
extern _Float32x __fminimum_magf32x(_Float32x __x, _Float32x __y) noexcept(true)
    __attribute__((__const__));

extern _Float32x fmaximum_mag_numf32x(_Float32x __x,
                                      _Float32x __y) noexcept(true)
    __attribute__((__const__));
extern _Float32x __fmaximum_mag_numf32x(_Float32x __x,
                                        _Float32x __y) noexcept(true)
    __attribute__((__const__));

extern _Float32x fminimum_mag_numf32x(_Float32x __x,
                                      _Float32x __y) noexcept(true)
    __attribute__((__const__));
extern _Float32x __fminimum_mag_numf32x(_Float32x __x,
                                        _Float32x __y) noexcept(true)
    __attribute__((__const__));

extern int totalorderf32x(const _Float32x *__x,
                          const _Float32x *__y) noexcept(true)

    __attribute__((__pure__));

extern int totalordermagf32x(const _Float32x *__x,
                             const _Float32x *__y) noexcept(true)

    __attribute__((__pure__));

extern _Float32x getpayloadf32x(const _Float32x *__x) noexcept(true);
extern _Float32x __getpayloadf32x(const _Float32x *__x) noexcept(true);

extern int setpayloadf32x(_Float32x *__x, _Float32x __payload) noexcept(true);

extern int setpayloadsigf32x(_Float32x *__x,
                             _Float32x __payload) noexcept(true);
# 502 "/usr/include/math.h" 2 3 4
# 518 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x acosf64x(_Float64x __x) noexcept(true);
extern _Float64x __acosf64x(_Float64x __x) noexcept(true);

extern _Float64x asinf64x(_Float64x __x) noexcept(true);
extern _Float64x __asinf64x(_Float64x __x) noexcept(true);

extern _Float64x atanf64x(_Float64x __x) noexcept(true);
extern _Float64x __atanf64x(_Float64x __x) noexcept(true);

extern _Float64x atan2f64x(_Float64x __y, _Float64x __x) noexcept(true);
extern _Float64x __atan2f64x(_Float64x __y, _Float64x __x) noexcept(true);

extern _Float64x cosf64x(_Float64x __x) noexcept(true);
extern _Float64x __cosf64x(_Float64x __x) noexcept(true);

extern _Float64x sinf64x(_Float64x __x) noexcept(true);
extern _Float64x __sinf64x(_Float64x __x) noexcept(true);

extern _Float64x tanf64x(_Float64x __x) noexcept(true);
extern _Float64x __tanf64x(_Float64x __x) noexcept(true);

extern _Float64x coshf64x(_Float64x __x) noexcept(true);
extern _Float64x __coshf64x(_Float64x __x) noexcept(true);

extern _Float64x sinhf64x(_Float64x __x) noexcept(true);
extern _Float64x __sinhf64x(_Float64x __x) noexcept(true);

extern _Float64x tanhf64x(_Float64x __x) noexcept(true);
extern _Float64x __tanhf64x(_Float64x __x) noexcept(true);

extern void sincosf64x(_Float64x __x, _Float64x *__sinx,
                       _Float64x *__cosx) noexcept(true);
extern void __sincosf64x(_Float64x __x, _Float64x *__sinx,
                         _Float64x *__cosx) noexcept(true);

extern _Float64x acoshf64x(_Float64x __x) noexcept(true);
extern _Float64x __acoshf64x(_Float64x __x) noexcept(true);

extern _Float64x asinhf64x(_Float64x __x) noexcept(true);
extern _Float64x __asinhf64x(_Float64x __x) noexcept(true);

extern _Float64x atanhf64x(_Float64x __x) noexcept(true);
extern _Float64x __atanhf64x(_Float64x __x) noexcept(true);

extern _Float64x expf64x(_Float64x __x) noexcept(true);
extern _Float64x __expf64x(_Float64x __x) noexcept(true);

extern _Float64x frexpf64x(_Float64x __x, int *__exponent) noexcept(true);
extern _Float64x __frexpf64x(_Float64x __x, int *__exponent) noexcept(true);

extern _Float64x ldexpf64x(_Float64x __x, int __exponent) noexcept(true);
extern _Float64x __ldexpf64x(_Float64x __x, int __exponent) noexcept(true);

extern _Float64x logf64x(_Float64x __x) noexcept(true);
extern _Float64x __logf64x(_Float64x __x) noexcept(true);

extern _Float64x log10f64x(_Float64x __x) noexcept(true);
extern _Float64x __log10f64x(_Float64x __x) noexcept(true);

extern _Float64x modff64x(_Float64x __x, _Float64x *__iptr) noexcept(true);
extern _Float64x __modff64x(_Float64x __x, _Float64x *__iptr) noexcept(true)
    __attribute__((__nonnull__(2)));

extern _Float64x exp10f64x(_Float64x __x) noexcept(true);
extern _Float64x __exp10f64x(_Float64x __x) noexcept(true);

extern _Float64x expm1f64x(_Float64x __x) noexcept(true);
extern _Float64x __expm1f64x(_Float64x __x) noexcept(true);

extern _Float64x log1pf64x(_Float64x __x) noexcept(true);
extern _Float64x __log1pf64x(_Float64x __x) noexcept(true);

extern _Float64x logbf64x(_Float64x __x) noexcept(true);
extern _Float64x __logbf64x(_Float64x __x) noexcept(true);

extern _Float64x exp2f64x(_Float64x __x) noexcept(true);
extern _Float64x __exp2f64x(_Float64x __x) noexcept(true);

extern _Float64x log2f64x(_Float64x __x) noexcept(true);
extern _Float64x __log2f64x(_Float64x __x) noexcept(true);

extern _Float64x powf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __powf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float64x sqrtf64x(_Float64x __x) noexcept(true);
extern _Float64x __sqrtf64x(_Float64x __x) noexcept(true);

extern _Float64x hypotf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __hypotf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float64x cbrtf64x(_Float64x __x) noexcept(true);
extern _Float64x __cbrtf64x(_Float64x __x) noexcept(true);

extern _Float64x ceilf64x(_Float64x __x) noexcept(true)
    __attribute__((__const__));
extern _Float64x __ceilf64x(_Float64x __x) noexcept(true)
    __attribute__((__const__));

extern _Float64x fabsf64x(_Float64x __x) noexcept(true)
    __attribute__((__const__));
extern _Float64x __fabsf64x(_Float64x __x) noexcept(true)
    __attribute__((__const__));

extern _Float64x floorf64x(_Float64x __x) noexcept(true)
    __attribute__((__const__));
extern _Float64x __floorf64x(_Float64x __x) noexcept(true)
    __attribute__((__const__));

extern _Float64x fmodf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __fmodf64x(_Float64x __x, _Float64x __y) noexcept(true);
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));
extern _Float64x __copysignf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));

extern _Float64x nanf64x(const char *__tagb) noexcept(true);
extern _Float64x __nanf64x(const char *__tagb) noexcept(true);
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x j0f64x(_Float64x) noexcept(true);
extern _Float64x __j0f64x(_Float64x) noexcept(true);
extern _Float64x j1f64x(_Float64x) noexcept(true);
extern _Float64x __j1f64x(_Float64x) noexcept(true);
extern _Float64x jnf64x(int, _Float64x) noexcept(true);
extern _Float64x __jnf64x(int, _Float64x) noexcept(true);
extern _Float64x y0f64x(_Float64x) noexcept(true);
extern _Float64x __y0f64x(_Float64x) noexcept(true);
extern _Float64x y1f64x(_Float64x) noexcept(true);
extern _Float64x __y1f64x(_Float64x) noexcept(true);
extern _Float64x ynf64x(int, _Float64x) noexcept(true);
extern _Float64x __ynf64x(int, _Float64x) noexcept(true);

extern _Float64x erff64x(_Float64x) noexcept(true);
extern _Float64x __erff64x(_Float64x) noexcept(true);
extern _Float64x erfcf64x(_Float64x) noexcept(true);
extern _Float64x __erfcf64x(_Float64x) noexcept(true);
extern _Float64x lgammaf64x(_Float64x) noexcept(true);
extern _Float64x __lgammaf64x(_Float64x) noexcept(true);

extern _Float64x tgammaf64x(_Float64x) noexcept(true);
extern _Float64x __tgammaf64x(_Float64x) noexcept(true);
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r(_Float64x, int *__signgamp) noexcept(true);
extern _Float64x __lgammaf64x_r(_Float64x, int *__signgamp) noexcept(true);

extern _Float64x rintf64x(_Float64x __x) noexcept(true);
extern _Float64x __rintf64x(_Float64x __x) noexcept(true);

extern _Float64x nextafterf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __nextafterf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float64x nextdownf64x(_Float64x __x) noexcept(true);
extern _Float64x __nextdownf64x(_Float64x __x) noexcept(true);

extern _Float64x nextupf64x(_Float64x __x) noexcept(true);
extern _Float64x __nextupf64x(_Float64x __x) noexcept(true);

extern _Float64x remainderf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __remainderf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float64x scalbnf64x(_Float64x __x, int __n) noexcept(true);
extern _Float64x __scalbnf64x(_Float64x __x, int __n) noexcept(true);

extern int ilogbf64x(_Float64x __x) noexcept(true);
extern int __ilogbf64x(_Float64x __x) noexcept(true);

extern long int llogbf64x(_Float64x __x) noexcept(true);
extern long int __llogbf64x(_Float64x __x) noexcept(true);

extern _Float64x scalblnf64x(_Float64x __x, long int __n) noexcept(true);
extern _Float64x __scalblnf64x(_Float64x __x, long int __n) noexcept(true);

extern _Float64x nearbyintf64x(_Float64x __x) noexcept(true);
extern _Float64x __nearbyintf64x(_Float64x __x) noexcept(true);

extern _Float64x roundf64x(_Float64x __x) noexcept(true)
    __attribute__((__const__));
extern _Float64x __roundf64x(_Float64x __x) noexcept(true)
    __attribute__((__const__));

extern _Float64x truncf64x(_Float64x __x) noexcept(true)
    __attribute__((__const__));
extern _Float64x __truncf64x(_Float64x __x) noexcept(true)
    __attribute__((__const__));

extern _Float64x remquof64x(_Float64x __x, _Float64x __y,
                            int *__quo) noexcept(true);
extern _Float64x __remquof64x(_Float64x __x, _Float64x __y,
                              int *__quo) noexcept(true);

extern long int lrintf64x(_Float64x __x) noexcept(true);
extern long int __lrintf64x(_Float64x __x) noexcept(true);
__extension__ extern long long int llrintf64x(_Float64x __x) noexcept(true);
extern long long int __llrintf64x(_Float64x __x) noexcept(true);

extern long int lroundf64x(_Float64x __x) noexcept(true);
extern long int __lroundf64x(_Float64x __x) noexcept(true);
__extension__ extern long long int llroundf64x(_Float64x __x) noexcept(true);
extern long long int __llroundf64x(_Float64x __x) noexcept(true);

extern _Float64x fdimf64x(_Float64x __x, _Float64x __y) noexcept(true);
extern _Float64x __fdimf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float64x fmaxf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));
extern _Float64x __fmaxf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));

extern _Float64x fminf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));
extern _Float64x __fminf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));

extern _Float64x fmaf64x(_Float64x __x, _Float64x __y,
                         _Float64x __z) noexcept(true);
extern _Float64x __fmaf64x(_Float64x __x, _Float64x __y,
                           _Float64x __z) noexcept(true);

extern _Float64x roundevenf64x(_Float64x __x) noexcept(true)
    __attribute__((__const__));
extern _Float64x __roundevenf64x(_Float64x __x) noexcept(true)
    __attribute__((__const__));

extern __intmax_t fromfpf64x(_Float64x __x, int __round,
                             unsigned int __width) noexcept(true);
extern __intmax_t __fromfpf64x(_Float64x __x, int __round,
                               unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpf64x(_Float64x __x, int __round,
                               unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpf64x(_Float64x __x, int __round,
                                 unsigned int __width) noexcept(true);

extern __intmax_t fromfpxf64x(_Float64x __x, int __round,
                              unsigned int __width) noexcept(true);
extern __intmax_t __fromfpxf64x(_Float64x __x, int __round,
                                unsigned int __width) noexcept(true);

extern __uintmax_t ufromfpxf64x(_Float64x __x, int __round,
                                unsigned int __width) noexcept(true);
extern __uintmax_t __ufromfpxf64x(_Float64x __x, int __round,
                                  unsigned int __width) noexcept(true);

extern int canonicalizef64x(_Float64x *__cx,
                            const _Float64x *__x) noexcept(true);

extern _Float64x fmaxmagf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));
extern _Float64x __fmaxmagf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));

extern _Float64x fminmagf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));
extern _Float64x __fminmagf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));

extern _Float64x fmaximumf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));
extern _Float64x __fmaximumf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));

extern _Float64x fminimumf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));
extern _Float64x __fminimumf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));

extern _Float64x fmaximum_numf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));
extern _Float64x __fmaximum_numf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));

extern _Float64x fminimum_numf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));
extern _Float64x __fminimum_numf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));

extern _Float64x fmaximum_magf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));
extern _Float64x __fmaximum_magf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));

extern _Float64x fminimum_magf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));
extern _Float64x __fminimum_magf64x(_Float64x __x, _Float64x __y) noexcept(true)
    __attribute__((__const__));

extern _Float64x fmaximum_mag_numf64x(_Float64x __x,
                                      _Float64x __y) noexcept(true)
    __attribute__((__const__));
extern _Float64x __fmaximum_mag_numf64x(_Float64x __x,
                                        _Float64x __y) noexcept(true)
    __attribute__((__const__));

extern _Float64x fminimum_mag_numf64x(_Float64x __x,
                                      _Float64x __y) noexcept(true)
    __attribute__((__const__));
extern _Float64x __fminimum_mag_numf64x(_Float64x __x,
                                        _Float64x __y) noexcept(true)
    __attribute__((__const__));

extern int totalorderf64x(const _Float64x *__x,
                          const _Float64x *__y) noexcept(true)

    __attribute__((__pure__));

extern int totalordermagf64x(const _Float64x *__x,
                             const _Float64x *__y) noexcept(true)

    __attribute__((__pure__));

extern _Float64x getpayloadf64x(const _Float64x *__x) noexcept(true);
extern _Float64x __getpayloadf64x(const _Float64x *__x) noexcept(true);

extern int setpayloadf64x(_Float64x *__x, _Float64x __payload) noexcept(true);

extern int setpayloadsigf64x(_Float64x *__x,
                             _Float64x __payload) noexcept(true);
# 519 "/usr/include/math.h" 2 3 4
# 566 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float fadd(double __x, double __y) noexcept(true);

extern float fdiv(double __x, double __y) noexcept(true);

extern float ffma(double __x, double __y, double __z) noexcept(true);

extern float fmul(double __x, double __y) noexcept(true);

extern float fsqrt(double __x) noexcept(true);

extern float fsub(double __x, double __y) noexcept(true);
# 567 "/usr/include/math.h" 2 3 4
# 587 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float faddl(long double __x, long double __y) noexcept(true);

extern float fdivl(long double __x, long double __y) noexcept(true);

extern float ffmal(long double __x, long double __y,
                   long double __z) noexcept(true);

extern float fmull(long double __x, long double __y) noexcept(true);

extern float fsqrtl(long double __x) noexcept(true);

extern float fsubl(long double __x, long double __y) noexcept(true);
# 588 "/usr/include/math.h" 2 3 4
# 616 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern double daddl(long double __x, long double __y) noexcept(true);

extern double ddivl(long double __x, long double __y) noexcept(true);

extern double dfmal(long double __x, long double __y,
                    long double __z) noexcept(true);

extern double dmull(long double __x, long double __y) noexcept(true);

extern double dsqrtl(long double __x) noexcept(true);

extern double dsubl(long double __x, long double __y) noexcept(true);
# 617 "/usr/include/math.h" 2 3 4
# 697 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x(_Float32x __x, _Float32x __y) noexcept(true);

extern _Float32 f32divf32x(_Float32x __x, _Float32x __y) noexcept(true);

extern _Float32 f32fmaf32x(_Float32x __x, _Float32x __y,
                           _Float32x __z) noexcept(true);

extern _Float32 f32mulf32x(_Float32x __x, _Float32x __y) noexcept(true);

extern _Float32 f32sqrtf32x(_Float32x __x) noexcept(true);

extern _Float32 f32subf32x(_Float32x __x, _Float32x __y) noexcept(true);
# 698 "/usr/include/math.h" 2 3 4
# 707 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float32 f32divf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float32 f32fmaf64(_Float64 __x, _Float64 __y,
                          _Float64 __z) noexcept(true);

extern _Float32 f32mulf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float32 f32sqrtf64(_Float64 __x) noexcept(true);

extern _Float32 f32subf64(_Float64 __x, _Float64 __y) noexcept(true);
# 708 "/usr/include/math.h" 2 3 4
# 717 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float32 f32divf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float32 f32fmaf64x(_Float64x __x, _Float64x __y,
                           _Float64x __z) noexcept(true);

extern _Float32 f32mulf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float32 f32sqrtf64x(_Float64x __x) noexcept(true);

extern _Float32 f32subf64x(_Float64x __x, _Float64x __y) noexcept(true);
# 718 "/usr/include/math.h" 2 3 4
# 747 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float32x f32xdivf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float32x f32xfmaf64(_Float64 __x, _Float64 __y,
                            _Float64 __z) noexcept(true);

extern _Float32x f32xmulf64(_Float64 __x, _Float64 __y) noexcept(true);

extern _Float32x f32xsqrtf64(_Float64 __x) noexcept(true);

extern _Float32x f32xsubf64(_Float64 __x, _Float64 __y) noexcept(true);
# 748 "/usr/include/math.h" 2 3 4
# 757 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float32x f32xdivf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float32x f32xfmaf64x(_Float64x __x, _Float64x __y,
                             _Float64x __z) noexcept(true);

extern _Float32x f32xmulf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float32x f32xsqrtf64x(_Float64x __x) noexcept(true);

extern _Float32x f32xsubf64x(_Float64x __x, _Float64x __y) noexcept(true);
# 758 "/usr/include/math.h" 2 3 4
# 787 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float64 f64divf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float64 f64fmaf64x(_Float64x __x, _Float64x __y,
                           _Float64x __z) noexcept(true);

extern _Float64 f64mulf64x(_Float64x __x, _Float64x __y) noexcept(true);

extern _Float64 f64sqrtf64x(_Float64x __x) noexcept(true);

extern _Float64 f64subf64x(_Float64x __x, _Float64x __y) noexcept(true);
# 788 "/usr/include/math.h" 2 3 4
# 854 "/usr/include/math.h" 3 4
extern int signgam;
# 934 "/usr/include/math.h" 3 4
enum {
  FP_NAN =

      0,
  FP_INFINITE =

      1,
  FP_ZERO =

      2,
  FP_SUBNORMAL =

      3,
  FP_NORMAL =

      4
};
# 1055 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern int __iscanonicall(long double __x) noexcept(true)
    __attribute__((__const__));
# 46 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical(float __val) {
  return ((void)(__typeof(__val))(__val), 1);
}
inline int iscanonical(double __val) {
  return ((void)(__typeof(__val))(__val), 1);
}
inline int iscanonical(long double __val) { return __iscanonicall(__val); }
}
# 1056 "/usr/include/math.h" 2 3 4
# 1067 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling(float __val) { return __issignalingf(__val); }
inline int issignaling(double __val) { return __issignaling(__val); }
inline int issignaling(long double __val) { return __issignalingl(__val); }
}
# 1098 "/usr/include/math.h" 3 4
extern "C++" {
# 1129 "/usr/include/math.h" 3 4
template <class __T> inline bool iszero(__T __val) { return __val == 0; }
}
# 1364 "/usr/include/math.h" 3 4
extern "C++" {
template <typename> struct __iseqsig_type;

template <> struct __iseqsig_type<float> {
  static int __call(float __x, float __y) throw() {
    return __iseqsigf(__x, __y);
  }
};

template <> struct __iseqsig_type<double> {
  static int __call(double __x, double __y) throw() {
    return __iseqsig(__x, __y);
  }
};

template <> struct __iseqsig_type<long double> {
  static int __call(long double __x, long double __y) throw() {

    return __iseqsigl(__x, __y);
  }
};
# 1455 "/usr/include/math.h" 3 4
template <typename _T1, typename _T2>
inline int iseqsig(_T1 __x, _T2 __y) throw() {

  typedef decltype(((__x) + (__y) + 0.0f)) _T3;

  return __iseqsig_type<_T3>::__call(__x, __y);
}
}
}
# 48 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cmath" 2 3
# 79 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cmath" 3
extern "C++" {
namespace std __attribute__((__visibility__("default"))) {

  using ::acos;

  inline constexpr float acos(float __x) { return __builtin_acosf(__x); }

  inline constexpr long double acos(long double __x) {
    return __builtin_acosl(__x);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  acos(_Tp __x) {
    return __builtin_acos(__x);
  }

  using ::asin;

  inline constexpr float asin(float __x) { return __builtin_asinf(__x); }

  inline constexpr long double asin(long double __x) {
    return __builtin_asinl(__x);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  asin(_Tp __x) {
    return __builtin_asin(__x);
  }

  using ::atan;

  inline constexpr float atan(float __x) { return __builtin_atanf(__x); }

  inline constexpr long double atan(long double __x) {
    return __builtin_atanl(__x);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  atan(_Tp __x) {
    return __builtin_atan(__x);
  }

  using ::atan2;

  inline constexpr float atan2(float __y, float __x) {
    return __builtin_atan2f(__y, __x);
  }

  inline constexpr long double atan2(long double __y, long double __x) {
    return __builtin_atan2l(__y, __x);
  }

  using ::ceil;

  inline constexpr float ceil(float __x) { return __builtin_ceilf(__x); }

  inline constexpr long double ceil(long double __x) {
    return __builtin_ceill(__x);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  ceil(_Tp __x) {
    return __builtin_ceil(__x);
  }

  using ::cos;

  inline constexpr float cos(float __x) { return __builtin_cosf(__x); }

  inline constexpr long double cos(long double __x) {
    return __builtin_cosl(__x);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  cos(_Tp __x) {
    return __builtin_cos(__x);
  }

  using ::cosh;

  inline constexpr float cosh(float __x) { return __builtin_coshf(__x); }

  inline constexpr long double cosh(long double __x) {
    return __builtin_coshl(__x);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  cosh(_Tp __x) {
    return __builtin_cosh(__x);
  }

  using ::exp;

  inline constexpr float exp(float __x) { return __builtin_expf(__x); }

  inline constexpr long double exp(long double __x) {
    return __builtin_expl(__x);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  exp(_Tp __x) {
    return __builtin_exp(__x);
  }

  using ::fabs;

  inline constexpr float fabs(float __x) { return __builtin_fabsf(__x); }

  inline constexpr long double fabs(long double __x) {
    return __builtin_fabsl(__x);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  fabs(_Tp __x) {
    return __builtin_fabs(__x);
  }

  using ::floor;

  inline constexpr float floor(float __x) { return __builtin_floorf(__x); }

  inline constexpr long double floor(long double __x) {
    return __builtin_floorl(__x);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  floor(_Tp __x) {
    return __builtin_floor(__x);
  }

  using ::fmod;

  inline constexpr float fmod(float __x, float __y) {
    return __builtin_fmodf(__x, __y);
  }

  inline constexpr long double fmod(long double __x, long double __y) {
    return __builtin_fmodl(__x, __y);
  }

  using ::frexp;

  inline float frexp(float __x, int *__exp) {
    return __builtin_frexpf(__x, __exp);
  }

  inline long double frexp(long double __x, int *__exp) {
    return __builtin_frexpl(__x, __exp);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  frexp(_Tp __x, int *__exp) {
    return __builtin_frexp(__x, __exp);
  }

  using ::ldexp;

  inline constexpr float ldexp(float __x, int __exp) {
    return __builtin_ldexpf(__x, __exp);
  }

  inline constexpr long double ldexp(long double __x, int __exp) {
    return __builtin_ldexpl(__x, __exp);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  ldexp(_Tp __x, int __exp) {
    return __builtin_ldexp(__x, __exp);
  }

  using ::log;

  inline constexpr float log(float __x) { return __builtin_logf(__x); }

  inline constexpr long double log(long double __x) {
    return __builtin_logl(__x);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  log(_Tp __x) {
    return __builtin_log(__x);
  }

  using ::log10;

  inline constexpr float log10(float __x) { return __builtin_log10f(__x); }

  inline constexpr long double log10(long double __x) {
    return __builtin_log10l(__x);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  log10(_Tp __x) {
    return __builtin_log10(__x);
  }

  using ::modf;

  inline float modf(float __x, float *__iptr) {
    return __builtin_modff(__x, __iptr);
  }

  inline long double modf(long double __x, long double *__iptr) {
    return __builtin_modfl(__x, __iptr);
  }

  using ::pow;

  inline constexpr float pow(float __x, float __y) {
    return __builtin_powf(__x, __y);
  }

  inline constexpr long double pow(long double __x, long double __y) {
    return __builtin_powl(__x, __y);
  }
# 396 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cmath" 3
  using ::sin;

  inline constexpr float sin(float __x) { return __builtin_sinf(__x); }

  inline constexpr long double sin(long double __x) {
    return __builtin_sinl(__x);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  sin(_Tp __x) {
    return __builtin_sin(__x);
  }

  using ::sinh;

  inline constexpr float sinh(float __x) { return __builtin_sinhf(__x); }

  inline constexpr long double sinh(long double __x) {
    return __builtin_sinhl(__x);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  sinh(_Tp __x) {
    return __builtin_sinh(__x);
  }

  using ::sqrt;

  inline constexpr float sqrt(float __x) { return __builtin_sqrtf(__x); }

  inline constexpr long double sqrt(long double __x) {
    return __builtin_sqrtl(__x);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  sqrt(_Tp __x) {
    return __builtin_sqrt(__x);
  }

  using ::tan;

  inline constexpr float tan(float __x) { return __builtin_tanf(__x); }

  inline constexpr long double tan(long double __x) {
    return __builtin_tanl(__x);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  tan(_Tp __x) {
    return __builtin_tan(__x);
  }

  using ::tanh;

  inline constexpr float tanh(float __x) { return __builtin_tanhf(__x); }

  inline constexpr long double tanh(long double __x) {
    return __builtin_tanhl(__x);
  }

  template <typename _Tp>
  inline constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                                   double>::__type
  tanh(_Tp __x) {
    return __builtin_tanh(__x);
  }
# 1049 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cmath" 3
  template <typename _Tp, typename _Up>
  inline constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type atan2(
      _Tp __y, _Up __x) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return atan2(__type(__y), __type(__x));
  }

  template <typename _Tp, typename _Up>
  inline constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmod(
      _Tp __x, _Up __y) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return fmod(__type(__x), __type(__y));
  }

  template <typename _Tp, typename _Up>
  inline constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type pow(
      _Tp __x, _Up __y) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return pow(__type(__x), __type(__y));
  }
# 1096 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cmath" 3
  constexpr int fpclassify(float __x) {
    return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
  }

  constexpr int fpclassify(double __x) {
    return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
  }

  constexpr int fpclassify(long double __x) {
    return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
  }

  template <typename _Tp>
  constexpr
      typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type
      fpclassify(_Tp __x) {
    return __x != 0 ? 4 : 2;
  }

  constexpr bool isfinite(float __x) { return __builtin_isfinite(__x); }

  constexpr bool isfinite(double __x) { return __builtin_isfinite(__x); }

  constexpr bool isfinite(long double __x) { return __builtin_isfinite(__x); }

  template <typename _Tp>
  constexpr
      typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type
      isfinite(_Tp) {
    return true;
  }

  constexpr bool isinf(float __x) { return __builtin_isinf(__x); }

  constexpr bool isinf(double __x) { return __builtin_isinf(__x); }

  constexpr bool isinf(long double __x) { return __builtin_isinf(__x); }

  template <typename _Tp>
  constexpr
      typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type
      isinf(_Tp) {
    return false;
  }

  constexpr bool isnan(float __x) { return __builtin_isnan(__x); }

  constexpr bool isnan(double __x) { return __builtin_isnan(__x); }

  constexpr bool isnan(long double __x) { return __builtin_isnan(__x); }

  template <typename _Tp>
  constexpr
      typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type
      isnan(_Tp) {
    return false;
  }

  constexpr bool isnormal(float __x) { return __builtin_isnormal(__x); }

  constexpr bool isnormal(double __x) { return __builtin_isnormal(__x); }

  constexpr bool isnormal(long double __x) { return __builtin_isnormal(__x); }

  template <typename _Tp>
  constexpr
      typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type
      isnormal(_Tp __x) {
    return __x != 0 ? true : false;
  }

  constexpr bool signbit(float __x) { return __builtin_signbit(__x); }

  constexpr bool signbit(double __x) { return __builtin_signbit(__x); }

  constexpr bool signbit(long double __x) { return __builtin_signbit(__x); }

  template <typename _Tp>
  constexpr
      typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type
      signbit(_Tp __x) {
    return __x < 0 ? true : false;
  }

  constexpr bool isgreater(float __x, float __y) {
    return __builtin_isgreater(__x, __y);
  }

  constexpr bool isgreater(double __x, double __y) {
    return __builtin_isgreater(__x, __y);
  }

  constexpr bool isgreater(long double __x, long double __y) {
    return __builtin_isgreater(__x, __y);
  }

  template <typename _Tp, typename _Up>
  constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value &&
                                             __is_arithmetic<_Up>::__value),
                                            bool>::__type
  isgreater(_Tp __x, _Up __y) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_isgreater(__type(__x), __type(__y));
  }

  constexpr bool isgreaterequal(float __x, float __y) {
    return __builtin_isgreaterequal(__x, __y);
  }

  constexpr bool isgreaterequal(double __x, double __y) {
    return __builtin_isgreaterequal(__x, __y);
  }

  constexpr bool isgreaterequal(long double __x, long double __y) {
    return __builtin_isgreaterequal(__x, __y);
  }

  template <typename _Tp, typename _Up>
  constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value &&
                                             __is_arithmetic<_Up>::__value),
                                            bool>::__type
  isgreaterequal(_Tp __x, _Up __y) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_isgreaterequal(__type(__x), __type(__y));
  }

  constexpr bool isless(float __x, float __y) {
    return __builtin_isless(__x, __y);
  }

  constexpr bool isless(double __x, double __y) {
    return __builtin_isless(__x, __y);
  }

  constexpr bool isless(long double __x, long double __y) {
    return __builtin_isless(__x, __y);
  }

  template <typename _Tp, typename _Up>
  constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value &&
                                             __is_arithmetic<_Up>::__value),
                                            bool>::__type
  isless(_Tp __x, _Up __y) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_isless(__type(__x), __type(__y));
  }

  constexpr bool islessequal(float __x, float __y) {
    return __builtin_islessequal(__x, __y);
  }

  constexpr bool islessequal(double __x, double __y) {
    return __builtin_islessequal(__x, __y);
  }

  constexpr bool islessequal(long double __x, long double __y) {
    return __builtin_islessequal(__x, __y);
  }

  template <typename _Tp, typename _Up>
  constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value &&
                                             __is_arithmetic<_Up>::__value),
                                            bool>::__type
  islessequal(_Tp __x, _Up __y) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_islessequal(__type(__x), __type(__y));
  }

  constexpr bool islessgreater(float __x, float __y) {
    return __builtin_islessgreater(__x, __y);
  }

  constexpr bool islessgreater(double __x, double __y) {
    return __builtin_islessgreater(__x, __y);
  }

  constexpr bool islessgreater(long double __x, long double __y) {
    return __builtin_islessgreater(__x, __y);
  }

  template <typename _Tp, typename _Up>
  constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value &&
                                             __is_arithmetic<_Up>::__value),
                                            bool>::__type
  islessgreater(_Tp __x, _Up __y) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_islessgreater(__type(__x), __type(__y));
  }

  constexpr bool isunordered(float __x, float __y) {
    return __builtin_isunordered(__x, __y);
  }

  constexpr bool isunordered(double __x, double __y) {
    return __builtin_isunordered(__x, __y);
  }

  constexpr bool isunordered(long double __x, long double __y) {
    return __builtin_isunordered(__x, __y);
  }

  template <typename _Tp, typename _Up>
  constexpr typename __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value &&
                                             __is_arithmetic<_Up>::__value),
                                            bool>::__type
  isunordered(_Tp __x, _Up __y) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_isunordered(__type(__x), __type(__y));
  }
# 1881 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cmath" 3
  using ::double_t;
  using ::float_t;

  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;

  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;

  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;

  constexpr float acosh(float __x) { return __builtin_acoshf(__x); }

  constexpr long double acosh(long double __x) { return __builtin_acoshl(__x); }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  acosh(_Tp __x) {
    return __builtin_acosh(__x);
  }

  constexpr float asinh(float __x) { return __builtin_asinhf(__x); }

  constexpr long double asinh(long double __x) { return __builtin_asinhl(__x); }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  asinh(_Tp __x) {
    return __builtin_asinh(__x);
  }

  constexpr float atanh(float __x) { return __builtin_atanhf(__x); }

  constexpr long double atanh(long double __x) { return __builtin_atanhl(__x); }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  atanh(_Tp __x) {
    return __builtin_atanh(__x);
  }

  constexpr float cbrt(float __x) { return __builtin_cbrtf(__x); }

  constexpr long double cbrt(long double __x) { return __builtin_cbrtl(__x); }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  cbrt(_Tp __x) {
    return __builtin_cbrt(__x);
  }

  constexpr float copysign(float __x, float __y) {
    return __builtin_copysignf(__x, __y);
  }

  constexpr long double copysign(long double __x, long double __y) {
    return __builtin_copysignl(__x, __y);
  }

  constexpr float erf(float __x) { return __builtin_erff(__x); }

  constexpr long double erf(long double __x) { return __builtin_erfl(__x); }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  erf(_Tp __x) {
    return __builtin_erf(__x);
  }

  constexpr float erfc(float __x) { return __builtin_erfcf(__x); }

  constexpr long double erfc(long double __x) { return __builtin_erfcl(__x); }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  erfc(_Tp __x) {
    return __builtin_erfc(__x);
  }

  constexpr float exp2(float __x) { return __builtin_exp2f(__x); }

  constexpr long double exp2(long double __x) { return __builtin_exp2l(__x); }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  exp2(_Tp __x) {
    return __builtin_exp2(__x);
  }

  constexpr float expm1(float __x) { return __builtin_expm1f(__x); }

  constexpr long double expm1(long double __x) { return __builtin_expm1l(__x); }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  expm1(_Tp __x) {
    return __builtin_expm1(__x);
  }

  constexpr float fdim(float __x, float __y) {
    return __builtin_fdimf(__x, __y);
  }

  constexpr long double fdim(long double __x, long double __y) {
    return __builtin_fdiml(__x, __y);
  }

  constexpr float fma(float __x, float __y, float __z) {
    return __builtin_fmaf(__x, __y, __z);
  }

  constexpr long double fma(long double __x, long double __y, long double __z) {
    return __builtin_fmal(__x, __y, __z);
  }

  constexpr float fmax(float __x, float __y) {
    return __builtin_fmaxf(__x, __y);
  }

  constexpr long double fmax(long double __x, long double __y) {
    return __builtin_fmaxl(__x, __y);
  }

  constexpr float fmin(float __x, float __y) {
    return __builtin_fminf(__x, __y);
  }

  constexpr long double fmin(long double __x, long double __y) {
    return __builtin_fminl(__x, __y);
  }

  constexpr float hypot(float __x, float __y) {
    return __builtin_hypotf(__x, __y);
  }

  constexpr long double hypot(long double __x, long double __y) {
    return __builtin_hypotl(__x, __y);
  }

  constexpr int ilogb(float __x) { return __builtin_ilogbf(__x); }

  constexpr int ilogb(long double __x) { return __builtin_ilogbl(__x); }

  template <typename _Tp>
  constexpr
      typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type
      ilogb(_Tp __x) {
    return __builtin_ilogb(__x);
  }

  constexpr float lgamma(float __x) { return __builtin_lgammaf(__x); }

  constexpr long double lgamma(long double __x) {
    return __builtin_lgammal(__x);
  }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  lgamma(_Tp __x) {
    return __builtin_lgamma(__x);
  }

  constexpr long long llrint(float __x) { return __builtin_llrintf(__x); }

  constexpr long long llrint(long double __x) { return __builtin_llrintl(__x); }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            long long>::__type
  llrint(_Tp __x) {
    return __builtin_llrint(__x);
  }

  constexpr long long llround(float __x) { return __builtin_llroundf(__x); }

  constexpr long long llround(long double __x) {
    return __builtin_llroundl(__x);
  }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            long long>::__type
  llround(_Tp __x) {
    return __builtin_llround(__x);
  }

  constexpr float log1p(float __x) { return __builtin_log1pf(__x); }

  constexpr long double log1p(long double __x) { return __builtin_log1pl(__x); }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  log1p(_Tp __x) {
    return __builtin_log1p(__x);
  }

  constexpr float log2(float __x) { return __builtin_log2f(__x); }

  constexpr long double log2(long double __x) { return __builtin_log2l(__x); }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  log2(_Tp __x) {
    return __builtin_log2(__x);
  }

  constexpr float logb(float __x) { return __builtin_logbf(__x); }

  constexpr long double logb(long double __x) { return __builtin_logbl(__x); }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  logb(_Tp __x) {
    return __builtin_logb(__x);
  }

  constexpr long lrint(float __x) { return __builtin_lrintf(__x); }

  constexpr long lrint(long double __x) { return __builtin_lrintl(__x); }

  template <typename _Tp>
  constexpr
      typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long>::__type
      lrint(_Tp __x) {
    return __builtin_lrint(__x);
  }

  constexpr long lround(float __x) { return __builtin_lroundf(__x); }

  constexpr long lround(long double __x) { return __builtin_lroundl(__x); }

  template <typename _Tp>
  constexpr
      typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long>::__type
      lround(_Tp __x) {
    return __builtin_lround(__x);
  }

  constexpr float nearbyint(float __x) { return __builtin_nearbyintf(__x); }

  constexpr long double nearbyint(long double __x) {
    return __builtin_nearbyintl(__x);
  }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  nearbyint(_Tp __x) {
    return __builtin_nearbyint(__x);
  }

  constexpr float nextafter(float __x, float __y) {
    return __builtin_nextafterf(__x, __y);
  }

  constexpr long double nextafter(long double __x, long double __y) {
    return __builtin_nextafterl(__x, __y);
  }

  constexpr float nexttoward(float __x, long double __y) {
    return __builtin_nexttowardf(__x, __y);
  }

  constexpr long double nexttoward(long double __x, long double __y) {
    return __builtin_nexttowardl(__x, __y);
  }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  nexttoward(_Tp __x, long double __y) {
    return __builtin_nexttoward(__x, __y);
  }

  constexpr float remainder(float __x, float __y) {
    return __builtin_remainderf(__x, __y);
  }

  constexpr long double remainder(long double __x, long double __y) {
    return __builtin_remainderl(__x, __y);
  }

  inline float remquo(float __x, float __y, int *__pquo) {
    return __builtin_remquof(__x, __y, __pquo);
  }

  inline long double remquo(long double __x, long double __y, int *__pquo) {
    return __builtin_remquol(__x, __y, __pquo);
  }

  constexpr float rint(float __x) { return __builtin_rintf(__x); }

  constexpr long double rint(long double __x) { return __builtin_rintl(__x); }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  rint(_Tp __x) {
    return __builtin_rint(__x);
  }

  constexpr float round(float __x) { return __builtin_roundf(__x); }

  constexpr long double round(long double __x) { return __builtin_roundl(__x); }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  round(_Tp __x) {
    return __builtin_round(__x);
  }

  constexpr float scalbln(float __x, long __ex) {
    return __builtin_scalblnf(__x, __ex);
  }

  constexpr long double scalbln(long double __x, long __ex) {
    return __builtin_scalblnl(__x, __ex);
  }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  scalbln(_Tp __x, long __ex) {
    return __builtin_scalbln(__x, __ex);
  }

  constexpr float scalbn(float __x, int __ex) {
    return __builtin_scalbnf(__x, __ex);
  }

  constexpr long double scalbn(long double __x, int __ex) {
    return __builtin_scalbnl(__x, __ex);
  }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  scalbn(_Tp __x, int __ex) {
    return __builtin_scalbn(__x, __ex);
  }

  constexpr float tgamma(float __x) { return __builtin_tgammaf(__x); }

  constexpr long double tgamma(long double __x) {
    return __builtin_tgammal(__x);
  }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  tgamma(_Tp __x) {
    return __builtin_tgamma(__x);
  }

  constexpr float trunc(float __x) { return __builtin_truncf(__x); }

  constexpr long double trunc(long double __x) { return __builtin_truncl(__x); }

  template <typename _Tp>
  constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                            double>::__type
  trunc(_Tp __x) {
    return __builtin_trunc(__x);
  }
# 3469 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cmath" 3
  template <typename _Tp, typename _Up>
  constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type copysign(
      _Tp __x, _Up __y) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return copysign(__type(__x), __type(__y));
  }

  template <typename _Tp, typename _Up>
  constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fdim(_Tp __x,
                                                                   _Up __y) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return fdim(__type(__x), __type(__y));
  }

  template <typename _Tp, typename _Up>
  constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmax(_Tp __x,
                                                                   _Up __y) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return fmax(__type(__x), __type(__y));
  }

  template <typename _Tp, typename _Up>
  constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type fmin(_Tp __x,
                                                                   _Up __y) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return fmin(__type(__x), __type(__y));
  }

  template <typename _Tp, typename _Up>
  constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type hypot(_Tp __x,
                                                                    _Up __y) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return hypot(__type(__x), __type(__y));
  }

  template <typename _Tp, typename _Up>
  constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type nextafter(
      _Tp __x, _Up __y) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return nextafter(__type(__x), __type(__y));
  }

  template <typename _Tp, typename _Up>
  constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type remainder(
      _Tp __x, _Up __y) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return remainder(__type(__x), __type(__y));
  }

  template <typename _Tp, typename _Up>
  inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type remquo(
      _Tp __x, _Up __y, int *__pquo) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return remquo(__type(__x), __type(__y), __pquo);
  }

  template <typename _Tp, typename _Up, typename _Vp>
  constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type fma(
      _Tp __x, _Up __y, _Vp __z) {
    typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
    return fma(__type(__x), __type(__y), __type(__z));
  }
# 3550 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cmath" 3
  template <typename _Tp> inline _Tp __hypot3(_Tp __x, _Tp __y, _Tp __z) {
    __x = std::abs(__x);
    __y = std::abs(__y);
    __z = std::abs(__z);
    if (_Tp __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
      return __a *
             std::sqrt((__x / __a) * (__x / __a) + (__y / __a) * (__y / __a) +
                       (__z / __a) * (__z / __a));
    else
      return {};
  }

  inline float hypot(float __x, float __y, float __z) {
    return std::__hypot3<float>(__x, __y, __z);
  }

  inline double hypot(double __x, double __y, double __z) {
    return std::__hypot3<double>(__x, __y, __z);
  }

  inline long double hypot(long double __x, long double __y, long double __z) {
    return std::__hypot3<long double>(__x, __y, __z);
  }

  template <typename _Tp, typename _Up, typename _Vp>
  __gnu_cxx::__promoted_t<_Tp, _Up, _Vp> hypot(_Tp __x, _Up __y, _Vp __z) {
    using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
    return std::__hypot3<__type>(__x, __y, __z);
  }
# 3623 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cmath" 3
  template <typename _Fp>
  constexpr _Fp __lerp(_Fp __a, _Fp __b, _Fp __t) noexcept {
    if ((__a <= 0 && __b >= 0) || (__a >= 0 && __b <= 0))
      return __t * __b + (1 - __t) * __a;

    if (__t == 1)
      return __b;

    const _Fp __x = __a + __t * (__b - __a);
    return (__t > 1) == (__b > __a) ? (__b < __x ? __x : __b)
                                    : (__b > __x ? __x : __b);
  }

  constexpr float lerp(float __a, float __b, float __t) noexcept {
    return std::__lerp(__a, __b, __t);
  }

  constexpr double lerp(double __a, double __b, double __t) noexcept {
    return std::__lerp(__a, __b, __t);
  }

  constexpr long double lerp(long double __a, long double __b,
                             long double __t) noexcept {
    return std::__lerp(__a, __b, __t);
  }

  template <typename _Tp, typename _Up, typename _Vp>
  constexpr __gnu_cxx::__promoted_t<_Tp, _Up, _Vp> lerp(_Tp __x, _Up __y,
                                                        _Vp __z) noexcept {
    using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
    return std::__lerp<__type>(__x, __y, __z);
  }
# 3696 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cmath" 3
} // namespace std

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 1 3
# 44 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/limits" 1 3
# 41 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/limits" 3
# 158 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/limits" 3
namespace std __attribute__((__visibility__("default"))) {

  enum float_round_style {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };

  enum float_denorm_style {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/limits" 3
  struct __numeric_limits_base {

    static constexpr bool is_specialized = false;

    static constexpr int digits = 0;

    static constexpr int digits10 = 0;

    static constexpr int max_digits10 = 0;

    static constexpr bool is_signed = false;

    static constexpr bool is_integer = false;

    static constexpr bool is_exact = false;

    static constexpr int radix = 0;

    static constexpr int min_exponent = 0;

    static constexpr int min_exponent10 = 0;

    static constexpr int max_exponent = 0;

    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;

    static constexpr bool has_quiet_NaN = false;

    static constexpr bool has_signaling_NaN = false;

    static constexpr float_denorm_style has_denorm = denorm_absent;

    static constexpr bool has_denorm_loss = false;

    static constexpr bool is_iec559 = false;

    static constexpr bool is_bounded = false;
# 288 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/limits" 3
    static constexpr bool is_modulo = false;

    static constexpr bool traps = false;

    static constexpr bool tinyness_before = false;

    static constexpr float_round_style round_style = round_toward_zero;
  };
# 311 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/limits" 3
  template <typename _Tp> struct numeric_limits : public __numeric_limits_base {

    static constexpr _Tp min() noexcept { return _Tp(); }

    static constexpr _Tp max() noexcept { return _Tp(); }

    static constexpr _Tp lowest() noexcept { return _Tp(); }

    static constexpr _Tp epsilon() noexcept { return _Tp(); }

    static constexpr _Tp round_error() noexcept { return _Tp(); }

    static constexpr _Tp infinity() noexcept { return _Tp(); }

    static constexpr _Tp quiet_NaN() noexcept { return _Tp(); }

    static constexpr _Tp signaling_NaN() noexcept { return _Tp(); }

    static constexpr _Tp denorm_min() noexcept { return _Tp(); }
  };

  template <typename _Tp>
  struct numeric_limits<const _Tp> : public numeric_limits<_Tp> {};

  template <typename _Tp>
  struct numeric_limits<volatile _Tp> : public numeric_limits<_Tp> {};

  template <typename _Tp>
  struct numeric_limits<const volatile _Tp> : public numeric_limits<_Tp> {};
# 383 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/limits" 3
  template <> struct numeric_limits<bool> {
    static constexpr bool is_specialized = true;

    static constexpr bool min() noexcept { return false; }

    static constexpr bool max() noexcept { return true; }

    static constexpr bool lowest() noexcept { return min(); }

    static constexpr int digits = 1;
    static constexpr int digits10 = 0;

    static constexpr int max_digits10 = 0;

    static constexpr bool is_signed = false;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr bool epsilon() noexcept { return false; }

    static constexpr bool round_error() noexcept { return false; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr bool infinity() noexcept { return false; }

    static constexpr bool quiet_NaN() noexcept { return false; }

    static constexpr bool signaling_NaN() noexcept { return false; }

    static constexpr bool denorm_min() noexcept { return false; }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };

  template <> struct numeric_limits<char> {
    static constexpr bool is_specialized = true;

    static constexpr char min() noexcept {
      return (
          ((char)(-1) < 0)
              ? -(((char)(-1) < 0)
                      ? (((((char)1
                            << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) -
                           1)
                          << 1) +
                         1)
                      : ~(char)0) -
                    1
              : (char)0);
    }

    static constexpr char max() noexcept {
      return (
          ((char)(-1) < 0)
              ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1)
                  << 1) +
                 1)
              : ~(char)0);
    }

    static constexpr char lowest() noexcept { return min(); }

    static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
    static constexpr int digits10 =
        ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

    static constexpr int max_digits10 = 0;

    static constexpr bool is_signed = ((char)(-1) < 0);
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr char epsilon() noexcept { return 0; }

    static constexpr char round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr char infinity() noexcept { return char(); }

    static constexpr char quiet_NaN() noexcept { return char(); }

    static constexpr char signaling_NaN() noexcept { return char(); }

    static constexpr char denorm_min() noexcept { return static_cast<char>(0); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = !is_signed;

    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };

  template <> struct numeric_limits<signed char> {
    static constexpr bool is_specialized = true;

    static constexpr signed char min() noexcept { return -127 - 1; }

    static constexpr signed char max() noexcept { return 127; }

    static constexpr signed char lowest() noexcept { return min(); }

    static constexpr int digits =
        (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
    static constexpr int digits10 =
        ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

    static constexpr int max_digits10 = 0;

    static constexpr bool is_signed = true;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr signed char epsilon() noexcept { return 0; }

    static constexpr signed char round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr signed char infinity() noexcept {
      return static_cast<signed char>(0);
    }

    static constexpr signed char quiet_NaN() noexcept {
      return static_cast<signed char>(0);
    }

    static constexpr signed char signaling_NaN() noexcept {
      return static_cast<signed char>(0);
    }

    static constexpr signed char denorm_min() noexcept {
      return static_cast<signed char>(0);
    }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };

  template <> struct numeric_limits<unsigned char> {
    static constexpr bool is_specialized = true;

    static constexpr unsigned char min() noexcept { return 0; }

    static constexpr unsigned char max() noexcept { return 127 * 2U + 1; }

    static constexpr unsigned char lowest() noexcept { return min(); }

    static constexpr int digits =
        (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
    static constexpr int digits10 =
        ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

    static constexpr int max_digits10 = 0;

    static constexpr bool is_signed = false;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr unsigned char epsilon() noexcept { return 0; }

    static constexpr unsigned char round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr unsigned char infinity() noexcept {
      return static_cast<unsigned char>(0);
    }

    static constexpr unsigned char quiet_NaN() noexcept {
      return static_cast<unsigned char>(0);
    }

    static constexpr unsigned char signaling_NaN() noexcept {
      return static_cast<unsigned char>(0);
    }

    static constexpr unsigned char denorm_min() noexcept {
      return static_cast<unsigned char>(0);
    }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = true;

    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };

  template <> struct numeric_limits<wchar_t> {
    static constexpr bool is_specialized = true;

    static constexpr wchar_t min() noexcept {
      return (((wchar_t)(-1) < 0)
                  ? -(((wchar_t)(-1) < 0)
                          ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 -
                                                ((wchar_t)(-1) < 0)) -
                                               1)) -
                               1)
                              << 1) +
                             1)
                          : ~(wchar_t)0) -
                        1
                  : (wchar_t)0);
    }

    static constexpr wchar_t max() noexcept {
      return (((wchar_t)(-1) < 0)
                  ? (((((wchar_t)1
                        << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) -
                       1)
                      << 1) +
                     1)
                  : ~(wchar_t)0);
    }

    static constexpr wchar_t lowest() noexcept { return min(); }

    static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
    static constexpr int digits10 =
        ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

    static constexpr int max_digits10 = 0;

    static constexpr bool is_signed = ((wchar_t)(-1) < 0);
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr wchar_t epsilon() noexcept { return 0; }

    static constexpr wchar_t round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr wchar_t infinity() noexcept { return wchar_t(); }

    static constexpr wchar_t quiet_NaN() noexcept { return wchar_t(); }

    static constexpr wchar_t signaling_NaN() noexcept { return wchar_t(); }

    static constexpr wchar_t denorm_min() noexcept { return wchar_t(); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = !is_signed;

    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };

  template <> struct numeric_limits<char8_t> {
    static constexpr bool is_specialized = true;

    static constexpr char8_t min() noexcept {
      return (((char8_t)(-1) < 0)
                  ? -(((char8_t)(-1) < 0)
                          ? (((((char8_t)1 << ((sizeof(char8_t) * 8 -
                                                ((char8_t)(-1) < 0)) -
                                               1)) -
                               1)
                              << 1) +
                             1)
                          : ~(char8_t)0) -
                        1
                  : (char8_t)0);
    }

    static constexpr char8_t max() noexcept {
      return (((char8_t)(-1) < 0)
                  ? (((((char8_t)1
                        << ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) - 1)) -
                       1)
                      << 1) +
                     1)
                  : ~(char8_t)0);
    }

    static constexpr char8_t lowest() noexcept { return min(); }

    static constexpr int digits = (sizeof(char8_t) * 8 - ((char8_t)(-1) < 0));
    static constexpr int digits10 =
        ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) * 643L / 2136);
    static constexpr int max_digits10 = 0;
    static constexpr bool is_signed = ((char8_t)(-1) < 0);
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr char8_t epsilon() noexcept { return 0; }

    static constexpr char8_t round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr char8_t infinity() noexcept { return char8_t(); }

    static constexpr char8_t quiet_NaN() noexcept { return char8_t(); }

    static constexpr char8_t signaling_NaN() noexcept { return char8_t(); }

    static constexpr char8_t denorm_min() noexcept { return char8_t(); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = !is_signed;

    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };

  template <> struct numeric_limits<char16_t> {
    static constexpr bool is_specialized = true;

    static constexpr char16_t min() noexcept {
      return (((char16_t)(-1) < 0)
                  ? -(((char16_t)(-1) < 0)
                          ? (((((char16_t)1 << ((sizeof(char16_t) * 8 -
                                                 ((char16_t)(-1) < 0)) -
                                                1)) -
                               1)
                              << 1) +
                             1)
                          : ~(char16_t)0) -
                        1
                  : (char16_t)0);
    }

    static constexpr char16_t max() noexcept {
      return (
          ((char16_t)(-1) < 0)
              ? (((((char16_t)1
                    << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) -
                   1)
                  << 1) +
                 1)
              : ~(char16_t)0);
    }

    static constexpr char16_t lowest() noexcept { return min(); }

    static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
    static constexpr int digits10 =
        ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
    static constexpr int max_digits10 = 0;
    static constexpr bool is_signed = ((char16_t)(-1) < 0);
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr char16_t epsilon() noexcept { return 0; }

    static constexpr char16_t round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr char16_t infinity() noexcept { return char16_t(); }

    static constexpr char16_t quiet_NaN() noexcept { return char16_t(); }

    static constexpr char16_t signaling_NaN() noexcept { return char16_t(); }

    static constexpr char16_t denorm_min() noexcept { return char16_t(); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = !is_signed;

    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };

  template <> struct numeric_limits<char32_t> {
    static constexpr bool is_specialized = true;

    static constexpr char32_t min() noexcept {
      return (((char32_t)(-1) < 0)
                  ? -(((char32_t)(-1) < 0)
                          ? (((((char32_t)1 << ((sizeof(char32_t) * 8 -
                                                 ((char32_t)(-1) < 0)) -
                                                1)) -
                               1)
                              << 1) +
                             1)
                          : ~(char32_t)0) -
                        1
                  : (char32_t)0);
    }

    static constexpr char32_t max() noexcept {
      return (
          ((char32_t)(-1) < 0)
              ? (((((char32_t)1
                    << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) -
                   1)
                  << 1) +
                 1)
              : ~(char32_t)0);
    }

    static constexpr char32_t lowest() noexcept { return min(); }

    static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
    static constexpr int digits10 =
        ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
    static constexpr int max_digits10 = 0;
    static constexpr bool is_signed = ((char32_t)(-1) < 0);
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr char32_t epsilon() noexcept { return 0; }

    static constexpr char32_t round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr char32_t infinity() noexcept { return char32_t(); }

    static constexpr char32_t quiet_NaN() noexcept { return char32_t(); }

    static constexpr char32_t signaling_NaN() noexcept { return char32_t(); }

    static constexpr char32_t denorm_min() noexcept { return char32_t(); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = !is_signed;

    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };

  template <> struct numeric_limits<short> {
    static constexpr bool is_specialized = true;

    static constexpr short min() noexcept { return -32767 - 1; }

    static constexpr short max() noexcept { return 32767; }

    static constexpr short lowest() noexcept { return min(); }

    static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
    static constexpr int digits10 =
        ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

    static constexpr int max_digits10 = 0;

    static constexpr bool is_signed = true;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr short epsilon() noexcept { return 0; }

    static constexpr short round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr short infinity() noexcept { return short(); }

    static constexpr short quiet_NaN() noexcept { return short(); }

    static constexpr short signaling_NaN() noexcept { return short(); }

    static constexpr short denorm_min() noexcept { return short(); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };

  template <> struct numeric_limits<unsigned short> {
    static constexpr bool is_specialized = true;

    static constexpr unsigned short min() noexcept { return 0; }

    static constexpr unsigned short max() noexcept { return 32767 * 2U + 1; }

    static constexpr unsigned short lowest() noexcept { return min(); }

    static constexpr int digits =
        (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
    static constexpr int digits10 =
        ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L /
         2136);

    static constexpr int max_digits10 = 0;

    static constexpr bool is_signed = false;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr unsigned short epsilon() noexcept { return 0; }

    static constexpr unsigned short round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr unsigned short infinity() noexcept {
      return static_cast<unsigned short>(0);
    }

    static constexpr unsigned short quiet_NaN() noexcept {
      return static_cast<unsigned short>(0);
    }

    static constexpr unsigned short signaling_NaN() noexcept {
      return static_cast<unsigned short>(0);
    }

    static constexpr unsigned short denorm_min() noexcept {
      return static_cast<unsigned short>(0);
    }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = true;

    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };

  template <> struct numeric_limits<int> {
    static constexpr bool is_specialized = true;

    static constexpr int min() noexcept { return -2147483647 - 1; }

    static constexpr int max() noexcept { return 2147483647; }

    static constexpr int lowest() noexcept { return min(); }

    static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
    static constexpr int digits10 =
        ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

    static constexpr int max_digits10 = 0;

    static constexpr bool is_signed = true;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr int epsilon() noexcept { return 0; }

    static constexpr int round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr int infinity() noexcept { return static_cast<int>(0); }

    static constexpr int quiet_NaN() noexcept { return static_cast<int>(0); }

    static constexpr int signaling_NaN() noexcept {
      return static_cast<int>(0);
    }

    static constexpr int denorm_min() noexcept { return static_cast<int>(0); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };

  template <> struct numeric_limits<unsigned int> {
    static constexpr bool is_specialized = true;

    static constexpr unsigned int min() noexcept { return 0; }

    static constexpr unsigned int max() noexcept { return 2147483647 * 2U + 1; }

    static constexpr unsigned int lowest() noexcept { return min(); }

    static constexpr int digits =
        (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
    static constexpr int digits10 =
        ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

    static constexpr int max_digits10 = 0;

    static constexpr bool is_signed = false;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr unsigned int epsilon() noexcept { return 0; }

    static constexpr unsigned int round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr unsigned int infinity() noexcept {
      return static_cast<unsigned int>(0);
    }

    static constexpr unsigned int quiet_NaN() noexcept {
      return static_cast<unsigned int>(0);
    }

    static constexpr unsigned int signaling_NaN() noexcept {
      return static_cast<unsigned int>(0);
    }

    static constexpr unsigned int denorm_min() noexcept {
      return static_cast<unsigned int>(0);
    }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = true;

    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };

  template <> struct numeric_limits<long> {
    static constexpr bool is_specialized = true;

    static constexpr long min() noexcept { return -9223372036854775807L - 1; }

    static constexpr long max() noexcept { return 9223372036854775807L; }

    static constexpr long lowest() noexcept { return min(); }

    static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
    static constexpr int digits10 =
        ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

    static constexpr int max_digits10 = 0;

    static constexpr bool is_signed = true;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr long epsilon() noexcept { return 0; }

    static constexpr long round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr long infinity() noexcept { return static_cast<long>(0); }

    static constexpr long quiet_NaN() noexcept { return static_cast<long>(0); }

    static constexpr long signaling_NaN() noexcept {
      return static_cast<long>(0);
    }

    static constexpr long denorm_min() noexcept { return static_cast<long>(0); }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };

  template <> struct numeric_limits<unsigned long> {
    static constexpr bool is_specialized = true;

    static constexpr unsigned long min() noexcept { return 0; }

    static constexpr unsigned long max() noexcept {
      return 9223372036854775807L * 2UL + 1;
    }

    static constexpr unsigned long lowest() noexcept { return min(); }

    static constexpr int digits =
        (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
    static constexpr int digits10 =
        ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

    static constexpr int max_digits10 = 0;

    static constexpr bool is_signed = false;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr unsigned long epsilon() noexcept { return 0; }

    static constexpr unsigned long round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr unsigned long infinity() noexcept {
      return static_cast<unsigned long>(0);
    }

    static constexpr unsigned long quiet_NaN() noexcept {
      return static_cast<unsigned long>(0);
    }

    static constexpr unsigned long signaling_NaN() noexcept {
      return static_cast<unsigned long>(0);
    }

    static constexpr unsigned long denorm_min() noexcept {
      return static_cast<unsigned long>(0);
    }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = true;

    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };

  template <> struct numeric_limits<long long> {
    static constexpr bool is_specialized = true;

    static constexpr long long min() noexcept {
      return -9223372036854775807LL - 1;
    }

    static constexpr long long max() noexcept { return 9223372036854775807LL; }

    static constexpr long long lowest() noexcept { return min(); }

    static constexpr int digits =
        (sizeof(long long) * 8 - ((long long)(-1) < 0));
    static constexpr int digits10 =
        ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

    static constexpr int max_digits10 = 0;

    static constexpr bool is_signed = true;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr long long epsilon() noexcept { return 0; }

    static constexpr long long round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr long long infinity() noexcept {
      return static_cast<long long>(0);
    }

    static constexpr long long quiet_NaN() noexcept {
      return static_cast<long long>(0);
    }

    static constexpr long long signaling_NaN() noexcept {
      return static_cast<long long>(0);
    }

    static constexpr long long denorm_min() noexcept {
      return static_cast<long long>(0);
    }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };

  template <> struct numeric_limits<unsigned long long> {
    static constexpr bool is_specialized = true;

    static constexpr unsigned long long min() noexcept { return 0; }

    static constexpr unsigned long long max() noexcept {
      return 9223372036854775807LL * 2ULL + 1;
    }

    static constexpr unsigned long long lowest() noexcept { return min(); }

    static constexpr int digits =
        (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
    static constexpr int digits10 =
        ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) *
         643L / 2136);

    static constexpr int max_digits10 = 0;

    static constexpr bool is_signed = false;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;

    static constexpr unsigned long long epsilon() noexcept { return 0; }

    static constexpr unsigned long long round_error() noexcept { return 0; }

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr unsigned long long infinity() noexcept {
      return static_cast<unsigned long long>(0);
    }

    static constexpr unsigned long long quiet_NaN() noexcept {
      return static_cast<unsigned long long>(0);
    }

    static constexpr unsigned long long signaling_NaN() noexcept {
      return static_cast<unsigned long long>(0);
    }

    static constexpr unsigned long long denorm_min() noexcept {
      return static_cast<unsigned long long>(0);
    }

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = true;

    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };
# 1658 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/limits" 3
  __extension__ template <> struct numeric_limits<__int128> {
    static constexpr bool is_specialized = true;
    static constexpr __int128 min() noexcept {
      return (
          ((__int128)(-1) < 0)
              ? -(((__int128)(-1) < 0)
                      ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) -
                           1)
                          << 1) +
                         1)
                      : ~(__int128)0) -
                    1
              : (__int128)0);
    }
    static constexpr __int128 max() noexcept {
      return (((__int128)(-1) < 0)
                  ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1)
                      << 1) +
                     1)
                  : ~(__int128)0);
    }
    static constexpr int digits = 128 - 1;
    static constexpr int digits10 = (128 - 1) * 643L / 2136;
    static constexpr bool is_signed = true;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;
    static constexpr __int128 epsilon() noexcept { return 0; }
    static constexpr __int128 round_error() noexcept { return 0; }
    static constexpr __int128 lowest() noexcept { return min(); }
    static constexpr int max_digits10 = 0;
    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;
    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;
    static constexpr __int128 infinity() noexcept {
      return static_cast<__int128>(0);
    }
    static constexpr __int128 quiet_NaN() noexcept {
      return static_cast<__int128>(0);
    }
    static constexpr __int128 signaling_NaN() noexcept {
      return static_cast<__int128>(0);
    }
    static constexpr __int128 denorm_min() noexcept {
      return static_cast<__int128>(0);
    }
    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;
    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };
  __extension__ template <> struct numeric_limits<unsigned __int128> {
    static constexpr bool is_specialized = true;
    static constexpr unsigned __int128 min() noexcept { return 0; }
    static constexpr unsigned __int128 max() noexcept {
      return (((unsigned __int128)(-1) < 0)
                  ? (((((unsigned __int128)1
                        << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) -
                       1)
                      << 1) +
                     1)
                  : ~(unsigned __int128)0);
    }
    static constexpr unsigned __int128 lowest() noexcept { return min(); }
    static constexpr int max_digits10 = 0;
    static constexpr int digits = 128;
    static constexpr int digits10 = 128 * 643L / 2136;
    static constexpr bool is_signed = false;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr int radix = 2;
    static constexpr unsigned __int128 epsilon() noexcept { return 0; }
    static constexpr unsigned __int128 round_error() noexcept { return 0; }
    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;
    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;
    static constexpr unsigned __int128 infinity() noexcept {
      return static_cast<unsigned __int128>(0);
    }
    static constexpr unsigned __int128 quiet_NaN() noexcept {
      return static_cast<unsigned __int128>(0);
    }
    static constexpr unsigned __int128 signaling_NaN() noexcept {
      return static_cast<unsigned __int128>(0);
    }
    static constexpr unsigned __int128 denorm_min() noexcept {
      return static_cast<unsigned __int128>(0);
    }
    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = true;
    static constexpr bool traps = true;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_toward_zero;
  };
# 1669 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/limits" 3
  template <> struct numeric_limits<float> {
    static constexpr bool is_specialized = true;

    static constexpr float min() noexcept { return 1.17549435e-38F; }

    static constexpr float max() noexcept { return 3.40282347e+38F; }

    static constexpr float lowest() noexcept { return -3.40282347e+38F; }

    static constexpr int digits = 24;
    static constexpr int digits10 = 6;

    static constexpr int max_digits10 = (2 + (24) * 643L / 2136);

    static constexpr bool is_signed = true;
    static constexpr bool is_integer = false;
    static constexpr bool is_exact = false;
    static constexpr int radix = 2;

    static constexpr float epsilon() noexcept { return 1.19209290e-7F; }

    static constexpr float round_error() noexcept { return 0.5F; }

    static constexpr int min_exponent = (-125);
    static constexpr int min_exponent10 = (-37);
    static constexpr int max_exponent = 128;
    static constexpr int max_exponent10 = 38;

    static constexpr bool has_infinity = 1;
    static constexpr bool has_quiet_NaN = 1;
    static constexpr bool has_signaling_NaN = has_quiet_NaN;
    static constexpr float_denorm_style has_denorm =
        bool(1) ? denorm_present : denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr float infinity() noexcept { return __builtin_huge_valf(); }

    static constexpr float quiet_NaN() noexcept { return __builtin_nanf(""); }

    static constexpr float signaling_NaN() noexcept {
      return __builtin_nansf("");
    }

    static constexpr float denorm_min() noexcept { return 1.40129846e-45F; }

    static constexpr bool is_iec559 =
        has_infinity && has_quiet_NaN && has_denorm == denorm_present;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_to_nearest;
  };

  template <> struct numeric_limits<double> {
    static constexpr bool is_specialized = true;

    static constexpr double min() noexcept { return 2.2250738585072014e-308; }

    static constexpr double max() noexcept { return 1.7976931348623157e+308; }

    static constexpr double lowest() noexcept {
      return -1.7976931348623157e+308;
    }

    static constexpr int digits = 53;
    static constexpr int digits10 = 15;

    static constexpr int max_digits10 = (2 + (53) * 643L / 2136);

    static constexpr bool is_signed = true;
    static constexpr bool is_integer = false;
    static constexpr bool is_exact = false;
    static constexpr int radix = 2;

    static constexpr double epsilon() noexcept {
      return 2.2204460492503131e-16;
    }

    static constexpr double round_error() noexcept { return 0.5; }

    static constexpr int min_exponent = (-1021);
    static constexpr int min_exponent10 = (-307);
    static constexpr int max_exponent = 1024;
    static constexpr int max_exponent10 = 308;

    static constexpr bool has_infinity = 1;
    static constexpr bool has_quiet_NaN = 1;
    static constexpr bool has_signaling_NaN = has_quiet_NaN;
    static constexpr float_denorm_style has_denorm =
        bool(1) ? denorm_present : denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr double infinity() noexcept { return __builtin_huge_val(); }

    static constexpr double quiet_NaN() noexcept { return __builtin_nan(""); }

    static constexpr double signaling_NaN() noexcept {
      return __builtin_nans("");
    }

    static constexpr double denorm_min() noexcept {
      return 4.9406564584124654e-324;
    }

    static constexpr bool is_iec559 =
        has_infinity && has_quiet_NaN && has_denorm == denorm_present;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_to_nearest;
  };

  template <> struct numeric_limits<long double> {
    static constexpr bool is_specialized = true;

    static constexpr long double min() noexcept {
      return 3.36210314311209350626e-4932L;
    }

    static constexpr long double max() noexcept {
      return 1.18973149535723176502e+4932L;
    }

    static constexpr long double lowest() noexcept {
      return -1.18973149535723176502e+4932L;
    }

    static constexpr int digits = 64;
    static constexpr int digits10 = 18;

    static constexpr int max_digits10 = (2 + (64) * 643L / 2136);

    static constexpr bool is_signed = true;
    static constexpr bool is_integer = false;
    static constexpr bool is_exact = false;
    static constexpr int radix = 2;

    static constexpr long double epsilon() noexcept {
      return 1.08420217248550443401e-19L;
    }

    static constexpr long double round_error() noexcept { return 0.5L; }

    static constexpr int min_exponent = (-16381);
    static constexpr int min_exponent10 = (-4931);
    static constexpr int max_exponent = 16384;
    static constexpr int max_exponent10 = 4932;

    static constexpr bool has_infinity = 1;
    static constexpr bool has_quiet_NaN = 1;
    static constexpr bool has_signaling_NaN = has_quiet_NaN;
    static constexpr float_denorm_style has_denorm =
        bool(1) ? denorm_present : denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr long double infinity() noexcept {
      return __builtin_huge_vall();
    }

    static constexpr long double quiet_NaN() noexcept {
      return __builtin_nanl("");
    }

    static constexpr long double signaling_NaN() noexcept {
      return __builtin_nansl("");
    }

    static constexpr long double denorm_min() noexcept {
      return 3.64519953188247460253e-4951L;
    }

    static constexpr bool is_iec559 =
        has_infinity && has_quiet_NaN && has_denorm == denorm_present;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;
    static constexpr float_round_style round_style = round_to_nearest;
  };
# 2077 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/limits" 3
} // namespace std
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 1 3
# 49 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/special_function_util.h" 1 3
# 39 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/special_function_util.h" 3
namespace std __attribute__((__visibility__("default"))) {
# 50 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/special_function_util.h" 3
  namespace __detail {

  template <typename _Tp> struct __floating_point_constant {
    static const _Tp __value;
  };

  template <typename _Tp> struct __numeric_constants {

    static _Tp __pi() throw() {
      return static_cast<_Tp>(3.1415926535897932384626433832795029L);
    }

    static _Tp __pi_2() throw() {
      return static_cast<_Tp>(1.5707963267948966192313216916397514L);
    }

    static _Tp __pi_3() throw() {
      return static_cast<_Tp>(1.0471975511965977461542144610931676L);
    }

    static _Tp __pi_4() throw() {
      return static_cast<_Tp>(0.7853981633974483096156608458198757L);
    }

    static _Tp __1_pi() throw() {
      return static_cast<_Tp>(0.3183098861837906715377675267450287L);
    }

    static _Tp __2_sqrtpi() throw() {
      return static_cast<_Tp>(1.1283791670955125738961589031215452L);
    }

    static _Tp __sqrt2() throw() {
      return static_cast<_Tp>(1.4142135623730950488016887242096981L);
    }

    static _Tp __sqrt3() throw() {
      return static_cast<_Tp>(1.7320508075688772935274463415058723L);
    }

    static _Tp __sqrtpio2() throw() {
      return static_cast<_Tp>(1.2533141373155002512078826424055226L);
    }

    static _Tp __sqrt1_2() throw() {
      return static_cast<_Tp>(0.7071067811865475244008443621048490L);
    }

    static _Tp __lnpi() throw() {
      return static_cast<_Tp>(1.1447298858494001741434273513530587L);
    }

    static _Tp __gamma_e() throw() {
      return static_cast<_Tp>(0.5772156649015328606065120900824024L);
    }

    static _Tp __euler() throw() {
      return static_cast<_Tp>(2.7182818284590452353602874713526625L);
    }
  };
# 114 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/special_function_util.h" 3
  template <typename _Tp> inline bool __isnan(_Tp __x) {
    return std::isnan(__x);
  }
# 133 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/special_function_util.h" 3
  } // namespace __detail

} // namespace std
# 50 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 65 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 3
  namespace __detail {
# 76 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 3
  template <typename _Tp> _Tp __bernoulli_series(unsigned int __n) {

    static const _Tp __num[28] = {_Tp(1UL),
                                  -_Tp(1UL) / _Tp(2UL),
                                  _Tp(1UL) / _Tp(6UL),
                                  _Tp(0UL),
                                  -_Tp(1UL) / _Tp(30UL),
                                  _Tp(0UL),
                                  _Tp(1UL) / _Tp(42UL),
                                  _Tp(0UL),
                                  -_Tp(1UL) / _Tp(30UL),
                                  _Tp(0UL),
                                  _Tp(5UL) / _Tp(66UL),
                                  _Tp(0UL),
                                  -_Tp(691UL) / _Tp(2730UL),
                                  _Tp(0UL),
                                  _Tp(7UL) / _Tp(6UL),
                                  _Tp(0UL),
                                  -_Tp(3617UL) / _Tp(510UL),
                                  _Tp(0UL),
                                  _Tp(43867UL) / _Tp(798UL),
                                  _Tp(0UL),
                                  -_Tp(174611) / _Tp(330UL),
                                  _Tp(0UL),
                                  _Tp(854513UL) / _Tp(138UL),
                                  _Tp(0UL),
                                  -_Tp(236364091UL) / _Tp(2730UL),
                                  _Tp(0UL),
                                  _Tp(8553103UL) / _Tp(6UL),
                                  _Tp(0UL)};

    if (__n == 0)
      return _Tp(1);

    if (__n == 1)
      return -_Tp(1) / _Tp(2);

    if (__n % 2 == 1)
      return _Tp(0);

    if (__n < 28)
      return __num[__n];

    _Tp __fact = _Tp(1);
    if ((__n / 2) % 2 == 0)
      __fact *= _Tp(-1);
    for (unsigned int __k = 1; __k <= __n; ++__k)
      __fact *= __k / (_Tp(2) * __numeric_constants<_Tp>::__pi());
    __fact *= _Tp(2);

    _Tp __sum = _Tp(0);
    for (unsigned int __i = 1; __i < 1000; ++__i) {
      _Tp __term = std::pow(_Tp(__i), -_Tp(__n));
      if (__term < std::numeric_limits<_Tp>::epsilon())
        break;
      __sum += __term;
    }

    return __fact * __sum;
  }
# 139 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 3
  template <typename _Tp> inline _Tp __bernoulli(int __n) {
    return __bernoulli_series<_Tp>(__n);
  }
# 153 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 3
  template <typename _Tp> _Tp __log_gamma_bernoulli(_Tp __x) {
    _Tp __lg = (__x - _Tp(0.5L)) * std::log(__x) - __x +
               _Tp(0.5L) * std::log(_Tp(2) * __numeric_constants<_Tp>::__pi());

    const _Tp __xx = __x * __x;
    _Tp __help = _Tp(1) / __x;
    for (unsigned int __i = 1; __i < 20; ++__i) {
      const _Tp __2i = _Tp(2 * __i);
      __help /= __2i * (__2i - _Tp(1)) * __xx;
      __lg += __bernoulli<_Tp>(2 * __i) * __help;
    }

    return __lg;
  }
# 181 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 3
  template <typename _Tp> _Tp __log_gamma_lanczos(_Tp __x) {
    const _Tp __xm1 = __x - _Tp(1);

    static const _Tp __lanczos_cheb_7[9] = {
        _Tp(0.99999999999980993227684700473478L),
        _Tp(676.520368121885098567009190444019L),
        _Tp(-1259.13921672240287047156078755283L),
        _Tp(771.3234287776530788486528258894L),
        _Tp(-176.61502916214059906584551354L),
        _Tp(12.507343278686904814458936853L),
        _Tp(-0.13857109526572011689554707L),
        _Tp(9.984369578019570859563e-6L),
        _Tp(1.50563273514931155834e-7L)};

    static const _Tp __LOGROOT2PI = _Tp(0.9189385332046727417803297364056176L);

    _Tp __sum = __lanczos_cheb_7[0];
    for (unsigned int __k = 1; __k < 9; ++__k)
      __sum += __lanczos_cheb_7[__k] / (__xm1 + __k);

    const _Tp __term1 =
        (__xm1 + _Tp(0.5L)) *
        std::log((__xm1 + _Tp(7.5L)) / __numeric_constants<_Tp>::__euler());
    const _Tp __term2 = __LOGROOT2PI + std::log(__sum);
    const _Tp __result = __term1 + (__term2 - _Tp(7));

    return __result;
  }
# 225 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 3
  template <typename _Tp> _Tp __log_gamma(_Tp __x) {
    if (__x > _Tp(0.5L))
      return __log_gamma_lanczos(__x);
    else {
      const _Tp __sin_fact =
          std::abs(std::sin(__numeric_constants<_Tp>::__pi() * __x));
      if (__sin_fact == _Tp(0))
        std::__throw_domain_error(("Argument is nonpositive integer "
                                   "in __log_gamma"));

      return __numeric_constants<_Tp>::__lnpi() - std::log(__sin_fact) -
             __log_gamma_lanczos(_Tp(1) - __x);
    }
  }
# 252 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 3
  template <typename _Tp> _Tp __log_gamma_sign(_Tp __x) {
    if (__x > _Tp(0))
      return _Tp(1);
    else {
      const _Tp __sin_fact = std::sin(__numeric_constants<_Tp>::__pi() * __x);
      if (__sin_fact > _Tp(0))
        return (1);
      else if (__sin_fact < _Tp(0))
        return -_Tp(1);
      else
        return _Tp(0);
    }
  }
# 283 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 3
  template <typename _Tp>
  _Tp __log_bincoef(unsigned int __n, unsigned int __k) {

    static const _Tp __max_bincoeff =
        std::numeric_limits<_Tp>::max_exponent10 * std::log(_Tp(10)) - _Tp(1);

    _Tp __coeff = ::std::lgamma(_Tp(1 + __n)) - ::std::lgamma(_Tp(1 + __k)) -
                  ::std::lgamma(_Tp(1 + __n - __k));
  }
# 314 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 3
  template <typename _Tp> _Tp __bincoef(unsigned int __n, unsigned int __k) {

    static const _Tp __max_bincoeff =
        std::numeric_limits<_Tp>::max_exponent10 * std::log(_Tp(10)) - _Tp(1);

    const _Tp __log_coeff = __log_bincoef<_Tp>(__n, __k);
    if (__log_coeff > __max_bincoeff)
      return std::numeric_limits<_Tp>::quiet_NaN();
    else
      return std::exp(__log_coeff);
  }
# 337 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 3
  template <typename _Tp> inline _Tp __gamma(_Tp __x) {
    return std::exp(__log_gamma(__x));
  }
# 356 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 3
  template <typename _Tp> _Tp __psi_series(_Tp __x) {
    _Tp __sum = -__numeric_constants<_Tp>::__gamma_e() - _Tp(1) / __x;
    const unsigned int __max_iter = 100000;
    for (unsigned int __k = 1; __k < __max_iter; ++__k) {
      const _Tp __term = __x / (__k * (__k + __x));
      __sum += __term;
      if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
        break;
    }
    return __sum;
  }
# 386 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 3
  template <typename _Tp> _Tp __psi_asymp(_Tp __x) {
    _Tp __sum = std::log(__x) - _Tp(0.5L) / __x;
    const _Tp __xx = __x * __x;
    _Tp __xp = __xx;
    const unsigned int __max_iter = 100;
    for (unsigned int __k = 1; __k < __max_iter; ++__k) {
      const _Tp __term = __bernoulli<_Tp>(2 * __k) / (2 * __k * __xp);
      __sum -= __term;
      if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
        break;
      __xp *= __xx;
    }
    return __sum;
  }
# 417 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 3
  template <typename _Tp> _Tp __psi(_Tp __x) {
    const int __n = static_cast<int>(__x + 0.5L);
    const _Tp __eps = _Tp(4) * std::numeric_limits<_Tp>::epsilon();
    if (__n <= 0 && std::abs(__x - _Tp(__n)) < __eps)
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (__x < _Tp(0)) {
      const _Tp __pi = __numeric_constants<_Tp>::__pi();
      return __psi(_Tp(1) - __x) -
             __pi * std::cos(__pi * __x) / std::sin(__pi * __x);
    } else if (__x > _Tp(100))
      return __psi_asymp(__x);
    else
      return __psi_series(__x);
  }
# 446 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/gamma.tcc" 3
  template <typename _Tp> _Tp __psi(unsigned int __n, _Tp __x) {
    if (__x <= _Tp(0))
      std::__throw_domain_error(("Argument out of range "
                                 "in __psi"));

    else if (__n == 0)
      return __psi(__x);
    else {
      const _Tp __hzeta = __hurwitz_zeta(_Tp(__n + 1), __x);

      const _Tp __ln_nfact = ::std::lgamma(_Tp(__n + 1));

      _Tp __result = std::exp(__ln_nfact) * __hzeta;
      if (__n % 2 == 1)
        __result = -__result;
      return __result;
    }
  }
  } // namespace __detail

} // namespace std
# 48 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/bessel_function.tcc" 1 3
# 55 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/bessel_function.tcc" 3
namespace std __attribute__((__visibility__("default"))) {
# 71 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/bessel_function.tcc" 3
  namespace __detail {
# 98 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/bessel_function.tcc" 3
  template <typename _Tp>
  void __gamma_temme(_Tp __mu, _Tp &__gam1, _Tp &__gam2, _Tp &__gampl,
                     _Tp &__gammi) {

    __gampl = _Tp(1) / ::std::tgamma(_Tp(1) + __mu);
    __gammi = _Tp(1) / ::std::tgamma(_Tp(1) - __mu);

    if (std::abs(__mu) < std::numeric_limits<_Tp>::epsilon())
      __gam1 = -_Tp(__numeric_constants<_Tp>::__gamma_e());
    else
      __gam1 = (__gammi - __gampl) / (_Tp(2) * __mu);

    __gam2 = (__gammi + __gampl) / (_Tp(2));

    return;
  }
# 136 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/bessel_function.tcc" 3
  template <typename _Tp>
  void __bessel_jn(_Tp __nu, _Tp __x, _Tp &__Jnu, _Tp &__Nnu, _Tp &__Jpnu,
                   _Tp &__Npnu) {
    if (__x == _Tp(0)) {
      if (__nu == _Tp(0)) {
        __Jnu = _Tp(1);
        __Jpnu = _Tp(0);
      } else if (__nu == _Tp(1)) {
        __Jnu = _Tp(0);
        __Jpnu = _Tp(0.5L);
      } else {
        __Jnu = _Tp(0);
        __Jpnu = _Tp(0);
      }
      __Nnu = -std::numeric_limits<_Tp>::infinity();
      __Npnu = std::numeric_limits<_Tp>::infinity();
      return;
    }

    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

    const _Tp __fp_min = std::sqrt(std::numeric_limits<_Tp>::min());
    const int __max_iter = 15000;
    const _Tp __x_min = _Tp(2);

    const int __nl =
        (__x < __x_min ? static_cast<int>(__nu + _Tp(0.5L))
                       : std::max(0, static_cast<int>(__nu - __x + _Tp(1.5L))));

    const _Tp __mu = __nu - __nl;
    const _Tp __mu2 = __mu * __mu;
    const _Tp __xi = _Tp(1) / __x;
    const _Tp __xi2 = _Tp(2) * __xi;
    _Tp __w = __xi2 / __numeric_constants<_Tp>::__pi();
    int __isign = 1;
    _Tp __h = __nu * __xi;
    if (__h < __fp_min)
      __h = __fp_min;
    _Tp __b = __xi2 * __nu;
    _Tp __d = _Tp(0);
    _Tp __c = __h;
    int __i;
    for (__i = 1; __i <= __max_iter; ++__i) {
      __b += __xi2;
      __d = __b - __d;
      if (std::abs(__d) < __fp_min)
        __d = __fp_min;
      __c = __b - _Tp(1) / __c;
      if (std::abs(__c) < __fp_min)
        __c = __fp_min;
      __d = _Tp(1) / __d;
      const _Tp __del = __c * __d;
      __h *= __del;
      if (__d < _Tp(0))
        __isign = -__isign;
      if (std::abs(__del - _Tp(1)) < __eps)
        break;
    }
    if (__i > __max_iter)
      std::__throw_runtime_error(("Argument x too large in __bessel_jn; "
                                  "try asymptotic expansion."));

    _Tp __Jnul = __isign * __fp_min;
    _Tp __Jpnul = __h * __Jnul;
    _Tp __Jnul1 = __Jnul;
    _Tp __Jpnu1 = __Jpnul;
    _Tp __fact = __nu * __xi;
    for (int __l = __nl; __l >= 1; --__l) {
      const _Tp __Jnutemp = __fact * __Jnul + __Jpnul;
      __fact -= __xi;
      __Jpnul = __fact * __Jnutemp - __Jnul;
      __Jnul = __Jnutemp;
    }
    if (__Jnul == _Tp(0))
      __Jnul = __eps;
    _Tp __f = __Jpnul / __Jnul;
    _Tp __Nmu, __Nnu1, __Npmu, __Jmu;
    if (__x < __x_min) {
      const _Tp __x2 = __x / _Tp(2);
      const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
      _Tp __fact =
          (std::abs(__pimu) < __eps ? _Tp(1) : __pimu / std::sin(__pimu));
      _Tp __d = -std::log(__x2);
      _Tp __e = __mu * __d;
      _Tp __fact2 = (std::abs(__e) < __eps ? _Tp(1) : std::sinh(__e) / __e);
      _Tp __gam1, __gam2, __gampl, __gammi;
      __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
      _Tp __ff = (_Tp(2) / __numeric_constants<_Tp>::__pi()) * __fact *
                 (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
      __e = std::exp(__e);
      _Tp __p = __e / (__numeric_constants<_Tp>::__pi() * __gampl);
      _Tp __q = _Tp(1) / (__e * __numeric_constants<_Tp>::__pi() * __gammi);
      const _Tp __pimu2 = __pimu / _Tp(2);
      _Tp __fact3 =
          (std::abs(__pimu2) < __eps ? _Tp(1) : std::sin(__pimu2) / __pimu2);
      _Tp __r = __numeric_constants<_Tp>::__pi() * __pimu2 * __fact3 * __fact3;
      _Tp __c = _Tp(1);
      __d = -__x2 * __x2;
      _Tp __sum = __ff + __r * __q;
      _Tp __sum1 = __p;
      for (__i = 1; __i <= __max_iter; ++__i) {
        __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
        __c *= __d / _Tp(__i);
        __p /= _Tp(__i) - __mu;
        __q /= _Tp(__i) + __mu;
        const _Tp __del = __c * (__ff + __r * __q);
        __sum += __del;
        const _Tp __del1 = __c * __p - __i * __del;
        __sum1 += __del1;
        if (std::abs(__del) < __eps * (_Tp(1) + std::abs(__sum)))
          break;
      }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Bessel y series failed to converge "
                                    "in __bessel_jn."));

      __Nmu = -__sum;
      __Nnu1 = -__sum1 * __xi2;
      __Npmu = __mu * __xi * __Nmu - __Nnu1;
      __Jmu = __w / (__Npmu - __f * __Nmu);
    } else {
      _Tp __a = _Tp(0.25L) - __mu2;
      _Tp __q = _Tp(1);
      _Tp __p = -__xi / _Tp(2);
      _Tp __br = _Tp(2) * __x;
      _Tp __bi = _Tp(2);
      _Tp __fact = __a * __xi / (__p * __p + __q * __q);
      _Tp __cr = __br + __q * __fact;
      _Tp __ci = __bi + __p * __fact;
      _Tp __den = __br * __br + __bi * __bi;
      _Tp __dr = __br / __den;
      _Tp __di = -__bi / __den;
      _Tp __dlr = __cr * __dr - __ci * __di;
      _Tp __dli = __cr * __di + __ci * __dr;
      _Tp __temp = __p * __dlr - __q * __dli;
      __q = __p * __dli + __q * __dlr;
      __p = __temp;
      int __i;
      for (__i = 2; __i <= __max_iter; ++__i) {
        __a += _Tp(2 * (__i - 1));
        __bi += _Tp(2);
        __dr = __a * __dr + __br;
        __di = __a * __di + __bi;
        if (std::abs(__dr) + std::abs(__di) < __fp_min)
          __dr = __fp_min;
        __fact = __a / (__cr * __cr + __ci * __ci);
        __cr = __br + __cr * __fact;
        __ci = __bi - __ci * __fact;
        if (std::abs(__cr) + std::abs(__ci) < __fp_min)
          __cr = __fp_min;
        __den = __dr * __dr + __di * __di;
        __dr /= __den;
        __di /= -__den;
        __dlr = __cr * __dr - __ci * __di;
        __dli = __cr * __di + __ci * __dr;
        __temp = __p * __dlr - __q * __dli;
        __q = __p * __dli + __q * __dlr;
        __p = __temp;
        if (std::abs(__dlr - _Tp(1)) + std::abs(__dli) < __eps)
          break;
      }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Lentz's method failed "
                                    "in __bessel_jn."));

      const _Tp __gam = (__p - __f) / __q;
      __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));

      __Jmu = ::std::copysign(__Jmu, __Jnul);

      __Nmu = __gam * __Jmu;
      __Npmu = (__p + __q / __gam) * __Nmu;
      __Nnu1 = __mu * __xi * __Nmu - __Npmu;
    }
    __fact = __Jmu / __Jnul;
    __Jnu = __fact * __Jnul1;
    __Jpnu = __fact * __Jpnu1;
    for (__i = 1; __i <= __nl; ++__i) {
      const _Tp __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
      __Nmu = __Nnu1;
      __Nnu1 = __Nnutemp;
    }
    __Nnu = __Nmu;
    __Npnu = __nu * __xi * __Nmu - __Nnu1;

    return;
  }
# 361 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/bessel_function.tcc" 3
  template <typename _Tp>
  void __cyl_bessel_jn_asymp(_Tp __nu, _Tp __x, _Tp &__Jnu, _Tp &__Nnu) {
    const _Tp __mu = _Tp(4) * __nu * __nu;
    const _Tp __8x = _Tp(8) * __x;

    _Tp __P = _Tp(0);
    _Tp __Q = _Tp(0);

    _Tp __k = _Tp(0);
    _Tp __term = _Tp(1);

    int __epsP = 0;
    int __epsQ = 0;

    _Tp __eps = std::numeric_limits<_Tp>::epsilon();

    do {
      __term *=
          (__k == 0 ? _Tp(1)
                    : -(__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x));

      __epsP = std::abs(__term) < __eps * std::abs(__P);
      __P += __term;

      __k++;

      __term *= (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x);
      __epsQ = std::abs(__term) < __eps * std::abs(__Q);
      __Q += __term;

      if (__epsP && __epsQ && __k > (__nu / 2.))
        break;

      __k++;
    } while (__k < 1000);

    const _Tp __chi =
        __x - (__nu + _Tp(0.5L)) * __numeric_constants<_Tp>::__pi_2();

    const _Tp __c = std::cos(__chi);
    const _Tp __s = std::sin(__chi);

    const _Tp __coef =
        std::sqrt(_Tp(2) / (__numeric_constants<_Tp>::__pi() * __x));

    __Jnu = __coef * (__c * __P - __s * __Q);
    __Nnu = __coef * (__s * __P + __c * __Q);

    return;
  }
# 444 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/bessel_function.tcc" 3
  template <typename _Tp>
  _Tp __cyl_bessel_ij_series(_Tp __nu, _Tp __x, _Tp __sgn,
                             unsigned int __max_iter) {
    if (__x == _Tp(0))
      return __nu == _Tp(0) ? _Tp(1) : _Tp(0);

    const _Tp __x2 = __x / _Tp(2);
    _Tp __fact = __nu * std::log(__x2);

    __fact -= ::std::lgamma(__nu + _Tp(1));

    __fact = std::exp(__fact);
    const _Tp __xx4 = __sgn * __x2 * __x2;
    _Tp __Jn = _Tp(1);
    _Tp __term = _Tp(1);

    for (unsigned int __i = 1; __i < __max_iter; ++__i) {
      __term *= __xx4 / (_Tp(__i) * (__nu + _Tp(__i)));
      __Jn += __term;
      if (std::abs(__term / __Jn) < std::numeric_limits<_Tp>::epsilon())
        break;
    }

    return __fact * __Jn;
  }
# 490 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/bessel_function.tcc" 3
  template <typename _Tp> _Tp __cyl_bessel_j(_Tp __nu, _Tp __x) {
    if (__nu < _Tp(0) || __x < _Tp(0))
      std::__throw_domain_error(("Bad argument "
                                 "in __cyl_bessel_j."));

    else if (__isnan(__nu) || __isnan(__x))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
      return __cyl_bessel_ij_series(__nu, __x, -_Tp(1), 200);
    else if (__x > _Tp(1000)) {
      _Tp __J_nu, __N_nu;
      __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
      return __J_nu;
    } else {
      _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
      __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
      return __J_nu;
    }
  }
# 532 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/bessel_function.tcc" 3
  template <typename _Tp> _Tp __cyl_neumann_n(_Tp __nu, _Tp __x) {
    if (__nu < _Tp(0) || __x < _Tp(0))
      std::__throw_domain_error(("Bad argument "
                                 "in __cyl_neumann_n."));

    else if (__isnan(__nu) || __isnan(__x))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (__x > _Tp(1000)) {
      _Tp __J_nu, __N_nu;
      __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
      return __N_nu;
    } else {
      _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
      __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
      return __N_nu;
    }
  }
# 569 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/bessel_function.tcc" 3
  template <typename _Tp>
  void __sph_bessel_jn(unsigned int __n, _Tp __x, _Tp &__j_n, _Tp &__n_n,
                       _Tp &__jp_n, _Tp &__np_n) {
    const _Tp __nu = _Tp(__n) + _Tp(0.5L);

    _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
    __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);

    const _Tp __factor =
        __numeric_constants<_Tp>::__sqrtpio2() / std::sqrt(__x);

    __j_n = __factor * __J_nu;
    __n_n = __factor * __N_nu;
    __jp_n = __factor * __Jp_nu - __j_n / (_Tp(2) * __x);
    __np_n = __factor * __Np_nu - __n_n / (_Tp(2) * __x);

    return;
  }
# 604 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/bessel_function.tcc" 3
  template <typename _Tp> _Tp __sph_bessel(unsigned int __n, _Tp __x) {
    if (__x < _Tp(0))
      std::__throw_domain_error(("Bad argument "
                                 "in __sph_bessel."));

    else if (__isnan(__x))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (__x == _Tp(0)) {
      if (__n == 0)
        return _Tp(1);
      else
        return _Tp(0);
    } else {
      _Tp __j_n, __n_n, __jp_n, __np_n;
      __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
      return __j_n;
    }
  }
# 642 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/bessel_function.tcc" 3
  template <typename _Tp> _Tp __sph_neumann(unsigned int __n, _Tp __x) {
    if (__x < _Tp(0))
      std::__throw_domain_error(("Bad argument "
                                 "in __sph_neumann."));

    else if (__isnan(__x))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (__x == _Tp(0))
      return -std::numeric_limits<_Tp>::infinity();
    else {
      _Tp __j_n, __n_n, __jp_n, __np_n;
      __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
      return __n_n;
    }
  }
  } // namespace __detail

} // namespace std
# 49 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/beta_function.tcc" 1 3
# 49 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/beta_function.tcc" 3
namespace std __attribute__((__visibility__("default"))) {
# 65 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/beta_function.tcc" 3
  namespace __detail {
# 79 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/beta_function.tcc" 3
  template <typename _Tp> _Tp __beta_gamma(_Tp __x, _Tp __y) {

    _Tp __bet;

    if (__x > __y) {
      __bet = ::std::tgamma(__x) / ::std::tgamma(__x + __y);
      __bet *= ::std::tgamma(__y);
    } else {
      __bet = ::std::tgamma(__y) / ::std::tgamma(__x + __y);
      __bet *= ::std::tgamma(__x);
    }
# 111 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/beta_function.tcc" 3
    return __bet;
  }
# 127 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/beta_function.tcc" 3
  template <typename _Tp> _Tp __beta_lgamma(_Tp __x, _Tp __y) {

    _Tp __bet =
        ::std::lgamma(__x) + ::std::lgamma(__y) - ::std::lgamma(__x + __y);

    __bet = std::exp(__bet);
    return __bet;
  }
# 158 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/beta_function.tcc" 3
  template <typename _Tp> _Tp __beta_product(_Tp __x, _Tp __y) {

    _Tp __bet = (__x + __y) / (__x * __y);

    unsigned int __max_iter = 1000000;
    for (unsigned int __k = 1; __k < __max_iter; ++__k) {
      _Tp __term = (_Tp(1) + (__x + __y) / __k) /
                   ((_Tp(1) + __x / __k) * (_Tp(1) + __y / __k));
      __bet *= __term;
    }

    return __bet;
  }
# 189 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/beta_function.tcc" 3
  template <typename _Tp> inline _Tp __beta(_Tp __x, _Tp __y) {
    if (__isnan(__x) || __isnan(__y))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else
      return __beta_lgamma(__x, __y);
  }
  } // namespace __detail

} // namespace std
# 50 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/ell_integral.tcc" 1 3
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/ell_integral.tcc" 3
namespace std __attribute__((__visibility__("default"))) {
# 59 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/ell_integral.tcc" 3
  namespace __detail {
# 76 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/ell_integral.tcc" 3
  template <typename _Tp> _Tp __ellint_rf(_Tp __x, _Tp __y, _Tp __z) {
    const _Tp __min = std::numeric_limits<_Tp>::min();
    const _Tp __lolim = _Tp(5) * __min;

    if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
      std::__throw_domain_error(("Argument less than zero "
                                 "in __ellint_rf."));

    else if (__x + __y < __lolim || __x + __z < __lolim || __y + __z < __lolim)
      std::__throw_domain_error(("Argument too small in __ellint_rf"));
    else {
      const _Tp __c0 = _Tp(1) / _Tp(4);
      const _Tp __c1 = _Tp(1) / _Tp(24);
      const _Tp __c2 = _Tp(1) / _Tp(10);
      const _Tp __c3 = _Tp(3) / _Tp(44);
      const _Tp __c4 = _Tp(1) / _Tp(14);

      _Tp __xn = __x;
      _Tp __yn = __y;
      _Tp __zn = __z;

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __errtol = std::pow(__eps, _Tp(1) / _Tp(6));
      _Tp __mu;
      _Tp __xndev, __yndev, __zndev;

      const unsigned int __max_iter = 100;
      for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
        __mu = (__xn + __yn + __zn) / _Tp(3);
        __xndev = 2 - (__mu + __xn) / __mu;
        __yndev = 2 - (__mu + __yn) / __mu;
        __zndev = 2 - (__mu + __zn) / __mu;
        _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
        __epsilon = std::max(__epsilon, std::abs(__zndev));
        if (__epsilon < __errtol)
          break;
        const _Tp __xnroot = std::sqrt(__xn);
        const _Tp __ynroot = std::sqrt(__yn);
        const _Tp __znroot = std::sqrt(__zn);
        const _Tp __lambda =
            __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
        __xn = __c0 * (__xn + __lambda);
        __yn = __c0 * (__yn + __lambda);
        __zn = __c0 * (__zn + __lambda);
      }

      const _Tp __e2 = __xndev * __yndev - __zndev * __zndev;
      const _Tp __e3 = __xndev * __yndev * __zndev;
      const _Tp __s =
          _Tp(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2 + __c4 * __e3;

      return __s / std::sqrt(__mu);
    }
  }
# 153 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/ell_integral.tcc" 3
  template <typename _Tp> _Tp __comp_ellint_1_series(_Tp __k) {

    const _Tp __kk = __k * __k;

    _Tp __term = __kk / _Tp(4);
    _Tp __sum = _Tp(1) + __term;

    const unsigned int __max_iter = 1000;
    for (unsigned int __i = 2; __i < __max_iter; ++__i) {
      __term *= (2 * __i - 1) * __kk / (2 * __i);
      if (__term < std::numeric_limits<_Tp>::epsilon())
        break;
      __sum += __term;
    }

    return __numeric_constants<_Tp>::__pi_2() * __sum;
  }
# 191 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/ell_integral.tcc" 3
  template <typename _Tp> _Tp __comp_ellint_1(_Tp __k) {

    if (__isnan(__k))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (std::abs(__k) >= _Tp(1))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else
      return __ellint_rf(_Tp(0), _Tp(1) - __k * __k, _Tp(1));
  }
# 219 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/ell_integral.tcc" 3
  template <typename _Tp> _Tp __ellint_1(_Tp __k, _Tp __phi) {

    if (__isnan(__k) || __isnan(__phi))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (std::abs(__k) > _Tp(1))
      std::__throw_domain_error(("Bad argument in __ellint_1."));
    else {

      const int __n =
          std::floor(__phi / __numeric_constants<_Tp>::__pi() + _Tp(0.5L));
      const _Tp __phi_red = __phi - __n * __numeric_constants<_Tp>::__pi();

      const _Tp __s = std::sin(__phi_red);
      const _Tp __c = std::cos(__phi_red);

      const _Tp __F =
          __s * __ellint_rf(__c * __c, _Tp(1) - __k * __k * __s * __s, _Tp(1));

      if (__n == 0)
        return __F;
      else
        return __F + _Tp(2) * __n * __comp_ellint_1(__k);
    }
  }
# 266 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/ell_integral.tcc" 3
  template <typename _Tp> _Tp __comp_ellint_2_series(_Tp __k) {

    const _Tp __kk = __k * __k;

    _Tp __term = __kk;
    _Tp __sum = __term;

    const unsigned int __max_iter = 1000;
    for (unsigned int __i = 2; __i < __max_iter; ++__i) {
      const _Tp __i2m = 2 * __i - 1;
      const _Tp __i2 = 2 * __i;
      __term *= __i2m * __i2m * __kk / (__i2 * __i2);
      if (__term < std::numeric_limits<_Tp>::epsilon())
        break;
      __sum += __term / __i2m;
    }

    return __numeric_constants<_Tp>::__pi_2() * (_Tp(1) - __sum);
  }
# 314 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/ell_integral.tcc" 3
  template <typename _Tp> _Tp __ellint_rd(_Tp __x, _Tp __y, _Tp __z) {
    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
    const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));
    const _Tp __max = std::numeric_limits<_Tp>::max();
    const _Tp __lolim = _Tp(2) / std::pow(__max, _Tp(2) / _Tp(3));

    if (__x < _Tp(0) || __y < _Tp(0))
      std::__throw_domain_error(("Argument less than zero "
                                 "in __ellint_rd."));

    else if (__x + __y < __lolim || __z < __lolim)
      std::__throw_domain_error(("Argument too small "
                                 "in __ellint_rd."));

    else {
      const _Tp __c0 = _Tp(1) / _Tp(4);
      const _Tp __c1 = _Tp(3) / _Tp(14);
      const _Tp __c2 = _Tp(1) / _Tp(6);
      const _Tp __c3 = _Tp(9) / _Tp(22);
      const _Tp __c4 = _Tp(3) / _Tp(26);

      _Tp __xn = __x;
      _Tp __yn = __y;
      _Tp __zn = __z;
      _Tp __sigma = _Tp(0);
      _Tp __power4 = _Tp(1);

      _Tp __mu;
      _Tp __xndev, __yndev, __zndev;

      const unsigned int __max_iter = 100;
      for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
        __mu = (__xn + __yn + _Tp(3) * __zn) / _Tp(5);
        __xndev = (__mu - __xn) / __mu;
        __yndev = (__mu - __yn) / __mu;
        __zndev = (__mu - __zn) / __mu;
        _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
        __epsilon = std::max(__epsilon, std::abs(__zndev));
        if (__epsilon < __errtol)
          break;
        _Tp __xnroot = std::sqrt(__xn);
        _Tp __ynroot = std::sqrt(__yn);
        _Tp __znroot = std::sqrt(__zn);
        _Tp __lambda = __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
        __sigma += __power4 / (__znroot * (__zn + __lambda));
        __power4 *= __c0;
        __xn = __c0 * (__xn + __lambda);
        __yn = __c0 * (__yn + __lambda);
        __zn = __c0 * (__zn + __lambda);
      }

      _Tp __ea = __xndev * __yndev;
      _Tp __eb = __zndev * __zndev;
      _Tp __ec = __ea - __eb;
      _Tp __ed = __ea - _Tp(6) * __eb;
      _Tp __ef = __ed + __ec + __ec;
      _Tp __s1 = __ed * (-__c1 + __c3 * __ed / _Tp(3) -
                         _Tp(3) * __c4 * __zndev * __ef / _Tp(2));
      _Tp __s2 = __zndev * (__c2 * __ef +
                            __zndev * (-__c3 * __ec - __zndev * __c4 - __ea));

      return _Tp(3) * __sigma +
             __power4 * (_Tp(1) + __s1 + __s2) / (__mu * std::sqrt(__mu));
    }
  }
# 399 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/ell_integral.tcc" 3
  template <typename _Tp> _Tp __comp_ellint_2(_Tp __k) {

    if (__isnan(__k))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (std::abs(__k) == 1)
      return _Tp(1);
    else if (std::abs(__k) > _Tp(1))
      std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
    else {
      const _Tp __kk = __k * __k;

      return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1)) -
             __kk * __ellint_rd(_Tp(0), _Tp(1) - __kk, _Tp(1)) / _Tp(3);
    }
  }
# 433 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/ell_integral.tcc" 3
  template <typename _Tp> _Tp __ellint_2(_Tp __k, _Tp __phi) {

    if (__isnan(__k) || __isnan(__phi))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (std::abs(__k) > _Tp(1))
      std::__throw_domain_error(("Bad argument in __ellint_2."));
    else {

      const int __n =
          std::floor(__phi / __numeric_constants<_Tp>::__pi() + _Tp(0.5L));
      const _Tp __phi_red = __phi - __n * __numeric_constants<_Tp>::__pi();

      const _Tp __kk = __k * __k;
      const _Tp __s = std::sin(__phi_red);
      const _Tp __ss = __s * __s;
      const _Tp __sss = __ss * __s;
      const _Tp __c = std::cos(__phi_red);
      const _Tp __cc = __c * __c;

      const _Tp __E = __s * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1)) -
                      __kk * __sss *
                          __ellint_rd(__cc, _Tp(1) - __kk * __ss, _Tp(1)) /
                          _Tp(3);

      if (__n == 0)
        return __E;
      else
        return __E + _Tp(2) * __n * __comp_ellint_2(__k);
    }
  }
# 492 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/ell_integral.tcc" 3
  template <typename _Tp> _Tp __ellint_rc(_Tp __x, _Tp __y) {
    const _Tp __min = std::numeric_limits<_Tp>::min();
    const _Tp __lolim = _Tp(5) * __min;

    if (__x < _Tp(0) || __y < _Tp(0) || __x + __y < __lolim)
      std::__throw_domain_error(("Argument less than zero "
                                 "in __ellint_rc."));

    else {
      const _Tp __c0 = _Tp(1) / _Tp(4);
      const _Tp __c1 = _Tp(1) / _Tp(7);
      const _Tp __c2 = _Tp(9) / _Tp(22);
      const _Tp __c3 = _Tp(3) / _Tp(10);
      const _Tp __c4 = _Tp(3) / _Tp(8);

      _Tp __xn = __x;
      _Tp __yn = __y;

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __errtol = std::pow(__eps / _Tp(30), _Tp(1) / _Tp(6));
      _Tp __mu;
      _Tp __sn;

      const unsigned int __max_iter = 100;
      for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
        __mu = (__xn + _Tp(2) * __yn) / _Tp(3);
        __sn = (__yn + __mu) / __mu - _Tp(2);
        if (std::abs(__sn) < __errtol)
          break;
        const _Tp __lambda = _Tp(2) * std::sqrt(__xn) * std::sqrt(__yn) + __yn;
        __xn = __c0 * (__xn + __lambda);
        __yn = __c0 * (__yn + __lambda);
      }

      _Tp __s =
          __sn * __sn * (__c3 + __sn * (__c1 + __sn * (__c4 + __sn * __c2)));

      return (_Tp(1) + __s) / std::sqrt(__mu);
    }
  }
# 561 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/ell_integral.tcc" 3
  template <typename _Tp> _Tp __ellint_rj(_Tp __x, _Tp __y, _Tp __z, _Tp __p) {
    const _Tp __min = std::numeric_limits<_Tp>::min();
    const _Tp __lolim = std::pow(_Tp(5) * __min, _Tp(1) / _Tp(3));

    if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
      std::__throw_domain_error(("Argument less than zero "
                                 "in __ellint_rj."));

    else if (__x + __y < __lolim || __x + __z < __lolim ||
             __y + __z < __lolim || __p < __lolim)
      std::__throw_domain_error(("Argument too small "
                                 "in __ellint_rj"));

    else {
      const _Tp __c0 = _Tp(1) / _Tp(4);
      const _Tp __c1 = _Tp(3) / _Tp(14);
      const _Tp __c2 = _Tp(1) / _Tp(3);
      const _Tp __c3 = _Tp(3) / _Tp(22);
      const _Tp __c4 = _Tp(3) / _Tp(26);

      _Tp __xn = __x;
      _Tp __yn = __y;
      _Tp __zn = __z;
      _Tp __pn = __p;
      _Tp __sigma = _Tp(0);
      _Tp __power4 = _Tp(1);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));

      _Tp __mu;
      _Tp __xndev, __yndev, __zndev, __pndev;

      const unsigned int __max_iter = 100;
      for (unsigned int __iter = 0; __iter < __max_iter; ++__iter) {
        __mu = (__xn + __yn + __zn + _Tp(2) * __pn) / _Tp(5);
        __xndev = (__mu - __xn) / __mu;
        __yndev = (__mu - __yn) / __mu;
        __zndev = (__mu - __zn) / __mu;
        __pndev = (__mu - __pn) / __mu;
        _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
        __epsilon = std::max(__epsilon, std::abs(__zndev));
        __epsilon = std::max(__epsilon, std::abs(__pndev));
        if (__epsilon < __errtol)
          break;
        const _Tp __xnroot = std::sqrt(__xn);
        const _Tp __ynroot = std::sqrt(__yn);
        const _Tp __znroot = std::sqrt(__zn);
        const _Tp __lambda =
            __xnroot * (__ynroot + __znroot) + __ynroot * __znroot;
        const _Tp __alpha1 = __pn * (__xnroot + __ynroot + __znroot) +
                             __xnroot * __ynroot * __znroot;
        const _Tp __alpha2 = __alpha1 * __alpha1;
        const _Tp __beta = __pn * (__pn + __lambda) * (__pn + __lambda);
        __sigma += __power4 * __ellint_rc(__alpha2, __beta);
        __power4 *= __c0;
        __xn = __c0 * (__xn + __lambda);
        __yn = __c0 * (__yn + __lambda);
        __zn = __c0 * (__zn + __lambda);
        __pn = __c0 * (__pn + __lambda);
      }

      _Tp __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;
      _Tp __eb = __xndev * __yndev * __zndev;
      _Tp __ec = __pndev * __pndev;
      _Tp __e2 = __ea - _Tp(3) * __ec;
      _Tp __e3 = __eb + _Tp(2) * __pndev * (__ea - __ec);
      _Tp __s1 = _Tp(1) + __e2 * (-__c1 + _Tp(3) * __c3 * __e2 / _Tp(4) -
                                  _Tp(3) * __c4 * __e3 / _Tp(2));
      _Tp __s2 =
          __eb * (__c2 / _Tp(2) + __pndev * (-__c3 - __c3 + __pndev * __c4));
      _Tp __s3 =
          __pndev * __ea * (__c2 - __pndev * __c3) - __c2 * __pndev * __ec;

      return _Tp(3) * __sigma +
             __power4 * (__s1 + __s2 + __s3) / (__mu * std::sqrt(__mu));
    }
  }
# 661 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/ell_integral.tcc" 3
  template <typename _Tp> _Tp __comp_ellint_3(_Tp __k, _Tp __nu) {

    if (__isnan(__k) || __isnan(__nu))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (__nu == _Tp(1))
      return std::numeric_limits<_Tp>::infinity();
    else if (std::abs(__k) > _Tp(1))
      std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
    else {
      const _Tp __kk = __k * __k;

      return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1)) +
             __nu * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) - __nu) /
                 _Tp(3);
    }
  }
# 701 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/ell_integral.tcc" 3
  template <typename _Tp> _Tp __ellint_3(_Tp __k, _Tp __nu, _Tp __phi) {

    if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (std::abs(__k) > _Tp(1))
      std::__throw_domain_error(("Bad argument in __ellint_3."));
    else {

      const int __n =
          std::floor(__phi / __numeric_constants<_Tp>::__pi() + _Tp(0.5L));
      const _Tp __phi_red = __phi - __n * __numeric_constants<_Tp>::__pi();

      const _Tp __kk = __k * __k;
      const _Tp __s = std::sin(__phi_red);
      const _Tp __ss = __s * __s;
      const _Tp __sss = __ss * __s;
      const _Tp __c = std::cos(__phi_red);
      const _Tp __cc = __c * __c;

      const _Tp __Pi = __s * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1)) +
                       __nu * __sss *
                           __ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1),
                                       _Tp(1) - __nu * __ss) /
                           _Tp(3);

      if (__n == 0)
        return __Pi;
      else
        return __Pi + _Tp(2) * __n * __comp_ellint_3(__k, __nu);
    }
  }
  } // namespace __detail

} // namespace std
# 51 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/exp_integral.tcc" 1 3
# 50 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/exp_integral.tcc" 3
namespace std __attribute__((__visibility__("default"))) {
# 64 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/exp_integral.tcc" 3
  namespace __detail {
  template <typename _Tp> _Tp __expint_E1(_Tp);
# 81 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/exp_integral.tcc" 3
  template <typename _Tp> _Tp __expint_E1_series(_Tp __x) {
    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
    _Tp __term = _Tp(1);
    _Tp __esum = _Tp(0);
    _Tp __osum = _Tp(0);
    const unsigned int __max_iter = 1000;
    for (unsigned int __i = 1; __i < __max_iter; ++__i) {
      __term *= -__x / __i;
      if (std::abs(__term) < __eps)
        break;
      if (__term >= _Tp(0))
        __esum += __term / __i;
      else
        __osum += __term / __i;
    }

    return -__esum - __osum - __numeric_constants<_Tp>::__gamma_e() -
           std::log(__x);
  }
# 118 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/exp_integral.tcc" 3
  template <typename _Tp> _Tp __expint_E1_asymp(_Tp __x) {
    _Tp __term = _Tp(1);
    _Tp __esum = _Tp(1);
    _Tp __osum = _Tp(0);
    const unsigned int __max_iter = 1000;
    for (unsigned int __i = 1; __i < __max_iter; ++__i) {
      _Tp __prev = __term;
      __term *= -__i / __x;
      if (std::abs(__term) > std::abs(__prev))
        break;
      if (__term >= _Tp(0))
        __esum += __term;
      else
        __osum += __term;
    }

    return std::exp(-__x) * (__esum + __osum) / __x;
  }
# 155 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/exp_integral.tcc" 3
  template <typename _Tp> _Tp __expint_En_series(unsigned int __n, _Tp __x) {
    const unsigned int __max_iter = 1000;
    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
    const int __nm1 = __n - 1;
    _Tp __ans =
        (__nm1 != 0 ? _Tp(1) / __nm1
                    : -std::log(__x) - __numeric_constants<_Tp>::__gamma_e());
    _Tp __fact = _Tp(1);
    for (int __i = 1; __i <= __max_iter; ++__i) {
      __fact *= -__x / _Tp(__i);
      _Tp __del;
      if (__i != __nm1)
        __del = -__fact / _Tp(__i - __nm1);
      else {
        _Tp __psi = -__numeric_constants<_Tp>::gamma_e();
        for (int __ii = 1; __ii <= __nm1; ++__ii)
          __psi += _Tp(1) / _Tp(__ii);
        __del = __fact * (__psi - std::log(__x));
      }
      __ans += __del;
      if (std::abs(__del) < __eps * std::abs(__ans))
        return __ans;
    }
    std::__throw_runtime_error(("Series summation failed "
                                "in __expint_En_series."));
  }
# 201 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/exp_integral.tcc" 3
  template <typename _Tp> _Tp __expint_En_cont_frac(unsigned int __n, _Tp __x) {
    const unsigned int __max_iter = 1000;
    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
    const _Tp __fp_min = std::numeric_limits<_Tp>::min();
    const int __nm1 = __n - 1;
    _Tp __b = __x + _Tp(__n);
    _Tp __c = _Tp(1) / __fp_min;
    _Tp __d = _Tp(1) / __b;
    _Tp __h = __d;
    for (unsigned int __i = 1; __i <= __max_iter; ++__i) {
      _Tp __a = -_Tp(__i * (__nm1 + __i));
      __b += _Tp(2);
      __d = _Tp(1) / (__a * __d + __b);
      __c = __b + __a / __c;
      const _Tp __del = __c * __d;
      __h *= __del;
      if (std::abs(__del - _Tp(1)) < __eps) {
        const _Tp __ans = __h * std::exp(-__x);
        return __ans;
      }
    }
    std::__throw_runtime_error(("Continued fraction failed "
                                "in __expint_En_cont_frac."));
  }
# 246 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/exp_integral.tcc" 3
  template <typename _Tp> _Tp __expint_En_recursion(unsigned int __n, _Tp __x) {
    _Tp __En;
    _Tp __E1 = __expint_E1(__x);
    if (__x < _Tp(__n)) {

      __En = __E1;
      for (unsigned int __j = 2; __j < __n; ++__j)
        __En = (std::exp(-__x) - __x * __En) / _Tp(__j - 1);
    } else {

      __En = _Tp(1);
      const int __N = __n + 20;
      _Tp __save = _Tp(0);
      for (int __j = __N; __j > 0; --__j) {
        __En = (std::exp(-__x) - __j * __En) / __x;
        if (__j == __n)
          __save = __En;
      }
      _Tp __norm = __En / __E1;
      __En /= __norm;
    }

    return __En;
  }
# 290 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/exp_integral.tcc" 3
  template <typename _Tp> _Tp __expint_Ei_series(_Tp __x) {
    _Tp __term = _Tp(1);
    _Tp __sum = _Tp(0);
    const unsigned int __max_iter = 1000;
    for (unsigned int __i = 1; __i < __max_iter; ++__i) {
      __term *= __x / __i;
      __sum += __term / __i;
      if (__term < std::numeric_limits<_Tp>::epsilon() * __sum)
        break;
    }

    return __numeric_constants<_Tp>::__gamma_e() + __sum + std::log(__x);
  }
# 321 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/exp_integral.tcc" 3
  template <typename _Tp> _Tp __expint_Ei_asymp(_Tp __x) {
    _Tp __term = _Tp(1);
    _Tp __sum = _Tp(1);
    const unsigned int __max_iter = 1000;
    for (unsigned int __i = 1; __i < __max_iter; ++__i) {
      _Tp __prev = __term;
      __term *= __i / __x;
      if (__term < std::numeric_limits<_Tp>::epsilon())
        break;
      if (__term >= __prev)
        break;
      __sum += __term;
    }

    return std::exp(__x) * __sum / __x;
  }
# 354 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/exp_integral.tcc" 3
  template <typename _Tp> _Tp __expint_Ei(_Tp __x) {
    if (__x < _Tp(0))
      return -__expint_E1(-__x);
    else if (__x < -std::log(std::numeric_limits<_Tp>::epsilon()))
      return __expint_Ei_series(__x);
    else
      return __expint_Ei_asymp(__x);
  }
# 378 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/exp_integral.tcc" 3
  template <typename _Tp> _Tp __expint_E1(_Tp __x) {
    if (__x < _Tp(0))
      return -__expint_Ei(-__x);
    else if (__x < _Tp(1))
      return __expint_E1_series(__x);
    else if (__x < _Tp(100))
      return __expint_En_cont_frac(1, __x);
    else
      return __expint_E1_asymp(__x);
  }
# 408 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/exp_integral.tcc" 3
  template <typename _Tp> _Tp __expint_asymp(unsigned int __n, _Tp __x) {
    _Tp __term = _Tp(1);
    _Tp __sum = _Tp(1);
    for (unsigned int __i = 1; __i <= __n; ++__i) {
      _Tp __prev = __term;
      __term *= -(__n - __i + 1) / __x;
      if (std::abs(__term) > std::abs(__prev))
        break;
      __sum += __term;
    }

    return std::exp(-__x) * __sum / __x;
  }
# 442 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/exp_integral.tcc" 3
  template <typename _Tp> _Tp __expint_large_n(unsigned int __n, _Tp __x) {
    const _Tp __xpn = __x + __n;
    const _Tp __xpn2 = __xpn * __xpn;
    _Tp __term = _Tp(1);
    _Tp __sum = _Tp(1);
    for (unsigned int __i = 1; __i <= __n; ++__i) {
      _Tp __prev = __term;
      __term *= (__n - 2 * (__i - 1) * __x) / __xpn2;
      if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
        break;
      __sum += __term;
    }

    return std::exp(-__x) * __sum / __xpn;
  }
# 476 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/exp_integral.tcc" 3
  template <typename _Tp> _Tp __expint(unsigned int __n, _Tp __x) {

    if (__isnan(__x))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (__n <= 1 && __x == _Tp(0))
      return std::numeric_limits<_Tp>::infinity();
    else {
      _Tp __E0 = std::exp(__x) / __x;
      if (__n == 0)
        return __E0;

      _Tp __E1 = __expint_E1(__x);
      if (__n == 1)
        return __E1;

      if (__x == _Tp(0))
        return _Tp(1) / static_cast<_Tp>(__n - 1);

      _Tp __En = __expint_En_recursion(__n, __x);

      return __En;
    }
  }
# 516 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/exp_integral.tcc" 3
  template <typename _Tp> inline _Tp __expint(_Tp __x) {
    if (__isnan(__x))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else
      return __expint_Ei(__x);
  }
  } // namespace __detail

} // namespace std
# 52 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/hypergeometric.tcc" 1 3
# 44 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/hypergeometric.tcc" 3
namespace std __attribute__((__visibility__("default"))) {
# 60 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/hypergeometric.tcc" 3
  namespace __detail {
# 83 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/hypergeometric.tcc" 3
  template <typename _Tp> _Tp __conf_hyperg_series(_Tp __a, _Tp __c, _Tp __x) {
    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

    _Tp __term = _Tp(1);
    _Tp __Fac = _Tp(1);
    const unsigned int __max_iter = 100000;
    unsigned int __i;
    for (__i = 0; __i < __max_iter; ++__i) {
      __term *= (__a + _Tp(__i)) * __x / ((__c + _Tp(__i)) * _Tp(1 + __i));
      if (std::abs(__term) < __eps) {
        break;
      }
      __Fac += __term;
    }
    if (__i == __max_iter)
      std::__throw_runtime_error(("Series failed to converge "
                                  "in __conf_hyperg_series."));

    return __Fac;
  }
# 120 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/hypergeometric.tcc" 3
  template <typename _Tp> _Tp __conf_hyperg_luke(_Tp __a, _Tp __c, _Tp __xin) {
    const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
    const int __nmax = 20000;
    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
    const _Tp __x = -__xin;
    const _Tp __x3 = __x * __x * __x;
    const _Tp __t0 = __a / __c;
    const _Tp __t1 = (__a + _Tp(1)) / (_Tp(2) * __c);
    const _Tp __t2 = (__a + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));
    _Tp __F = _Tp(1);
    _Tp __prec;

    _Tp __Bnm3 = _Tp(1);
    _Tp __Bnm2 = _Tp(1) + __t1 * __x;
    _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

    _Tp __Anm3 = _Tp(1);
    _Tp __Anm2 = __Bnm2 - __t0 * __x;
    _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x +
                 __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

    int __n = 3;
    while (1) {
      _Tp __npam1 = _Tp(__n - 1) + __a;
      _Tp __npcm1 = _Tp(__n - 1) + __c;
      _Tp __npam2 = _Tp(__n - 2) + __a;
      _Tp __npcm2 = _Tp(__n - 2) + __c;
      _Tp __tnm1 = _Tp(2 * __n - 1);
      _Tp __tnm3 = _Tp(2 * __n - 3);
      _Tp __tnm5 = _Tp(2 * __n - 5);
      _Tp __F1 = (_Tp(__n - 2) - __a) / (_Tp(2) * __tnm3 * __npcm1);
      _Tp __F2 = (_Tp(__n) + __a) * __npam1 /
                 (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
      _Tp __F3 = -__npam2 * __npam1 * (_Tp(__n - 2) - __a) /
                 (_Tp(8) * __tnm3 * __tnm3 * __tnm5 * (_Tp(__n - 3) + __c) *
                  __npcm2 * __npcm1);
      _Tp __E = -__npam1 * (_Tp(__n - 1) - __c) /
                (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

      _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1 +
                 (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
      _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1 +
                 (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
      _Tp __r = __An / __Bn;

      __prec = std::abs((__F - __r) / __F);
      __F = __r;

      if (__prec < __eps || __n > __nmax)
        break;

      if (std::abs(__An) > __big || std::abs(__Bn) > __big) {
        __An /= __big;
        __Bn /= __big;
        __Anm1 /= __big;
        __Bnm1 /= __big;
        __Anm2 /= __big;
        __Bnm2 /= __big;
        __Anm3 /= __big;
        __Bnm3 /= __big;
      } else if (std::abs(__An) < _Tp(1) / __big ||
                 std::abs(__Bn) < _Tp(1) / __big) {
        __An *= __big;
        __Bn *= __big;
        __Anm1 *= __big;
        __Bnm1 *= __big;
        __Anm2 *= __big;
        __Bnm2 *= __big;
        __Anm3 *= __big;
        __Bnm3 *= __big;
      }

      ++__n;
      __Bnm3 = __Bnm2;
      __Bnm2 = __Bnm1;
      __Bnm1 = __Bn;
      __Anm3 = __Anm2;
      __Anm2 = __Anm1;
      __Anm1 = __An;
    }

    if (__n >= __nmax)
      std::__throw_runtime_error(("Iteration failed to converge "
                                  "in __conf_hyperg_luke."));

    return __F;
  }
# 227 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/hypergeometric.tcc" 3
  template <typename _Tp> _Tp __conf_hyperg(_Tp __a, _Tp __c, _Tp __x) {

    const _Tp __c_nint = ::std::nearbyint(__c);

    if (__isnan(__a) || __isnan(__c) || __isnan(__x))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (__c_nint == __c && __c_nint <= 0)
      return std::numeric_limits<_Tp>::infinity();
    else if (__a == _Tp(0))
      return _Tp(1);
    else if (__c == __a)
      return std::exp(__x);
    else if (__x < _Tp(0))
      return __conf_hyperg_luke(__a, __c, __x);
    else
      return __conf_hyperg_series(__a, __c, __x);
  }
# 271 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/hypergeometric.tcc" 3
  template <typename _Tp>
  _Tp __hyperg_series(_Tp __a, _Tp __b, _Tp __c, _Tp __x) {
    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

    _Tp __term = _Tp(1);
    _Tp __Fabc = _Tp(1);
    const unsigned int __max_iter = 100000;
    unsigned int __i;
    for (__i = 0; __i < __max_iter; ++__i) {
      __term *= (__a + _Tp(__i)) * (__b + _Tp(__i)) * __x /
                ((__c + _Tp(__i)) * _Tp(1 + __i));
      if (std::abs(__term) < __eps) {
        break;
      }
      __Fabc += __term;
    }
    if (__i == __max_iter)
      std::__throw_runtime_error(("Series failed to converge "
                                  "in __hyperg_series."));

    return __Fabc;
  }

  template <typename _Tp>
  _Tp __hyperg_luke(_Tp __a, _Tp __b, _Tp __c, _Tp __xin) {
    const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
    const int __nmax = 20000;
    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
    const _Tp __x = -__xin;
    const _Tp __x3 = __x * __x * __x;
    const _Tp __t0 = __a * __b / __c;
    const _Tp __t1 = (__a + _Tp(1)) * (__b + _Tp(1)) / (_Tp(2) * __c);
    const _Tp __t2 =
        (__a + _Tp(2)) * (__b + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));

    _Tp __F = _Tp(1);

    _Tp __Bnm3 = _Tp(1);
    _Tp __Bnm2 = _Tp(1) + __t1 * __x;
    _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

    _Tp __Anm3 = _Tp(1);
    _Tp __Anm2 = __Bnm2 - __t0 * __x;
    _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x +
                 __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

    int __n = 3;
    while (1) {
      const _Tp __npam1 = _Tp(__n - 1) + __a;
      const _Tp __npbm1 = _Tp(__n - 1) + __b;
      const _Tp __npcm1 = _Tp(__n - 1) + __c;
      const _Tp __npam2 = _Tp(__n - 2) + __a;
      const _Tp __npbm2 = _Tp(__n - 2) + __b;
      const _Tp __npcm2 = _Tp(__n - 2) + __c;
      const _Tp __tnm1 = _Tp(2 * __n - 1);
      const _Tp __tnm3 = _Tp(2 * __n - 3);
      const _Tp __tnm5 = _Tp(2 * __n - 5);
      const _Tp __n2 = __n * __n;
      const _Tp __F1 = (_Tp(3) * __n2 + (__a + __b - _Tp(6)) * __n + _Tp(2) -
                        __a * __b - _Tp(2) * (__a + __b)) /
                       (_Tp(2) * __tnm3 * __npcm1);
      const _Tp __F2 =
          -(_Tp(3) * __n2 - (__a + __b + _Tp(6)) * __n + _Tp(2) - __a * __b) *
          __npam1 * __npbm1 / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
      const _Tp __F3 = (__npam2 * __npam1 * __npbm2 * __npbm1 *
                        (_Tp(__n - 2) - __a) * (_Tp(__n - 2) - __b)) /
                       (_Tp(8) * __tnm3 * __tnm3 * __tnm5 *
                        (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
      const _Tp __E = -__npam1 * __npbm1 * (_Tp(__n - 1) - __c) /
                      (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

      _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1 +
                 (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
      _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1 +
                 (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
      const _Tp __r = __An / __Bn;

      const _Tp __prec = std::abs((__F - __r) / __F);
      __F = __r;

      if (__prec < __eps || __n > __nmax)
        break;

      if (std::abs(__An) > __big || std::abs(__Bn) > __big) {
        __An /= __big;
        __Bn /= __big;
        __Anm1 /= __big;
        __Bnm1 /= __big;
        __Anm2 /= __big;
        __Bnm2 /= __big;
        __Anm3 /= __big;
        __Bnm3 /= __big;
      } else if (std::abs(__An) < _Tp(1) / __big ||
                 std::abs(__Bn) < _Tp(1) / __big) {
        __An *= __big;
        __Bn *= __big;
        __Anm1 *= __big;
        __Bnm1 *= __big;
        __Anm2 *= __big;
        __Bnm2 *= __big;
        __Anm3 *= __big;
        __Bnm3 *= __big;
      }

      ++__n;
      __Bnm3 = __Bnm2;
      __Bnm2 = __Bnm1;
      __Bnm1 = __Bn;
      __Anm3 = __Anm2;
      __Anm2 = __Anm1;
      __Anm1 = __An;
    }

    if (__n >= __nmax)
      std::__throw_runtime_error(("Iteration failed to converge "
                                  "in __hyperg_luke."));

    return __F;
  }
# 438 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/hypergeometric.tcc" 3
  template <typename _Tp>
  _Tp __hyperg_reflect(_Tp __a, _Tp __b, _Tp __c, _Tp __x) {
    const _Tp __d = __c - __a - __b;
    const int __intd = std::floor(__d + _Tp(0.5L));
    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
    const _Tp __toler = _Tp(1000) * __eps;
    const _Tp __log_max = std::log(std::numeric_limits<_Tp>::max());
    const bool __d_integer = (std::abs(__d - __intd) < __toler);

    if (__d_integer) {
      const _Tp __ln_omx = std::log(_Tp(1) - __x);
      const _Tp __ad = std::abs(__d);
      _Tp __F1, __F2;

      _Tp __d1, __d2;
      if (__d >= _Tp(0)) {
        __d1 = __d;
        __d2 = _Tp(0);
      } else {
        __d1 = _Tp(0);
        __d2 = __d;
      }

      const _Tp __lng_c = __log_gamma(__c);

      if (__ad < __eps) {

        __F1 = _Tp(0);
      } else {

        bool __ok_d1 = true;
        _Tp __lng_ad, __lng_ad1, __lng_bd1;
        try {
          __lng_ad = __log_gamma(__ad);
          __lng_ad1 = __log_gamma(__a + __d1);
          __lng_bd1 = __log_gamma(__b + __d1);
        } catch (...) {
          __ok_d1 = false;
        }

        if (__ok_d1) {

          _Tp __sum1 = _Tp(1);
          _Tp __term = _Tp(1);
          _Tp __ln_pre1 =
              __lng_ad + __lng_c + __d2 * __ln_omx - __lng_ad1 - __lng_bd1;

          for (int __i = 1; __i < __ad; ++__i) {
            const int __j = __i - 1;
            __term *= (__a + __d2 + __j) * (__b + __d2 + __j) /
                      (_Tp(1) + __d2 + __j) / __i * (_Tp(1) - __x);
            __sum1 += __term;
          }

          if (__ln_pre1 > __log_max)
            std::__throw_runtime_error(("Overflow of gamma functions"
                                        " in __hyperg_luke."));

          else
            __F1 = std::exp(__ln_pre1) * __sum1;
        } else {

          __F1 = _Tp(0);
        }
      }

      bool __ok_d2 = true;
      _Tp __lng_ad2, __lng_bd2;
      try {
        __lng_ad2 = __log_gamma(__a + __d2);
        __lng_bd2 = __log_gamma(__b + __d2);
      } catch (...) {
        __ok_d2 = false;
      }

      if (__ok_d2) {

        const int __maxiter = 2000;
        const _Tp __psi_1 = -__numeric_constants<_Tp>::__gamma_e();
        const _Tp __psi_1pd = __psi(_Tp(1) + __ad);
        const _Tp __psi_apd1 = __psi(__a + __d1);
        const _Tp __psi_bpd1 = __psi(__b + __d1);

        _Tp __psi_term =
            __psi_1 + __psi_1pd - __psi_apd1 - __psi_bpd1 - __ln_omx;
        _Tp __fact = _Tp(1);
        _Tp __sum2 = __psi_term;
        _Tp __ln_pre2 = __lng_c + __d1 * __ln_omx - __lng_ad2 - __lng_bd2;

        int __j;
        for (__j = 1; __j < __maxiter; ++__j) {

          const _Tp __term1 = _Tp(1) / _Tp(__j) + _Tp(1) / (__ad + __j);
          const _Tp __term2 = _Tp(1) / (__a + __d1 + _Tp(__j - 1)) +
                              _Tp(1) / (__b + __d1 + _Tp(__j - 1));
          __psi_term += __term1 - __term2;
          __fact *= (__a + __d1 + _Tp(__j - 1)) * (__b + __d1 + _Tp(__j - 1)) /
                    ((__ad + __j) * __j) * (_Tp(1) - __x);
          const _Tp __delta = __fact * __psi_term;
          __sum2 += __delta;
          if (std::abs(__delta) < __eps * std::abs(__sum2))
            break;
        }
        if (__j == __maxiter)
          std::__throw_runtime_error(("Sum F2 failed to converge "
                                      "in __hyperg_reflect"));

        if (__sum2 == _Tp(0))
          __F2 = _Tp(0);
        else
          __F2 = std::exp(__ln_pre2) * __sum2;
      } else {

        __F2 = _Tp(0);
      }

      const _Tp __sgn_2 = (__intd % 2 == 1 ? -_Tp(1) : _Tp(1));
      const _Tp __F = __F1 + __sgn_2 * __F2;

      return __F;
    } else {

      bool __ok1 = true;
      _Tp __sgn_g1ca = _Tp(0), __ln_g1ca = _Tp(0);
      _Tp __sgn_g1cb = _Tp(0), __ln_g1cb = _Tp(0);
      try {
        __sgn_g1ca = __log_gamma_sign(__c - __a);
        __ln_g1ca = __log_gamma(__c - __a);
        __sgn_g1cb = __log_gamma_sign(__c - __b);
        __ln_g1cb = __log_gamma(__c - __b);
      } catch (...) {
        __ok1 = false;
      }

      bool __ok2 = true;
      _Tp __sgn_g2a = _Tp(0), __ln_g2a = _Tp(0);
      _Tp __sgn_g2b = _Tp(0), __ln_g2b = _Tp(0);
      try {
        __sgn_g2a = __log_gamma_sign(__a);
        __ln_g2a = __log_gamma(__a);
        __sgn_g2b = __log_gamma_sign(__b);
        __ln_g2b = __log_gamma(__b);
      } catch (...) {
        __ok2 = false;
      }

      const _Tp __sgn_gc = __log_gamma_sign(__c);
      const _Tp __ln_gc = __log_gamma(__c);
      const _Tp __sgn_gd = __log_gamma_sign(__d);
      const _Tp __ln_gd = __log_gamma(__d);
      const _Tp __sgn_gmd = __log_gamma_sign(-__d);
      const _Tp __ln_gmd = __log_gamma(-__d);

      const _Tp __sgn1 = __sgn_gc * __sgn_gd * __sgn_g1ca * __sgn_g1cb;
      const _Tp __sgn2 = __sgn_gc * __sgn_gmd * __sgn_g2a * __sgn_g2b;

      _Tp __pre1, __pre2;
      if (__ok1 && __ok2) {
        _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
        _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b +
                        __d * std::log(_Tp(1) - __x);
        if (__ln_pre1 < __log_max && __ln_pre2 < __log_max) {
          __pre1 = std::exp(__ln_pre1);
          __pre2 = std::exp(__ln_pre2);
          __pre1 *= __sgn1;
          __pre2 *= __sgn2;
        } else {
          std::__throw_runtime_error(("Overflow of gamma functions "
                                      "in __hyperg_reflect"));
        }
      } else if (__ok1 && !__ok2) {
        _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
        if (__ln_pre1 < __log_max) {
          __pre1 = std::exp(__ln_pre1);
          __pre1 *= __sgn1;
          __pre2 = _Tp(0);
        } else {
          std::__throw_runtime_error(("Overflow of gamma functions "
                                      "in __hyperg_reflect"));
        }
      } else if (!__ok1 && __ok2) {
        _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b +
                        __d * std::log(_Tp(1) - __x);
        if (__ln_pre2 < __log_max) {
          __pre1 = _Tp(0);
          __pre2 = std::exp(__ln_pre2);
          __pre2 *= __sgn2;
        } else {
          std::__throw_runtime_error(("Overflow of gamma functions "
                                      "in __hyperg_reflect"));
        }
      } else {
        __pre1 = _Tp(0);
        __pre2 = _Tp(0);
        std::__throw_runtime_error(("Underflow of gamma functions "
                                    "in __hyperg_reflect"));
      }

      const _Tp __F1 = __hyperg_series(__a, __b, _Tp(1) - __d, _Tp(1) - __x);
      const _Tp __F2 =
          __hyperg_series(__c - __a, __c - __b, _Tp(1) + __d, _Tp(1) - __x);

      const _Tp __F = __pre1 * __F1 + __pre2 * __F2;

      return __F;
    }
  }
# 728 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/hypergeometric.tcc" 3
  template <typename _Tp> _Tp __hyperg(_Tp __a, _Tp __b, _Tp __c, _Tp __x) {

    const _Tp __a_nint = ::std::nearbyint(__a);
    const _Tp __b_nint = ::std::nearbyint(__b);
    const _Tp __c_nint = ::std::nearbyint(__c);

    const _Tp __toler = _Tp(1000) * std::numeric_limits<_Tp>::epsilon();
    if (std::abs(__x) >= _Tp(1))
      std::__throw_domain_error(("Argument outside unit circle "
                                 "in __hyperg."));

    else if (__isnan(__a) || __isnan(__b) || __isnan(__c) || __isnan(__x))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (__c_nint == __c && __c_nint <= _Tp(0))
      return std::numeric_limits<_Tp>::infinity();
    else if (std::abs(__c - __b) < __toler || std::abs(__c - __a) < __toler)
      return std::pow(_Tp(1) - __x, __c - __a - __b);
    else if (__a >= _Tp(0) && __b >= _Tp(0) && __c >= _Tp(0) && __x >= _Tp(0) &&
             __x < _Tp(0.995L))
      return __hyperg_series(__a, __b, __c, __x);
    else if (std::abs(__a) < _Tp(10) && std::abs(__b) < _Tp(10)) {

      if (__a < _Tp(0) && std::abs(__a - __a_nint) < __toler)
        return __hyperg_series(__a_nint, __b, __c, __x);
      else if (__b < _Tp(0) && std::abs(__b - __b_nint) < __toler)
        return __hyperg_series(__a, __b_nint, __c, __x);
      else if (__x < -_Tp(0.25L))
        return __hyperg_luke(__a, __b, __c, __x);
      else if (__x < _Tp(0.5L))
        return __hyperg_series(__a, __b, __c, __x);
      else if (std::abs(__c) > _Tp(10))
        return __hyperg_series(__a, __b, __c, __x);
      else
        return __hyperg_reflect(__a, __b, __c, __x);
    } else
      return __hyperg_luke(__a, __b, __c, __x);
  }
  } // namespace __detail

} // namespace std
# 53 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/legendre_function.tcc" 1 3
# 49 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/legendre_function.tcc" 3
namespace std __attribute__((__visibility__("default"))) {
# 65 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/legendre_function.tcc" 3
  namespace __detail {
# 80 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/legendre_function.tcc" 3
  template <typename _Tp> _Tp __poly_legendre_p(unsigned int __l, _Tp __x) {

    if (__isnan(__x))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (__x == +_Tp(1))
      return +_Tp(1);
    else if (__x == -_Tp(1))
      return (__l % 2 == 1 ? -_Tp(1) : +_Tp(1));
    else {
      _Tp __p_lm2 = _Tp(1);
      if (__l == 0)
        return __p_lm2;

      _Tp __p_lm1 = __x;
      if (__l == 1)
        return __p_lm1;

      _Tp __p_l = 0;
      for (unsigned int __ll = 2; __ll <= __l; ++__ll) {

        __p_l = _Tp(2) * __x * __p_lm1 - __p_lm2 -
                (__x * __p_lm1 - __p_lm2) / _Tp(__ll);
        __p_lm2 = __p_lm1;
        __p_lm1 = __p_l;
      }

      return __p_l;
    }
  }
# 136 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/legendre_function.tcc" 3
  template <typename _Tp>
  _Tp __assoc_legendre_p(unsigned int __l, unsigned int __m, _Tp __x,
                         _Tp __phase = _Tp(+1)) {

    if (__m > __l)
      return _Tp(0);
    else if (__isnan(__x))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (__m == 0)
      return __poly_legendre_p(__l, __x);
    else {
      _Tp __p_mm = _Tp(1);
      if (__m > 0) {

        _Tp __root = std::sqrt(_Tp(1) - __x) * std::sqrt(_Tp(1) + __x);
        _Tp __fact = _Tp(1);
        for (unsigned int __i = 1; __i <= __m; ++__i) {
          __p_mm *= __phase * __fact * __root;
          __fact += _Tp(2);
        }
      }
      if (__l == __m)
        return __p_mm;

      _Tp __p_mp1m = _Tp(2 * __m + 1) * __x * __p_mm;
      if (__l == __m + 1)
        return __p_mp1m;

      _Tp __p_lm2m = __p_mm;
      _Tp __P_lm1m = __p_mp1m;
      _Tp __p_lm = _Tp(0);
      for (unsigned int __j = __m + 2; __j <= __l; ++__j) {
        __p_lm = (_Tp(2 * __j - 1) * __x * __P_lm1m -
                  _Tp(__j + __m - 1) * __p_lm2m) /
                 _Tp(__j - __m);
        __p_lm2m = __P_lm1m;
        __P_lm1m = __p_lm;
      }

      return __p_lm;
    }
  }
# 214 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/legendre_function.tcc" 3
  template <typename _Tp>
  _Tp __sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta) {
    if (__isnan(__theta))
      return std::numeric_limits<_Tp>::quiet_NaN();

    const _Tp __x = std::cos(__theta);

    if (__m > __l)
      return _Tp(0);
    else if (__m == 0) {
      _Tp __P = __poly_legendre_p(__l, __x);
      _Tp __fact = std::sqrt(_Tp(2 * __l + 1) /
                             (_Tp(4) * __numeric_constants<_Tp>::__pi()));
      __P *= __fact;
      return __P;
    } else if (__x == _Tp(1) || __x == -_Tp(1)) {

      return _Tp(0);
    } else {

      const _Tp __sgn = (__m % 2 == 1 ? -_Tp(1) : _Tp(1));
      const _Tp __y_mp1m_factor = __x * std::sqrt(_Tp(2 * __m + 3));

      const _Tp __lncirc = ::std::log1p(-__x * __x);

      const _Tp __lnpoch =
          ::std::lgamma(_Tp(__m + _Tp(0.5L))) - ::std::lgamma(_Tp(__m));

      const _Tp __lnpre_val = -_Tp(0.25L) * __numeric_constants<_Tp>::__lnpi() +
                              _Tp(0.5L) * (__lnpoch + __m * __lncirc);
      const _Tp __sr = std::sqrt((_Tp(2) + _Tp(1) / __m) /
                                 (_Tp(4) * __numeric_constants<_Tp>::__pi()));
      _Tp __y_mm = __sgn * __sr * std::exp(__lnpre_val);
      _Tp __y_mp1m = __y_mp1m_factor * __y_mm;

      if (__l == __m)
        return __y_mm;
      else if (__l == __m + 1)
        return __y_mp1m;
      else {
        _Tp __y_lm = _Tp(0);

        for (unsigned int __ll = __m + 2; __ll <= __l; ++__ll) {
          const _Tp __rat1 = _Tp(__ll - __m) / _Tp(__ll + __m);
          const _Tp __rat2 = _Tp(__ll - __m - 1) / _Tp(__ll + __m - 1);
          const _Tp __fact1 =
              std::sqrt(__rat1 * _Tp(2 * __ll + 1) * _Tp(2 * __ll - 1));
          const _Tp __fact2 = std::sqrt(__rat1 * __rat2 * _Tp(2 * __ll + 1) /
                                        _Tp(2 * __ll - 3));
          __y_lm =
              (__x * __y_mp1m * __fact1 - (__ll + __m - 1) * __y_mm * __fact2) /
              _Tp(__ll - __m);
          __y_mm = __y_mp1m;
          __y_mp1m = __y_lm;
        }

        return __y_lm;
      }
    }
  }
  } // namespace __detail

} // namespace std
# 54 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/modified_bessel_func.tcc" 1 3
# 51 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/modified_bessel_func.tcc" 3
namespace std __attribute__((__visibility__("default"))) {
# 65 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/modified_bessel_func.tcc" 3
  namespace __detail {
# 83 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/modified_bessel_func.tcc" 3
  template <typename _Tp>
  void __bessel_ik(_Tp __nu, _Tp __x, _Tp &__Inu, _Tp &__Knu, _Tp &__Ipnu,
                   _Tp &__Kpnu) {
    if (__x == _Tp(0)) {
      if (__nu == _Tp(0)) {
        __Inu = _Tp(1);
        __Ipnu = _Tp(0);
      } else if (__nu == _Tp(1)) {
        __Inu = _Tp(0);
        __Ipnu = _Tp(0.5L);
      } else {
        __Inu = _Tp(0);
        __Ipnu = _Tp(0);
      }
      __Knu = std::numeric_limits<_Tp>::infinity();
      __Kpnu = -std::numeric_limits<_Tp>::infinity();
      return;
    }

    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
    const _Tp __fp_min = _Tp(10) * std::numeric_limits<_Tp>::epsilon();
    const int __max_iter = 15000;
    const _Tp __x_min = _Tp(2);

    const int __nl = static_cast<int>(__nu + _Tp(0.5L));

    const _Tp __mu = __nu - __nl;
    const _Tp __mu2 = __mu * __mu;
    const _Tp __xi = _Tp(1) / __x;
    const _Tp __xi2 = _Tp(2) * __xi;
    _Tp __h = __nu * __xi;
    if (__h < __fp_min)
      __h = __fp_min;
    _Tp __b = __xi2 * __nu;
    _Tp __d = _Tp(0);
    _Tp __c = __h;
    int __i;
    for (__i = 1; __i <= __max_iter; ++__i) {
      __b += __xi2;
      __d = _Tp(1) / (__b + __d);
      __c = __b + _Tp(1) / __c;
      const _Tp __del = __c * __d;
      __h *= __del;
      if (std::abs(__del - _Tp(1)) < __eps)
        break;
    }
    if (__i > __max_iter)
      std::__throw_runtime_error(("Argument x too large "
                                  "in __bessel_ik; "
                                  "try asymptotic expansion."));

    _Tp __Inul = __fp_min;
    _Tp __Ipnul = __h * __Inul;
    _Tp __Inul1 = __Inul;
    _Tp __Ipnu1 = __Ipnul;
    _Tp __fact = __nu * __xi;
    for (int __l = __nl; __l >= 1; --__l) {
      const _Tp __Inutemp = __fact * __Inul + __Ipnul;
      __fact -= __xi;
      __Ipnul = __fact * __Inutemp + __Inul;
      __Inul = __Inutemp;
    }
    _Tp __f = __Ipnul / __Inul;
    _Tp __Kmu, __Knu1;
    if (__x < __x_min) {
      const _Tp __x2 = __x / _Tp(2);
      const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
      const _Tp __fact =
          (std::abs(__pimu) < __eps ? _Tp(1) : __pimu / std::sin(__pimu));
      _Tp __d = -std::log(__x2);
      _Tp __e = __mu * __d;
      const _Tp __fact2 =
          (std::abs(__e) < __eps ? _Tp(1) : std::sinh(__e) / __e);
      _Tp __gam1, __gam2, __gampl, __gammi;
      __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
      _Tp __ff = __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
      _Tp __sum = __ff;
      __e = std::exp(__e);
      _Tp __p = __e / (_Tp(2) * __gampl);
      _Tp __q = _Tp(1) / (_Tp(2) * __e * __gammi);
      _Tp __c = _Tp(1);
      __d = __x2 * __x2;
      _Tp __sum1 = __p;
      int __i;
      for (__i = 1; __i <= __max_iter; ++__i) {
        __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
        __c *= __d / __i;
        __p /= __i - __mu;
        __q /= __i + __mu;
        const _Tp __del = __c * __ff;
        __sum += __del;
        const _Tp __del1 = __c * (__p - __i * __ff);
        __sum1 += __del1;
        if (std::abs(__del) < __eps * std::abs(__sum))
          break;
      }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Bessel k series failed to converge "
                                    "in __bessel_ik."));

      __Kmu = __sum;
      __Knu1 = __sum1 * __xi2;
    } else {
      _Tp __b = _Tp(2) * (_Tp(1) + __x);
      _Tp __d = _Tp(1) / __b;
      _Tp __delh = __d;
      _Tp __h = __delh;
      _Tp __q1 = _Tp(0);
      _Tp __q2 = _Tp(1);
      _Tp __a1 = _Tp(0.25L) - __mu2;
      _Tp __q = __c = __a1;
      _Tp __a = -__a1;
      _Tp __s = _Tp(1) + __q * __delh;
      int __i;
      for (__i = 2; __i <= __max_iter; ++__i) {
        __a -= 2 * (__i - 1);
        __c = -__a * __c / __i;
        const _Tp __qnew = (__q1 - __b * __q2) / __a;
        __q1 = __q2;
        __q2 = __qnew;
        __q += __c * __qnew;
        __b += _Tp(2);
        __d = _Tp(1) / (__b + __a * __d);
        __delh = (__b * __d - _Tp(1)) * __delh;
        __h += __delh;
        const _Tp __dels = __q * __delh;
        __s += __dels;
        if (std::abs(__dels / __s) < __eps)
          break;
      }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Steed's method failed "
                                    "in __bessel_ik."));

      __h = __a1 * __h;
      __Kmu = std::sqrt(__numeric_constants<_Tp>::__pi() / (_Tp(2) * __x)) *
              std::exp(-__x) / __s;
      __Knu1 = __Kmu * (__mu + __x + _Tp(0.5L) - __h) * __xi;
    }

    _Tp __Kpmu = __mu * __xi * __Kmu - __Knu1;
    _Tp __Inumu = __xi / (__f * __Kmu - __Kpmu);
    __Inu = __Inumu * __Inul1 / __Inul;
    __Ipnu = __Inumu * __Ipnu1 / __Inul;
    for (__i = 1; __i <= __nl; ++__i) {
      const _Tp __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
      __Kmu = __Knu1;
      __Knu1 = __Knutemp;
    }
    __Knu = __Kmu;
    __Kpnu = __nu * __xi * __Kmu - __Knu1;

    return;
  }
# 267 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/modified_bessel_func.tcc" 3
  template <typename _Tp> _Tp __cyl_bessel_i(_Tp __nu, _Tp __x) {
    if (__nu < _Tp(0) || __x < _Tp(0))
      std::__throw_domain_error(("Bad argument "
                                 "in __cyl_bessel_i."));

    else if (__isnan(__nu) || __isnan(__x))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
      return __cyl_bessel_ij_series(__nu, __x, +_Tp(1), 200);
    else {
      _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
      __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
      return __I_nu;
    }
  }
# 303 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/modified_bessel_func.tcc" 3
  template <typename _Tp> _Tp __cyl_bessel_k(_Tp __nu, _Tp __x) {
    if (__nu < _Tp(0) || __x < _Tp(0))
      std::__throw_domain_error(("Bad argument "
                                 "in __cyl_bessel_k."));

    else if (__isnan(__nu) || __isnan(__x))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else {
      _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
      __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
      return __K_nu;
    }
  }
# 337 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/modified_bessel_func.tcc" 3
  template <typename _Tp>
  void __sph_bessel_ik(unsigned int __n, _Tp __x, _Tp &__i_n, _Tp &__k_n,
                       _Tp &__ip_n, _Tp &__kp_n) {
    const _Tp __nu = _Tp(__n) + _Tp(0.5L);

    _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;
    __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);

    const _Tp __factor =
        __numeric_constants<_Tp>::__sqrtpio2() / std::sqrt(__x);

    __i_n = __factor * __I_nu;
    __k_n = __factor * __K_nu;
    __ip_n = __factor * __Ip_nu - __i_n / (_Tp(2) * __x);
    __kp_n = __factor * __Kp_nu - __k_n / (_Tp(2) * __x);

    return;
  }
# 373 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/modified_bessel_func.tcc" 3
  template <typename _Tp>
  void __airy(_Tp __x, _Tp &__Ai, _Tp &__Bi, _Tp &__Aip, _Tp &__Bip) {
    const _Tp __absx = std::abs(__x);
    const _Tp __rootx = std::sqrt(__absx);
    const _Tp __z = _Tp(2) * __absx * __rootx / _Tp(3);
    const _Tp _S_inf = std::numeric_limits<_Tp>::infinity();

    if (__isnan(__x))
      __Bip = __Aip = __Bi = __Ai = std::numeric_limits<_Tp>::quiet_NaN();
    else if (__z == _S_inf) {
      __Aip = __Ai = _Tp(0);
      __Bip = __Bi = _S_inf;
    } else if (__z == -_S_inf)
      __Bip = __Aip = __Bi = __Ai = _Tp(0);
    else if (__x > _Tp(0)) {
      _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;

      __bessel_ik(_Tp(1) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
      __Ai = __rootx * __K_nu /
             (__numeric_constants<_Tp>::__sqrt3() *
              __numeric_constants<_Tp>::__pi());
      __Bi = __rootx * (__K_nu / __numeric_constants<_Tp>::__pi() +
                        _Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());

      __bessel_ik(_Tp(2) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
      __Aip = -__x * __K_nu /
              (__numeric_constants<_Tp>::__sqrt3() *
               __numeric_constants<_Tp>::__pi());
      __Bip = __x * (__K_nu / __numeric_constants<_Tp>::__pi() +
                     _Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());
    } else if (__x < _Tp(0)) {
      _Tp __J_nu, __Jp_nu, __N_nu, __Np_nu;

      __bessel_jn(_Tp(1) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
      __Ai = __rootx * (__J_nu - __N_nu / __numeric_constants<_Tp>::__sqrt3()) /
             _Tp(2);
      __Bi = -__rootx *
             (__N_nu + __J_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);

      __bessel_jn(_Tp(2) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
      __Aip = __absx * (__N_nu / __numeric_constants<_Tp>::__sqrt3() + __J_nu) /
              _Tp(2);
      __Bip = __absx * (__J_nu / __numeric_constants<_Tp>::__sqrt3() - __N_nu) /
              _Tp(2);
    } else {

      __Ai = _Tp(0.35502805388781723926L);
      __Bi = __Ai * __numeric_constants<_Tp>::__sqrt3();

      __Aip = -_Tp(0.25881940379280679840L);
      __Bip = -__Aip * __numeric_constants<_Tp>::__sqrt3();
    }

    return;
  }
  } // namespace __detail

} // namespace std
# 55 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/poly_hermite.tcc" 1 3
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/poly_hermite.tcc" 3
namespace std __attribute__((__visibility__("default"))) {
# 56 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/poly_hermite.tcc" 3
  namespace __detail {
# 72 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/poly_hermite.tcc" 3
  template <typename _Tp>
  _Tp __poly_hermite_recursion(unsigned int __n, _Tp __x) {

    _Tp __H_0 = 1;
    if (__n == 0)
      return __H_0;

    _Tp __H_1 = 2 * __x;
    if (__n == 1)
      return __H_1;

    _Tp __H_n, __H_nm1, __H_nm2;
    unsigned int __i;
    for (__H_nm2 = __H_0, __H_nm1 = __H_1, __i = 2; __i <= __n; ++__i) {
      __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
      __H_nm2 = __H_nm1;
      __H_nm1 = __H_n;
    }

    return __H_n;
  }
# 114 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/poly_hermite.tcc" 3
  template <typename _Tp> inline _Tp __poly_hermite(unsigned int __n, _Tp __x) {
    if (__isnan(__x))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else
      return __poly_hermite_recursion(__n, __x);
  }
  } // namespace __detail

} // namespace std
# 56 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/poly_laguerre.tcc" 1 3
# 44 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/poly_laguerre.tcc" 3
namespace std __attribute__((__visibility__("default"))) {
# 60 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/poly_laguerre.tcc" 3
  namespace __detail {
# 75 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/poly_laguerre.tcc" 3
  template <typename _Tpa, typename _Tp>
  _Tp __poly_laguerre_large_n(unsigned __n, _Tpa __alpha1, _Tp __x) {
    const _Tp __a = -_Tp(__n);
    const _Tp __b = _Tp(__alpha1) + _Tp(1);
    const _Tp __eta = _Tp(2) * __b - _Tp(4) * __a;
    const _Tp __cos2th = __x / __eta;
    const _Tp __sin2th = _Tp(1) - __cos2th;
    const _Tp __th = std::acos(std::sqrt(__cos2th));
    const _Tp __pre_h = __numeric_constants<_Tp>::__pi_2() *
                        __numeric_constants<_Tp>::__pi_2() * __eta * __eta *
                        __cos2th * __sin2th;

    const _Tp __lg_b = ::std::lgamma(_Tp(__n) + __b);
    const _Tp __lnfact = ::std::lgamma(_Tp(__n + 1));

    _Tp __pre_term1 =
        _Tp(0.5L) * (_Tp(1) - __b) * std::log(_Tp(0.25L) * __x * __eta);
    _Tp __pre_term2 = _Tp(0.25L) * std::log(__pre_h);
    _Tp __lnpre =
        __lg_b - __lnfact + _Tp(0.5L) * __x + __pre_term1 - __pre_term2;
    _Tp __ser_term1 = std::sin(__a * __numeric_constants<_Tp>::__pi());
    _Tp __ser_term2 = std::sin(_Tp(0.25L) * __eta *
                                   (_Tp(2) * __th - std::sin(_Tp(2) * __th)) +
                               __numeric_constants<_Tp>::__pi_4());
    _Tp __ser = __ser_term1 + __ser_term2;

    return std::exp(__lnpre) * __ser;
  }
# 129 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/poly_laguerre.tcc" 3
  template <typename _Tpa, typename _Tp>
  _Tp __poly_laguerre_hyperg(unsigned int __n, _Tpa __alpha1, _Tp __x) {
    const _Tp __b = _Tp(__alpha1) + _Tp(1);
    const _Tp __mx = -__x;
    const _Tp __tc_sgn =
        (__x < _Tp(0) ? _Tp(1) : ((__n % 2 == 1) ? -_Tp(1) : _Tp(1)));

    _Tp __tc = _Tp(1);
    const _Tp __ax = std::abs(__x);
    for (unsigned int __k = 1; __k <= __n; ++__k)
      __tc *= (__ax / __k);

    _Tp __term = __tc * __tc_sgn;
    _Tp __sum = __term;
    for (int __k = int(__n) - 1; __k >= 0; --__k) {
      __term *= ((__b + _Tp(__k)) / _Tp(int(__n) - __k)) * _Tp(__k + 1) / __mx;
      __sum += __term;
    }

    return __sum;
  }
# 185 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/poly_laguerre.tcc" 3
  template <typename _Tpa, typename _Tp>
  _Tp __poly_laguerre_recursion(unsigned int __n, _Tpa __alpha1, _Tp __x) {

    _Tp __l_0 = _Tp(1);
    if (__n == 0)
      return __l_0;

    _Tp __l_1 = -__x + _Tp(1) + _Tp(__alpha1);
    if (__n == 1)
      return __l_1;

    _Tp __l_n2 = __l_0;
    _Tp __l_n1 = __l_1;
    _Tp __l_n = _Tp(0);
    for (unsigned int __nn = 2; __nn <= __n; ++__nn) {
      __l_n = (_Tp(2 * __nn - 1) + _Tp(__alpha1) - __x) * __l_n1 / _Tp(__nn) -
              (_Tp(__nn - 1) + _Tp(__alpha1)) * __l_n2 / _Tp(__nn);
      __l_n2 = __l_n1;
      __l_n1 = __l_n;
    }

    return __l_n;
  }
# 244 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/poly_laguerre.tcc" 3
  template <typename _Tpa, typename _Tp>
  _Tp __poly_laguerre(unsigned int __n, _Tpa __alpha1, _Tp __x) {
    if (__x < _Tp(0))
      std::__throw_domain_error(("Negative argument "
                                 "in __poly_laguerre."));

    else if (__isnan(__x))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (__n == 0)
      return _Tp(1);
    else if (__n == 1)
      return _Tp(1) + _Tp(__alpha1) - __x;
    else if (__x == _Tp(0)) {
      _Tp __prod = _Tp(__alpha1) + _Tp(1);
      for (unsigned int __k = 2; __k <= __n; ++__k)
        __prod *= (_Tp(__alpha1) + _Tp(__k)) / _Tp(__k);
      return __prod;
    } else if (__n > 10000000 && _Tp(__alpha1) > -_Tp(1) &&
               __x < _Tp(2) * (_Tp(__alpha1) + _Tp(1)) + _Tp(4 * __n))
      return __poly_laguerre_large_n(__n, __alpha1, __x);
    else if (_Tp(__alpha1) >= _Tp(0) ||
             (__x > _Tp(0) && _Tp(__alpha1) < -_Tp(__n + 1)))
      return __poly_laguerre_recursion(__n, __alpha1, __x);
    else
      return __poly_laguerre_hyperg(__n, __alpha1, __x);
  }
# 296 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/poly_laguerre.tcc" 3
  template <typename _Tp>
  inline _Tp __assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x) {
    return __poly_laguerre<unsigned int, _Tp>(__n, __m, __x);
  }
# 316 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/poly_laguerre.tcc" 3
  template <typename _Tp> inline _Tp __laguerre(unsigned int __n, _Tp __x) {
    return __poly_laguerre<unsigned int, _Tp>(__n, 0, __x);
  }
  } // namespace __detail

} // namespace std
# 57 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/riemann_zeta.tcc" 1 3
# 47 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/riemann_zeta.tcc" 3
namespace std __attribute__((__visibility__("default"))) {
# 63 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/riemann_zeta.tcc" 3
  namespace __detail {
# 78 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/riemann_zeta.tcc" 3
  template <typename _Tp> _Tp __riemann_zeta_sum(_Tp __s) {

    if (__s < _Tp(1))
      std::__throw_domain_error(("Bad argument in zeta sum."));

    const unsigned int max_iter = 10000;
    _Tp __zeta = _Tp(0);
    for (unsigned int __k = 1; __k < max_iter; ++__k) {
      _Tp __term = std::pow(static_cast<_Tp>(__k), -__s);
      if (__term < std::numeric_limits<_Tp>::epsilon()) {
        break;
      }
      __zeta += __term;
    }

    return __zeta;
  }
# 115 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/riemann_zeta.tcc" 3
  template <typename _Tp> _Tp __riemann_zeta_alt(_Tp __s) {
    _Tp __sgn = _Tp(1);
    _Tp __zeta = _Tp(0);
    for (unsigned int __i = 1; __i < 10000000; ++__i) {
      _Tp __term = __sgn / std::pow(__i, __s);
      if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
        break;
      __zeta += __term;
      __sgn *= _Tp(-1);
    }
    __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

    return __zeta;
  }
# 157 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/riemann_zeta.tcc" 3
  template <typename _Tp> _Tp __riemann_zeta_glob(_Tp __s) {
    _Tp __zeta = _Tp(0);

    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

    const _Tp __max_bincoeff =
        std::numeric_limits<_Tp>::max_exponent10 * std::log(_Tp(10)) - _Tp(1);

    if (__s < _Tp(0)) {

      if (::std::fmod(__s, _Tp(2)) == _Tp(0))
        return _Tp(0);
      else

      {
        _Tp __zeta = __riemann_zeta_glob(_Tp(1) - __s);
        __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s) *
                  std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                  * std::exp(::std::lgamma(_Tp(1) - __s))

                  / __numeric_constants<_Tp>::__pi();
        return __zeta;
      }
    }

    _Tp __num = _Tp(0.5L);
    const unsigned int __maxit = 10000;
    for (unsigned int __i = 0; __i < __maxit; ++__i) {
      bool __punt = false;
      _Tp __sgn = _Tp(1);
      _Tp __term = _Tp(0);
      for (unsigned int __j = 0; __j <= __i; ++__j) {

        _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i)) -
                         ::std::lgamma(_Tp(1 + __j)) -
                         ::std::lgamma(_Tp(1 + __i - __j));

        if (__bincoeff > __max_bincoeff) {

          __punt = true;
          break;
        }
        __bincoeff = std::exp(__bincoeff);
        __term += __sgn * __bincoeff * std::pow(_Tp(1 + __j), -__s);
        __sgn *= _Tp(-1);
      }
      if (__punt)
        break;
      __term *= __num;
      __zeta += __term;
      if (std::abs(__term / __zeta) < __eps)
        break;
      __num *= _Tp(0.5L);
    }

    __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

    return __zeta;
  }
# 252 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/riemann_zeta.tcc" 3
  template <typename _Tp> _Tp __riemann_zeta_product(_Tp __s) {
    static const _Tp __prime[] = {
        _Tp(2),  _Tp(3),   _Tp(5),   _Tp(7),   _Tp(11), _Tp(13),
        _Tp(17), _Tp(19),  _Tp(23),  _Tp(29),  _Tp(31), _Tp(37),
        _Tp(41), _Tp(43),  _Tp(47),  _Tp(53),  _Tp(59), _Tp(61),
        _Tp(67), _Tp(71),  _Tp(73),  _Tp(79),  _Tp(83), _Tp(89),
        _Tp(97), _Tp(101), _Tp(103), _Tp(107), _Tp(109)};
    static const unsigned int __num_primes = sizeof(__prime) / sizeof(_Tp);

    _Tp __zeta = _Tp(1);
    for (unsigned int __i = 0; __i < __num_primes; ++__i) {
      const _Tp __fact = _Tp(1) - std::pow(__prime[__i], -__s);
      __zeta *= __fact;
      if (_Tp(1) - __fact < std::numeric_limits<_Tp>::epsilon())
        break;
    }

    __zeta = _Tp(1) / __zeta;

    return __zeta;
  }
# 293 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/riemann_zeta.tcc" 3
  template <typename _Tp> _Tp __riemann_zeta(_Tp __s) {
    if (__isnan(__s))
      return std::numeric_limits<_Tp>::quiet_NaN();
    else if (__s == _Tp(1))
      return std::numeric_limits<_Tp>::infinity();
    else if (__s < -_Tp(19)) {
      _Tp __zeta = __riemann_zeta_product(_Tp(1) - __s);
      __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s) *
                std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                * std::exp(::std::lgamma(_Tp(1) - __s))

                / __numeric_constants<_Tp>::__pi();
      return __zeta;
    } else if (__s < _Tp(20)) {

      bool __glob = true;
      if (__glob)
        return __riemann_zeta_glob(__s);
      else {
        if (__s > _Tp(1))
          return __riemann_zeta_sum(__s);
        else {
          _Tp __zeta =
              std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s) *
              std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

              * ::std::tgamma(_Tp(1) - __s)

              * __riemann_zeta_sum(_Tp(1) - __s);
          return __zeta;
        }
      }
    } else
      return __riemann_zeta_product(__s);
  }
# 365 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/riemann_zeta.tcc" 3
  template <typename _Tp> _Tp __hurwitz_zeta_glob(_Tp __a, _Tp __s) {
    _Tp __zeta = _Tp(0);

    const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

    const _Tp __max_bincoeff =
        std::numeric_limits<_Tp>::max_exponent10 * std::log(_Tp(10)) - _Tp(1);

    const unsigned int __maxit = 10000;
    for (unsigned int __i = 0; __i < __maxit; ++__i) {
      bool __punt = false;
      _Tp __sgn = _Tp(1);
      _Tp __term = _Tp(0);
      for (unsigned int __j = 0; __j <= __i; ++__j) {

        _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i)) -
                         ::std::lgamma(_Tp(1 + __j)) -
                         ::std::lgamma(_Tp(1 + __i - __j));

        if (__bincoeff > __max_bincoeff) {

          __punt = true;
          break;
        }
        __bincoeff = std::exp(__bincoeff);
        __term += __sgn * __bincoeff * std::pow(_Tp(__a + __j), -__s);
        __sgn *= _Tp(-1);
      }
      if (__punt)
        break;
      __term /= _Tp(__i + 1);
      if (std::abs(__term / __zeta) < __eps)
        break;
      __zeta += __term;
    }

    __zeta /= __s - _Tp(1);

    return __zeta;
  }
# 430 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/tr1/riemann_zeta.tcc" 3
  template <typename _Tp> inline _Tp __hurwitz_zeta(_Tp __a, _Tp __s) {
    return __hurwitz_zeta_glob(__a, __s);
  }
  } // namespace __detail

} // namespace std
# 58 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 203 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float assoc_laguerref(unsigned int __n, unsigned int __m, float __x) {
    return __detail::__assoc_laguerre<float>(__n, __m, __x);
  }

  inline long double assoc_laguerrel(unsigned int __n, unsigned int __m,
                                     long double __x) {
    return __detail::__assoc_laguerre<long double>(__n, __m, __x);
  }
# 248 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tp>
  inline typename __gnu_cxx::__promote<_Tp>::__type assoc_laguerre(
      unsigned int __n, unsigned int __m, _Tp __x) {
    typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
    return __detail::__assoc_laguerre<__type>(__n, __m, __x);
  }
# 264 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float assoc_legendref(unsigned int __l, unsigned int __m, float __x) {
    return __detail::__assoc_legendre_p<float>(__l, __m, __x);
  }

  inline long double assoc_legendrel(unsigned int __l, unsigned int __m,
                                     long double __x) {
    return __detail::__assoc_legendre_p<long double>(__l, __m, __x);
  }
# 294 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tp>
  inline typename __gnu_cxx::__promote<_Tp>::__type assoc_legendre(
      unsigned int __l, unsigned int __m, _Tp __x) {
    typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
    return __detail::__assoc_legendre_p<__type>(__l, __m, __x);
  }
# 309 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float betaf(float __a, float __b) {
    return __detail::__beta<float>(__a, __b);
  }

  inline long double betal(long double __a, long double __b) {
    return __detail::__beta<long double>(__a, __b);
  }
# 339 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tpa, typename _Tpb>
  inline typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type beta(_Tpa __a,
                                                                  _Tpb __b) {
    typedef typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type __type;
    return __detail::__beta<__type>(__a, __b);
  }
# 355 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float comp_ellint_1f(float __k) {
    return __detail::__comp_ellint_1<float>(__k);
  }

  inline long double comp_ellint_1l(long double __k) {
    return __detail::__comp_ellint_1<long double>(__k);
  }
# 387 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tp>
  inline typename __gnu_cxx::__promote<_Tp>::__type comp_ellint_1(_Tp __k) {
    typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
    return __detail::__comp_ellint_1<__type>(__k);
  }
# 403 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float comp_ellint_2f(float __k) {
    return __detail::__comp_ellint_2<float>(__k);
  }

  inline long double comp_ellint_2l(long double __k) {
    return __detail::__comp_ellint_2<long double>(__k);
  }
# 434 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tp>
  inline typename __gnu_cxx::__promote<_Tp>::__type comp_ellint_2(_Tp __k) {
    typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
    return __detail::__comp_ellint_2<__type>(__k);
  }
# 450 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float comp_ellint_3f(float __k, float __nu) {
    return __detail::__comp_ellint_3<float>(__k, __nu);
  }

  inline long double comp_ellint_3l(long double __k, long double __nu) {
    return __detail::__comp_ellint_3<long double>(__k, __nu);
  }
# 485 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tp, typename _Tpn>
  inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type comp_ellint_3(
      _Tp __k, _Tpn __nu) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type __type;
    return __detail::__comp_ellint_3<__type>(__k, __nu);
  }
# 501 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float cyl_bessel_if(float __nu, float __x) {
    return __detail::__cyl_bessel_i<float>(__nu, __x);
  }

  inline long double cyl_bessel_il(long double __nu, long double __x) {
    return __detail::__cyl_bessel_i<long double>(__nu, __x);
  }
# 531 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tpnu, typename _Tp>
  inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_bessel_i(
      _Tpnu __nu, _Tp __x) {
    typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
    return __detail::__cyl_bessel_i<__type>(__nu, __x);
  }
# 547 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float cyl_bessel_jf(float __nu, float __x) {
    return __detail::__cyl_bessel_j<float>(__nu, __x);
  }

  inline long double cyl_bessel_jl(long double __nu, long double __x) {
    return __detail::__cyl_bessel_j<long double>(__nu, __x);
  }
# 577 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tpnu, typename _Tp>
  inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_bessel_j(
      _Tpnu __nu, _Tp __x) {
    typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
    return __detail::__cyl_bessel_j<__type>(__nu, __x);
  }
# 593 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float cyl_bessel_kf(float __nu, float __x) {
    return __detail::__cyl_bessel_k<float>(__nu, __x);
  }

  inline long double cyl_bessel_kl(long double __nu, long double __x) {
    return __detail::__cyl_bessel_k<long double>(__nu, __x);
  }
# 629 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tpnu, typename _Tp>
  inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_bessel_k(
      _Tpnu __nu, _Tp __x) {
    typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
    return __detail::__cyl_bessel_k<__type>(__nu, __x);
  }
# 645 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float cyl_neumannf(float __nu, float __x) {
    return __detail::__cyl_neumann_n<float>(__nu, __x);
  }

  inline long double cyl_neumannl(long double __nu, long double __x) {
    return __detail::__cyl_neumann_n<long double>(__nu, __x);
  }
# 677 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tpnu, typename _Tp>
  inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type cyl_neumann(
      _Tpnu __nu, _Tp __x) {
    typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
    return __detail::__cyl_neumann_n<__type>(__nu, __x);
  }
# 693 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float ellint_1f(float __k, float __phi) {
    return __detail::__ellint_1<float>(__k, __phi);
  }

  inline long double ellint_1l(long double __k, long double __phi) {
    return __detail::__ellint_1<long double>(__k, __phi);
  }
# 725 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tp, typename _Tpp>
  inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type ellint_1(
      _Tp __k, _Tpp __phi) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
    return __detail::__ellint_1<__type>(__k, __phi);
  }
# 741 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float ellint_2f(float __k, float __phi) {
    return __detail::__ellint_2<float>(__k, __phi);
  }

  inline long double ellint_2l(long double __k, long double __phi) {
    return __detail::__ellint_2<long double>(__k, __phi);
  }
# 773 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tp, typename _Tpp>
  inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type ellint_2(
      _Tp __k, _Tpp __phi) {
    typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
    return __detail::__ellint_2<__type>(__k, __phi);
  }
# 789 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float ellint_3f(float __k, float __nu, float __phi) {
    return __detail::__ellint_3<float>(__k, __nu, __phi);
  }

  inline long double ellint_3l(long double __k, long double __nu,
                               long double __phi) {
    return __detail::__ellint_3<long double>(__k, __nu, __phi);
  }
# 826 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tp, typename _Tpn, typename _Tpp>
  inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type ellint_3(
      _Tp __k, _Tpn __nu, _Tpp __phi) {
    typedef typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type __type;
    return __detail::__ellint_3<__type>(__k, __nu, __phi);
  }
# 841 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float expintf(float __x) { return __detail::__expint<float>(__x); }

  inline long double expintl(long double __x) {
    return __detail::__expint<long double>(__x);
  }
# 866 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tp>
  inline typename __gnu_cxx::__promote<_Tp>::__type expint(_Tp __x) {
    typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
    return __detail::__expint<__type>(__x);
  }
# 882 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float hermitef(unsigned int __n, float __x) {
    return __detail::__poly_hermite<float>(__n, __x);
  }

  inline long double hermitel(unsigned int __n, long double __x) {
    return __detail::__poly_hermite<long double>(__n, __x);
  }
# 914 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tp>
  inline typename __gnu_cxx::__promote<_Tp>::__type hermite(unsigned int __n,
                                                            _Tp __x) {
    typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
    return __detail::__poly_hermite<__type>(__n, __x);
  }
# 930 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float laguerref(unsigned int __n, float __x) {
    return __detail::__laguerre<float>(__n, __x);
  }

  inline long double laguerrel(unsigned int __n, long double __x) {
    return __detail::__laguerre<long double>(__n, __x);
  }
# 958 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tp>
  inline typename __gnu_cxx::__promote<_Tp>::__type laguerre(unsigned int __n,
                                                             _Tp __x) {
    typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
    return __detail::__laguerre<__type>(__n, __x);
  }
# 974 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float legendref(unsigned int __l, float __x) {
    return __detail::__poly_legendre_p<float>(__l, __x);
  }

  inline long double legendrel(unsigned int __l, long double __x) {
    return __detail::__poly_legendre_p<long double>(__l, __x);
  }
# 1003 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tp>
  inline typename __gnu_cxx::__promote<_Tp>::__type legendre(unsigned int __l,
                                                             _Tp __x) {
    typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
    return __detail::__poly_legendre_p<__type>(__l, __x);
  }
# 1019 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float riemann_zetaf(float __s) {
    return __detail::__riemann_zeta<float>(__s);
  }

  inline long double riemann_zetal(long double __s) {
    return __detail::__riemann_zeta<long double>(__s);
  }
# 1054 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tp>
  inline typename __gnu_cxx::__promote<_Tp>::__type riemann_zeta(_Tp __s) {
    typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
    return __detail::__riemann_zeta<__type>(__s);
  }
# 1070 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float sph_besself(unsigned int __n, float __x) {
    return __detail::__sph_bessel<float>(__n, __x);
  }

  inline long double sph_bessell(unsigned int __n, long double __x) {
    return __detail::__sph_bessel<long double>(__n, __x);
  }
# 1098 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tp>
  inline typename __gnu_cxx::__promote<_Tp>::__type sph_bessel(unsigned int __n,
                                                               _Tp __x) {
    typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
    return __detail::__sph_bessel<__type>(__n, __x);
  }
# 1114 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float sph_legendref(unsigned int __l, unsigned int __m,
                             float __theta) {
    return __detail::__sph_legendre<float>(__l, __m, __theta);
  }
# 1125 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline long double sph_legendrel(unsigned int __l, unsigned int __m,
                                   long double __theta) {
    return __detail::__sph_legendre<long double>(__l, __m, __theta);
  }
# 1145 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tp>
  inline typename __gnu_cxx::__promote<_Tp>::__type sph_legendre(
      unsigned int __l, unsigned int __m, _Tp __theta) {
    typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
    return __detail::__sph_legendre<__type>(__l, __m, __theta);
  }
# 1161 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  inline float sph_neumannf(unsigned int __n, float __x) {
    return __detail::__sph_neumann<float>(__n, __x);
  }

  inline long double sph_neumannl(unsigned int __n, long double __x) {
    return __detail::__sph_neumann<long double>(__n, __x);
  }
# 1189 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/specfun.h" 3
  template <typename _Tp>
  inline typename __gnu_cxx::__promote<_Tp>::__type sph_neumann(
      unsigned int __n, _Tp __x) {
    typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
    return __detail::__sph_neumann<__type>(__n, __x);
  }

} // namespace std
# 3700 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cmath" 2 3
}
# 3 "CG_stdexec.hpp" 2

# 1 "./CGData.hpp" 1
# 24 "./CGData.hpp"
# 1 "./SparseMatrix.hpp" 1
# 24 "./SparseMatrix.hpp"
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/vector" 1 3
# 59 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/vector" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_uninitialized.h" 1 3
# 70 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_uninitialized.h" 3
namespace std __attribute__((__visibility__("default"))) {
# 81 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_uninitialized.h" 3
  template <typename _ValueType, typename _Tp>
  constexpr bool __check_constructible() {

    static_assert(is_constructible<_ValueType, _Tp>::value,
                  "result type must be constructible from input type");

    return true;
  }
# 110 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_uninitialized.h" 3
  template <typename _InputIterator, typename _ForwardIterator>
  constexpr _ForwardIterator __do_uninit_copy(_InputIterator __first,
                                              _InputIterator __last,
                                              _ForwardIterator __result) {
    _ForwardIterator __cur = __result;
    try {
      for (; __first != __last; ++__first, (void)++__cur)
        std::_Construct(std::__addressof(*__cur), *__first);
      return __cur;
    } catch (...) {
      std::_Destroy(__result, __cur);
      throw;
    }
  }

  template <bool _TrivialValueTypes> struct __uninitialized_copy {
    template <typename _InputIterator, typename _ForwardIterator>
    static _ForwardIterator __uninit_copy(_InputIterator __first,
                                          _InputIterator __last,
                                          _ForwardIterator __result) {
      return std::__do_uninit_copy(__first, __last, __result);
    }
  };

  template <> struct __uninitialized_copy<true> {
    template <typename _InputIterator, typename _ForwardIterator>
    static _ForwardIterator __uninit_copy(_InputIterator __first,
                                          _InputIterator __last,
                                          _ForwardIterator __result) {
      return std::copy(__first, __last, __result);
    }
  };
# 161 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_uninitialized.h" 3
  template <typename _InputIterator, typename _ForwardIterator>
  inline _ForwardIterator uninitialized_copy(_InputIterator __first,
                                             _InputIterator __last,
                                             _ForwardIterator __result) {
    typedef typename iterator_traits<_InputIterator>::value_type _ValueType1;
    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;

    const bool __can_memmove = __is_trivial(_ValueType1);

    using _From = decltype(*__first);

    const bool __assignable = __is_trivial(_ValueType2) &&
                              __is_assignable(_ValueType2 &, _From) &&
                              std::__check_constructible<_ValueType2, _From>();

    return std::__uninitialized_copy < __can_memmove &&
           __assignable > ::__uninit_copy(__first, __last, __result);
  }

  template <typename _ForwardIterator, typename _Tp>
  constexpr void __do_uninit_fill(_ForwardIterator __first,
                                  _ForwardIterator __last, const _Tp &__x) {
    _ForwardIterator __cur = __first;
    try {
      for (; __cur != __last; ++__cur)
        std::_Construct(std::__addressof(*__cur), __x);
    } catch (...) {
      std::_Destroy(__first, __cur);
      throw;
    }
  }

  template <bool _TrivialValueType> struct __uninitialized_fill {
    template <typename _ForwardIterator, typename _Tp>
    static void __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                              const _Tp &__x) {
      std::__do_uninit_fill(__first, __last, __x);
    }
  };

  template <> struct __uninitialized_fill<true> {
    template <typename _ForwardIterator, typename _Tp>
    static void __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                              const _Tp &__x) {
      std::fill(__first, __last, __x);
    }
  };
# 239 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_uninitialized.h" 3
  template <typename _ForwardIterator, typename _Tp>
  inline void uninitialized_fill(_ForwardIterator __first,
                                 _ForwardIterator __last, const _Tp &__x) {
    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;

    const bool __can_fill =
        __is_trivial(_ValueType) &&
        __is_assignable(_ValueType &, const _Tp &) &&
        std::__check_constructible<_ValueType, const _Tp &>();

    std::__uninitialized_fill<__can_fill>::__uninit_fill(__first, __last, __x);
  }

  template <typename _ForwardIterator, typename _Size, typename _Tp>
  constexpr _ForwardIterator __do_uninit_fill_n(_ForwardIterator __first,
                                                _Size __n, const _Tp &__x) {
    _ForwardIterator __cur = __first;
    try {
      for (; __n > 0; --__n, (void)++__cur)
        std::_Construct(std::__addressof(*__cur), __x);
      return __cur;
    } catch (...) {
      std::_Destroy(__first, __cur);
      throw;
    }
  }

  template <bool _TrivialValueType> struct __uninitialized_fill_n {
    template <typename _ForwardIterator, typename _Size, typename _Tp>
    static _ForwardIterator __uninit_fill_n(_ForwardIterator __first, _Size __n,
                                            const _Tp &__x) {
      return std::__do_uninit_fill_n(__first, __n, __x);
    }
  };

  template <> struct __uninitialized_fill_n<true> {
    template <typename _ForwardIterator, typename _Size, typename _Tp>
    static _ForwardIterator __uninit_fill_n(_ForwardIterator __first, _Size __n,
                                            const _Tp &__x) {
      return std::fill_n(__first, __n, __x);
    }
  };
# 310 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_uninitialized.h" 3
  template <typename _ForwardIterator, typename _Size, typename _Tp>
  inline _ForwardIterator uninitialized_fill_n(_ForwardIterator __first,
                                               _Size __n, const _Tp &__x) {
    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;

    const bool __can_fill =
        __is_trivial(_ValueType) &&
        __is_assignable(_ValueType &, const _Tp &) &&
        std::__check_constructible<_ValueType, const _Tp &>()

        && __is_integer<_Size>::__value;

    return __uninitialized_fill_n<__can_fill>::__uninit_fill_n(__first, __n,
                                                               __x);
  }
# 340 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_uninitialized.h" 3
  template <typename _InputIterator, typename _ForwardIterator,
            typename _Allocator>
  constexpr _ForwardIterator __uninitialized_copy_a(
      _InputIterator __first, _InputIterator __last, _ForwardIterator __result,
      _Allocator & __alloc) {
    _ForwardIterator __cur = __result;
    try {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first, (void)++__cur)
        __traits::construct(__alloc, std::__addressof(*__cur), *__first);
      return __cur;
    } catch (...) {
      std::_Destroy(__result, __cur, __alloc);
      throw;
    }
  }

  template <typename _InputIterator, typename _ForwardIterator, typename _Tp>
  constexpr inline _ForwardIterator __uninitialized_copy_a(
      _InputIterator __first, _InputIterator __last, _ForwardIterator __result,
      allocator<_Tp> &) {

    if (std::is_constant_evaluated())
      return std::__do_uninit_copy(__first, __last, __result);

    return std::uninitialized_copy(__first, __last, __result);
  }

  template <typename _InputIterator, typename _ForwardIterator,
            typename _Allocator>
  constexpr inline _ForwardIterator __uninitialized_move_a(
      _InputIterator __first, _InputIterator __last, _ForwardIterator __result,
      _Allocator & __alloc) {
    return std::__uninitialized_copy_a(std::make_move_iterator(__first),
                                       std::make_move_iterator(__last),
                                       __result, __alloc);
  }

  template <typename _InputIterator, typename _ForwardIterator,
            typename _Allocator>
  constexpr inline _ForwardIterator __uninitialized_move_if_noexcept_a(
      _InputIterator __first, _InputIterator __last, _ForwardIterator __result,
      _Allocator & __alloc) {
    return std::__uninitialized_copy_a(
        std::__make_move_if_noexcept_iterator(__first),
        std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
  }

  template <typename _ForwardIterator, typename _Tp, typename _Allocator>
  constexpr void __uninitialized_fill_a(_ForwardIterator __first,
                                        _ForwardIterator __last, const _Tp &__x,
                                        _Allocator &__alloc) {
    _ForwardIterator __cur = __first;
    try {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __cur != __last; ++__cur)
        __traits::construct(__alloc, std::__addressof(*__cur), __x);
    } catch (...) {
      std::_Destroy(__first, __cur, __alloc);
      throw;
    }
  }

  template <typename _ForwardIterator, typename _Tp, typename _Tp2>
  constexpr inline void __uninitialized_fill_a(
      _ForwardIterator __first, _ForwardIterator __last, const _Tp &__x,
      allocator<_Tp2> &) {

    if (std::is_constant_evaluated())
      return std::__do_uninit_fill(__first, __last, __x);

    std::uninitialized_fill(__first, __last, __x);
  }

  template <typename _ForwardIterator, typename _Size, typename _Tp,
            typename _Allocator>
  constexpr _ForwardIterator __uninitialized_fill_n_a(_ForwardIterator __first,
                                                      _Size __n, const _Tp &__x,
                                                      _Allocator &__alloc) {
    _ForwardIterator __cur = __first;
    try {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __n > 0; --__n, (void)++__cur)
        __traits::construct(__alloc, std::__addressof(*__cur), __x);
      return __cur;
    } catch (...) {
      std::_Destroy(__first, __cur, __alloc);
      throw;
    }
  }

  template <typename _ForwardIterator, typename _Size, typename _Tp,
            typename _Tp2>
  constexpr inline _ForwardIterator __uninitialized_fill_n_a(
      _ForwardIterator __first, _Size __n, const _Tp &__x, allocator<_Tp2> &) {

    if (std::is_constant_evaluated())
      return std::__do_uninit_fill_n(__first, __n, __x);

    return std::uninitialized_fill_n(__first, __n, __x);
  }
# 485 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_uninitialized.h" 3
  template <typename _InputIterator1, typename _InputIterator2,
            typename _ForwardIterator, typename _Allocator>
  inline _ForwardIterator __uninitialized_copy_move(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _ForwardIterator __result, _Allocator & __alloc) {
    _ForwardIterator __mid =
        std::__uninitialized_copy_a(__first1, __last1, __result, __alloc);
    try {
      return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
    } catch (...) {
      std::_Destroy(__result, __mid, __alloc);
      throw;
    }
  }

  template <typename _InputIterator1, typename _InputIterator2,
            typename _ForwardIterator, typename _Allocator>
  inline _ForwardIterator __uninitialized_move_copy(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _ForwardIterator __result, _Allocator & __alloc) {
    _ForwardIterator __mid =
        std::__uninitialized_move_a(__first1, __last1, __result, __alloc);
    try {
      return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
    } catch (...) {
      std::_Destroy(__result, __mid, __alloc);
      throw;
    }
  }

  template <typename _ForwardIterator, typename _Tp, typename _InputIterator,
            typename _Allocator>
  inline _ForwardIterator __uninitialized_fill_move(
      _ForwardIterator __result, _ForwardIterator __mid, const _Tp &__x,
      _InputIterator __first, _InputIterator __last, _Allocator &__alloc) {
    std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
    try {
      return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
    } catch (...) {
      std::_Destroy(__result, __mid, __alloc);
      throw;
    }
  }

  template <typename _InputIterator, typename _ForwardIterator, typename _Tp,
            typename _Allocator>
  inline void __uninitialized_move_fill(
      _InputIterator __first1, _InputIterator __last1,
      _ForwardIterator __first2, _ForwardIterator __last2, const _Tp &__x,
      _Allocator &__alloc) {
    _ForwardIterator __mid2 =
        std::__uninitialized_move_a(__first1, __last1, __first2, __alloc);
    try {
      std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
    } catch (...) {
      std::_Destroy(__first2, __mid2, __alloc);
      throw;
    }
  }
# 592 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_uninitialized.h" 3
  template <bool _TrivialValueType> struct __uninitialized_default_1 {
    template <typename _ForwardIterator>
    static void __uninit_default(_ForwardIterator __first,
                                 _ForwardIterator __last) {
      _ForwardIterator __cur = __first;
      try {
        for (; __cur != __last; ++__cur)
          std::_Construct(std::__addressof(*__cur));
      } catch (...) {
        std::_Destroy(__first, __cur);
        throw;
      }
    }
  };

  template <> struct __uninitialized_default_1<true> {
    template <typename _ForwardIterator>
    static void __uninit_default(_ForwardIterator __first,
                                 _ForwardIterator __last) {
      if (__first == __last)
        return;

      typename iterator_traits<_ForwardIterator>::value_type *__val =
          std::__addressof(*__first);
      std::_Construct(__val);
      if (++__first != __last)
        std::fill(__first, __last, *__val);
    }
  };

  template <bool _TrivialValueType> struct __uninitialized_default_n_1 {
    template <typename _ForwardIterator, typename _Size>
    constexpr static _ForwardIterator
    __uninit_default_n(_ForwardIterator __first, _Size __n) {
      _ForwardIterator __cur = __first;
      try {
        for (; __n > 0; --__n, (void)++__cur)
          std::_Construct(std::__addressof(*__cur));
        return __cur;
      } catch (...) {
        std::_Destroy(__first, __cur);
        throw;
      }
    }
  };

  template <> struct __uninitialized_default_n_1<true> {
    template <typename _ForwardIterator, typename _Size>
    constexpr static _ForwardIterator
    __uninit_default_n(_ForwardIterator __first, _Size __n) {
      if (__n > 0) {
        typename iterator_traits<_ForwardIterator>::value_type *__val =
            std::__addressof(*__first);
        std::_Construct(__val);
        ++__first;
        __first = std::fill_n(__first, __n - 1, *__val);
      }
      return __first;
    }
  };

  template <typename _ForwardIterator>
  inline void __uninitialized_default(_ForwardIterator __first,
                                      _ForwardIterator __last) {
    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;

    const bool __assignable = is_copy_assignable<_ValueType>::value;

    std::__uninitialized_default_1<__is_trivial(_ValueType) &&
                                   __assignable>::__uninit_default(__first,
                                                                   __last);
  }

  template <typename _ForwardIterator, typename _Size>
  constexpr inline _ForwardIterator __uninitialized_default_n(
      _ForwardIterator __first, _Size __n) {

    if (std::is_constant_evaluated())
      return __uninitialized_default_n_1<false>::__uninit_default_n(__first,
                                                                    __n);

    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;

    constexpr bool __can_fill =
        __and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value;

    return __uninitialized_default_n_1 < __is_trivial(_ValueType) &&
           __can_fill > ::__uninit_default_n(__first, __n);
  }

  template <typename _ForwardIterator, typename _Allocator>
  void __uninitialized_default_a(
      _ForwardIterator __first, _ForwardIterator __last, _Allocator & __alloc) {
    _ForwardIterator __cur = __first;
    try {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __cur != __last; ++__cur)
        __traits::construct(__alloc, std::__addressof(*__cur));
    } catch (...) {
      std::_Destroy(__first, __cur, __alloc);
      throw;
    }
  }

  template <typename _ForwardIterator, typename _Tp>
  inline void __uninitialized_default_a(
      _ForwardIterator __first, _ForwardIterator __last, allocator<_Tp> &) {
    std::__uninitialized_default(__first, __last);
  }

  template <typename _ForwardIterator, typename _Size, typename _Allocator>
  constexpr _ForwardIterator __uninitialized_default_n_a(
      _ForwardIterator __first, _Size __n, _Allocator & __alloc) {
    _ForwardIterator __cur = __first;
    try {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __n > 0; --__n, (void)++__cur)
        __traits::construct(__alloc, std::__addressof(*__cur));
      return __cur;
    } catch (...) {
      std::_Destroy(__first, __cur, __alloc);
      throw;
    }
  }

  template <typename _ForwardIterator, typename _Size, typename _Tp>
  constexpr inline _ForwardIterator __uninitialized_default_n_a(
      _ForwardIterator __first, _Size __n, allocator<_Tp> &) {
    return std::__uninitialized_default_n(__first, __n);
  }

  template <bool _TrivialValueType> struct __uninitialized_default_novalue_1 {
    template <typename _ForwardIterator>
    static void __uninit_default_novalue(_ForwardIterator __first,
                                         _ForwardIterator __last) {
      _ForwardIterator __cur = __first;
      try {
        for (; __cur != __last; ++__cur)
          std::_Construct_novalue(std::__addressof(*__cur));
      } catch (...) {
        std::_Destroy(__first, __cur);
        throw;
      }
    }
  };

  template <> struct __uninitialized_default_novalue_1<true> {
    template <typename _ForwardIterator>
    static void __uninit_default_novalue(_ForwardIterator, _ForwardIterator) {}
  };

  template <bool _TrivialValueType> struct __uninitialized_default_novalue_n_1 {
    template <typename _ForwardIterator, typename _Size>
    static _ForwardIterator __uninit_default_novalue_n(_ForwardIterator __first,
                                                       _Size __n) {
      _ForwardIterator __cur = __first;
      try {
        for (; __n > 0; --__n, (void)++__cur)
          std::_Construct_novalue(std::__addressof(*__cur));
        return __cur;
      } catch (...) {
        std::_Destroy(__first, __cur);
        throw;
      }
    }
  };

  template <> struct __uninitialized_default_novalue_n_1<true> {
    template <typename _ForwardIterator, typename _Size>
    static _ForwardIterator __uninit_default_novalue_n(_ForwardIterator __first,
                                                       _Size __n) {
      return std::next(__first, __n);
    }
  };

  template <typename _ForwardIterator>
  inline void __uninitialized_default_novalue(_ForwardIterator __first,
                                              _ForwardIterator __last) {
    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;

    std::__uninitialized_default_novalue_1<is_trivially_default_constructible<
        _ValueType>::value>::__uninit_default_novalue(__first, __last);
  }

  template <typename _ForwardIterator, typename _Size>
  inline _ForwardIterator __uninitialized_default_novalue_n(
      _ForwardIterator __first, _Size __n) {
    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;

    return __uninitialized_default_novalue_n_1<
        is_trivially_default_constructible<_ValueType>::value>::
        __uninit_default_novalue_n(__first, __n);
  }

  template <typename _InputIterator, typename _Size, typename _ForwardIterator>
  _ForwardIterator __uninitialized_copy_n(_InputIterator __first, _Size __n,
                                          _ForwardIterator __result,
                                          input_iterator_tag) {
    _ForwardIterator __cur = __result;
    try {
      for (; __n > 0; --__n, (void)++__first, ++__cur)
        std::_Construct(std::__addressof(*__cur), *__first);
      return __cur;
    } catch (...) {
      std::_Destroy(__result, __cur);
      throw;
    }
  }

  template <typename _RandomAccessIterator, typename _Size,
            typename _ForwardIterator>
  inline _ForwardIterator __uninitialized_copy_n(
      _RandomAccessIterator __first, _Size __n, _ForwardIterator __result,
      random_access_iterator_tag) {
    return std::uninitialized_copy(__first, __first + __n, __result);
  }

  template <typename _InputIterator, typename _Size, typename _ForwardIterator>
  pair<_InputIterator, _ForwardIterator> __uninitialized_copy_n_pair(
      _InputIterator __first, _Size __n, _ForwardIterator __result,
      input_iterator_tag) {
    _ForwardIterator __cur = __result;
    try {
      for (; __n > 0; --__n, (void)++__first, ++__cur)
        std::_Construct(std::__addressof(*__cur), *__first);
      return {__first, __cur};
    } catch (...) {
      std::_Destroy(__result, __cur);
      throw;
    }
  }

  template <typename _RandomAccessIterator, typename _Size,
            typename _ForwardIterator>
  inline pair<_RandomAccessIterator, _ForwardIterator>
  __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
                              _ForwardIterator __result,
                              random_access_iterator_tag) {
    auto __second_res = uninitialized_copy(__first, __first + __n, __result);
    auto __first_res = std::next(__first, __n);
    return {__first_res, __second_res};
  }
# 946 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_uninitialized.h" 3
  template <typename _InputIterator, typename _Size, typename _ForwardIterator>
  inline _ForwardIterator uninitialized_copy_n(
      _InputIterator __first, _Size __n, _ForwardIterator __result) {
    return std::__uninitialized_copy_n(__first, __n, __result,
                                       std::__iterator_category(__first));
  }

  template <typename _InputIterator, typename _Size, typename _ForwardIterator>
  inline pair<_InputIterator, _ForwardIterator> __uninitialized_copy_n_pair(
      _InputIterator __first, _Size __n, _ForwardIterator __result) {
    return std::__uninitialized_copy_n_pair(__first, __n, __result,
                                            std::__iterator_category(__first));
  }
# 975 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_uninitialized.h" 3
  template <typename _ForwardIterator>
  inline void uninitialized_default_construct(_ForwardIterator __first,
                                              _ForwardIterator __last) {
    __uninitialized_default_novalue(__first, __last);
  }
# 990 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_uninitialized.h" 3
  template <typename _ForwardIterator, typename _Size>
  inline _ForwardIterator uninitialized_default_construct_n(
      _ForwardIterator __first, _Size __count) {
    return __uninitialized_default_novalue_n(__first, __count);
  }

  template <typename _ForwardIterator>
  inline void uninitialized_value_construct(_ForwardIterator __first,
                                            _ForwardIterator __last) {
    return __uninitialized_default(__first, __last);
  }
# 1018 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_uninitialized.h" 3
  template <typename _ForwardIterator, typename _Size>
  inline _ForwardIterator uninitialized_value_construct_n(
      _ForwardIterator __first, _Size __count) {
    return __uninitialized_default_n(__first, __count);
  }
# 1033 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_uninitialized.h" 3
  template <typename _InputIterator, typename _ForwardIterator>
  inline _ForwardIterator uninitialized_move(_InputIterator __first,
                                             _InputIterator __last,
                                             _ForwardIterator __result) {
    return std::uninitialized_copy(std::make_move_iterator(__first),
                                   std::make_move_iterator(__last), __result);
  }
# 1051 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_uninitialized.h" 3
  template <typename _InputIterator, typename _Size, typename _ForwardIterator>
  inline pair<_InputIterator, _ForwardIterator> uninitialized_move_n(
      _InputIterator __first, _Size __count, _ForwardIterator __result) {
    auto __res = std::__uninitialized_copy_n_pair(
        std::make_move_iterator(__first), __count, __result);
    return {__res.first.base(), __res.second};
  }

  template <typename _Tp, typename _Up, typename _Allocator>
  constexpr inline void __relocate_object_a(
      _Tp *__restrict __dest, _Up *__restrict __orig,
      _Allocator &
          __alloc) noexcept(noexcept(std::allocator_traits<_Allocator>::
                                         construct(__alloc, __dest,
                                                   std::move(*__orig))) &&
                            noexcept(std::allocator_traits<_Allocator>::destroy(
                                __alloc, std::__addressof(*__orig)))) {
    typedef std::allocator_traits<_Allocator> __traits;
    __traits::construct(__alloc, __dest, std::move(*__orig));
    __traits::destroy(__alloc, std::__addressof(*__orig));
  }

  template <typename _Tp, typename = void>
  struct __is_bitwise_relocatable : is_trivial<_Tp> {};

  template <typename _InputIterator, typename _ForwardIterator,
            typename _Allocator>
  constexpr inline _ForwardIterator __relocate_a_1(
      _InputIterator __first, _InputIterator __last, _ForwardIterator __result,
      _Allocator & __alloc) noexcept(noexcept(std::
                                                  __relocate_object_a(
                                                      std::addressof(*__result),
                                                      std::addressof(*__first),
                                                      __alloc))) {
    typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;
    static_assert(std::is_same<_ValueType, _ValueType2>::value,
                  "relocation is only possible for values of the same type");
    _ForwardIterator __cur = __result;
    for (; __first != __last; ++__first, (void)++__cur)
      std::__relocate_object_a(std::__addressof(*__cur),
                               std::__addressof(*__first), __alloc);
    return __cur;
  }

  template <typename _Tp, typename _Up>
  constexpr inline __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value,
                                 _Tp *>
  __relocate_a_1(_Tp * __first, _Tp * __last, _Tp * __result,
                 [[__maybe_unused__]] allocator<_Up> & __alloc) noexcept {
    ptrdiff_t __count = __last - __first;
    if (__count > 0) {

      if (std::is_constant_evaluated()) {

        __gnu_cxx::__normal_iterator<_Tp *, void> __out(__result);
        __out = std::__relocate_a_1(__first, __last, __out, __alloc);
        return __out.base();
      }

      __builtin_memmove(__result, __first, __count * sizeof(_Tp));
    }
    return __result + __count;
  }

  template <typename _InputIterator, typename _ForwardIterator,
            typename _Allocator>
  constexpr inline _ForwardIterator __relocate_a(
      _InputIterator __first, _InputIterator __last, _ForwardIterator __result,
      _Allocator &
          __alloc) noexcept(noexcept(__relocate_a_1(std::__niter_base(__first),
                                                    std::__niter_base(__last),
                                                    std::__niter_base(__result),
                                                    __alloc))) {
    return std::__relocate_a_1(std::__niter_base(__first),
                               std::__niter_base(__last),
                               std::__niter_base(__result), __alloc);
  }

} // namespace std
# 66 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/vector" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 1 3
# 78 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
namespace std __attribute__((__visibility__("default"))) {

  template <typename _Tp, typename _Alloc> struct _Vector_base {
    typedef
        typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<_Tp>::other
            _Tp_alloc_type;
    typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer pointer;

    struct _Vector_impl_data {
      pointer _M_start;
      pointer _M_finish;
      pointer _M_end_of_storage;

      constexpr _Vector_impl_data() noexcept
          : _M_start(), _M_finish(), _M_end_of_storage() {}

      constexpr _Vector_impl_data(_Vector_impl_data &&__x) noexcept
          : _M_start(__x._M_start), _M_finish(__x._M_finish),
            _M_end_of_storage(__x._M_end_of_storage) {
        __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer();
      }

      constexpr void _M_copy_data(_Vector_impl_data const &__x) noexcept {
        _M_start = __x._M_start;
        _M_finish = __x._M_finish;
        _M_end_of_storage = __x._M_end_of_storage;
      }

      constexpr void _M_swap_data(_Vector_impl_data &__x) noexcept {

        _Vector_impl_data __tmp;
        __tmp._M_copy_data(*this);
        _M_copy_data(__x);
        __x._M_copy_data(__tmp);
      }
    };

    struct _Vector_impl : public _Tp_alloc_type, public _Vector_impl_data {
      constexpr _Vector_impl() noexcept(
          is_nothrow_default_constructible<_Tp_alloc_type>::value)

        requires is_default_constructible_v<_Tp_alloc_type>

          : _Tp_alloc_type() {}

      constexpr _Vector_impl(_Tp_alloc_type const &__a) noexcept
          : _Tp_alloc_type(__a) {}

      constexpr _Vector_impl(_Vector_impl &&__x) noexcept
          : _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x)) {}

      constexpr _Vector_impl(_Tp_alloc_type &&__a) noexcept
          : _Tp_alloc_type(std::move(__a)) {}

      constexpr _Vector_impl(_Tp_alloc_type &&__a, _Vector_impl &&__rv) noexcept
          : _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv)) {
      }
# 294 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    };

  public:
    typedef _Alloc allocator_type;

    constexpr _Tp_alloc_type &_M_get_Tp_allocator() noexcept {
      return this->_M_impl;
    }

    constexpr const _Tp_alloc_type &_M_get_Tp_allocator() const noexcept {
      return this->_M_impl;
    }

    constexpr allocator_type get_allocator() const noexcept {
      return allocator_type(_M_get_Tp_allocator());
    }

    _Vector_base() = default;

    constexpr _Vector_base(const allocator_type &__a) noexcept : _M_impl(__a) {}

    constexpr _Vector_base(size_t __n) : _M_impl() { _M_create_storage(__n); }

    constexpr _Vector_base(size_t __n, const allocator_type &__a)
        : _M_impl(__a) {
      _M_create_storage(__n);
    }

    _Vector_base(_Vector_base &&) = default;

    constexpr _Vector_base(_Tp_alloc_type &&__a) noexcept
        : _M_impl(std::move(__a)) {}

    constexpr _Vector_base(_Vector_base &&__x, const allocator_type &__a)
        : _M_impl(__a) {
      if (__x.get_allocator() == __a)
        this->_M_impl._M_swap_data(__x._M_impl);
      else {
        size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
        _M_create_storage(__n);
      }
    }

    constexpr _Vector_base(const allocator_type &__a, _Vector_base &&__x)
        : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl)) {}

    constexpr ~_Vector_base() noexcept {
      _M_deallocate(_M_impl._M_start,
                    _M_impl._M_end_of_storage - _M_impl._M_start);
    }

  public:
    _Vector_impl _M_impl;

    constexpr pointer _M_allocate(size_t __n) {
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
      return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
    }

    constexpr void _M_deallocate(pointer __p, size_t __n) {
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
      if (__p)
        _Tr::deallocate(_M_impl, __p, __n);
    }

  protected:
    constexpr void _M_create_storage(size_t __n) {
      this->_M_impl._M_start = this->_M_allocate(__n);
      this->_M_impl._M_finish = this->_M_impl._M_start;
      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
    }
  };
# 427 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
  template <typename _Tp, typename _Alloc = std::allocator<_Tp>>
  class vector : protected _Vector_base<_Tp, _Alloc> {
# 440 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
                  "std::vector must have a non-const, non-volatile value_type");

    static_assert(is_same<typename _Alloc::value_type, _Tp>::value,
                  "std::vector must have the same value_type as its allocator");

    typedef _Vector_base<_Tp, _Alloc> _Base;
    typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
    typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

  public:
    typedef _Tp value_type;
    typedef typename _Base::pointer pointer;
    typedef typename _Alloc_traits::const_pointer const_pointer;
    typedef typename _Alloc_traits::reference reference;
    typedef typename _Alloc_traits::const_reference const_reference;
    typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
    typedef __gnu_cxx::__normal_iterator<const_pointer, vector> const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Alloc allocator_type;

  private:
    static constexpr bool _S_nothrow_relocate(true_type) {
      return noexcept(std::__relocate_a(
          std::declval<pointer>(), std::declval<pointer>(),
          std::declval<pointer>(), std::declval<_Tp_alloc_type &>()));
    }

    static constexpr bool _S_nothrow_relocate(false_type) { return false; }

    static constexpr bool _S_use_relocate() {

      return _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});
    }

    static pointer _S_do_relocate(pointer __first, pointer __last,
                                  pointer __result, _Tp_alloc_type &__alloc,
                                  true_type) noexcept {
      return std::__relocate_a(__first, __last, __result, __alloc);
    }

    static pointer _S_do_relocate(pointer, pointer, pointer __result,
                                  _Tp_alloc_type &, false_type) noexcept {
      return __result;
    }

    static constexpr pointer _S_relocate(pointer __first, pointer __last,
                                         pointer __result,
                                         _Tp_alloc_type &__alloc) noexcept {

      return std::__relocate_a(__first, __last, __result, __alloc);
    }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_M_get_Tp_allocator;
    using _Base::_M_impl;

  public:
    vector() = default;
# 540 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    explicit constexpr vector(const allocator_type &__a) noexcept
        : _Base(__a) {}
# 554 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    explicit constexpr vector(size_type __n,
                              const allocator_type &__a = allocator_type())
        : _Base(_S_check_init_len(__n, __a), __a) {
      _M_default_initialize(__n);
    }
# 568 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr vector(size_type __n, const value_type &__value,
                     const allocator_type &__a = allocator_type())
        : _Base(_S_check_init_len(__n, __a), __a) {
      _M_fill_initialize(__n, __value);
    }
# 600 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr vector(const vector &__x)
        : _Base(__x.size(),
                _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator())) {
      this->_M_impl._M_finish = std::__uninitialized_copy_a(
          __x.begin(), __x.end(), this->_M_impl._M_start,
          _M_get_Tp_allocator());
    }
# 620 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    vector(vector &&) noexcept = default;

    constexpr vector(const vector &__x,
                     const __type_identity_t<allocator_type> &__a)
        : _Base(__x.size(), __a) {
      this->_M_impl._M_finish = std::__uninitialized_copy_a(
          __x.begin(), __x.end(), this->_M_impl._M_start,
          _M_get_Tp_allocator());
    }

  private:
    constexpr vector(vector &&__rv, const allocator_type &__m,
                     true_type) noexcept
        : _Base(__m, std::move(__rv)) {}

    constexpr vector(vector &&__rv, const allocator_type &__m, false_type)
        : _Base(__m) {
      if (__rv.get_allocator() == __m)
        this->_M_impl._M_swap_data(__rv._M_impl);
      else if (!__rv.empty()) {
        this->_M_create_storage(__rv.size());
        this->_M_impl._M_finish = std::__uninitialized_move_a(
            __rv.begin(), __rv.end(), this->_M_impl._M_start,
            _M_get_Tp_allocator());
        __rv.clear();
      }
    }

  public:
    constexpr vector(
        vector &&__rv,
        const __type_identity_t<allocator_type> &
            __m) noexcept(noexcept(vector(std::declval<vector &&>(),
                                          std::declval<
                                              const allocator_type &>(),
                                          std::declval<typename _Alloc_traits::
                                                           is_always_equal>())))
        : vector(std::move(__rv), __m,
                 typename _Alloc_traits::is_always_equal{}) {}
# 677 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr vector(initializer_list<value_type> __l,
                     const allocator_type &__a = allocator_type())
        : _Base(__a) {
      _M_range_initialize(__l.begin(), __l.end(), random_access_iterator_tag());
    }
# 704 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    template <typename _InputIterator,
              typename = std::_RequireInputIter<_InputIterator>>
    constexpr vector(_InputIterator __first, _InputIterator __last,
                     const allocator_type &__a = allocator_type())
        : _Base(__a) {
      _M_range_initialize(__first, __last, std::__iterator_category(__first));
    }
# 732 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr ~vector() noexcept {
      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                    _M_get_Tp_allocator());
      ;
    }
# 749 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr vector &operator=(const vector &__x);
# 764 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr vector &
    operator=(vector &&__x) noexcept(_Alloc_traits::_S_nothrow_move()) {
      constexpr bool __move_storage =
          _Alloc_traits::_S_propagate_on_move_assign() ||
          _Alloc_traits::_S_always_equal();
      _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
      return *this;
    }
# 786 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr vector &operator=(initializer_list<value_type> __l) {
      this->_M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag());
      return *this;
    }
# 806 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr void assign(size_type __n, const value_type &__val) {
      _M_fill_assign(__n, __val);
    }
# 824 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    template <typename _InputIterator,
              typename = std::_RequireInputIter<_InputIterator>>
    constexpr void assign(_InputIterator __first, _InputIterator __last) {
      _M_assign_aux(__first, __last, std::__iterator_category(__first));
    }
# 853 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr void assign(initializer_list<value_type> __l) {
      this->_M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag());
    }

    using _Base::get_allocator;

    [[__nodiscard__]] constexpr iterator begin() noexcept {
      return iterator(this->_M_impl._M_start);
    }

    [[__nodiscard__]] constexpr const_iterator begin() const noexcept {
      return const_iterator(this->_M_impl._M_start);
    }

    [[__nodiscard__]] constexpr iterator end() noexcept {
      return iterator(this->_M_impl._M_finish);
    }

    [[__nodiscard__]] constexpr const_iterator end() const noexcept {
      return const_iterator(this->_M_impl._M_finish);
    }

    [[__nodiscard__]] constexpr reverse_iterator rbegin() noexcept {
      return reverse_iterator(end());
    }

    [[__nodiscard__]] constexpr const_reverse_iterator rbegin() const noexcept {
      return const_reverse_iterator(end());
    }

    [[__nodiscard__]] constexpr reverse_iterator rend() noexcept {
      return reverse_iterator(begin());
    }

    [[__nodiscard__]] constexpr const_reverse_iterator rend() const noexcept {
      return const_reverse_iterator(begin());
    }

    [[__nodiscard__]] constexpr const_iterator cbegin() const noexcept {
      return const_iterator(this->_M_impl._M_start);
    }

    [[__nodiscard__]] constexpr const_iterator cend() const noexcept {
      return const_iterator(this->_M_impl._M_finish);
    }

    [[__nodiscard__]] constexpr const_reverse_iterator
    crbegin() const noexcept {
      return const_reverse_iterator(end());
    }

    [[__nodiscard__]] constexpr const_reverse_iterator crend() const noexcept {
      return const_reverse_iterator(begin());
    }

    [[__nodiscard__]] constexpr size_type size() const noexcept {
      return size_type(this->_M_impl._M_finish - this->_M_impl._M_start);
    }

    [[__nodiscard__]] constexpr size_type max_size() const noexcept {
      return _S_max_size(_M_get_Tp_allocator());
    }
# 1011 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr void resize(size_type __new_size) {
      if (__new_size > size())
        _M_default_append(__new_size - size());
      else if (__new_size < size())
        _M_erase_at_end(this->_M_impl._M_start + __new_size);
    }
# 1032 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr void resize(size_type __new_size, const value_type &__x) {
      if (__new_size > size())
        _M_fill_insert(end(), __new_size - size(), __x);
      else if (__new_size < size())
        _M_erase_at_end(this->_M_impl._M_start + __new_size);
    }
# 1066 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr void shrink_to_fit() { _M_shrink_to_fit(); }

    [[__nodiscard__]] constexpr size_type capacity() const noexcept {
      return size_type(this->_M_impl._M_end_of_storage -
                       this->_M_impl._M_start);
    }

    [[__nodiscard__]] constexpr bool empty() const noexcept {
      return begin() == end();
    }
# 1108 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr void reserve(size_type __n);
# 1124 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    [[__nodiscard__]] constexpr reference operator[](size_type __n) noexcept {
      ;
      return *(this->_M_impl._M_start + __n);
    }
# 1143 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    [[__nodiscard__]] constexpr const_reference
    operator[](size_type __n) const noexcept {
      ;
      return *(this->_M_impl._M_start + __n);
    }

  protected:
    constexpr void _M_range_check(size_type __n) const {
      if (__n >= this->size())
        __throw_out_of_range_fmt(("vector::_M_range_check: __n "
                                  "(which is %zu) >= this->size() "
                                  "(which is %zu)"),

                                 __n, this->size());
    }

  public:
# 1176 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr reference at(size_type __n) {
      _M_range_check(__n);
      return (*this)[__n];
    }
# 1195 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr const_reference at(size_type __n) const {
      _M_range_check(__n);
      return (*this)[__n];
    }

    [[__nodiscard__]] constexpr reference front() noexcept {
      ;
      return *begin();
    }

    [[__nodiscard__]] constexpr const_reference front() const noexcept {
      ;
      return *begin();
    }

    [[__nodiscard__]] constexpr reference back() noexcept {
      ;
      return *(end() - 1);
    }

    [[__nodiscard__]] constexpr const_reference back() const noexcept {
      ;
      return *(end() - 1);
    }
# 1258 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    [[__nodiscard__]] constexpr _Tp *data() noexcept {
      return _M_data_ptr(this->_M_impl._M_start);
    }

    [[__nodiscard__]] constexpr const _Tp *data() const noexcept {
      return _M_data_ptr(this->_M_impl._M_start);
    }
# 1279 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr void push_back(const value_type &__x) {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage) {
        ;
        _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
        ++this->_M_impl._M_finish;
        ;
      } else
        _M_realloc_insert(end(), __x);
    }

    constexpr void push_back(value_type &&__x) { emplace_back(std::move(__x)); }

    template <typename... _Args>

    constexpr reference

    emplace_back(_Args &&...__args);
# 1320 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr void pop_back() noexcept {
      ;
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      ;
    }
# 1343 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    template <typename... _Args>
    constexpr iterator emplace(const_iterator __position, _Args &&...__args) {
      return _M_emplace_aux(__position, std::forward<_Args>(__args)...);
    }
# 1360 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr iterator insert(const_iterator __position, const value_type &__x);
# 1391 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr iterator insert(const_iterator __position, value_type &&__x) {
      return _M_insert_rval(__position, std::move(__x));
    }
# 1409 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr iterator insert(const_iterator __position,
                              initializer_list<value_type> __l) {
      auto __offset = __position - cbegin();
      _M_range_insert(begin() + __offset, __l.begin(), __l.end(),
                      std::random_access_iterator_tag());
      return begin() + __offset;
    }
# 1435 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr iterator insert(const_iterator __position, size_type __n,
                              const value_type &__x) {
      difference_type __offset = __position - cbegin();
      _M_fill_insert(begin() + __offset, __n, __x);
      return begin() + __offset;
    }
# 1478 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    template <typename _InputIterator,
              typename = std::_RequireInputIter<_InputIterator>>
    constexpr iterator insert(const_iterator __position, _InputIterator __first,
                              _InputIterator __last) {
      difference_type __offset = __position - cbegin();
      _M_range_insert(begin() + __offset, __first, __last,
                      std::__iterator_category(__first));
      return begin() + __offset;
    }
# 1531 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr iterator

    erase(const_iterator __position) {
      return _M_erase(begin() + (__position - cbegin()));
    }
# 1559 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr iterator

    erase(const_iterator __first, const_iterator __last) {
      const auto __beg = begin();
      const auto __cbeg = cbegin();
      return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
    }
# 1584 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    constexpr void swap(vector &__x) noexcept {

      do {
        if (std::__is_constant_evaluated() &&
            !bool(_Alloc_traits::propagate_on_container_swap::value ||
                  _M_get_Tp_allocator() == __x._M_get_Tp_allocator()))
          __builtin_unreachable();
      } while (false);

      this->_M_impl._M_swap_data(__x._M_impl);
      _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                                __x._M_get_Tp_allocator());
    }

    constexpr void clear() noexcept { _M_erase_at_end(this->_M_impl._M_start); }

  protected:
    template <typename _ForwardIterator>
    constexpr pointer _M_allocate_and_copy(size_type __n,
                                           _ForwardIterator __first,
                                           _ForwardIterator __last) {
      pointer __result = this->_M_allocate(__n);
      try {
        std::__uninitialized_copy_a(__first, __last, __result,
                                    _M_get_Tp_allocator());
        return __result;
      } catch (...) {
        _M_deallocate(__result, __n);
        throw;
      }
    }
# 1664 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    template <typename _InputIterator>
    constexpr void _M_range_initialize(_InputIterator __first,
                                       _InputIterator __last,
                                       std::input_iterator_tag) {
      try {
        for (; __first != __last; ++__first)

          emplace_back(*__first);

      } catch (...) {
        clear();
        throw;
      }
    }

    template <typename _ForwardIterator>
    constexpr void _M_range_initialize(_ForwardIterator __first,
                                       _ForwardIterator __last,
                                       std::forward_iterator_tag) {
      const size_type __n = std::distance(__first, __last);
      this->_M_impl._M_start =
          this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      this->_M_impl._M_finish = std::__uninitialized_copy_a(
          __first, __last, this->_M_impl._M_start, _M_get_Tp_allocator());
    }

    constexpr void _M_fill_initialize(size_type __n,
                                      const value_type &__value) {
      this->_M_impl._M_finish = std::__uninitialized_fill_n_a(
          this->_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
    }

    constexpr void _M_default_initialize(size_type __n) {
      this->_M_impl._M_finish = std::__uninitialized_default_n_a(
          this->_M_impl._M_start, __n, _M_get_Tp_allocator());
    }
# 1730 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    template <typename _Integer>
    constexpr void _M_assign_dispatch(_Integer __n, _Integer __val,
                                      __true_type) {
      _M_fill_assign(__n, __val);
    }

    template <typename _InputIterator>
    constexpr void _M_assign_dispatch(_InputIterator __first,
                                      _InputIterator __last, __false_type) {
      _M_assign_aux(__first, __last, std::__iterator_category(__first));
    }

    template <typename _InputIterator>
    constexpr void _M_assign_aux(_InputIterator __first, _InputIterator __last,
                                 std::input_iterator_tag);

    template <typename _ForwardIterator>
    constexpr void _M_assign_aux(_ForwardIterator __first,
                                 _ForwardIterator __last,
                                 std::forward_iterator_tag);

    constexpr void _M_fill_assign(size_type __n, const value_type &__val);

    template <typename _Integer>
    constexpr void _M_insert_dispatch(iterator __pos, _Integer __n,
                                      _Integer __val, __true_type) {
      _M_fill_insert(__pos, __n, __val);
    }

    template <typename _InputIterator>
    constexpr void _M_insert_dispatch(iterator __pos, _InputIterator __first,
                                      _InputIterator __last, __false_type) {
      _M_range_insert(__pos, __first, __last,
                      std::__iterator_category(__first));
    }

    template <typename _InputIterator>
    constexpr void _M_range_insert(iterator __pos, _InputIterator __first,
                                   _InputIterator __last,
                                   std::input_iterator_tag);

    template <typename _ForwardIterator>
    constexpr void _M_range_insert(iterator __pos, _ForwardIterator __first,
                                   _ForwardIterator __last,
                                   std::forward_iterator_tag);

    constexpr void _M_fill_insert(iterator __pos, size_type __n,
                                  const value_type &__x);

    constexpr void _M_default_append(size_type __n);

    constexpr bool _M_shrink_to_fit();
# 1829 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
    struct _Temporary_value {
      template <typename... _Args>
      constexpr explicit _Temporary_value(vector *__vec, _Args &&...__args)
          : _M_this(__vec) {
        _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
                                 std::forward<_Args>(__args)...);
      }

      constexpr ~_Temporary_value() {
        _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr());
      }

      constexpr value_type &_M_val() noexcept { return _M_storage._M_val; }

    private:
      constexpr _Tp *_M_ptr() noexcept {
        return std::__addressof(_M_storage._M_val);
      }

      union _Storage {
        constexpr _Storage() : _M_byte() {}
        constexpr ~_Storage() {}
        _Storage &operator=(const _Storage &) = delete;
        unsigned char _M_byte;
        _Tp _M_val;
      };

      vector *_M_this;
      _Storage _M_storage;
    };

    template <typename _Arg>
    constexpr void _M_insert_aux(iterator __position, _Arg &&__arg);

    template <typename... _Args>
    constexpr void _M_realloc_insert(iterator __position, _Args &&...__args);

    constexpr iterator _M_insert_rval(const_iterator __position,
                                      value_type &&__v);

    template <typename... _Args>
    constexpr iterator _M_emplace_aux(const_iterator __position,
                                      _Args &&...__args);

    constexpr iterator _M_emplace_aux(const_iterator __position,
                                      value_type &&__v) {
      return _M_insert_rval(__position, std::move(__v));
    }

    constexpr size_type _M_check_len(size_type __n, const char *__s) const {
      if (max_size() - size() < __n)
        __throw_length_error((__s));

      const size_type __len = size() + (std::max)(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    static constexpr size_type _S_check_init_len(size_type __n,
                                                 const allocator_type &__a) {
      if (__n > _S_max_size(_Tp_alloc_type(__a)))
        __throw_length_error(
            ("cannot create std::vector larger than max_size()"));
      return __n;
    }

    static constexpr size_type _S_max_size(const _Tp_alloc_type &__a) noexcept {

      const size_t __diffmax =
          __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      const size_t __allocmax = _Alloc_traits::max_size(__a);
      return (std::min)(__diffmax, __allocmax);
    }

    constexpr void _M_erase_at_end(pointer __pos) noexcept {
      if (size_type __n = this->_M_impl._M_finish - __pos) {
        std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
        this->_M_impl._M_finish = __pos;
        ;
      }
    }

    constexpr iterator _M_erase(iterator __position);

    constexpr iterator _M_erase(iterator __first, iterator __last);

  private:
    constexpr void _M_move_assign(vector &&__x, true_type) noexcept {
      vector __tmp(get_allocator());
      this->_M_impl._M_swap_data(__x._M_impl);
      __tmp._M_impl._M_swap_data(__x._M_impl);
      std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
    }

    constexpr void _M_move_assign(vector &&__x, false_type) {
      if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
        _M_move_assign(std::move(__x), true_type());
      else {

        this->_M_assign_aux(std::make_move_iterator(__x.begin()),
                            std::make_move_iterator(__x.end()),
                            std::random_access_iterator_tag());
        __x.clear();
      }
    }

    template <typename _Up>
    constexpr _Up *_M_data_ptr(_Up *__ptr) const noexcept {
      return __ptr;
    }

    template <typename _Ptr>
    constexpr typename std::pointer_traits<_Ptr>::element_type *
    _M_data_ptr(_Ptr __ptr) const {
      return empty() ? nullptr : std::__to_address(__ptr);
    }
# 2015 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
  };

  template <typename _InputIterator,
            typename _ValT =
                typename iterator_traits<_InputIterator>::value_type,
            typename _Allocator = allocator<_ValT>,
            typename = _RequireInputIter<_InputIterator>,
            typename = _RequireAllocator<_Allocator>>
  vector(_InputIterator, _InputIterator,
         _Allocator = _Allocator()) -> vector<_ValT, _Allocator>;
# 2037 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
  template <typename _Tp, typename _Alloc>
  constexpr inline bool operator==(const vector<_Tp, _Alloc> &__x,
                                   const vector<_Tp, _Alloc> &__y) {
    return (__x.size() == __y.size() &&
            std::equal(__x.begin(), __x.end(), __y.begin()));
  }
# 2056 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
  template <typename _Tp, typename _Alloc>
  constexpr inline __detail::__synth3way_t<_Tp> operator<=>(
      const vector<_Tp, _Alloc> &__x, const vector<_Tp, _Alloc> &__y) {
    return std::lexicographical_compare_three_way(
        __x.begin(), __x.end(), __y.begin(), __y.end(), __detail::__synth3way);
  }
# 2109 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_vector.h" 3
  template <typename _Tp, typename _Alloc>
  constexpr inline void swap(vector<_Tp, _Alloc> & __x,
                             vector<_Tp, _Alloc> &
                                 __y) noexcept(noexcept(__x.swap(__y))) {
    __x.swap(__y);
  }

  namespace __detail::__variant {
  template <typename> struct _Never_valueless_alt;

  template <typename _Tp, typename _Alloc>
  struct _Never_valueless_alt<std::vector<_Tp, _Alloc>>
      : std::is_nothrow_move_assignable<std::vector<_Tp, _Alloc>> {};
  } // namespace __detail::__variant

} // namespace std
# 67 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/vector" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_bvector.h" 1 3
# 68 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_bvector.h" 3
namespace std __attribute__((__visibility__("default"))) {

  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  __attribute__((__nonnull__)) constexpr void __fill_bvector_n(
      _Bit_type *, size_t, bool) noexcept;

  struct _Bit_reference {
    _Bit_type *_M_p;
    _Bit_type _M_mask;

    constexpr _Bit_reference(_Bit_type *__x, _Bit_type __y)
        : _M_p(__x), _M_mask(__y) {}

    constexpr _Bit_reference() noexcept : _M_p(0), _M_mask(0) {}

    _Bit_reference(const _Bit_reference &) = default;

    [[__nodiscard__]] constexpr operator bool() const noexcept {
      return !!(*_M_p & _M_mask);
    }

    constexpr _Bit_reference &operator=(bool __x) noexcept {
      if (__x)
        *_M_p |= _M_mask;
      else
        *_M_p &= ~_M_mask;
      return *this;
    }
# 125 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_bvector.h" 3
    constexpr _Bit_reference &operator=(const _Bit_reference &__x) noexcept {
      return *this = bool(__x);
    }

    [[__nodiscard__]] constexpr bool
    operator==(const _Bit_reference &__x) const {
      return bool(*this) == bool(__x);
    }

    [[__nodiscard__]] constexpr bool
    operator<(const _Bit_reference &__x) const {
      return !bool(*this) && bool(__x);
    }

    constexpr void flip() noexcept { *_M_p ^= _M_mask; }

    constexpr friend void swap(_Bit_reference __x,
                               _Bit_reference __y) noexcept {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    constexpr friend void swap(_Bit_reference __x, bool &__y) noexcept {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    constexpr friend void swap(bool &__x, _Bit_reference __y) noexcept {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }
  };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  struct _Bit_iterator_base
      : public std::iterator<std::random_access_iterator_tag, bool> {
    _Bit_type *_M_p;
    unsigned int _M_offset;

    constexpr inline __attribute__((__always_inline__)) void
    _M_assume_normalized() const {}

    constexpr _Bit_iterator_base(_Bit_type *__x, unsigned int __y)
        : _M_p(__x), _M_offset(__y) {}

    constexpr void _M_bump_up() {
      _M_assume_normalized();
      if (_M_offset++ == int(_S_word_bit) - 1) {
        _M_offset = 0;
        ++_M_p;
      }
    }

    constexpr void _M_bump_down() {
      _M_assume_normalized();
      if (_M_offset-- == 0) {
        _M_offset = int(_S_word_bit) - 1;
        --_M_p;
      }
    }

    constexpr void _M_incr(ptrdiff_t __i) {
      _M_assume_normalized();
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0) {
        __n += int(_S_word_bit);
        --_M_p;
      }
      _M_offset = static_cast<unsigned int>(__n);
    }

    [[__nodiscard__]]
    friend constexpr bool operator==(const _Bit_iterator_base &__x,
                                     const _Bit_iterator_base &__y) {
      __x._M_assume_normalized();
      __y._M_assume_normalized();
      return __x._M_p == __y._M_p && __x._M_offset == __y._M_offset;
    }

    [[nodiscard]]
    friend constexpr strong_ordering
    operator<=>(const _Bit_iterator_base &__x,
                const _Bit_iterator_base &__y) noexcept {
      __x._M_assume_normalized();
      __y._M_assume_normalized();
      if (const auto __cmp = __x._M_p <=> __y._M_p; __cmp != 0)
        return __cmp;
      return __x._M_offset <=> __y._M_offset;
    }
# 291 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_bvector.h" 3
    friend constexpr ptrdiff_t operator-(const _Bit_iterator_base &__x,
                                         const _Bit_iterator_base &__y) {
      __x._M_assume_normalized();
      __y._M_assume_normalized();
      return (int(_S_word_bit) * (__x._M_p - __y._M_p) + __x._M_offset -
              __y._M_offset);
    }
  };
#pragma GCC diagnostic pop

  struct _Bit_iterator : public _Bit_iterator_base {
    typedef _Bit_reference reference;

    typedef void pointer;

    typedef _Bit_iterator iterator;

    constexpr _Bit_iterator() : _Bit_iterator_base(0, 0) {}

    constexpr _Bit_iterator(_Bit_type *__x, unsigned int __y)
        : _Bit_iterator_base(__x, __y) {}

    constexpr iterator _M_const_cast() const { return *this; }

    [[__nodiscard__]] constexpr reference operator*() const {
      _M_assume_normalized();
      return reference(_M_p, 1UL << _M_offset);
    }

    constexpr iterator &operator++() {
      _M_bump_up();
      return *this;
    }

    constexpr iterator operator++(int) {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    constexpr iterator &operator--() {
      _M_bump_down();
      return *this;
    }

    constexpr iterator operator--(int) {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    constexpr iterator &operator+=(difference_type __i) {
      _M_incr(__i);
      return *this;
    }

    constexpr iterator &operator-=(difference_type __i) {
      *this += -__i;
      return *this;
    }

    [[__nodiscard__]] constexpr reference
    operator[](difference_type __i) const {
      return *(*this + __i);
    }

    [[__nodiscard__]]
    friend constexpr iterator operator+(const iterator &__x,
                                        difference_type __n) {
      iterator __tmp = __x;
      __tmp += __n;
      return __tmp;
    }

    [[__nodiscard__]]
    friend constexpr iterator operator+(difference_type __n,
                                        const iterator &__x) {
      return __x + __n;
    }

    [[__nodiscard__]]
    friend constexpr iterator operator-(const iterator &__x,
                                        difference_type __n) {
      iterator __tmp = __x;
      __tmp -= __n;
      return __tmp;
    }
  };

  struct _Bit_const_iterator : public _Bit_iterator_base {
    typedef bool reference;
    typedef bool const_reference;

    typedef void pointer;

    typedef _Bit_const_iterator const_iterator;

    constexpr _Bit_const_iterator() : _Bit_iterator_base(0, 0) {}

    constexpr _Bit_const_iterator(_Bit_type *__x, unsigned int __y)
        : _Bit_iterator_base(__x, __y) {}

    constexpr _Bit_const_iterator(const _Bit_iterator &__x)
        : _Bit_iterator_base(__x._M_p, __x._M_offset) {}

    constexpr _Bit_iterator _M_const_cast() const {
      return _Bit_iterator(_M_p, _M_offset);
    }

    [[__nodiscard__]] constexpr const_reference operator*() const {
      _M_assume_normalized();
      return _Bit_reference(_M_p, 1UL << _M_offset);
    }

    constexpr const_iterator &operator++() {
      _M_bump_up();
      return *this;
    }

    constexpr const_iterator operator++(int) {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    constexpr const_iterator &operator--() {
      _M_bump_down();
      return *this;
    }

    constexpr const_iterator operator--(int) {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    constexpr const_iterator &operator+=(difference_type __i) {
      _M_incr(__i);
      return *this;
    }

    constexpr const_iterator &operator-=(difference_type __i) {
      *this += -__i;
      return *this;
    }

    [[__nodiscard__]] constexpr const_reference
    operator[](difference_type __i) const {
      return *(*this + __i);
    }

    [[__nodiscard__]]
    friend constexpr const_iterator operator+(const const_iterator &__x,
                                              difference_type __n) {
      const_iterator __tmp = __x;
      __tmp += __n;
      return __tmp;
    }

    [[__nodiscard__]]
    friend constexpr const_iterator operator-(const const_iterator &__x,
                                              difference_type __n) {
      const_iterator __tmp = __x;
      __tmp -= __n;
      return __tmp;
    }

    [[__nodiscard__]]
    friend constexpr const_iterator operator+(difference_type __n,
                                              const const_iterator &__x) {
      return __x + __n;
    }
  };

  template <typename _Alloc> struct _Bvector_base {
    typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template rebind<
        _Bit_type>::other _Bit_alloc_type;
    typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
        _Bit_alloc_traits;
    typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

    struct _Bvector_impl_data {

      _Bit_iterator _M_start;
# 547 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_bvector.h" 3
      _Bit_iterator _M_finish;
      _Bit_pointer _M_end_of_storage;

      constexpr _Bvector_impl_data() noexcept
          : _M_start(), _M_finish(), _M_end_of_storage() {}

      _Bvector_impl_data(const _Bvector_impl_data &) = default;

      _Bvector_impl_data &operator=(const _Bvector_impl_data &) = default;

      constexpr _Bvector_impl_data(_Bvector_impl_data &&__x) noexcept
          : _Bvector_impl_data(__x) {
        __x._M_reset();
      }

      constexpr void _M_move_data(_Bvector_impl_data &&__x) noexcept {
        *this = __x;
        __x._M_reset();
      }

      constexpr void _M_reset() noexcept { *this = _Bvector_impl_data(); }

      constexpr void _M_swap_data(_Bvector_impl_data &__x) noexcept {

        std::swap(*this, __x);
      }
    };

    struct _Bvector_impl : public _Bit_alloc_type, public _Bvector_impl_data {
      constexpr _Bvector_impl() noexcept(
          is_nothrow_default_constructible<_Bit_alloc_type>::value)

        requires is_default_constructible_v<_Bit_alloc_type>

          : _Bit_alloc_type() {}

      constexpr _Bvector_impl(const _Bit_alloc_type &__a) noexcept
          : _Bit_alloc_type(__a) {}

      constexpr _Bvector_impl(_Bvector_impl &&__x) noexcept
          : _Bit_alloc_type(std::move(__x)),
            _Bvector_impl_data(std::move(__x)) {}

      constexpr _Bvector_impl(_Bit_alloc_type &&__a,
                              _Bvector_impl &&__x) noexcept
          : _Bit_alloc_type(std::move(__a)),
            _Bvector_impl_data(std::move(__x)) {}

      constexpr _Bit_type *_M_end_addr() const noexcept {
        if (this->_M_end_of_storage)
          return std::__addressof(this->_M_end_of_storage[-1]) + 1;
        return 0;
      }
    };

  public:
    typedef _Alloc allocator_type;

    constexpr _Bit_alloc_type &_M_get_Bit_allocator() noexcept {
      return this->_M_impl;
    }

    constexpr const _Bit_alloc_type &_M_get_Bit_allocator() const noexcept {
      return this->_M_impl;
    }

    constexpr allocator_type get_allocator() const noexcept {
      return allocator_type(_M_get_Bit_allocator());
    }

    _Bvector_base() = default;

    constexpr _Bvector_base(const allocator_type &__a) : _M_impl(__a) {}

    _Bvector_base(_Bvector_base &&) = default;

    constexpr _Bvector_base(_Bvector_base &&__x,
                            const allocator_type &__a) noexcept
        : _M_impl(_Bit_alloc_type(__a), std::move(__x._M_impl)) {}

    constexpr ~_Bvector_base() { this->_M_deallocate(); }

  protected:
    _Bvector_impl _M_impl;

    constexpr _Bit_pointer _M_allocate(size_t __n) {
      _Bit_pointer __p = _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n));

      if (std::is_constant_evaluated()) {
        __n = _S_nword(__n);
        for (size_t __i = 0; __i < __n; ++__i)
          std::construct_at(std::to_address(__p) + __i);
      }

      return __p;
    }

    constexpr void _M_deallocate() {
      if (_M_impl._M_start._M_p) {
        const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
        _Bit_alloc_traits::deallocate(_M_impl, _M_impl._M_end_of_storage - __n,
                                      __n);
        _M_impl._M_reset();
      }
    }

    constexpr void _M_move_data(_Bvector_base &&__x) noexcept {
      _M_impl._M_move_data(std::move(__x._M_impl));
    }

    constexpr static size_t _S_nword(size_t __n) {
      return (__n + int(_S_word_bit) - 1) / int(_S_word_bit);
    }
  };
# 739 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_bvector.h" 3
  template <typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc> {
    typedef _Bvector_base<_Alloc> _Base;
    typedef typename _Base::_Bit_pointer _Bit_pointer;
    typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;

    friend struct std::hash<vector>;

  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference *pointer;
    typedef const bool *const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    constexpr allocator_type get_allocator() const {
      return _Base::get_allocator();
    }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_M_get_Bit_allocator;
    using _Base::_S_nword;

  public:
    vector() = default;

    constexpr explicit vector(const allocator_type &__a) : _Base(__a) {}

    constexpr explicit vector(size_type __n,
                              const allocator_type &__a = allocator_type())
        : vector(__n, false, __a) {}

    constexpr vector(size_type __n, const bool &__value,
                     const allocator_type &__a = allocator_type())

        : _Base(__a) {
      _M_initialize(__n);
      _M_initialize_value(__value);
    }

    constexpr vector(const vector &__x)
        : _Base(_Bit_alloc_traits::_S_select_on_copy(
              __x._M_get_Bit_allocator())) {
      const_iterator __xbegin = __x.begin(), __xend = __x.end();
      _M_initialize(__x.size());
      _M_copy_aligned(__xbegin, __xend, begin());
    }

    vector(vector &&) = default;

  private:
    constexpr vector(vector &&__x, const allocator_type &__a,
                     true_type) noexcept
        : _Base(std::move(__x), __a) {}

    constexpr vector(vector &&__x, const allocator_type &__a, false_type)
        : _Base(__a) {
      if (__x.get_allocator() == __a)
        this->_M_move_data(std::move(__x));
      else {
        _M_initialize(__x.size());
        _M_copy_aligned(__x.begin(), __x.end(), begin());
        __x.clear();
      }
    }

  public:
    constexpr vector(vector &&__x,
                     const __type_identity_t<allocator_type>
                         &__a) noexcept(_Bit_alloc_traits::_S_always_equal())
        : vector(std::move(__x), __a,
                 typename _Bit_alloc_traits::is_always_equal{}) {}

    constexpr vector(const vector &__x,
                     const __type_identity_t<allocator_type> &__a)
        : _Base(__a) {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), begin());
    }

    constexpr vector(initializer_list<bool> __l,
                     const allocator_type &__a = allocator_type())
        : _Base(__a) {
      _M_initialize_range(__l.begin(), __l.end(), random_access_iterator_tag());
    }

    template <typename _InputIterator,
              typename = std::_RequireInputIter<_InputIterator>>
    constexpr vector(_InputIterator __first, _InputIterator __last,
                     const allocator_type &__a = allocator_type())
        : _Base(__a) {
      _M_initialize_range(__first, __last, std::__iterator_category(__first));
    }
# 889 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_bvector.h" 3
    constexpr ~vector() noexcept {}

    constexpr vector &operator=(const vector &__x) {
      if (&__x == this)
        return *this;

      if (_Bit_alloc_traits::_S_propagate_on_copy_assign()) {
        if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator()) {
          this->_M_deallocate();
          std::__alloc_on_copy(_M_get_Bit_allocator(),
                               __x._M_get_Bit_allocator());
          _M_initialize(__x.size());
        } else
          std::__alloc_on_copy(_M_get_Bit_allocator(),
                               __x._M_get_Bit_allocator());
      }

      if (__x.size() > capacity()) {
        this->_M_deallocate();
        _M_initialize(__x.size());
      }
      this->_M_impl._M_finish =
          _M_copy_aligned(__x.begin(), __x.end(), begin());
      return *this;
    }

    constexpr vector &
    operator=(vector &&__x) noexcept(_Bit_alloc_traits::_S_nothrow_move()) {
      if (_Bit_alloc_traits::_S_propagate_on_move_assign() ||
          this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator()) {
        this->_M_deallocate();
        this->_M_move_data(std::move(__x));
        std::__alloc_on_move(_M_get_Bit_allocator(),
                             __x._M_get_Bit_allocator());
      } else {
        if (__x.size() > capacity()) {
          this->_M_deallocate();
          _M_initialize(__x.size());
        }
        this->_M_impl._M_finish =
            _M_copy_aligned(__x.begin(), __x.end(), begin());
        __x.clear();
      }
      return *this;
    }

    constexpr vector &operator=(initializer_list<bool> __l) {
      this->assign(__l.begin(), __l.end());
      return *this;
    }

    constexpr void assign(size_type __n, const bool &__x) {
      _M_fill_assign(__n, __x);
    }

    template <typename _InputIterator,
              typename = std::_RequireInputIter<_InputIterator>>
    constexpr void assign(_InputIterator __first, _InputIterator __last) {
      _M_assign_aux(__first, __last, std::__iterator_category(__first));
    }
# 987 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_bvector.h" 3
    constexpr void assign(initializer_list<bool> __l) {
      _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag());
    }

    [[__nodiscard__]] constexpr iterator begin() noexcept {
      return iterator(this->_M_impl._M_start._M_p, 0);
    }

    [[__nodiscard__]] constexpr const_iterator begin() const noexcept {
      return const_iterator(this->_M_impl._M_start._M_p, 0);
    }

    [[__nodiscard__]] constexpr iterator end() noexcept {
      return this->_M_impl._M_finish;
    }

    [[__nodiscard__]] constexpr const_iterator end() const noexcept {
      return this->_M_impl._M_finish;
    }

    [[__nodiscard__]] constexpr reverse_iterator rbegin() noexcept {
      return reverse_iterator(end());
    }

    [[__nodiscard__]] constexpr const_reverse_iterator rbegin() const noexcept {
      return const_reverse_iterator(end());
    }

    [[__nodiscard__]] constexpr reverse_iterator rend() noexcept {
      return reverse_iterator(begin());
    }

    [[__nodiscard__]] constexpr const_reverse_iterator rend() const noexcept {
      return const_reverse_iterator(begin());
    }

    [[__nodiscard__]] constexpr const_iterator cbegin() const noexcept {
      return const_iterator(this->_M_impl._M_start._M_p, 0);
    }

    [[__nodiscard__]] constexpr const_iterator cend() const noexcept {
      return this->_M_impl._M_finish;
    }

    [[__nodiscard__]] constexpr const_reverse_iterator
    crbegin() const noexcept {
      return const_reverse_iterator(end());
    }

    [[__nodiscard__]] constexpr const_reverse_iterator crend() const noexcept {
      return const_reverse_iterator(begin());
    }

    [[__nodiscard__]] constexpr size_type size() const noexcept {
      return size_type(end() - begin());
    }

    [[__nodiscard__]] constexpr size_type max_size() const noexcept {
      const size_type __isize =
          __gnu_cxx::__numeric_traits<difference_type>::__max -
          int(_S_word_bit) + 1;
      const size_type __asize =
          _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
      return (__asize <= __isize / int(_S_word_bit) ? __asize * int(_S_word_bit)
                                                    : __isize);
    }

    [[__nodiscard__]] constexpr size_type capacity() const noexcept {
      return size_type(const_iterator(this->_M_impl._M_end_addr(), 0) -
                       begin());
    }

    [[__nodiscard__]] constexpr bool empty() const noexcept {
      return begin() == end();
    }

    [[__nodiscard__]] constexpr reference operator[](size_type __n) {
      return begin()[__n];
    }

    [[__nodiscard__]] constexpr const_reference
    operator[](size_type __n) const {
      return begin()[__n];
    }

  protected:
    constexpr void _M_range_check(size_type __n) const {
      if (__n >= this->size())
        __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n "
                                  "(which is %zu) >= this->size() "
                                  "(which is %zu)"),

                                 __n, this->size());
    }

  public:
    constexpr reference at(size_type __n) {
      _M_range_check(__n);
      return (*this)[__n];
    }

    constexpr const_reference at(size_type __n) const {
      _M_range_check(__n);
      return (*this)[__n];
    }

    constexpr void reserve(size_type __n) {
      if (__n > max_size())
        __throw_length_error(("vector::reserve"));
      if (capacity() < __n)
        _M_reallocate(__n);
    }

    [[__nodiscard__]] constexpr reference front() { return *begin(); }

    [[__nodiscard__]] constexpr const_reference front() const {
      return *begin();
    }

    [[__nodiscard__]] constexpr reference back() { return *(end() - 1); }

    [[__nodiscard__]] constexpr const_reference back() const {
      return *(end() - 1);
    }

    constexpr void push_back(bool __x) {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    constexpr void swap(vector &__x) noexcept {

      do {
        if (std::__is_constant_evaluated() &&
            !bool(_Bit_alloc_traits::propagate_on_container_swap::value ||
                  _M_get_Bit_allocator() == __x._M_get_Bit_allocator()))
          __builtin_unreachable();
      } while (false);

      this->_M_impl._M_swap_data(__x._M_impl);
      _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
                                    __x._M_get_Bit_allocator());
    }

    constexpr static void swap(reference __x, reference __y) noexcept {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    constexpr iterator

    insert(const_iterator __position, const bool &__x)

    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr() &&
          __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position._M_const_cast(), __x);
      return begin() + __n;
    }

    __attribute__((__deprecated__("use '"
                                  "insert(position, false)"
                                  "' instead"))) iterator
    insert(const_iterator __position) {
      return this->insert(__position._M_const_cast(), false);
    }

    template <typename _InputIterator,
              typename = std::_RequireInputIter<_InputIterator>>
    constexpr iterator insert(const_iterator __position, _InputIterator __first,
                              _InputIterator __last) {
      difference_type __offset = __position - cbegin();
      _M_insert_range(__position._M_const_cast(), __first, __last,
                      std::__iterator_category(__first));
      return begin() + __offset;
    }
# 1237 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_bvector.h" 3
    constexpr iterator insert(const_iterator __position, size_type __n,
                              const bool &__x) {
      difference_type __offset = __position - cbegin();
      _M_fill_insert(__position._M_const_cast(), __n, __x);
      return begin() + __offset;
    }

    constexpr iterator insert(const_iterator __p, initializer_list<bool> __l) {
      return this->insert(__p, __l.begin(), __l.end());
    }

    constexpr void pop_back() { --this->_M_impl._M_finish; }

    constexpr iterator

    erase(const_iterator __position)

    {
      return _M_erase(__position._M_const_cast());
    }

    constexpr iterator

    erase(const_iterator __first, const_iterator __last)

    {
      return _M_erase(__first._M_const_cast(), __last._M_const_cast());
    }

    constexpr void resize(size_type __new_size, bool __x = bool()) {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }

    constexpr void shrink_to_fit() { _M_shrink_to_fit(); }

    constexpr void flip() noexcept {
      _Bit_type *const __end = this->_M_impl._M_end_addr();
      for (_Bit_type *__p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
        *__p = ~*__p;
    }

    constexpr void clear() noexcept { _M_erase_at_end(begin()); }

    template <typename... _Args>

    constexpr reference

    emplace_back(_Args &&...__args) {
      push_back(bool(__args...));

      return back();
    }

    template <typename... _Args>
    constexpr iterator emplace(const_iterator __pos, _Args &&...__args) {
      return insert(__pos, bool(__args...));
    }

  protected:
    constexpr iterator _M_copy_aligned(const_iterator __first,
                                       const_iterator __last,
                                       iterator __result) {
      _Bit_type *__q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
                       iterator(__q, 0));
    }

    constexpr void _M_initialize(size_type __n) {
      if (__n) {
        _Bit_pointer __q = this->_M_allocate(__n);
        this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
        iterator __start = iterator(std::__addressof(*__q), 0);
        this->_M_impl._M_start = __start;
        this->_M_impl._M_finish = __start + difference_type(__n);
      }
    }

    constexpr void _M_initialize_value(bool __x) noexcept {
      if (_Bit_type *__p = this->_M_impl._M_start._M_p)
        __fill_bvector_n(__p, this->_M_impl._M_end_addr() - __p, __x);
    }

    constexpr void _M_reallocate(size_type __n);

    constexpr bool _M_shrink_to_fit();
# 1398 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_bvector.h" 3
    template <typename _InputIterator>
    constexpr void _M_initialize_range(_InputIterator __first,
                                       _InputIterator __last,
                                       std::input_iterator_tag) {
      for (; __first != __last; ++__first)
        push_back(*__first);
    }

    template <typename _ForwardIterator>
    constexpr void _M_initialize_range(_ForwardIterator __first,
                                       _ForwardIterator __last,
                                       std::forward_iterator_tag) {
      const size_type __n = std::distance(__first, __last);
      _M_initialize(__n);
      std::copy(__first, __last, begin());
    }
# 1434 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_bvector.h" 3
    constexpr void _M_fill_assign(size_t __n, bool __x) {
      if (__n > size()) {
        _M_initialize_value(__x);
        insert(end(), __n - size(), __x);
      } else {
        _M_erase_at_end(begin() + __n);
        _M_initialize_value(__x);
      }
    }

    template <typename _InputIterator>
    constexpr void _M_assign_aux(_InputIterator __first, _InputIterator __last,
                                 std::input_iterator_tag) {
      iterator __cur = begin();
      for (; __first != __last && __cur != end(); ++__cur, (void)++__first)
        *__cur = *__first;
      if (__first == __last)
        _M_erase_at_end(__cur);
      else
        insert(end(), __first, __last);
    }

    template <typename _ForwardIterator>
    constexpr void _M_assign_aux(_ForwardIterator __first,
                                 _ForwardIterator __last,
                                 std::forward_iterator_tag) {
      const size_type __len = std::distance(__first, __last);
      if (__len < size())
        _M_erase_at_end(std::copy(__first, __last, begin()));
      else {
        _ForwardIterator __mid = __first;
        std::advance(__mid, size());
        std::copy(__first, __mid, begin());
        insert(end(), __mid, __last);
      }
    }
# 1501 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_bvector.h" 3
    constexpr void _M_fill_insert(iterator __position, size_type __n, bool __x);

    template <typename _InputIterator>
    constexpr void _M_insert_range(iterator __pos, _InputIterator __first,
                                   _InputIterator __last,
                                   std::input_iterator_tag) {
      for (; __first != __last; ++__first) {
        __pos = insert(__pos, *__first);
        ++__pos;
      }
    }

    template <typename _ForwardIterator>
    constexpr void
    _M_insert_range(iterator __position, _ForwardIterator __first,
                    _ForwardIterator __last, std::forward_iterator_tag);

    constexpr void _M_insert_aux(iterator __position, bool __x);

    constexpr size_type _M_check_len(size_type __n, const char *__s) const {
      if (max_size() - size() < __n)
        __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    constexpr void _M_erase_at_end(iterator __pos) {
      this->_M_impl._M_finish = __pos;
    }

    constexpr iterator _M_erase(iterator __pos);

    constexpr iterator _M_erase(iterator __first, iterator __last);

  protected:
    void data() = delete;
  };

  constexpr inline void __fill_bvector(_Bit_type * __v, unsigned int __first,
                                       unsigned int __last, bool __x) noexcept {
    const _Bit_type __fmask = ~0ul << __first;
    const _Bit_type __lmask = ~0ul >> (_S_word_bit - __last);
    const _Bit_type __mask = __fmask & __lmask;

    if (__x)
      *__v |= __mask;
    else
      *__v &= ~__mask;
  }

  __attribute__((__nonnull__)) constexpr inline void __fill_bvector_n(
      _Bit_type * __p, size_t __n, bool __x) noexcept {

    if (std::is_constant_evaluated()) {
      for (size_t __i = 0; __i < __n; ++__i)
        __p[__i] = __x ? ~0ul : 0ul;
      return;
    }

    __builtin_memset(__p, __x ? ~0 : 0, __n * sizeof(_Bit_type));
  }

  constexpr inline void __fill_a1(std::_Bit_iterator __first,
                                  std::_Bit_iterator __last, const bool &__x) {
    if (__first._M_p != __last._M_p) {
      _Bit_type *__first_p = __first._M_p;
      if (__first._M_offset != 0)
        __fill_bvector(__first_p++, __first._M_offset, _S_word_bit, __x);

      __fill_bvector_n(__first_p, __last._M_p - __first_p, __x);

      if (__last._M_offset != 0)
        __fill_bvector(__last._M_p, 0, __last._M_offset, __x);
    } else if (__first._M_offset != __last._M_offset)
      __fill_bvector(__first._M_p, __first._M_offset, __last._M_offset, __x);
  }

  template <typename _Alloc>
  struct hash<std::vector<bool, _Alloc>>
      : public __hash_base<size_t, std::vector<bool, _Alloc>> {
    size_t operator()(const std::vector<bool, _Alloc> &) const noexcept;
  };

} // namespace std
# 68 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/vector" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/vector.tcc" 1 3
# 59 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/vector.tcc" 3
namespace std __attribute__((__visibility__("default"))) {

  template <typename _Tp, typename _Alloc>
  constexpr void vector<_Tp, _Alloc>::reserve(size_type __n) {
    if (__n > this->max_size())
      __throw_length_error(("vector::reserve"));
    if (this->capacity() < __n) {
      const size_type __old_size = size();
      pointer __tmp;

      if constexpr (_S_use_relocate()) {
        __tmp = this->_M_allocate(__n);
        _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish, __tmp,
                    _M_get_Tp_allocator());
      } else

      {
        __tmp = _M_allocate_and_copy(
            __n, std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
            std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                      _M_get_Tp_allocator());
      };
      _M_deallocate(this->_M_impl._M_start,
                    this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
      this->_M_impl._M_start = __tmp;
      this->_M_impl._M_finish = __tmp + __old_size;
      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
    }
  }

  template <typename _Tp, typename _Alloc>
  template <typename... _Args>

  constexpr typename vector<_Tp, _Alloc>::reference

  vector<_Tp, _Alloc>::emplace_back(_Args && ...__args) {
    if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage) {
      ;
      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                               std::forward<_Args>(__args)...);
      ++this->_M_impl._M_finish;
      ;
    } else
      _M_realloc_insert(end(), std::forward<_Args>(__args)...);

    return back();
  }

  template <typename _Tp, typename _Alloc>
  constexpr typename vector<_Tp, _Alloc>::iterator vector<_Tp, _Alloc>::

      insert(const_iterator __position, const value_type &__x)

  {
    const size_type __n = __position - begin();
    if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage) {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__position != const_iterator()))
          __builtin_unreachable();
      } while (false);
      if (!(__position != const_iterator()))
        __builtin_unreachable();

      if (__position == end()) {
        ;
        _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
        ++this->_M_impl._M_finish;
        ;
      } else {

        const auto __pos = begin() + (__position - cbegin());

        _Temporary_value __x_copy(this, __x);
        _M_insert_aux(__pos, std::move(__x_copy._M_val()));
      }
    } else

      _M_realloc_insert(begin() + (__position - cbegin()), __x);

    return iterator(this->_M_impl._M_start + __n);
  }

  template <typename _Tp, typename _Alloc>
  constexpr typename vector<_Tp, _Alloc>::iterator
  vector<_Tp, _Alloc>::_M_erase(iterator __position) {
    if (__position + 1 != end())
      std::move(__position + 1, end(), __position);
    --this->_M_impl._M_finish;
    _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
    ;
    return __position;
  }

  template <typename _Tp, typename _Alloc>
  constexpr typename vector<_Tp, _Alloc>::iterator
  vector<_Tp, _Alloc>::_M_erase(iterator __first, iterator __last) {
    if (__first != __last) {
      if (__last != end())
        std::move(__last, end(), __first);
      _M_erase_at_end(__first.base() + (end() - __last));
    }
    return __first;
  }

  template <typename _Tp, typename _Alloc>
  constexpr vector<_Tp, _Alloc> &vector<_Tp, _Alloc>::operator=(
      const vector<_Tp, _Alloc> &__x) {
    if (std::__addressof(__x) != this) {
      ;

      if (_Alloc_traits::_S_propagate_on_copy_assign()) {
        if (!_Alloc_traits::_S_always_equal() &&
            _M_get_Tp_allocator() != __x._M_get_Tp_allocator()) {

          this->clear();
          _M_deallocate(this->_M_impl._M_start,
                        this->_M_impl._M_end_of_storage -
                            this->_M_impl._M_start);
          this->_M_impl._M_start = nullptr;
          this->_M_impl._M_finish = nullptr;
          this->_M_impl._M_end_of_storage = nullptr;
        }
        std::__alloc_on_copy(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }

      const size_type __xlen = __x.size();
      if (__xlen > capacity()) {
        pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                      _M_get_Tp_allocator());
        _M_deallocate(this->_M_impl._M_start,
                      this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
        this->_M_impl._M_start = __tmp;
        this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
      } else if (size() >= __xlen) {
        std::_Destroy(std::copy(__x.begin(), __x.end(), begin()), end(),
                      _M_get_Tp_allocator());
      } else {
        std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
                  this->_M_impl._M_start);
        std::__uninitialized_copy_a(
            __x._M_impl._M_start + size(), __x._M_impl._M_finish,
            this->_M_impl._M_finish, _M_get_Tp_allocator());
      }
      this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
    }
    return *this;
  }

  template <typename _Tp, typename _Alloc>
  constexpr void vector<_Tp, _Alloc>::_M_fill_assign(size_t __n,
                                                     const value_type &__val) {
    if (__n > capacity()) {
      vector __tmp(__n, __val, _M_get_Tp_allocator());
      __tmp._M_impl._M_swap_data(this->_M_impl);
    } else if (__n > size()) {
      std::fill(begin(), end(), __val);
      const size_type __add = __n - size();
      ;
      this->_M_impl._M_finish = std::__uninitialized_fill_n_a(
          this->_M_impl._M_finish, __add, __val, _M_get_Tp_allocator());
      ;
    } else
      _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
  }

  template <typename _Tp, typename _Alloc>
  template <typename _InputIterator>
  constexpr void vector<_Tp, _Alloc>::_M_assign_aux(
      _InputIterator __first, _InputIterator __last, std::input_iterator_tag) {
    pointer __cur(this->_M_impl._M_start);
    for (; __first != __last && __cur != this->_M_impl._M_finish;
         ++__cur, (void)++__first)
      *__cur = *__first;
    if (__first == __last)
      _M_erase_at_end(__cur);
    else
      _M_range_insert(end(), __first, __last,
                      std::__iterator_category(__first));
  }

  template <typename _Tp, typename _Alloc>
  template <typename _ForwardIterator>
  constexpr void vector<_Tp, _Alloc>::_M_assign_aux(_ForwardIterator __first,
                                                    _ForwardIterator __last,
                                                    std::forward_iterator_tag) {
    const size_type __len = std::distance(__first, __last);

    if (__len > capacity()) {
      _S_check_init_len(__len, _M_get_Tp_allocator());
      pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                    _M_get_Tp_allocator());
      ;
      _M_deallocate(this->_M_impl._M_start,
                    this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
      this->_M_impl._M_start = __tmp;
      this->_M_impl._M_finish = this->_M_impl._M_start + __len;
      this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
    } else if (size() >= __len)
      _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
    else {
      _ForwardIterator __mid = __first;
      std::advance(__mid, size());
      std::copy(__first, __mid, this->_M_impl._M_start);
      const size_type __attribute__((__unused__)) __n = __len - size();
      ;
      this->_M_impl._M_finish = std::__uninitialized_copy_a(
          __mid, __last, this->_M_impl._M_finish, _M_get_Tp_allocator());
      ;
    }
  }

  template <typename _Tp, typename _Alloc>
  constexpr auto vector<_Tp, _Alloc>::_M_insert_rval(
      const_iterator __position, value_type && __v) -> iterator {
    const auto __n = __position - cbegin();
    if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
      if (__position == cend()) {
        ;
        _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                                 std::move(__v));
        ++this->_M_impl._M_finish;
        ;
      } else
        _M_insert_aux(begin() + __n, std::move(__v));
    else
      _M_realloc_insert(begin() + __n, std::move(__v));

    return iterator(this->_M_impl._M_start + __n);
  }

  template <typename _Tp, typename _Alloc>
  template <typename... _Args>
  constexpr auto vector<_Tp, _Alloc>::_M_emplace_aux(
      const_iterator __position, _Args && ...__args) -> iterator {
    const auto __n = __position - cbegin();
    if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
      if (__position == cend()) {
        ;
        _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                                 std::forward<_Args>(__args)...);
        ++this->_M_impl._M_finish;
        ;
      } else {

        _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
        _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
      }
    else
      _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);

    return iterator(this->_M_impl._M_start + __n);
  }

  template <typename _Tp, typename _Alloc>
  template <typename _Arg>
  constexpr void vector<_Tp, _Alloc>::_M_insert_aux(iterator __position,
                                                    _Arg && __arg)

  {
    ;
    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                             std::move(*(this->_M_impl._M_finish - 1)));
    ++this->_M_impl._M_finish;
    ;

    std::move_backward(__position.base(), this->_M_impl._M_finish - 2,
                       this->_M_impl._M_finish - 1);

    *__position = std::forward<_Arg>(__arg);
  }

  template <typename _Tp, typename _Alloc>
  template <typename... _Args>
  constexpr void vector<_Tp, _Alloc>::_M_realloc_insert(iterator __position,
                                                        _Args && ...__args)

  {
    const size_type __len =
        _M_check_len(size_type(1), "vector::_M_realloc_insert");
    pointer __old_start = this->_M_impl._M_start;
    pointer __old_finish = this->_M_impl._M_finish;
    const size_type __elems_before = __position - begin();
    pointer __new_start(this->_M_allocate(__len));
    pointer __new_finish(__new_start);
    try {

      _Alloc_traits::construct(this->_M_impl, __new_start + __elems_before,

                               std::forward<_Args>(__args)...);

      __new_finish = pointer();

      if constexpr (_S_use_relocate()) {
        __new_finish = _S_relocate(__old_start, __position.base(), __new_start,
                                   _M_get_Tp_allocator());

        ++__new_finish;

        __new_finish = _S_relocate(__position.base(), __old_finish,
                                   __new_finish, _M_get_Tp_allocator());
      } else

      {
        __new_finish = std::__uninitialized_move_if_noexcept_a(
            __old_start, __position.base(), __new_start, _M_get_Tp_allocator());

        ++__new_finish;

        __new_finish = std::__uninitialized_move_if_noexcept_a(
            __position.base(), __old_finish, __new_finish,
            _M_get_Tp_allocator());
      }
    } catch (...) {
      if (!__new_finish)
        _Alloc_traits::destroy(this->_M_impl, __new_start + __elems_before);
      else
        std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }

    if constexpr (!_S_use_relocate())

      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
    ;
    _M_deallocate(__old_start, this->_M_impl._M_end_of_storage - __old_start);
    this->_M_impl._M_start = __new_start;
    this->_M_impl._M_finish = __new_finish;
    this->_M_impl._M_end_of_storage = __new_start + __len;
  }

  template <typename _Tp, typename _Alloc>
  constexpr void vector<_Tp, _Alloc>::_M_fill_insert(
      iterator __position, size_type __n, const value_type &__x) {
    if (__n != 0) {
      if (size_type(this->_M_impl._M_end_of_storage -
                    this->_M_impl._M_finish) >= __n) {

        _Temporary_value __tmp(this, __x);
        value_type &__x_copy = __tmp._M_val();

        const size_type __elems_after = end() - __position;
        pointer __old_finish(this->_M_impl._M_finish);
        if (__elems_after > __n) {
          ;
          std::__uninitialized_move_a(__old_finish - __n, __old_finish,
                                      __old_finish, _M_get_Tp_allocator());
          this->_M_impl._M_finish += __n;
          ;
          std::move_backward(__position.base(), __old_finish - __n,
                             __old_finish);

          std::fill(__position.base(), __position.base() + __n, __x_copy);
        } else {
          ;
          this->_M_impl._M_finish =
              std::__uninitialized_fill_n_a(__old_finish, __n - __elems_after,
                                            __x_copy, _M_get_Tp_allocator());
          ;
          std::__uninitialized_move_a(__position.base(), __old_finish,
                                      this->_M_impl._M_finish,
                                      _M_get_Tp_allocator());
          this->_M_impl._M_finish += __elems_after;
          ;
          std::fill(__position.base(), __old_finish, __x_copy);
        }
      } else {

        pointer __old_start = this->_M_impl._M_start;
        pointer __old_finish = this->_M_impl._M_finish;
        const pointer __pos = __position.base();

        const size_type __len = _M_check_len(__n, "vector::_M_fill_insert");
        const size_type __elems_before = __pos - __old_start;
        pointer __new_start(this->_M_allocate(__len));
        pointer __new_finish(__new_start);
        try {

          std::__uninitialized_fill_n_a(__new_start + __elems_before, __n, __x,
                                        _M_get_Tp_allocator());
          __new_finish = pointer();

          __new_finish = std::__uninitialized_move_if_noexcept_a(
              __old_start, __pos, __new_start, _M_get_Tp_allocator());

          __new_finish += __n;

          __new_finish = std::__uninitialized_move_if_noexcept_a(
              __pos, __old_finish, __new_finish, _M_get_Tp_allocator());
        } catch (...) {
          if (!__new_finish)
            std::_Destroy(__new_start + __elems_before,
                          __new_start + __elems_before + __n,
                          _M_get_Tp_allocator());
          else
            std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
          _M_deallocate(__new_start, __len);
          throw;
        }
        std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
        ;
        _M_deallocate(__old_start,
                      this->_M_impl._M_end_of_storage - __old_start);
        this->_M_impl._M_start = __new_start;
        this->_M_impl._M_finish = __new_finish;
        this->_M_impl._M_end_of_storage = __new_start + __len;
      }
    }
  }

  template <typename _Tp, typename _Alloc>
  constexpr void vector<_Tp, _Alloc>::_M_default_append(size_type __n) {
    if (__n != 0) {
      const size_type __size = size();
      size_type __navail =
          size_type(this->_M_impl._M_end_of_storage - this->_M_impl._M_finish);

      if (__size > max_size() || __navail > max_size() - __size)
        __builtin_unreachable();

      if (__navail >= __n) {
        ;
        this->_M_impl._M_finish = std::__uninitialized_default_n_a(
            this->_M_impl._M_finish, __n, _M_get_Tp_allocator());
        ;
      } else {

        pointer __old_start = this->_M_impl._M_start;
        pointer __old_finish = this->_M_impl._M_finish;

        const size_type __len = _M_check_len(__n, "vector::_M_default_append");
        pointer __new_start(this->_M_allocate(__len));
        if constexpr (_S_use_relocate()) {
          try {
            std::__uninitialized_default_n_a(__new_start + __size, __n,
                                             _M_get_Tp_allocator());
          } catch (...) {
            _M_deallocate(__new_start, __len);
            throw;
          }
          _S_relocate(__old_start, __old_finish, __new_start,
                      _M_get_Tp_allocator());
        } else {
          pointer __destroy_from = pointer();
          try {
            std::__uninitialized_default_n_a(__new_start + __size, __n,
                                             _M_get_Tp_allocator());
            __destroy_from = __new_start + __size;
            std::__uninitialized_move_if_noexcept_a(
                __old_start, __old_finish, __new_start, _M_get_Tp_allocator());
          } catch (...) {
            if (__destroy_from)
              std::_Destroy(__destroy_from, __destroy_from + __n,
                            _M_get_Tp_allocator());
            _M_deallocate(__new_start, __len);
            throw;
          }
          std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
        };
        _M_deallocate(__old_start,
                      this->_M_impl._M_end_of_storage - __old_start);
        this->_M_impl._M_start = __new_start;
        this->_M_impl._M_finish = __new_start + __size + __n;
        this->_M_impl._M_end_of_storage = __new_start + __len;
      }
    }
  }

  template <typename _Tp, typename _Alloc>
  constexpr bool vector<_Tp, _Alloc>::_M_shrink_to_fit() {
    if (capacity() == size())
      return false;
    ;
    return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
  }

  template <typename _Tp, typename _Alloc>
  template <typename _InputIterator>
  constexpr void vector<_Tp, _Alloc>::_M_range_insert(
      iterator __pos, _InputIterator __first, _InputIterator __last,
      std::input_iterator_tag) {
    if (__pos == end()) {
      for (; __first != __last; ++__first)
        insert(end(), *__first);
    } else if (__first != __last) {
      vector __tmp(__first, __last, _M_get_Tp_allocator());
      insert(__pos, std::make_move_iterator(__tmp.begin()),
             std::make_move_iterator(__tmp.end()));
    }
  }

  template <typename _Tp, typename _Alloc>
  template <typename _ForwardIterator>
  constexpr void vector<_Tp, _Alloc>::_M_range_insert(
      iterator __position, _ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag) {
    if (__first != __last) {
      const size_type __n = std::distance(__first, __last);
      if (size_type(this->_M_impl._M_end_of_storage -
                    this->_M_impl._M_finish) >= __n) {
        const size_type __elems_after = end() - __position;
        pointer __old_finish(this->_M_impl._M_finish);
        if (__elems_after > __n) {
          ;
          std::__uninitialized_move_a(
              this->_M_impl._M_finish - __n, this->_M_impl._M_finish,
              this->_M_impl._M_finish, _M_get_Tp_allocator());
          this->_M_impl._M_finish += __n;
          ;
          std::move_backward(__position.base(), __old_finish - __n,
                             __old_finish);

          std::copy(__first, __last, __position);
        } else {
          _ForwardIterator __mid = __first;
          std::advance(__mid, __elems_after);
          ;
          std::__uninitialized_copy_a(__mid, __last, this->_M_impl._M_finish,
                                      _M_get_Tp_allocator());
          this->_M_impl._M_finish += __n - __elems_after;
          ;
          std::__uninitialized_move_a(__position.base(), __old_finish,
                                      this->_M_impl._M_finish,
                                      _M_get_Tp_allocator());
          this->_M_impl._M_finish += __elems_after;
          ;
          std::copy(__first, __mid, __position);
        }
      } else {

        pointer __old_start = this->_M_impl._M_start;
        pointer __old_finish = this->_M_impl._M_finish;

        const size_type __len = _M_check_len(__n, "vector::_M_range_insert");
        pointer __new_start(this->_M_allocate(__len));
        pointer __new_finish(__new_start);
        try {
          __new_finish = std::__uninitialized_move_if_noexcept_a(
              __old_start, __position.base(), __new_start,
              _M_get_Tp_allocator());
          __new_finish = std::__uninitialized_copy_a(
              __first, __last, __new_finish, _M_get_Tp_allocator());
          __new_finish = std::__uninitialized_move_if_noexcept_a(
              __position.base(), __old_finish, __new_finish,
              _M_get_Tp_allocator());
        } catch (...) {
          std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
          _M_deallocate(__new_start, __len);
          throw;
        }
        std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
        ;
        _M_deallocate(__old_start,
                      this->_M_impl._M_end_of_storage - __old_start);
        this->_M_impl._M_start = __new_start;
        this->_M_impl._M_finish = __new_finish;
        this->_M_impl._M_end_of_storage = __new_start + __len;
      }
    }
  }

  template <typename _Alloc>
  constexpr void vector<bool, _Alloc>::_M_reallocate(size_type __n) {
    _Bit_pointer __q = this->_M_allocate(__n);
    iterator __start(std::__addressof(*__q), 0);
    iterator __finish(_M_copy_aligned(begin(), end(), __start));
    this->_M_deallocate();
    this->_M_impl._M_start = __start;
    this->_M_impl._M_finish = __finish;
    this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
  }

  template <typename _Alloc>
  constexpr void vector<bool, _Alloc>::_M_fill_insert(iterator __position,
                                                      size_type __n, bool __x) {
    if (__n == 0)
      return;
    if (capacity() - size() >= __n) {
      std::copy_backward(__position, end(),
                         this->_M_impl._M_finish + difference_type(__n));
      std::fill(__position, __position + difference_type(__n), __x);
      this->_M_impl._M_finish += difference_type(__n);
    } else {
      const size_type __len = _M_check_len(__n, "vector<bool>::_M_fill_insert");
      _Bit_pointer __q = this->_M_allocate(__len);
      iterator __start(std::__addressof(*__q), 0);
      iterator __i = _M_copy_aligned(begin(), __position, __start);
      std::fill(__i, __i + difference_type(__n), __x);
      iterator __finish =
          std::copy(__position, end(), __i + difference_type(__n));
      this->_M_deallocate();
      this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
      this->_M_impl._M_start = __start;
      this->_M_impl._M_finish = __finish;
    }
  }

  template <typename _Alloc>
  template <typename _ForwardIterator>
  constexpr void vector<bool, _Alloc>::_M_insert_range(
      iterator __position, _ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag) {
    if (__first != __last) {
      size_type __n = std::distance(__first, __last);
      if (capacity() - size() >= __n) {
        std::copy_backward(__position, end(),
                           this->_M_impl._M_finish + difference_type(__n));
        std::copy(__first, __last, __position);
        this->_M_impl._M_finish += difference_type(__n);
      } else {
        const size_type __len =
            _M_check_len(__n, "vector<bool>::_M_insert_range");
        const iterator __begin = begin(), __end = end();
        _Bit_pointer __q = this->_M_allocate(__len);
        iterator __start(std::__addressof(*__q), 0);
        iterator __i = _M_copy_aligned(__begin, __position, __start);
        __i = std::copy(__first, __last, __i);
        iterator __finish = std::copy(__position, __end, __i);
        this->_M_deallocate();
        this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
        this->_M_impl._M_start = __start;
        this->_M_impl._M_finish = __finish;
      }
    }
  }

  template <typename _Alloc>
  constexpr void vector<bool, _Alloc>::_M_insert_aux(iterator __position,
                                                     bool __x) {
    if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()) {
      std::copy_backward(__position, this->_M_impl._M_finish,
                         this->_M_impl._M_finish + 1);
      *__position = __x;
      ++this->_M_impl._M_finish;
    } else {
      const size_type __len =
          _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
      _Bit_pointer __q = this->_M_allocate(__len);
      iterator __start(std::__addressof(*__q), 0);
      iterator __i = _M_copy_aligned(begin(), __position, __start);
      *__i++ = __x;
      iterator __finish = std::copy(__position, end(), __i);
      this->_M_deallocate();
      this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
      this->_M_impl._M_start = __start;
      this->_M_impl._M_finish = __finish;
    }
  }

  template <typename _Alloc>
  constexpr typename vector<bool, _Alloc>::iterator
  vector<bool, _Alloc>::_M_erase(iterator __position) {
    if (__position + 1 != end())
      std::copy(__position + 1, end(), __position);
    --this->_M_impl._M_finish;
    return __position;
  }

  template <typename _Alloc>
  constexpr typename vector<bool, _Alloc>::iterator
  vector<bool, _Alloc>::_M_erase(iterator __first, iterator __last) {
    if (__first != __last)
      _M_erase_at_end(std::copy(__last, end(), __first));
    return __first;
  }

  template <typename _Alloc>
  constexpr bool vector<bool, _Alloc>::_M_shrink_to_fit() {
    if (capacity() - size() < int(_S_word_bit))
      return false;
    try {
      if (size_type __n = size())
        _M_reallocate(__n);
      else {
        this->_M_deallocate();
        this->_M_impl._M_reset();
      }
      return true;
    } catch (...) {
      return false;
    }
  }

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

  template <typename _Alloc>
  size_t hash<std::vector<bool, _Alloc>>::operator()(
      const std::vector<bool, _Alloc> &__b) const noexcept {
    size_t __hash = 0;
    const size_t __words = __b.size() / _S_word_bit;
    if (__words) {
      const size_t __clength = __words * sizeof(_Bit_type);
      __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
    }

    const size_t __extrabits = __b.size() % _S_word_bit;
    if (__extrabits) {
      _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
      __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

      const size_t __clength = (__extrabits + 8 - 1) / 8;
      if (__words)
        __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
      else
        __hash = std::_Hash_impl::hash(&__hiword, __clength);
    }

    return __hash;
  }

} // namespace std
# 73 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/vector" 2 3

namespace std __attribute__((__visibility__("default"))) {

  namespace pmr {
  template <typename _Tp>
  using vector = std::vector<_Tp, polymorphic_allocator<_Tp>>;
  }
# 96 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/vector" 3
} // namespace std

namespace std __attribute__((__visibility__("default"))) {

  template <typename _Tp, typename _Alloc, typename _Predicate>
  constexpr inline typename vector<_Tp, _Alloc>::size_type erase_if(
      vector<_Tp, _Alloc> & __cont, _Predicate __pred) {
    using namespace __gnu_cxx;
    std::vector<_Tp, _Alloc> &__ucont = __cont;
    const auto __osz = __cont.size();
    const auto __end = __ucont.end();
    auto __removed = std::__remove_if(__ucont.begin(), __end,
                                      __ops::__pred_iter(std::ref(__pred)));
    if (__removed != __end) {
      __cont.erase(__niter_wrap(__cont.begin(), __removed), __cont.end());
      return __osz - __cont.size();
    }

    return 0;
  }

  template <typename _Tp, typename _Alloc, typename _Up>
  constexpr inline typename vector<_Tp, _Alloc>::size_type erase(
      vector<_Tp, _Alloc> & __cont, const _Up &__value) {
    using namespace __gnu_cxx;
    std::vector<_Tp, _Alloc> &__ucont = __cont;
    const auto __osz = __cont.size();
    const auto __end = __ucont.end();
    auto __removed = std::__remove_if(__ucont.begin(), __end,
                                      __ops::__iter_equals_val(__value));
    if (__removed != __end) {
      __cont.erase(__niter_wrap(__cont.begin(), __removed), __cont.end());
      return __osz - __cont.size();
    }

    return 0;
  }

} // namespace std
# 25 "./SparseMatrix.hpp" 2
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 1 3
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4
extern "C" {

extern void __assert_fail(const char *__assertion, const char *__file,
                          unsigned int __line,
                          const char *__function) noexcept(true)
    __attribute__((__noreturn__));

extern void __assert_perror_fail(int __errnum, const char *__file,
                                 unsigned int __line,
                                 const char *__function) noexcept(true)
    __attribute__((__noreturn__));

extern void __assert(const char *__assertion, const char *__file,
                     int __line) noexcept(true) __attribute__((__noreturn__));
}
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 2 3
# 26 "./SparseMatrix.hpp" 2
# 1 "./Geometry.hpp" 1
# 29 "./Geometry.hpp"
typedef int local_int_t;
# 40 "./Geometry.hpp"
typedef long long global_int_t;
# 50 "./Geometry.hpp"
struct Geometry_STRUCT {
  int size;
  int rank;
  int numThreads;
  local_int_t nx;
  local_int_t ny;
  local_int_t nz;
  int npx;
  int npy;
  int npz;
  int pz;
  int npartz;
  int *partz_ids;
  local_int_t *partz_nz;
  int ipx;
  int ipy;
  int ipz;
  global_int_t gnx;
  global_int_t gny;
  global_int_t gnz;
  global_int_t gix0;
  global_int_t giy0;
  global_int_t giz0;
};
typedef struct Geometry_STRUCT Geometry;
# 86 "./Geometry.hpp"
inline int ComputeRankOfMatrixRow(const Geometry &geom, global_int_t index) {
  global_int_t gnx = geom.gnx;
  global_int_t gny = geom.gny;

  global_int_t iz = index / (gny * gnx);
  global_int_t iy = (index - iz * gny * gnx) / gnx;
  global_int_t ix = index % gnx;

  int ipz = 0;
  int ipartz_ids = 0;
  for (int i = 0; i < geom.npartz; ++i) {
    int ipart_nz = geom.partz_nz[i];
    ipartz_ids = geom.partz_ids[i] - ipartz_ids;
    if (iz <= ipart_nz * ipartz_ids) {
      ipz += iz / ipart_nz;
      break;
    } else {
      ipz += ipartz_ids;
      iz -= ipart_nz * ipartz_ids;
    }
  }

  int ipy = iy / geom.ny;
  int ipx = ix / geom.nx;
  int rank = ipx + ipy * geom.npx + ipz * geom.npy * geom.npx;
  return rank;
}

inline void DeleteGeometry(Geometry &geom) {

  delete[] geom.partz_nz;
  delete[] geom.partz_ids;

  return;
}
# 27 "./SparseMatrix.hpp" 2
# 1 "./Vector.hpp" 1
# 23 "./Vector.hpp"
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 1 3
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 2 3
# 24 "./Vector.hpp" 2
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdlib" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdlib" 3
# 25 "./Vector.hpp" 2

struct Vector_STRUCT {
  local_int_t localLength;
  double *values;

  void *optimizationData;
};
typedef struct Vector_STRUCT Vector;

inline void InitializeVector(Vector &v, local_int_t localLength) {
  v.localLength = localLength;
  v.values = new double[localLength];
  v.optimizationData = 0;
  return;
}

inline void ZeroVector(Vector &v) {
  local_int_t localLength = v.localLength;
  double *vv = v.values;
  for (int i = 0; i < localLength; ++i)
    vv[i] = 0.0;
  return;
}

inline void ScaleVectorValue(Vector &v, local_int_t index, double value) {
  (static_cast<bool>(index >= 0 && index < v.localLength)
       ? void(0)
       : __assert_fail("index>=0 && index < v.localLength", __builtin_FILE(),
                       __builtin_LINE(), __extension__ __PRETTY_FUNCTION__));
  double *vv = v.values;
  vv[index] *= value;
  return;
}

inline void FillRandomVector(Vector &v) {
  local_int_t localLength = v.localLength;
  double *vv = v.values;
  for (int i = 0; i < localLength; ++i)
    vv[i] = rand() / (double)(2147483647) + 1.0;
  return;
}

inline void CopyVector(const Vector &v, Vector &w) {
  local_int_t localLength = v.localLength;
  (static_cast<bool>(w.localLength >= localLength)
       ? void(0)
       : __assert_fail("w.localLength >= localLength", __builtin_FILE(),
                       __builtin_LINE(), __extension__ __PRETTY_FUNCTION__));
  double *vv = v.values;
  double *wv = w.values;
  for (int i = 0; i < localLength; ++i)
    wv[i] = vv[i];
  return;
}

inline void DeleteVector(Vector &v) {

  delete[] v.values;
  v.localLength = 0;
  return;
}
# 28 "./SparseMatrix.hpp" 2
# 1 "./MGData.hpp" 1
# 24 "./MGData.hpp"
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 1 3
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 2 3
# 25 "./MGData.hpp" 2
# 1 "./SparseMatrix.hpp" 1
# 26 "./MGData.hpp" 2

struct MGData_STRUCT {
  int numberOfPresmootherSteps;
  int numberOfPostsmootherSteps;
  local_int_t *f2cOperator;
  Vector *rc;
  Vector *xc;
  Vector *Axf;

  void *optimizationData;
};
typedef struct MGData_STRUCT MGData;
# 50 "./MGData.hpp"
inline void InitializeMGData(local_int_t *f2cOperator, Vector *rc, Vector *xc,
                             Vector *Axf, MGData &data) {
  data.numberOfPresmootherSteps = 1;
  data.numberOfPostsmootherSteps = 1;
  data.f2cOperator = f2cOperator;
  data.rc = rc;
  data.xc = xc;
  data.Axf = Axf;
  return;
}

inline void DeleteMGData(MGData &data) {

  delete[] data.f2cOperator;
  DeleteVector(*data.Axf);
  DeleteVector(*data.rc);
  DeleteVector(*data.xc);
  delete data.Axf;
  delete data.rc;
  delete data.xc;
  return;
}
# 29 "./SparseMatrix.hpp" 2

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/unordered_map" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/unordered_map" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hashtable.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hashtable.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hashtable_policy.h" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hashtable_policy.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/aligned_buffer.h" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/aligned_buffer.h" 3

namespace __gnu_cxx {

template <typename _Tp> struct __aligned_membuf {

  struct _Tp2 {
    _Tp _M_t;
  };

  alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];

  __aligned_membuf() = default;

  __aligned_membuf(std::nullptr_t) {}

  void *_M_addr() noexcept { return static_cast<void *>(&_M_storage); }

  const void *_M_addr() const noexcept {
    return static_cast<const void *>(&_M_storage);
  }

  _Tp *_M_ptr() noexcept { return static_cast<_Tp *>(_M_addr()); }

  const _Tp *_M_ptr() const noexcept {
    return static_cast<const _Tp *>(_M_addr());
  }
};

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

template <typename _Tp>
struct __aligned_buffer : std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)> {
  typename std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;

  __aligned_buffer() = default;

  __aligned_buffer(std::nullptr_t) {}

  void *_M_addr() noexcept { return static_cast<void *>(&_M_storage); }

  const void *_M_addr() const noexcept {
    return static_cast<const void *>(&_M_storage);
  }

  _Tp *_M_ptr() noexcept { return static_cast<_Tp *>(_M_addr()); }

  const _Tp *_M_ptr() const noexcept {
    return static_cast<const _Tp *>(_M_addr());
  }
};
#pragma GCC diagnostic pop

} // namespace __gnu_cxx
# 39 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hashtable_policy.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  class _Hashtable;

  namespace __detail {

  template <typename _Key, typename _Value, typename _ExtractKey,
            typename _Equal, typename _Hash, typename _RangeHash,
            typename _Unused, typename _Traits>
  struct _Hashtable_base;

  template <typename _Iterator>
  inline typename std::iterator_traits<_Iterator>::difference_type
  __distance_fw(_Iterator __first, _Iterator __last, std::input_iterator_tag) {
    return __first != __last ? 1 : 0;
  }

  template <typename _Iterator>
  inline typename std::iterator_traits<_Iterator>::difference_type
  __distance_fw(_Iterator __first, _Iterator __last,
                std::forward_iterator_tag) {
    return std::distance(__first, __last);
  }

  template <typename _Iterator>
  inline typename std::iterator_traits<_Iterator>::difference_type
  __distance_fw(_Iterator __first, _Iterator __last) {
    return __distance_fw(__first, __last, std::__iterator_category(__first));
  }

  struct _Identity {
    template <typename _Tp> _Tp &&operator()(_Tp &&__x) const noexcept {
      return std::forward<_Tp>(__x);
    }
  };

  struct _Select1st {
    template <typename _Pair> struct __1st_type;

    template <typename _Tp, typename _Up> struct __1st_type<pair<_Tp, _Up>> {
      using type = _Tp;
    };

    template <typename _Tp, typename _Up>
    struct __1st_type<const pair<_Tp, _Up>> {
      using type = const _Tp;
    };

    template <typename _Pair> struct __1st_type<_Pair &> {
      using type = typename __1st_type<_Pair>::type &;
    };

    template <typename _Tp>
    typename __1st_type<_Tp>::type &&operator()(_Tp &&__x) const noexcept {
      return std::forward<_Tp>(__x).first;
    }
  };

  template <typename _ExKey, typename _Value> struct _ConvertToValueType;

  template <typename _Value> struct _ConvertToValueType<_Identity, _Value> {
    template <typename _Kt>
    constexpr _Kt &&operator()(_Kt &&__k) const noexcept {
      return std::forward<_Kt>(__k);
    }
  };

  template <typename _Value> struct _ConvertToValueType<_Select1st, _Value> {
    constexpr _Value &&operator()(_Value &&__x) const noexcept {
      return std::move(__x);
    }

    constexpr const _Value &operator()(const _Value &__x) const noexcept {
      return __x;
    }

    template <typename _Kt, typename _Val>
    constexpr std::pair<_Kt, _Val> &&
    operator()(std::pair<_Kt, _Val> &&__x) const noexcept {
      return std::move(__x);
    }

    template <typename _Kt, typename _Val>
    constexpr const std::pair<_Kt, _Val> &
    operator()(const std::pair<_Kt, _Val> &__x) const noexcept {
      return __x;
    }
  };

  template <typename _ExKey> struct _NodeBuilder;

  template <> struct _NodeBuilder<_Select1st> {
    template <typename _Kt, typename _Arg, typename _NodeGenerator>
    static auto _S_build(_Kt &&__k, _Arg &&__arg,
                         const _NodeGenerator &__node_gen) ->
        typename _NodeGenerator::__node_type * {
      return __node_gen(std::forward<_Kt>(__k),
                        std::forward<_Arg>(__arg).second);
    }
  };

  template <> struct _NodeBuilder<_Identity> {
    template <typename _Kt, typename _Arg, typename _NodeGenerator>
    static auto _S_build(_Kt &&__k, _Arg &&,
                         const _NodeGenerator &__node_gen) ->
        typename _NodeGenerator::__node_type * {
      return __node_gen(std::forward<_Kt>(__k));
    }
  };

  template <typename _NodeAlloc> struct _Hashtable_alloc;

  template <typename _NodeAlloc> struct _ReuseOrAllocNode {
  private:
    using __node_alloc_type = _NodeAlloc;
    using __hashtable_alloc = _Hashtable_alloc<__node_alloc_type>;
    using __node_alloc_traits = typename __hashtable_alloc::__node_alloc_traits;

  public:
    using __node_type = typename __hashtable_alloc::__node_type;

    _ReuseOrAllocNode(__node_type *__nodes, __hashtable_alloc &__h)
        : _M_nodes(__nodes), _M_h(__h) {}
    _ReuseOrAllocNode(const _ReuseOrAllocNode &) = delete;

    ~_ReuseOrAllocNode() { _M_h._M_deallocate_nodes(_M_nodes); }

    template <typename... _Args>
    __node_type *operator()(_Args &&...__args) const {
      if (_M_nodes) {
        __node_type *__node = _M_nodes;
        _M_nodes = _M_nodes->_M_next();
        __node->_M_nxt = nullptr;
        auto &__a = _M_h._M_node_allocator();
        __node_alloc_traits::destroy(__a, __node->_M_valptr());
        try {
          __node_alloc_traits::construct(__a, __node->_M_valptr(),
                                         std::forward<_Args>(__args)...);
        } catch (...) {
          _M_h._M_deallocate_node_ptr(__node);
          throw;
        }
        return __node;
      }
      return _M_h._M_allocate_node(std::forward<_Args>(__args)...);
    }

  private:
    mutable __node_type *_M_nodes;
    __hashtable_alloc &_M_h;
  };

  template <typename _NodeAlloc> struct _AllocNode {
  private:
    using __hashtable_alloc = _Hashtable_alloc<_NodeAlloc>;

  public:
    using __node_type = typename __hashtable_alloc::__node_type;

    _AllocNode(__hashtable_alloc &__h) : _M_h(__h) {}

    template <typename... _Args>
    __node_type *operator()(_Args &&...__args) const {
      return _M_h._M_allocate_node(std::forward<_Args>(__args)...);
    }

  private:
    __hashtable_alloc &_M_h;
  };
# 279 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hashtable_policy.h" 3
  template <bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys>
  struct _Hashtable_traits {
    using __hash_cached = __bool_constant<_Cache_hash_code>;
    using __constant_iterators = __bool_constant<_Constant_iterators>;
    using __unique_keys = __bool_constant<_Unique_keys>;
  };

  template <typename _Hash> struct _Hashtable_hash_traits {
    static constexpr std::size_t __small_size_threshold() noexcept {
      return std::__is_fast_hash<_Hash>::value ? 0 : 20;
    }
  };
# 309 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hashtable_policy.h" 3
  struct _Hash_node_base {
    _Hash_node_base *_M_nxt;

    _Hash_node_base() noexcept : _M_nxt() {}

    _Hash_node_base(_Hash_node_base *__next) noexcept : _M_nxt(__next) {}
  };

  template <typename _Value> struct _Hash_node_value_base {
    typedef _Value value_type;

    __gnu_cxx::__aligned_buffer<_Value> _M_storage;

    [[__gnu__::__always_inline__]]
    _Value *_M_valptr() noexcept {
      return _M_storage._M_ptr();
    }

    [[__gnu__::__always_inline__]]
    const _Value *_M_valptr() const noexcept {
      return _M_storage._M_ptr();
    }

    [[__gnu__::__always_inline__]]
    _Value &_M_v() noexcept {
      return *_M_valptr();
    }

    [[__gnu__::__always_inline__]]
    const _Value &_M_v() const noexcept {
      return *_M_valptr();
    }
  };

  template <bool _Cache_hash_code> struct _Hash_node_code_cache {};

  template <> struct _Hash_node_code_cache<true> {
    std::size_t _M_hash_code;
  };

  template <typename _Value, bool _Cache_hash_code>
  struct _Hash_node_value : _Hash_node_value_base<_Value>,
                            _Hash_node_code_cache<_Cache_hash_code> {};

  template <typename _Value, bool _Cache_hash_code>
  struct _Hash_node : _Hash_node_base,
                      _Hash_node_value<_Value, _Cache_hash_code> {
    _Hash_node *_M_next() const noexcept {
      return static_cast<_Hash_node *>(this->_M_nxt);
    }
  };

  template <typename _Value, bool _Cache_hash_code> struct _Node_iterator_base {
    using __node_type = _Hash_node<_Value, _Cache_hash_code>;

    __node_type *_M_cur;

    _Node_iterator_base() : _M_cur(nullptr) {}
    _Node_iterator_base(__node_type *__p) noexcept : _M_cur(__p) {}

    void _M_incr() noexcept { _M_cur = _M_cur->_M_next(); }

    friend bool operator==(const _Node_iterator_base &__x,
                           const _Node_iterator_base &__y) noexcept {
      return __x._M_cur == __y._M_cur;
    }
  };

  template <typename _Value, bool __constant_iterators, bool __cache>
  struct _Node_iterator : public _Node_iterator_base<_Value, __cache> {
  private:
    using __base_type = _Node_iterator_base<_Value, __cache>;
    using __node_type = typename __base_type::__node_type;

  public:
    using value_type = _Value;
    using difference_type = std::ptrdiff_t;
    using iterator_category = std::forward_iterator_tag;

    using pointer =
        __conditional_t<__constant_iterators, const value_type *, value_type *>;

    using reference =
        __conditional_t<__constant_iterators, const value_type &, value_type &>;

    _Node_iterator() = default;

    explicit _Node_iterator(__node_type *__p) noexcept : __base_type(__p) {}

    reference operator*() const noexcept { return this->_M_cur->_M_v(); }

    pointer operator->() const noexcept { return this->_M_cur->_M_valptr(); }

    _Node_iterator &operator++() noexcept {
      this->_M_incr();
      return *this;
    }

    _Node_iterator operator++(int) noexcept {
      _Node_iterator __tmp(*this);
      this->_M_incr();
      return __tmp;
    }
  };

  template <typename _Value, bool __constant_iterators, bool __cache>
  struct _Node_const_iterator : public _Node_iterator_base<_Value, __cache> {
  private:
    using __base_type = _Node_iterator_base<_Value, __cache>;
    using __node_type = typename __base_type::__node_type;

  public:
    typedef _Value value_type;
    typedef std::ptrdiff_t difference_type;
    typedef std::forward_iterator_tag iterator_category;

    typedef const value_type *pointer;
    typedef const value_type &reference;

    _Node_const_iterator() = default;

    explicit _Node_const_iterator(__node_type *__p) noexcept
        : __base_type(__p) {}

    _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,
                                              __cache> &__x) noexcept
        : __base_type(__x._M_cur) {}

    reference operator*() const noexcept { return this->_M_cur->_M_v(); }

    pointer operator->() const noexcept { return this->_M_cur->_M_valptr(); }

    _Node_const_iterator &operator++() noexcept {
      this->_M_incr();
      return *this;
    }

    _Node_const_iterator operator++(int) noexcept {
      _Node_const_iterator __tmp(*this);
      this->_M_incr();
      return __tmp;
    }
  };

  struct _Mod_range_hashing {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type operator()(first_argument_type __num,
                           second_argument_type __den) const noexcept {
      return __num % __den;
    }
  };

  struct _Default_ranged_hash {};

  struct _Prime_rehash_policy {
    using __has_load_factor = true_type;

    _Prime_rehash_policy(float __z = 1.0) noexcept
        : _M_max_load_factor(__z), _M_next_resize(0) {}

    float max_load_factor() const noexcept { return _M_max_load_factor; }

    std::size_t _M_next_bkt(std::size_t __n) const;

    std::size_t _M_bkt_for_elements(std::size_t __n) const {
      return __builtin_ceil(__n / (double)_M_max_load_factor);
    }

    std::pair<bool, std::size_t> _M_need_rehash(std::size_t __n_bkt,
                                                std::size_t __n_elt,
                                                std::size_t __n_ins) const;

    typedef std::size_t _State;

    _State _M_state() const { return _M_next_resize; }

    void _M_reset() noexcept { _M_next_resize = 0; }

    void _M_reset(_State __state) { _M_next_resize = __state; }

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    mutable std::size_t _M_next_resize;
  };

  struct _Mask_range_hashing {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type operator()(first_argument_type __num,
                           second_argument_type __den) const noexcept {
      return __num & (__den - 1);
    }
  };

  inline std::size_t __clp2(std::size_t __n) noexcept {
    using __gnu_cxx::__int_traits;

    if (__n < 2)
      return __n;
    const unsigned __lz = sizeof(size_t) > sizeof(long)
                              ? __builtin_clzll(__n - 1ull)
                              : __builtin_clzl(__n - 1ul);

    return (size_t(1) << (__int_traits<size_t>::__digits - __lz - 1)) << 1;
  }

  struct _Power2_rehash_policy {
    using __has_load_factor = true_type;

    _Power2_rehash_policy(float __z = 1.0) noexcept
        : _M_max_load_factor(__z), _M_next_resize(0) {}

    float max_load_factor() const noexcept { return _M_max_load_factor; }

    std::size_t _M_next_bkt(std::size_t __n) noexcept {
      if (__n == 0)

        return 1;

      const auto __max_width = std::min<size_t>(sizeof(size_t), 8);
      const auto __max_bkt = size_t(1) << (__max_width * 8 - 1);
      std::size_t __res = __clp2(__n);

      if (__res == 0)
        __res = __max_bkt;
      else if (__res == 1)

        __res = 2;

      if (__res == __max_bkt)

        _M_next_resize = size_t(-1);
      else
        _M_next_resize = __builtin_floor(__res * (double)_M_max_load_factor);

      return __res;
    }

    std::size_t _M_bkt_for_elements(std::size_t __n) const noexcept {
      return __builtin_ceil(__n / (double)_M_max_load_factor);
    }

    std::pair<bool, std::size_t> _M_need_rehash(std::size_t __n_bkt,
                                                std::size_t __n_elt,
                                                std::size_t __n_ins) noexcept {
      if (__n_elt + __n_ins > _M_next_resize) {

        double __min_bkts =
            std::max<std::size_t>(__n_elt + __n_ins, _M_next_resize ? 0 : 11) /
            (double)_M_max_load_factor;
        if (__min_bkts >= __n_bkt)
          return {true, _M_next_bkt(std::max<std::size_t>(
                            __builtin_floor(__min_bkts) + 1,
                            __n_bkt * _S_growth_factor))};

        _M_next_resize = __builtin_floor(__n_bkt * (double)_M_max_load_factor);
        return {false, 0};
      } else
        return {false, 0};
    }

    typedef std::size_t _State;

    _State _M_state() const noexcept { return _M_next_resize; }

    void _M_reset() noexcept { _M_next_resize = 0; }

    void _M_reset(_State __state) noexcept { _M_next_resize = __state; }

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    std::size_t _M_next_resize;
  };
# 736 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hashtable_policy.h" 3
  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits, bool _Unique_keys = _Traits::__unique_keys::value>
  struct _Map_base {};

  template <typename _Key, typename _Val, typename _Alloc, typename _Equal,
            typename _Hash, typename _RangeHash, typename _Unused,
            typename _RehashPolicy, typename _Traits>
  struct _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
                   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false> {
    using mapped_type = _Val;
  };

  template <typename _Key, typename _Val, typename _Alloc, typename _Equal,
            typename _Hash, typename _RangeHash, typename _Unused,
            typename _RehashPolicy, typename _Traits>
  struct _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
                   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true> {
  private:
    using __hashtable_base =
        _Hashtable_base<_Key, pair<const _Key, _Val>, _Select1st, _Equal, _Hash,
                        _RangeHash, _Unused, _Traits>;

    using __hashtable =
        _Hashtable<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
                   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>;

    using __hash_code = typename __hashtable_base::__hash_code;

  public:
    using key_type = typename __hashtable_base::key_type;
    using mapped_type = _Val;

    mapped_type &operator[](const key_type &__k);

    mapped_type &operator[](key_type &&__k);

    mapped_type &at(const key_type &__k) {
      auto __ite = static_cast<__hashtable *>(this)->find(__k);
      if (!__ite._M_cur)
        __throw_out_of_range(("unordered_map::at"));
      return __ite->second;
    }

    const mapped_type &at(const key_type &__k) const {
      auto __ite = static_cast<const __hashtable *>(this)->find(__k);
      if (!__ite._M_cur)
        __throw_out_of_range(("unordered_map::at"));
      return __ite->second;
    }
  };

  template <typename _Key, typename _Val, typename _Alloc, typename _Equal,
            typename _Hash, typename _RangeHash, typename _Unused,
            typename _RehashPolicy, typename _Traits>
  auto _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
                 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits,
                 true>::operator[](const key_type &__k) -> mapped_type & {
    __hashtable *__h = static_cast<__hashtable *>(this);
    __hash_code __code = __h->_M_hash_code(__k);
    std::size_t __bkt = __h->_M_bucket_index(__code);
    if (auto __node = __h->_M_find_node(__bkt, __k, __code))
      return __node->_M_v().second;

    typename __hashtable::_Scoped_node __node{__h, std::piecewise_construct,
                                              std::tuple<const key_type &>(__k),
                                              std::tuple<>()};
    auto __pos = __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
    __node._M_node = nullptr;
    return __pos->second;
  }

  template <typename _Key, typename _Val, typename _Alloc, typename _Equal,
            typename _Hash, typename _RangeHash, typename _Unused,
            typename _RehashPolicy, typename _Traits>
  auto _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
                 _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits,
                 true>::operator[](key_type &&__k) -> mapped_type & {
    __hashtable *__h = static_cast<__hashtable *>(this);
    __hash_code __code = __h->_M_hash_code(__k);
    std::size_t __bkt = __h->_M_bucket_index(__code);
    if (auto __node = __h->_M_find_node(__bkt, __k, __code))
      return __node->_M_v().second;

    typename __hashtable::_Scoped_node __node{
        __h, std::piecewise_construct, std::forward_as_tuple(std::move(__k)),
        std::tuple<>()};
    auto __pos = __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
    __node._M_node = nullptr;
    return __pos->second;
  }

  template <typename _Key, typename _Val, typename _Alloc, typename _Equal,
            typename _Hash, typename _RangeHash, typename _Unused,
            typename _RehashPolicy, typename _Traits, bool __uniq>
  struct _Map_base<const _Key, pair<const _Key, _Val>, _Alloc, _Select1st,
                   _Equal, _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits,
                   __uniq>
      : _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
                  _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, __uniq> {
  };

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  struct _Insert_base {
  protected:
    using __hashtable_base =
        _Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _Hash, _RangeHash,
                        _Unused, _Traits>;

    using __hashtable =
        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                   _Unused, _RehashPolicy, _Traits>;

    using __hash_cached = typename _Traits::__hash_cached;
    using __constant_iterators = typename _Traits::__constant_iterators;

    using __hashtable_alloc = _Hashtable_alloc<
        __alloc_rebind<_Alloc, _Hash_node<_Value, __hash_cached::value>>>;

    using value_type = typename __hashtable_base::value_type;
    using size_type = typename __hashtable_base::size_type;

    using __unique_keys = typename _Traits::__unique_keys;
    using __node_alloc_type = typename __hashtable_alloc::__node_alloc_type;
    using __node_gen_type = _AllocNode<__node_alloc_type>;

    __hashtable &_M_conjure_hashtable() {
      return *(static_cast<__hashtable *>(this));
    }

    template <typename _InputIterator, typename _NodeGetter>
    void _M_insert_range(_InputIterator __first, _InputIterator __last,
                         const _NodeGetter &, true_type __uks);

    template <typename _InputIterator, typename _NodeGetter>
    void _M_insert_range(_InputIterator __first, _InputIterator __last,
                         const _NodeGetter &, false_type __uks);

  public:
    using iterator = _Node_iterator<_Value, __constant_iterators::value,
                                    __hash_cached::value>;

    using const_iterator =
        _Node_const_iterator<_Value, __constant_iterators::value,
                             __hash_cached::value>;

    using __ireturn_type = __conditional_t<__unique_keys::value,
                                           std::pair<iterator, bool>, iterator>;

    __ireturn_type insert(const value_type &__v) {
      __hashtable &__h = _M_conjure_hashtable();
      __node_gen_type __node_gen(__h);
      return __h._M_insert(__v, __node_gen, __unique_keys{});
    }

    iterator insert(const_iterator __hint, const value_type &__v) {
      __hashtable &__h = _M_conjure_hashtable();
      __node_gen_type __node_gen(__h);
      return __h._M_insert(__hint, __v, __node_gen, __unique_keys{});
    }

    template <typename _KType, typename... _Args>
    std::pair<iterator, bool> try_emplace(const_iterator, _KType &&__k,
                                          _Args &&...__args) {
      __hashtable &__h = _M_conjure_hashtable();
      auto __code = __h._M_hash_code(__k);
      std::size_t __bkt = __h._M_bucket_index(__code);
      if (auto __node = __h._M_find_node(__bkt, __k, __code))
        return {iterator(__node), false};

      typename __hashtable::_Scoped_node __node{
          &__h, std::piecewise_construct,
          std::forward_as_tuple(std::forward<_KType>(__k)),
          std::forward_as_tuple(std::forward<_Args>(__args)...)};
      auto __it = __h._M_insert_unique_node(__bkt, __code, __node._M_node);
      __node._M_node = nullptr;
      return {__it, true};
    }

    void insert(initializer_list<value_type> __l) {
      this->insert(__l.begin(), __l.end());
    }

    template <typename _InputIterator>
    void insert(_InputIterator __first, _InputIterator __last) {
      __hashtable &__h = _M_conjure_hashtable();
      __node_gen_type __node_gen(__h);
      return _M_insert_range(__first, __last, __node_gen, __unique_keys{});
    }
  };

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  template <typename _InputIterator, typename _NodeGetter>
  void _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash,
                    _RangeHash, _Unused, _RehashPolicy,
                    _Traits>::_M_insert_range(_InputIterator __first,
                                              _InputIterator __last,
                                              const _NodeGetter &__node_gen,
                                              true_type __uks) {
    __hashtable &__h = _M_conjure_hashtable();
    for (; __first != __last; ++__first)
      __h._M_insert(*__first, __node_gen, __uks);
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  template <typename _InputIterator, typename _NodeGetter>
  void _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash,
                    _RangeHash, _Unused, _RehashPolicy,
                    _Traits>::_M_insert_range(_InputIterator __first,
                                              _InputIterator __last,
                                              const _NodeGetter &__node_gen,
                                              false_type __uks) {
    using __rehash_type = typename __hashtable::__rehash_type;
    using __rehash_state = typename __hashtable::__rehash_state;
    using pair_type = std::pair<bool, std::size_t>;

    size_type __n_elt = __detail::__distance_fw(__first, __last);
    if (__n_elt == 0)
      return;

    __hashtable &__h = _M_conjure_hashtable();
    __rehash_type &__rehash = __h._M_rehash_policy;
    const __rehash_state &__saved_state = __rehash._M_state();
    pair_type __do_rehash = __rehash._M_need_rehash(
        __h._M_bucket_count, __h._M_element_count, __n_elt);

    if (__do_rehash.first)
      __h._M_rehash(__do_rehash.second, __saved_state);

    for (; __first != __last; ++__first)
      __h._M_insert(*__first, __node_gen, __uks);
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits,
            bool _Constant_iterators = _Traits::__constant_iterators::value>
  struct _Insert;

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                 _Unused, _RehashPolicy, _Traits, true>
      : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash,
                            _RangeHash, _Unused, _RehashPolicy, _Traits> {
    using __base_type =
        _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash,
                     _RangeHash, _Unused, _RehashPolicy, _Traits>;

    using value_type = typename __base_type::value_type;
    using iterator = typename __base_type::iterator;
    using const_iterator = typename __base_type::const_iterator;
    using __ireturn_type = typename __base_type::__ireturn_type;

    using __unique_keys = typename __base_type::__unique_keys;
    using __hashtable = typename __base_type::__hashtable;
    using __node_gen_type = typename __base_type::__node_gen_type;

    using __base_type::insert;

    __ireturn_type insert(value_type &&__v) {
      __hashtable &__h = this->_M_conjure_hashtable();
      __node_gen_type __node_gen(__h);
      return __h._M_insert(std::move(__v), __node_gen, __unique_keys{});
    }

    iterator insert(const_iterator __hint, value_type &&__v) {
      __hashtable &__h = this->_M_conjure_hashtable();
      __node_gen_type __node_gen(__h);
      return __h._M_insert(__hint, std::move(__v), __node_gen, __unique_keys{});
    }
  };

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                 _Unused, _RehashPolicy, _Traits, false>
      : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash,
                            _RangeHash, _Unused, _RehashPolicy, _Traits> {
    using __base_type =
        _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash,
                     _RangeHash, _Unused, _RehashPolicy, _Traits>;
    using value_type = typename __base_type::value_type;
    using iterator = typename __base_type::iterator;
    using const_iterator = typename __base_type::const_iterator;

    using __unique_keys = typename __base_type::__unique_keys;
    using __hashtable = typename __base_type::__hashtable;
    using __ireturn_type = typename __base_type::__ireturn_type;

    using __base_type::insert;

    template <typename _Pair>
    using __is_cons = std::is_constructible<value_type, _Pair &&>;

    template <typename _Pair>
    using _IFcons = std::enable_if<__is_cons<_Pair>::value>;

    template <typename _Pair> using _IFconsp = typename _IFcons<_Pair>::type;

    template <typename _Pair, typename = _IFconsp<_Pair>>
    __ireturn_type insert(_Pair &&__v) {
      __hashtable &__h = this->_M_conjure_hashtable();
      return __h._M_emplace(__unique_keys{}, std::forward<_Pair>(__v));
    }

    template <typename _Pair, typename = _IFconsp<_Pair>>
    iterator insert(const_iterator __hint, _Pair &&__v) {
      __hashtable &__h = this->_M_conjure_hashtable();
      return __h._M_emplace(__hint, __unique_keys{}, std::forward<_Pair>(__v));
    }
  };

  template <typename _Policy>
  using __has_load_factor = typename _Policy::__has_load_factor;

  template <
      typename _Key, typename _Value, typename _Alloc, typename _ExtractKey,
      typename _Equal, typename _Hash, typename _RangeHash, typename _Unused,
      typename _RehashPolicy, typename _Traits,
      typename = __detected_or_t<false_type, __has_load_factor, _RehashPolicy>>
  struct _Rehash_base;

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash,
                      _RangeHash, _Unused, _RehashPolicy, _Traits, false_type> {
  };

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash,
                      _RangeHash, _Unused, _RehashPolicy, _Traits, true_type> {
  private:
    using __hashtable =
        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                   _Unused, _RehashPolicy, _Traits>;

  public:
    float max_load_factor() const noexcept {
      const __hashtable *__this = static_cast<const __hashtable *>(this);
      return __this->__rehash_policy().max_load_factor();
    }

    void max_load_factor(float __z) {
      __hashtable *__this = static_cast<__hashtable *>(this);
      __this->__rehash_policy(_RehashPolicy(__z));
    }

    void reserve(std::size_t __n) {
      __hashtable *__this = static_cast<__hashtable *>(this);
      __this->rehash(__this->__rehash_policy()._M_bkt_for_elements(__n));
    }
  };

  template <int _Nm, typename _Tp,
            bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
  struct _Hashtable_ebo_helper;

  template <int _Nm, typename _Tp>
  struct _Hashtable_ebo_helper<_Nm, _Tp, true> : private _Tp {
    _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() {}

    template <typename _OtherTp>
    _Hashtable_ebo_helper(_OtherTp &&__tp)
        : _Tp(std::forward<_OtherTp>(__tp)) {}

    const _Tp &_M_cget() const { return static_cast<const _Tp &>(*this); }
    _Tp &_M_get() { return static_cast<_Tp &>(*this); }
  };

  template <int _Nm, typename _Tp>
  struct _Hashtable_ebo_helper<_Nm, _Tp, false> {
    _Hashtable_ebo_helper() = default;

    template <typename _OtherTp>
    _Hashtable_ebo_helper(_OtherTp &&__tp)
        : _M_tp(std::forward<_OtherTp>(__tp)) {}

    const _Tp &_M_cget() const { return _M_tp; }
    _Tp &_M_get() { return _M_tp; }

  private:
    _Tp _M_tp{};
  };

  template <typename _Key, typename _Value, typename _ExtractKey,
            typename _Hash, typename _RangeHash, typename _Unused,
            bool __cache_hash_code>
  struct _Local_iterator_base;
# 1276 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hashtable_policy.h" 3
  template <typename _Key, typename _Value, typename _ExtractKey,
            typename _Hash, typename _RangeHash, typename _Unused,
            bool __cache_hash_code>
  struct _Hash_code_base : private _Hashtable_ebo_helper<1, _Hash> {
  private:
    using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;

    friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _Hash,
                                       _RangeHash, _Unused, false>;

  public:
    typedef _Hash hasher;

    hasher hash_function() const { return _M_hash(); }

  protected:
    typedef std::size_t __hash_code;

    _Hash_code_base() = default;

    _Hash_code_base(const _Hash &__hash) : __ebo_hash(__hash) {}

    __hash_code _M_hash_code(const _Key &__k) const {
      static_assert(
          __is_invocable<const _Hash &, const _Key &>{},
          "hash function must be invocable with an argument of key type");
      return _M_hash()(__k);
    }

    template <typename _Kt> __hash_code _M_hash_code_tr(const _Kt &__k) const {
      static_assert(
          __is_invocable<const _Hash &, const _Kt &>{},
          "hash function must be invocable with an argument of key type");
      return _M_hash()(__k);
    }

    __hash_code _M_hash_code(const _Hash_node_value<_Value, false> &__n) const {
      return _M_hash_code(_ExtractKey{}(__n._M_v()));
    }

    __hash_code _M_hash_code(const _Hash_node_value<_Value, true> &__n) const {
      return __n._M_hash_code;
    }

    std::size_t _M_bucket_index(__hash_code __c,
                                std::size_t __bkt_count) const {
      return _RangeHash{}(__c, __bkt_count);
    }

    std::size_t _M_bucket_index(const _Hash_node_value<_Value, false> &__n,
                                std::size_t __bkt_count) const
        noexcept(noexcept(declval<const _Hash &>()(declval<const _Key &>())) &&
                 noexcept(declval<const _RangeHash &>()((__hash_code)0,
                                                        (std::size_t)0))) {
      return _RangeHash{}(_M_hash_code(_ExtractKey{}(__n._M_v())), __bkt_count);
    }

    std::size_t _M_bucket_index(const _Hash_node_value<_Value, true> &__n,
                                std::size_t __bkt_count) const
        noexcept(noexcept(declval<const _RangeHash &>()((__hash_code)0,
                                                        (std::size_t)0))) {
      return _RangeHash{}(__n._M_hash_code, __bkt_count);
    }

    void _M_store_code(_Hash_node_code_cache<false> &, __hash_code) const {}

    void _M_copy_code(_Hash_node_code_cache<false> &,
                      const _Hash_node_code_cache<false> &) const {}

    void _M_store_code(_Hash_node_code_cache<true> &__n,
                       __hash_code __c) const {
      __n._M_hash_code = __c;
    }

    void _M_copy_code(_Hash_node_code_cache<true> &__to,
                      const _Hash_node_code_cache<true> &__from) const {
      __to._M_hash_code = __from._M_hash_code;
    }

    void _M_swap(_Hash_code_base &__x) {
      std::swap(__ebo_hash::_M_get(), __x.__ebo_hash::_M_get());
    }

    const _Hash &_M_hash() const { return __ebo_hash::_M_cget(); }
  };

  template <typename _Key, typename _Value, typename _ExtractKey,
            typename _Hash, typename _RangeHash, typename _Unused>
  struct _Local_iterator_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash,
                              _Unused, true>
      : public _Node_iterator_base<_Value, true> {
  protected:
    using __base_node_iter = _Node_iterator_base<_Value, true>;
    using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey, _Hash,
                                             _RangeHash, _Unused, true>;

    _Local_iterator_base() = default;
    _Local_iterator_base(const __hash_code_base &,
                         _Hash_node<_Value, true> *__p, std::size_t __bkt,
                         std::size_t __bkt_count)
        : __base_node_iter(__p), _M_bucket(__bkt),
          _M_bucket_count(__bkt_count) {}

    void _M_incr() {
      __base_node_iter::_M_incr();
      if (this->_M_cur) {
        std::size_t __bkt =
            _RangeHash{}(this->_M_cur->_M_hash_code, _M_bucket_count);
        if (__bkt != _M_bucket)
          this->_M_cur = nullptr;
      }
    }

    std::size_t _M_bucket;
    std::size_t _M_bucket_count;

  public:
    std::size_t _M_get_bucket() const { return _M_bucket; }
  };

  template <typename _Tp, bool _IsEmpty = std::is_empty<_Tp>::value>
  struct _Hash_code_storage {
    __gnu_cxx::__aligned_buffer<_Tp> _M_storage;

    _Tp *_M_h() { return _M_storage._M_ptr(); }

    const _Tp *_M_h() const { return _M_storage._M_ptr(); }
  };

  template <typename _Tp> struct _Hash_code_storage<_Tp, true> {
    static_assert(std::is_empty<_Tp>::value, "Type must be empty");

    _Tp *_M_h() { return reinterpret_cast<_Tp *>(this); }

    const _Tp *_M_h() const { return reinterpret_cast<const _Tp *>(this); }
  };

  template <typename _Key, typename _Value, typename _ExtractKey,
            typename _Hash, typename _RangeHash, typename _Unused>
  using __hash_code_for_local_iter =
      _Hash_code_storage<_Hash_code_base<_Key, _Value, _ExtractKey, _Hash,
                                         _RangeHash, _Unused, false>>;

  template <typename _Key, typename _Value, typename _ExtractKey,
            typename _Hash, typename _RangeHash, typename _Unused>
  struct _Local_iterator_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash,
                              _Unused, false>
      : __hash_code_for_local_iter<_Key, _Value, _ExtractKey, _Hash, _RangeHash,
                                   _Unused>,
        _Node_iterator_base<_Value, false> {
  protected:
    using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey, _Hash,
                                             _RangeHash, _Unused, false>;
    using __node_iter_base = _Node_iterator_base<_Value, false>;

    _Local_iterator_base() : _M_bucket_count(-1) {}

    _Local_iterator_base(const __hash_code_base &__base,
                         _Hash_node<_Value, false> *__p, std::size_t __bkt,
                         std::size_t __bkt_count)
        : __node_iter_base(__p), _M_bucket(__bkt),
          _M_bucket_count(__bkt_count) {
      _M_init(__base);
    }

    ~_Local_iterator_base() {
      if (_M_bucket_count != size_t(-1))
        _M_destroy();
    }

    _Local_iterator_base(const _Local_iterator_base &__iter)
        : __node_iter_base(__iter._M_cur), _M_bucket(__iter._M_bucket),
          _M_bucket_count(__iter._M_bucket_count) {
      if (_M_bucket_count != size_t(-1))
        _M_init(*__iter._M_h());
    }

    _Local_iterator_base &operator=(const _Local_iterator_base &__iter) {
      if (_M_bucket_count != -1)
        _M_destroy();
      this->_M_cur = __iter._M_cur;
      _M_bucket = __iter._M_bucket;
      _M_bucket_count = __iter._M_bucket_count;
      if (_M_bucket_count != -1)
        _M_init(*__iter._M_h());
      return *this;
    }

    void _M_incr() {
      __node_iter_base::_M_incr();
      if (this->_M_cur) {
        std::size_t __bkt =
            this->_M_h()->_M_bucket_index(*this->_M_cur, _M_bucket_count);
        if (__bkt != _M_bucket)
          this->_M_cur = nullptr;
      }
    }

    std::size_t _M_bucket;
    std::size_t _M_bucket_count;

    void _M_init(const __hash_code_base &__base) {
      ::new (this->_M_h()) __hash_code_base(__base);
    }

    void _M_destroy() { this->_M_h()->~__hash_code_base(); }

  public:
    std::size_t _M_get_bucket() const { return _M_bucket; }
  };

  template <typename _Key, typename _Value, typename _ExtractKey,
            typename _Hash, typename _RangeHash, typename _Unused,
            bool __constant_iterators, bool __cache>
  struct _Local_iterator
      : public _Local_iterator_base<_Key, _Value, _ExtractKey, _Hash,
                                    _RangeHash, _Unused, __cache> {
  private:
    using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey, _Hash,
                                             _RangeHash, _Unused, __cache>;
    using __hash_code_base = typename __base_type::__hash_code_base;

  public:
    using value_type = _Value;
    using pointer =
        __conditional_t<__constant_iterators, const value_type *, value_type *>;
    using reference =
        __conditional_t<__constant_iterators, const value_type &, value_type &>;
    using difference_type = ptrdiff_t;
    using iterator_category = forward_iterator_tag;

    _Local_iterator() = default;

    _Local_iterator(const __hash_code_base &__base,
                    _Hash_node<_Value, __cache> *__n, std::size_t __bkt,
                    std::size_t __bkt_count)
        : __base_type(__base, __n, __bkt, __bkt_count) {}

    reference operator*() const { return this->_M_cur->_M_v(); }

    pointer operator->() const { return this->_M_cur->_M_valptr(); }

    _Local_iterator &operator++() {
      this->_M_incr();
      return *this;
    }

    _Local_iterator operator++(int) {
      _Local_iterator __tmp(*this);
      this->_M_incr();
      return __tmp;
    }
  };

  template <typename _Key, typename _Value, typename _ExtractKey,
            typename _Hash, typename _RangeHash, typename _Unused,
            bool __constant_iterators, bool __cache>
  struct _Local_const_iterator
      : public _Local_iterator_base<_Key, _Value, _ExtractKey, _Hash,
                                    _RangeHash, _Unused, __cache> {
  private:
    using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey, _Hash,
                                             _RangeHash, _Unused, __cache>;
    using __hash_code_base = typename __base_type::__hash_code_base;

  public:
    typedef _Value value_type;
    typedef const value_type *pointer;
    typedef const value_type &reference;
    typedef std::ptrdiff_t difference_type;
    typedef std::forward_iterator_tag iterator_category;

    _Local_const_iterator() = default;

    _Local_const_iterator(const __hash_code_base &__base,
                          _Hash_node<_Value, __cache> *__n, std::size_t __bkt,
                          std::size_t __bkt_count)
        : __base_type(__base, __n, __bkt, __bkt_count) {}

    _Local_const_iterator(
        const _Local_iterator<_Key, _Value, _ExtractKey, _Hash, _RangeHash,
                              _Unused, __constant_iterators, __cache> &__x)
        : __base_type(__x) {}

    reference operator*() const { return this->_M_cur->_M_v(); }

    pointer operator->() const { return this->_M_cur->_M_valptr(); }

    _Local_const_iterator &operator++() {
      this->_M_incr();
      return *this;
    }

    _Local_const_iterator operator++(int) {
      _Local_const_iterator __tmp(*this);
      this->_M_incr();
      return __tmp;
    }
  };
# 1655 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hashtable_policy.h" 3
  template <typename _Key, typename _Value, typename _ExtractKey,
            typename _Equal, typename _Hash, typename _RangeHash,
            typename _Unused, typename _Traits>
  struct _Hashtable_base
      : public _Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash,
                               _Unused, _Traits::__hash_cached::value>,
        private _Hashtable_ebo_helper<0, _Equal> {
  public:
    typedef _Key key_type;
    typedef _Value value_type;
    typedef _Equal key_equal;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;

    using __traits_type = _Traits;
    using __hash_cached = typename __traits_type::__hash_cached;

    using __hash_code_base =
        _Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash, _Unused,
                        __hash_cached::value>;

    using __hash_code = typename __hash_code_base::__hash_code;

  private:
    using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;

    static bool _S_equals(__hash_code, const _Hash_node_code_cache<false> &) {
      return true;
    }

    static bool _S_node_equals(const _Hash_node_code_cache<false> &,
                               const _Hash_node_code_cache<false> &) {
      return true;
    }

    static bool _S_equals(__hash_code __c,
                          const _Hash_node_code_cache<true> &__n) {
      return __c == __n._M_hash_code;
    }

    static bool _S_node_equals(const _Hash_node_code_cache<true> &__lhn,
                               const _Hash_node_code_cache<true> &__rhn) {
      return __lhn._M_hash_code == __rhn._M_hash_code;
    }

  protected:
    _Hashtable_base() = default;

    _Hashtable_base(const _Hash &__hash, const _Equal &__eq)
        : __hash_code_base(__hash), _EqualEBO(__eq) {}

    bool _M_key_equals(
        const _Key &__k,
        const _Hash_node_value<_Value, __hash_cached::value> &__n) const {
      static_assert(
          __is_invocable<const _Equal &, const _Key &, const _Key &>{},
          "key equality predicate must be invocable with two arguments of "
          "key type");
      return _M_eq()(__k, _ExtractKey{}(__n._M_v()));
    }

    template <typename _Kt>
    bool _M_key_equals_tr(
        const _Kt &__k,
        const _Hash_node_value<_Value, __hash_cached::value> &__n) const {
      static_assert(
          __is_invocable<const _Equal &, const _Kt &, const _Key &>{},
          "key equality predicate must be invocable with two arguments of "
          "key type");
      return _M_eq()(__k, _ExtractKey{}(__n._M_v()));
    }

    bool
    _M_equals(const _Key &__k, __hash_code __c,
              const _Hash_node_value<_Value, __hash_cached::value> &__n) const {
      return _S_equals(__c, __n) && _M_key_equals(__k, __n);
    }

    template <typename _Kt>
    bool _M_equals_tr(
        const _Kt &__k, __hash_code __c,
        const _Hash_node_value<_Value, __hash_cached::value> &__n) const {
      return _S_equals(__c, __n) && _M_key_equals_tr(__k, __n);
    }

    bool _M_node_equals(
        const _Hash_node_value<_Value, __hash_cached::value> &__lhn,
        const _Hash_node_value<_Value, __hash_cached::value> &__rhn) const {
      return _S_node_equals(__lhn, __rhn) &&
             _M_key_equals(_ExtractKey{}(__lhn._M_v()), __rhn);
    }

    void _M_swap(_Hashtable_base &__x) {
      __hash_code_base::_M_swap(__x);
      std::swap(_EqualEBO::_M_get(), __x._EqualEBO::_M_get());
    }

    const _Equal &_M_eq() const { return _EqualEBO::_M_cget(); }
  };
# 1771 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hashtable_policy.h" 3
  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits, bool _Unique_keys = _Traits::__unique_keys::value>
  struct _Equality;

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                   _Unused, _RehashPolicy, _Traits, true> {
    using __hashtable =
        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                   _Unused, _RehashPolicy, _Traits>;

    bool _M_equal(const __hashtable &) const;
  };

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  bool _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                 _Unused, _RehashPolicy, _Traits,
                 true>::_M_equal(const __hashtable &__other) const {
    using __node_type = typename __hashtable::__node_type;
    const __hashtable *__this = static_cast<const __hashtable *>(this);
    if (__this->size() != __other.size())
      return false;

    for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx) {
      std::size_t __ybkt = __other._M_bucket_index(*__itx._M_cur);
      auto __prev_n = __other._M_buckets[__ybkt];
      if (!__prev_n)
        return false;

      for (__node_type *__n = static_cast<__node_type *>(__prev_n->_M_nxt);;
           __n = __n->_M_next()) {
        if (__n->_M_v() == *__itx)
          break;

        if (!__n->_M_nxt || __other._M_bucket_index(*__n->_M_next()) != __ybkt)
          return false;
      }
    }

    return true;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                   _Unused, _RehashPolicy, _Traits, false> {
    using __hashtable =
        _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                   _Unused, _RehashPolicy, _Traits>;

    bool _M_equal(const __hashtable &) const;
  };

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  bool _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                 _Unused, _RehashPolicy, _Traits,
                 false>::_M_equal(const __hashtable &__other) const {
    using __node_type = typename __hashtable::__node_type;
    const __hashtable *__this = static_cast<const __hashtable *>(this);
    if (__this->size() != __other.size())
      return false;

    for (auto __itx = __this->begin(); __itx != __this->end();) {
      std::size_t __x_count = 1;
      auto __itx_end = __itx;
      for (++__itx_end;
           __itx_end != __this->end() &&
           __this->key_eq()(_ExtractKey{}(*__itx), _ExtractKey{}(*__itx_end));
           ++__itx_end)
        ++__x_count;

      std::size_t __ybkt = __other._M_bucket_index(*__itx._M_cur);
      auto __y_prev_n = __other._M_buckets[__ybkt];
      if (!__y_prev_n)
        return false;

      __node_type *__y_n = static_cast<__node_type *>(__y_prev_n->_M_nxt);
      for (;;) {
        if (__this->key_eq()(_ExtractKey{}(__y_n->_M_v()),
                             _ExtractKey{}(*__itx)))
          break;

        auto __y_ref_n = __y_n;
        for (__y_n = __y_n->_M_next(); __y_n; __y_n = __y_n->_M_next())
          if (!__other._M_node_equals(*__y_ref_n, *__y_n))
            break;

        if (!__y_n || __other._M_bucket_index(*__y_n) != __ybkt)
          return false;
      }

      typename __hashtable::const_iterator __ity(__y_n);
      for (auto __ity_end = __ity; __ity_end != __other.end(); ++__ity_end)
        if (--__x_count == 0)
          break;

      if (__x_count != 0)
        return false;

      if (!std::is_permutation(__itx, __itx_end, __ity))
        return false;

      __itx = __itx_end;
    }
    return true;
  }

  template <typename _NodeAlloc>
  struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc> {
  private:
    using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;

    template <typename> struct __get_value_type;
    template <typename _Val, bool _Cache_hash_code>
    struct __get_value_type<_Hash_node<_Val, _Cache_hash_code>> {
      using type = _Val;
    };

  public:
    using __node_type = typename _NodeAlloc::value_type;
    using __node_alloc_type = _NodeAlloc;

    using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;

    using __value_alloc_traits =
        typename __node_alloc_traits::template rebind_traits<
            typename __get_value_type<__node_type>::type>;

    using __node_ptr = __node_type *;
    using __node_base = _Hash_node_base;
    using __node_base_ptr = __node_base *;
    using __buckets_alloc_type =
        __alloc_rebind<__node_alloc_type, __node_base_ptr>;
    using __buckets_alloc_traits = std::allocator_traits<__buckets_alloc_type>;
    using __buckets_ptr = __node_base_ptr *;

    _Hashtable_alloc() = default;
    _Hashtable_alloc(const _Hashtable_alloc &) = default;
    _Hashtable_alloc(_Hashtable_alloc &&) = default;

    template <typename _Alloc>
    _Hashtable_alloc(_Alloc &&__a)
        : __ebo_node_alloc(std::forward<_Alloc>(__a)) {}

    __node_alloc_type &_M_node_allocator() {
      return __ebo_node_alloc::_M_get();
    }

    const __node_alloc_type &_M_node_allocator() const {
      return __ebo_node_alloc::_M_cget();
    }

    template <typename... _Args> __node_ptr _M_allocate_node(_Args &&...__args);

    void _M_deallocate_node(__node_ptr __n);

    void _M_deallocate_node_ptr(__node_ptr __n);

    void _M_deallocate_nodes(__node_ptr __n);

    __buckets_ptr _M_allocate_buckets(std::size_t __bkt_count);

    void _M_deallocate_buckets(__buckets_ptr, std::size_t __bkt_count);
  };

  template <typename _NodeAlloc>
  template <typename... _Args>
  auto _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args &&...__args)
      -> __node_ptr {
    auto __nptr = __node_alloc_traits::allocate(_M_node_allocator(), 1);
    __node_ptr __n = std::__to_address(__nptr);
    try {
      ::new ((void *)__n) __node_type;
      __node_alloc_traits::construct(_M_node_allocator(), __n->_M_valptr(),
                                     std::forward<_Args>(__args)...);
      return __n;
    } catch (...) {
      __node_alloc_traits::deallocate(_M_node_allocator(), __nptr, 1);
      throw;
    }
  }

  template <typename _NodeAlloc>
  void _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_ptr __n) {
    __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
    _M_deallocate_node_ptr(__n);
  }

  template <typename _NodeAlloc>
  void _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_ptr __n) {
    typedef typename __node_alloc_traits::pointer _Ptr;
    auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
    __n->~__node_type();
    __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
  }

  template <typename _NodeAlloc>
  void _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n) {
    while (__n) {
      __node_ptr __tmp = __n;
      __n = __n->_M_next();
      _M_deallocate_node(__tmp);
    }
  }

  template <typename _NodeAlloc>
  auto _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(
      std::size_t __bkt_count) -> __buckets_ptr {
    __buckets_alloc_type __alloc(_M_node_allocator());

    auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
    __buckets_ptr __p = std::__to_address(__ptr);
    __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
    return __p;
  }

  template <typename _NodeAlloc>
  void
  _Hashtable_alloc<_NodeAlloc>::_M_deallocate_buckets(__buckets_ptr __bkts,
                                                      std::size_t __bkt_count) {
    typedef typename __buckets_alloc_traits::pointer _Ptr;
    auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
    __buckets_alloc_type __alloc(_M_node_allocator());
    __buckets_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
  }

  } // namespace __detail

} // namespace std
# 36 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hashtable.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/enable_special_members.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/enable_special_members.h" 3

namespace std __attribute__((__visibility__("default"))) {

  struct _Enable_default_constructor_tag {
    explicit constexpr _Enable_default_constructor_tag() = default;
  };

  template <bool _Switch, typename _Tag = void>
  struct _Enable_default_constructor {
    constexpr _Enable_default_constructor() noexcept = default;
    constexpr _Enable_default_constructor(
        _Enable_default_constructor const &) noexcept = default;
    constexpr _Enable_default_constructor(
        _Enable_default_constructor &&) noexcept = default;
    _Enable_default_constructor &
    operator=(_Enable_default_constructor const &) noexcept = default;
    _Enable_default_constructor &
    operator=(_Enable_default_constructor &&) noexcept = default;

    constexpr explicit _Enable_default_constructor(
        _Enable_default_constructor_tag) {}
  };

  template <bool _Switch, typename _Tag = void> struct _Enable_destructor {};

  template <bool _Copy, bool _CopyAssignment, bool _Move, bool _MoveAssignment,
            typename _Tag = void>
  struct _Enable_copy_move {};
# 96 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/enable_special_members.h" 3
  template <bool _Default, bool _Destructor, bool _Copy, bool _CopyAssignment,
            bool _Move, bool _MoveAssignment, typename _Tag = void>
  struct _Enable_special_members
      : private _Enable_default_constructor<_Default, _Tag>,
        private _Enable_destructor<_Destructor, _Tag>,
        private _Enable_copy_move<_Copy, _CopyAssignment, _Move,
                                  _MoveAssignment, _Tag> {};

  template <typename _Tag> struct _Enable_default_constructor<false, _Tag> {
    constexpr _Enable_default_constructor() noexcept = delete;
    constexpr _Enable_default_constructor(
        _Enable_default_constructor const &) noexcept = default;
    constexpr _Enable_default_constructor(
        _Enable_default_constructor &&) noexcept = default;
    _Enable_default_constructor &
    operator=(_Enable_default_constructor const &) noexcept = default;
    _Enable_default_constructor &
    operator=(_Enable_default_constructor &&) noexcept = default;

    constexpr explicit _Enable_default_constructor(
        _Enable_default_constructor_tag) {}
  };

  template <typename _Tag> struct _Enable_destructor<false, _Tag> {
    ~_Enable_destructor() noexcept = delete;
  };

  template <typename _Tag>
  struct _Enable_copy_move<false, true, true, true, _Tag> {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const &) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move &&) noexcept = default;
    _Enable_copy_move &operator=(_Enable_copy_move const &) noexcept = default;
    _Enable_copy_move &operator=(_Enable_copy_move &&) noexcept = default;
  };

  template <typename _Tag>
  struct _Enable_copy_move<true, false, true, true, _Tag> {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const &) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move &&) noexcept = default;
    _Enable_copy_move &operator=(_Enable_copy_move const &) noexcept = delete;
    _Enable_copy_move &operator=(_Enable_copy_move &&) noexcept = default;
  };

  template <typename _Tag>
  struct _Enable_copy_move<false, false, true, true, _Tag> {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const &) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move &&) noexcept = default;
    _Enable_copy_move &operator=(_Enable_copy_move const &) noexcept = delete;
    _Enable_copy_move &operator=(_Enable_copy_move &&) noexcept = default;
  };

  template <typename _Tag>
  struct _Enable_copy_move<true, true, false, true, _Tag> {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const &) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move &&) noexcept = delete;
    _Enable_copy_move &operator=(_Enable_copy_move const &) noexcept = default;
    _Enable_copy_move &operator=(_Enable_copy_move &&) noexcept = default;
  };

  template <typename _Tag>
  struct _Enable_copy_move<false, true, false, true, _Tag> {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const &) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move &&) noexcept = delete;
    _Enable_copy_move &operator=(_Enable_copy_move const &) noexcept = default;
    _Enable_copy_move &operator=(_Enable_copy_move &&) noexcept = default;
  };

  template <typename _Tag>
  struct _Enable_copy_move<true, false, false, true, _Tag> {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const &) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move &&) noexcept = delete;
    _Enable_copy_move &operator=(_Enable_copy_move const &) noexcept = delete;
    _Enable_copy_move &operator=(_Enable_copy_move &&) noexcept = default;
  };

  template <typename _Tag>
  struct _Enable_copy_move<false, false, false, true, _Tag> {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const &) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move &&) noexcept = delete;
    _Enable_copy_move &operator=(_Enable_copy_move const &) noexcept = delete;
    _Enable_copy_move &operator=(_Enable_copy_move &&) noexcept = default;
  };

  template <typename _Tag>
  struct _Enable_copy_move<true, true, true, false, _Tag> {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const &) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move &&) noexcept = default;
    _Enable_copy_move &operator=(_Enable_copy_move const &) noexcept = default;
    _Enable_copy_move &operator=(_Enable_copy_move &&) noexcept = delete;
  };

  template <typename _Tag>
  struct _Enable_copy_move<false, true, true, false, _Tag> {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const &) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move &&) noexcept = default;
    _Enable_copy_move &operator=(_Enable_copy_move const &) noexcept = default;
    _Enable_copy_move &operator=(_Enable_copy_move &&) noexcept = delete;
  };

  template <typename _Tag>
  struct _Enable_copy_move<true, false, true, false, _Tag> {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const &) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move &&) noexcept = default;
    _Enable_copy_move &operator=(_Enable_copy_move const &) noexcept = delete;
    _Enable_copy_move &operator=(_Enable_copy_move &&) noexcept = delete;
  };

  template <typename _Tag>
  struct _Enable_copy_move<false, false, true, false, _Tag> {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const &) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move &&) noexcept = default;
    _Enable_copy_move &operator=(_Enable_copy_move const &) noexcept = delete;
    _Enable_copy_move &operator=(_Enable_copy_move &&) noexcept = delete;
  };

  template <typename _Tag>
  struct _Enable_copy_move<true, true, false, false, _Tag> {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const &) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move &&) noexcept = delete;
    _Enable_copy_move &operator=(_Enable_copy_move const &) noexcept = default;
    _Enable_copy_move &operator=(_Enable_copy_move &&) noexcept = delete;
  };

  template <typename _Tag>
  struct _Enable_copy_move<false, true, false, false, _Tag> {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const &) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move &&) noexcept = delete;
    _Enable_copy_move &operator=(_Enable_copy_move const &) noexcept = default;
    _Enable_copy_move &operator=(_Enable_copy_move &&) noexcept = delete;
  };

  template <typename _Tag>
  struct _Enable_copy_move<true, false, false, false, _Tag> {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const &) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move &&) noexcept = delete;
    _Enable_copy_move &operator=(_Enable_copy_move const &) noexcept = delete;
    _Enable_copy_move &operator=(_Enable_copy_move &&) noexcept = delete;
  };

  template <typename _Tag>
  struct _Enable_copy_move<false, false, false, false, _Tag> {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const &) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move &&) noexcept = delete;
    _Enable_copy_move &operator=(_Enable_copy_move const &) noexcept = delete;
    _Enable_copy_move &operator=(_Enable_copy_move &&) noexcept = delete;
  };

} // namespace std
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hashtable.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/node_handle.h" 1 3
# 35 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/node_handle.h" 3

namespace std __attribute__((__visibility__("default"))) {
# 63 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/node_handle.h" 3
  template <typename _Val, typename _NodeAlloc> class _Node_handle_common {
    using _AllocTraits = allocator_traits<_NodeAlloc>;

  public:
    using allocator_type = __alloc_rebind<_NodeAlloc, _Val>;

    allocator_type get_allocator() const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(!this->empty()))
          __builtin_unreachable();
      } while (false);
      return allocator_type(_M_alloc._M_alloc);
    }

    explicit operator bool() const noexcept { return _M_ptr != nullptr; }

    [[nodiscard]] bool empty() const noexcept { return _M_ptr == nullptr; }

  protected:
    constexpr _Node_handle_common() noexcept : _M_ptr() {}

    ~_Node_handle_common() {
      if (!empty())
        _M_reset();
    }

    _Node_handle_common(_Node_handle_common &&__nh) noexcept
        : _M_ptr(__nh._M_ptr) {
      if (_M_ptr)
        _M_move(std::move(__nh));
    }

    _Node_handle_common &operator=(_Node_handle_common &&__nh) noexcept {
      if (empty()) {
        if (!__nh.empty())
          _M_move(std::move(__nh));
      } else if (__nh.empty())
        _M_reset();
      else {

        _AllocTraits::destroy(*_M_alloc, _M_ptr->_M_valptr());
        _AllocTraits::deallocate(*_M_alloc, _M_ptr, 1);

        _M_alloc = __nh._M_alloc.release();
        _M_ptr = __nh._M_ptr;
        __nh._M_ptr = nullptr;
      }
      return *this;
    }

    _Node_handle_common(typename _AllocTraits::pointer __ptr,
                        const _NodeAlloc &__alloc)
        : _M_ptr(__ptr), _M_alloc(__alloc) {
      do {
        if (std::__is_constant_evaluated() && !bool(__ptr != nullptr))
          __builtin_unreachable();
      } while (false);
    }

    void _M_swap(_Node_handle_common &__nh) noexcept {
      if (empty()) {
        if (!__nh.empty())
          _M_move(std::move(__nh));
      } else if (__nh.empty())
        __nh._M_move(std::move(*this));
      else {
        using std::swap;
        swap(_M_ptr, __nh._M_ptr);
        _M_alloc.swap(__nh._M_alloc);
      }
    }

  private:
    void _M_move(_Node_handle_common &&__nh) noexcept {
      ::new (std::__addressof(_M_alloc)) _NodeAlloc(__nh._M_alloc.release());
      _M_ptr = __nh._M_ptr;
      __nh._M_ptr = nullptr;
    }

    void _M_reset() noexcept {
      _NodeAlloc __alloc = _M_alloc.release();
      _AllocTraits::destroy(__alloc, _M_ptr->_M_valptr());
      _AllocTraits::deallocate(__alloc, _M_ptr, 1);
      _M_ptr = nullptr;
    }

    void release() noexcept {
      _M_alloc.release();
      _M_ptr = nullptr;
    }

  protected:
    typename _AllocTraits::pointer _M_ptr;

  private:
    union _Optional_alloc {
      _Optional_alloc() {}
      ~_Optional_alloc() {}

      _Optional_alloc(_Optional_alloc &&) = delete;
      _Optional_alloc &operator=(_Optional_alloc &&) = delete;

      _Optional_alloc(const _NodeAlloc &__alloc) noexcept : _M_alloc(__alloc) {}

      void operator=(_NodeAlloc &&__alloc) noexcept {
        using _ATr = _AllocTraits;
        if constexpr (_ATr::propagate_on_container_move_assignment::value)
          _M_alloc = std::move(__alloc);
        else if constexpr (!_AllocTraits::is_always_equal::value)
          do {
            if (std::__is_constant_evaluated() && !bool(_M_alloc == __alloc))
              __builtin_unreachable();
          } while (false);
      }

      void swap(_Optional_alloc &__other) noexcept {
        using std::swap;
        if constexpr (_AllocTraits::propagate_on_container_swap::value)
          swap(_M_alloc, __other._M_alloc);
        else if constexpr (!_AllocTraits::is_always_equal::value)
          do {
            if (std::__is_constant_evaluated() &&
                !bool(_M_alloc == __other._M_alloc))
              __builtin_unreachable();
          } while (false);
      }

      _NodeAlloc &operator*() noexcept { return _M_alloc; }

      _NodeAlloc release() noexcept {
        _NodeAlloc __tmp = std::move(_M_alloc);
        _M_alloc.~_NodeAlloc();
        return __tmp;
      }

      [[__no_unique_address__]] _NodeAlloc _M_alloc;
    };

    [[__no_unique_address__]] _Optional_alloc _M_alloc;

    template <typename _Key2, typename _Value2, typename _KeyOfValue,
              typename _Compare, typename _ValueAlloc>
    friend class _Rb_tree;

    template <typename _Key2, typename _Value2, typename _ValueAlloc,
              typename _ExtractKey, typename _Equal, typename _Hash,
              typename _RangeHash, typename _Unused, typename _RehashPolicy,
              typename _Traits>
    friend class _Hashtable;
  };

  template <typename _Key, typename _Value, typename _NodeAlloc>
  class _Node_handle : public _Node_handle_common<_Value, _NodeAlloc> {
  public:
    constexpr _Node_handle() noexcept = default;
    ~_Node_handle() = default;
    _Node_handle(_Node_handle &&) noexcept = default;

    _Node_handle &operator=(_Node_handle &&) noexcept = default;

    using key_type = _Key;
    using mapped_type = typename _Value::second_type;

    key_type &key() const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(!this->empty()))
          __builtin_unreachable();
      } while (false);
      return *_M_pkey;
    }

    mapped_type &mapped() const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(!this->empty()))
          __builtin_unreachable();
      } while (false);
      return *_M_pmapped;
    }

    void swap(_Node_handle &__nh) noexcept {
      this->_M_swap(__nh);
      using std::swap;
      swap(_M_pkey, __nh._M_pkey);
      swap(_M_pmapped, __nh._M_pmapped);
    }

    friend void swap(_Node_handle &__x,
                     _Node_handle &__y) noexcept(noexcept(__x.swap(__y))) {
      __x.swap(__y);
    }

  private:
    using _AllocTraits = allocator_traits<_NodeAlloc>;

    _Node_handle(typename _AllocTraits::pointer __ptr,
                 const _NodeAlloc &__alloc)
        : _Node_handle_common<_Value, _NodeAlloc>(__ptr, __alloc) {
      if (__ptr) {
        auto &__key = const_cast<_Key &>(__ptr->_M_valptr()->first);
        _M_pkey = _S_pointer_to(__key);
        _M_pmapped = _S_pointer_to(__ptr->_M_valptr()->second);
      } else {
        _M_pkey = nullptr;
        _M_pmapped = nullptr;
      }
    }

    template <typename _Tp>
    using __pointer =
        __ptr_rebind<typename _AllocTraits::pointer, remove_reference_t<_Tp>>;

    __pointer<_Key> _M_pkey = nullptr;
    __pointer<typename _Value::second_type> _M_pmapped = nullptr;

    template <typename _Tp> __pointer<_Tp> _S_pointer_to(_Tp &__obj) {
      return pointer_traits<__pointer<_Tp>>::pointer_to(__obj);
    }

    const key_type &_M_key() const noexcept { return key(); }

    template <typename _Key2, typename _Value2, typename _KeyOfValue,
              typename _Compare, typename _ValueAlloc>
    friend class _Rb_tree;

    template <typename _Key2, typename _Value2, typename _ValueAlloc,
              typename _ExtractKey, typename _Equal, typename _Hash,
              typename _RangeHash, typename _Unused, typename _RehashPolicy,
              typename _Traits>
    friend class _Hashtable;
  };

  template <typename _Value, typename _NodeAlloc>
  class _Node_handle<_Value, _Value, _NodeAlloc>
      : public _Node_handle_common<_Value, _NodeAlloc> {
  public:
    constexpr _Node_handle() noexcept = default;
    ~_Node_handle() = default;
    _Node_handle(_Node_handle &&) noexcept = default;

    _Node_handle &operator=(_Node_handle &&) noexcept = default;

    using value_type = _Value;

    value_type &value() const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(!this->empty()))
          __builtin_unreachable();
      } while (false);
      return *this->_M_ptr->_M_valptr();
    }

    void swap(_Node_handle &__nh) noexcept { this->_M_swap(__nh); }

    friend void swap(_Node_handle &__x,
                     _Node_handle &__y) noexcept(noexcept(__x.swap(__y))) {
      __x.swap(__y);
    }

  private:
    using _AllocTraits = allocator_traits<_NodeAlloc>;

    _Node_handle(typename _AllocTraits::pointer __ptr,
                 const _NodeAlloc &__alloc)
        : _Node_handle_common<_Value, _NodeAlloc>(__ptr, __alloc) {}

    const value_type &_M_key() const noexcept { return value(); }

    template <typename _Key, typename _Val, typename _KeyOfValue,
              typename _Compare, typename _Alloc>
    friend class _Rb_tree;

    template <typename _Key2, typename _Value2, typename _ValueAlloc,
              typename _ExtractKey, typename _Equal, typename _Hash,
              typename _RangeHash, typename _Unused, typename _RehashPolicy,
              typename _Traits>
    friend class _Hashtable;
  };

  template <typename _Iterator, typename _NodeHandle>
  struct _Node_insert_return {
    _Iterator position = _Iterator();
    bool inserted = false;
    _NodeHandle node;
  };

} // namespace std
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hashtable.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _Tp, typename _Hash>
  using __cache_default =
      __not_<__and_<__is_fast_hash<_Hash>,

                    __is_nothrow_invocable<const _Hash &, const _Tp &>>>;

  template <typename _Equal, typename _Hash, typename _Allocator>
  using _Hashtable_enable_default_ctor = _Enable_default_constructor<
      __and_<is_default_constructible<_Equal>, is_default_constructible<_Hash>,
             is_default_constructible<_Allocator>>{},
      __detail::_Hash_node_base>;
# 177 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/hashtable.h" 3
  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  class _Hashtable
      : public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,
                                         _Hash, _RangeHash, _Unused, _Traits>,
        public __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                                   _Hash, _RangeHash, _Unused, _RehashPolicy,
                                   _Traits>,
        public __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                                 _Hash, _RangeHash, _Unused, _RehashPolicy,
                                 _Traits>,
        public __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                                      _Hash, _RangeHash, _Unused, _RehashPolicy,
                                      _Traits>,
        public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                                   _Hash, _RangeHash, _Unused, _RehashPolicy,
                                   _Traits>,
        private __detail::_Hashtable_alloc<__alloc_rebind<
            _Alloc,
            __detail::_Hash_node<_Value, _Traits::__hash_cached::value>>>,
        private _Hashtable_enable_default_ctor<_Equal, _Hash, _Alloc> {
    static_assert(
        is_same<typename remove_cv<_Value>::type, _Value>::value,
        "unordered container must have a non-const, non-volatile value_type");

    static_assert(
        is_same<typename _Alloc::value_type, _Value>{},
        "unordered container must have the same value_type as its allocator");

    using __traits_type = _Traits;
    using __hash_cached = typename __traits_type::__hash_cached;
    using __constant_iterators = typename __traits_type::__constant_iterators;
    using __node_type = __detail::_Hash_node<_Value, __hash_cached::value>;
    using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;

    using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;

    using __node_value_type =
        __detail::_Hash_node_value<_Value, __hash_cached::value>;
    using __node_ptr = typename __hashtable_alloc::__node_ptr;
    using __value_alloc_traits =
        typename __hashtable_alloc::__value_alloc_traits;
    using __node_alloc_traits = typename __hashtable_alloc::__node_alloc_traits;
    using __node_base = typename __hashtable_alloc::__node_base;
    using __node_base_ptr = typename __hashtable_alloc::__node_base_ptr;
    using __buckets_ptr = typename __hashtable_alloc::__buckets_ptr;

    using __insert_base =
        __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash,
                          _RangeHash, _Unused, _RehashPolicy, _Traits>;
    using __enable_default_ctor =
        _Hashtable_enable_default_ctor<_Equal, _Hash, _Alloc>;

  public:
    typedef _Key key_type;
    typedef _Value value_type;
    typedef _Alloc allocator_type;
    typedef _Equal key_equal;

    typedef typename __value_alloc_traits::pointer pointer;
    typedef typename __value_alloc_traits::const_pointer const_pointer;
    typedef value_type &reference;
    typedef const value_type &const_reference;

    using iterator = typename __insert_base::iterator;

    using const_iterator = typename __insert_base::const_iterator;

    using local_iterator = __detail::_Local_iterator<
        key_type, _Value, _ExtractKey, _Hash, _RangeHash, _Unused,
        __constant_iterators::value, __hash_cached::value>;

    using const_local_iterator = __detail::_Local_const_iterator<
        key_type, _Value, _ExtractKey, _Hash, _RangeHash, _Unused,
        __constant_iterators::value, __hash_cached::value>;

  private:
    using __rehash_type = _RehashPolicy;
    using __rehash_state = typename __rehash_type::_State;

    using __unique_keys = typename __traits_type::__unique_keys;

    using __hashtable_base =
        __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _Hash,
                                  _RangeHash, _Unused, _Traits>;

    using __hash_code_base = typename __hashtable_base::__hash_code_base;
    using __hash_code = typename __hashtable_base::__hash_code;
    using __ireturn_type = typename __insert_base::__ireturn_type;

    using __map_base =
        __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash,
                            _RangeHash, _Unused, _RehashPolicy, _Traits>;

    using __rehash_base =
        __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash,
                               _RangeHash, _Unused, _RehashPolicy, _Traits>;

    using __eq_base =
        __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash,
                            _RangeHash, _Unused, _RehashPolicy, _Traits>;

    using __reuse_or_alloc_node_gen_t =
        __detail::_ReuseOrAllocNode<__node_alloc_type>;
    using __alloc_node_gen_t = __detail::_AllocNode<__node_alloc_type>;
    using __node_builder_t = __detail::_NodeBuilder<_ExtractKey>;

    struct _Scoped_node {

      _Scoped_node(__node_ptr __n, __hashtable_alloc *__h)
          : _M_h(__h), _M_node(__n) {}

      template <typename... _Args>
      _Scoped_node(__hashtable_alloc *__h, _Args &&...__args)
          : _M_h(__h),
            _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...)) {}

      ~_Scoped_node() {
        if (_M_node)
          _M_h->_M_deallocate_node(_M_node);
      };

      _Scoped_node(const _Scoped_node &) = delete;
      _Scoped_node &operator=(const _Scoped_node &) = delete;

      __hashtable_alloc *_M_h;
      __node_ptr _M_node;
    };

    template <typename _Ht>
    static constexpr __conditional_t<std::is_lvalue_reference<_Ht>::value,
                                     const value_type &, value_type &&>
    __fwd_value_for(value_type &__val) noexcept {
      return std::move(__val);
    }

    struct __hash_code_base_access : __hash_code_base {
      using __hash_code_base::_M_bucket_index;
    };

    static_assert(is_nothrow_default_constructible<_RangeHash>::value,
                  "Functor used to map hash code to bucket index"
                  " must be nothrow default constructible");
    static_assert(noexcept(std::declval<const _RangeHash &>()((std::size_t)0,
                                                              (std::size_t)0)),
                  "Functor used to map hash code to bucket index must be"
                  " noexcept");

    static_assert(is_nothrow_default_constructible<_ExtractKey>::value,
                  "_ExtractKey must be nothrow default constructible");
    static_assert(
        noexcept(std::declval<const _ExtractKey &>()(std::declval<_Value>())),
        "_ExtractKey functor must be noexcept invocable");

    template <typename _Keya, typename _Valuea, typename _Alloca,
              typename _ExtractKeya, typename _Equala, typename _Hasha,
              typename _RangeHasha, typename _Unuseda, typename _RehashPolicya,
              typename _Traitsa, bool _Unique_keysa>
    friend struct __detail::_Map_base;

    template <typename _Keya, typename _Valuea, typename _Alloca,
              typename _ExtractKeya, typename _Equala, typename _Hasha,
              typename _RangeHasha, typename _Unuseda, typename _RehashPolicya,
              typename _Traitsa>
    friend struct __detail::_Insert_base;

    template <typename _Keya, typename _Valuea, typename _Alloca,
              typename _ExtractKeya, typename _Equala, typename _Hasha,
              typename _RangeHasha, typename _Unuseda, typename _RehashPolicya,
              typename _Traitsa, bool _Constant_iteratorsa>
    friend struct __detail::_Insert;

    template <typename _Keya, typename _Valuea, typename _Alloca,
              typename _ExtractKeya, typename _Equala, typename _Hasha,
              typename _RangeHasha, typename _Unuseda, typename _RehashPolicya,
              typename _Traitsa, bool _Unique_keysa>
    friend struct __detail::_Equality;

  public:
    using size_type = typename __hashtable_base::size_type;
    using difference_type = typename __hashtable_base::difference_type;

    using node_type = _Node_handle<_Key, _Value, __node_alloc_type>;
    using insert_return_type = _Node_insert_return<iterator, node_type>;

  private:
    __buckets_ptr _M_buckets = &_M_single_bucket;
    size_type _M_bucket_count = 1;
    __node_base _M_before_begin;
    size_type _M_element_count = 0;
    _RehashPolicy _M_rehash_policy;

    __node_base_ptr _M_single_bucket = nullptr;

    void _M_update_bbegin() {
      if (_M_begin())
        _M_buckets[_M_bucket_index(*_M_begin())] = &_M_before_begin;
    }

    void _M_update_bbegin(__node_ptr __n) {
      _M_before_begin._M_nxt = __n;
      _M_update_bbegin();
    }

    bool _M_uses_single_bucket(__buckets_ptr __bkts) const {
      return __builtin_expect(__bkts == &_M_single_bucket, false);
    }

    bool _M_uses_single_bucket() const {
      return _M_uses_single_bucket(_M_buckets);
    }

    static constexpr size_t __small_size_threshold() noexcept {
      return __detail::_Hashtable_hash_traits<_Hash>::__small_size_threshold();
    }

    __hashtable_alloc &_M_base_alloc() { return *this; }

    __buckets_ptr _M_allocate_buckets(size_type __bkt_count) {
      if (__builtin_expect(__bkt_count == 1, false)) {
        _M_single_bucket = nullptr;
        return &_M_single_bucket;
      }

      return __hashtable_alloc::_M_allocate_buckets(__bkt_count);
    }

    void _M_deallocate_buckets(__buckets_ptr __bkts, size_type __bkt_count) {
      if (_M_uses_single_bucket(__bkts))
        return;

      __hashtable_alloc::_M_deallocate_buckets(__bkts, __bkt_count);
    }

    void _M_deallocate_buckets() {
      _M_deallocate_buckets(_M_buckets, _M_bucket_count);
    }

    __node_ptr _M_bucket_begin(size_type __bkt) const;

    __node_ptr _M_begin() const {
      return static_cast<__node_ptr>(_M_before_begin._M_nxt);
    }

    template <typename _Ht> void _M_assign_elements(_Ht &&);

    template <typename _Ht, typename _NodeGenerator>
    void _M_assign(_Ht &&, const _NodeGenerator &);

    void _M_move_assign(_Hashtable &&, true_type);

    void _M_move_assign(_Hashtable &&, false_type);

    void _M_reset() noexcept;

    _Hashtable(const _Hash &__h, const _Equal &__eq, const allocator_type &__a)
        : __hashtable_base(__h, __eq),
          __hashtable_alloc(__node_alloc_type(__a)),
          __enable_default_ctor(_Enable_default_constructor_tag{}) {}

    template <bool _No_realloc = true> static constexpr bool _S_nothrow_move() {

      if constexpr (_No_realloc)
        if constexpr (is_nothrow_copy_constructible<_Hash>())
          return is_nothrow_copy_constructible<_Equal>();
      return false;
    }

    _Hashtable(_Hashtable &&__ht, __node_alloc_type &&__a,
               true_type) noexcept(_S_nothrow_move());

    _Hashtable(_Hashtable &&, __node_alloc_type &&, false_type);

    template <typename _InputIterator>
    _Hashtable(_InputIterator __first, _InputIterator __last,
               size_type __bkt_count_hint, const _Hash &, const _Equal &,
               const allocator_type &, true_type __uks);

    template <typename _InputIterator>
    _Hashtable(_InputIterator __first, _InputIterator __last,
               size_type __bkt_count_hint, const _Hash &, const _Equal &,
               const allocator_type &, false_type __uks);

  public:
    _Hashtable() = default;

    _Hashtable(const _Hashtable &);

    _Hashtable(const _Hashtable &, const allocator_type &);

    explicit _Hashtable(size_type __bkt_count_hint, const _Hash &__hf = _Hash(),
                        const key_equal &__eql = key_equal(),
                        const allocator_type &__a = allocator_type());

    _Hashtable(_Hashtable &&__ht) noexcept(_S_nothrow_move())
        : _Hashtable(std::move(__ht), std::move(__ht._M_node_allocator()),
                     true_type{}) {}

    _Hashtable(_Hashtable &&__ht, const allocator_type &__a) noexcept(
        _S_nothrow_move<__node_alloc_traits::_S_always_equal()>())
        : _Hashtable(std::move(__ht), __node_alloc_type(__a),
                     typename __node_alloc_traits::is_always_equal{}) {}

    explicit _Hashtable(const allocator_type &__a)
        : __hashtable_alloc(__node_alloc_type(__a)),
          __enable_default_ctor(_Enable_default_constructor_tag{}) {}

    template <typename _InputIterator>
    _Hashtable(_InputIterator __f, _InputIterator __l,
               size_type __bkt_count_hint = 0, const _Hash &__hf = _Hash(),
               const key_equal &__eql = key_equal(),
               const allocator_type &__a = allocator_type())
        : _Hashtable(__f, __l, __bkt_count_hint, __hf, __eql, __a,
                     __unique_keys{}) {}

    _Hashtable(initializer_list<value_type> __l, size_type __bkt_count_hint = 0,
               const _Hash &__hf = _Hash(),
               const key_equal &__eql = key_equal(),
               const allocator_type &__a = allocator_type())
        : _Hashtable(__l.begin(), __l.end(), __bkt_count_hint, __hf, __eql, __a,
                     __unique_keys{}) {}

    _Hashtable &operator=(const _Hashtable &__ht);

    _Hashtable &operator=(_Hashtable &&__ht) noexcept(
        __node_alloc_traits::_S_nothrow_move() &&
        is_nothrow_move_assignable<_Hash>::value &&
        is_nothrow_move_assignable<_Equal>::value) {
      constexpr bool __move_storage =
          __node_alloc_traits::_S_propagate_on_move_assign() ||
          __node_alloc_traits::_S_always_equal();
      _M_move_assign(std::move(__ht), __bool_constant<__move_storage>());
      return *this;
    }

    _Hashtable &operator=(initializer_list<value_type> __l) {
      __reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);
      _M_before_begin._M_nxt = nullptr;
      clear();

      auto __l_bkt_count = _M_rehash_policy._M_bkt_for_elements(__l.size());

      if (_M_bucket_count < __l_bkt_count)
        rehash(__l_bkt_count);

      this->_M_insert_range(__l.begin(), __l.end(), __roan, __unique_keys{});
      return *this;
    }

    ~_Hashtable() noexcept;

    void
    swap(_Hashtable &) noexcept(__and_<__is_nothrow_swappable<_Hash>,
                                       __is_nothrow_swappable<_Equal>>::value);

    iterator begin() noexcept { return iterator(_M_begin()); }

    const_iterator begin() const noexcept { return const_iterator(_M_begin()); }

    iterator end() noexcept { return iterator(nullptr); }

    const_iterator end() const noexcept { return const_iterator(nullptr); }

    const_iterator cbegin() const noexcept {
      return const_iterator(_M_begin());
    }

    const_iterator cend() const noexcept { return const_iterator(nullptr); }

    size_type size() const noexcept { return _M_element_count; }

    [[__nodiscard__]] bool empty() const noexcept { return size() == 0; }

    allocator_type get_allocator() const noexcept {
      return allocator_type(this->_M_node_allocator());
    }

    size_type max_size() const noexcept {
      return __node_alloc_traits::max_size(this->_M_node_allocator());
    }

    key_equal key_eq() const { return this->_M_eq(); }

    size_type bucket_count() const noexcept { return _M_bucket_count; }

    size_type max_bucket_count() const noexcept { return max_size(); }

    size_type bucket_size(size_type __bkt) const {
      return std::distance(begin(__bkt), end(__bkt));
    }

    size_type bucket(const key_type &__k) const {
      return _M_bucket_index(this->_M_hash_code(__k));
    }

    local_iterator begin(size_type __bkt) {
      return local_iterator(*this, _M_bucket_begin(__bkt), __bkt,
                            _M_bucket_count);
    }

    local_iterator end(size_type __bkt) {
      return local_iterator(*this, nullptr, __bkt, _M_bucket_count);
    }

    const_local_iterator begin(size_type __bkt) const {
      return const_local_iterator(*this, _M_bucket_begin(__bkt), __bkt,
                                  _M_bucket_count);
    }

    const_local_iterator end(size_type __bkt) const {
      return const_local_iterator(*this, nullptr, __bkt, _M_bucket_count);
    }

    const_local_iterator cbegin(size_type __bkt) const {
      return const_local_iterator(*this, _M_bucket_begin(__bkt), __bkt,
                                  _M_bucket_count);
    }

    const_local_iterator cend(size_type __bkt) const {
      return const_local_iterator(*this, nullptr, __bkt, _M_bucket_count);
    }

    float load_factor() const noexcept {
      return static_cast<float>(size()) / static_cast<float>(bucket_count());
    }

    const _RehashPolicy &__rehash_policy() const { return _M_rehash_policy; }

    void __rehash_policy(const _RehashPolicy &__pol) {
      _M_rehash_policy = __pol;
    }

    iterator find(const key_type &__k);

    const_iterator find(const key_type &__k) const;

    size_type count(const key_type &__k) const;

    std::pair<iterator, iterator> equal_range(const key_type &__k);

    std::pair<const_iterator, const_iterator>
    equal_range(const key_type &__k) const;

    template <typename _Kt, typename = __has_is_transparent_t<_Hash, _Kt>,
              typename = __has_is_transparent_t<_Equal, _Kt>>
    iterator _M_find_tr(const _Kt &__k);

    template <typename _Kt, typename = __has_is_transparent_t<_Hash, _Kt>,
              typename = __has_is_transparent_t<_Equal, _Kt>>
    const_iterator _M_find_tr(const _Kt &__k) const;

    template <typename _Kt, typename = __has_is_transparent_t<_Hash, _Kt>,
              typename = __has_is_transparent_t<_Equal, _Kt>>
    size_type _M_count_tr(const _Kt &__k) const;

    template <typename _Kt, typename = __has_is_transparent_t<_Hash, _Kt>,
              typename = __has_is_transparent_t<_Equal, _Kt>>
    pair<iterator, iterator> _M_equal_range_tr(const _Kt &__k);

    template <typename _Kt, typename = __has_is_transparent_t<_Hash, _Kt>,
              typename = __has_is_transparent_t<_Equal, _Kt>>
    pair<const_iterator, const_iterator>
    _M_equal_range_tr(const _Kt &__k) const;

  private:
    size_type _M_bucket_index(const __node_value_type &__n) const noexcept {
      return __hash_code_base::_M_bucket_index(__n, _M_bucket_count);
    }

    size_type _M_bucket_index(__hash_code __c) const {
      return __hash_code_base::_M_bucket_index(__c, _M_bucket_count);
    }

    __node_base_ptr _M_find_before_node(const key_type &);

    __node_base_ptr _M_find_before_node(size_type, const key_type &,
                                        __hash_code) const;

    template <typename _Kt>
    __node_base_ptr _M_find_before_node_tr(size_type, const _Kt &,
                                           __hash_code) const;

    __node_ptr _M_find_node(size_type __bkt, const key_type &__key,
                            __hash_code __c) const {
      __node_base_ptr __before_n = _M_find_before_node(__bkt, __key, __c);
      if (__before_n)
        return static_cast<__node_ptr>(__before_n->_M_nxt);
      return nullptr;
    }

    template <typename _Kt>
    __node_ptr _M_find_node_tr(size_type __bkt, const _Kt &__key,
                               __hash_code __c) const {
      auto __before_n = _M_find_before_node_tr(__bkt, __key, __c);
      if (__before_n)
        return static_cast<__node_ptr>(__before_n->_M_nxt);
      return nullptr;
    }

    void _M_insert_bucket_begin(size_type, __node_ptr);

    void _M_remove_bucket_begin(size_type __bkt, __node_ptr __next_n,
                                size_type __next_bkt);

    __node_base_ptr _M_get_previous_node(size_type __bkt, __node_ptr __n);

    pair<const_iterator, __hash_code>
    _M_compute_hash_code(const_iterator __hint, const key_type &__k) const;

    iterator _M_insert_unique_node(size_type __bkt, __hash_code, __node_ptr __n,
                                   size_type __n_elt = 1);

    iterator _M_insert_multi_node(__node_ptr __hint, __hash_code __code,
                                  __node_ptr __n);

    template <typename... _Args>
    std::pair<iterator, bool> _M_emplace(true_type __uks, _Args &&...__args);

    template <typename... _Args>
    iterator _M_emplace(false_type __uks, _Args &&...__args) {
      return _M_emplace(cend(), __uks, std::forward<_Args>(__args)...);
    }

    template <typename... _Args>
    iterator _M_emplace(const_iterator, true_type __uks, _Args &&...__args) {
      return _M_emplace(__uks, std::forward<_Args>(__args)...).first;
    }

    template <typename... _Args>
    iterator _M_emplace(const_iterator, false_type __uks, _Args &&...__args);

    template <typename _Kt, typename _Arg, typename _NodeGenerator>
    std::pair<iterator, bool> _M_insert_unique(_Kt &&, _Arg &&,
                                               const _NodeGenerator &);

    template <typename _Kt>
    static __conditional_t<
        __and_<__is_nothrow_invocable<_Hash &, const key_type &>,
               __not_<__is_nothrow_invocable<_Hash &, _Kt>>>::value,
        key_type, _Kt &&>
    _S_forward_key(_Kt &&__k) {
      return std::forward<_Kt>(__k);
    }

    static const key_type &_S_forward_key(const key_type &__k) { return __k; }

    static key_type &&_S_forward_key(key_type &&__k) { return std::move(__k); }

    template <typename _Arg, typename _NodeGenerator>
    std::pair<iterator, bool>
    _M_insert_unique_aux(_Arg &&__arg, const _NodeGenerator &__node_gen) {
      return _M_insert_unique(
          _S_forward_key(_ExtractKey{}(std::forward<_Arg>(__arg))),
          std::forward<_Arg>(__arg), __node_gen);
    }

    template <typename _Arg, typename _NodeGenerator>
    std::pair<iterator, bool>
    _M_insert(_Arg &&__arg, const _NodeGenerator &__node_gen, true_type) {
      using __to_value = __detail::_ConvertToValueType<_ExtractKey, value_type>;
      return _M_insert_unique_aux(__to_value{}(std::forward<_Arg>(__arg)),
                                  __node_gen);
    }

    template <typename _Arg, typename _NodeGenerator>
    iterator _M_insert(_Arg &&__arg, const _NodeGenerator &__node_gen,
                       false_type __uks) {
      using __to_value = __detail::_ConvertToValueType<_ExtractKey, value_type>;
      return _M_insert(cend(), __to_value{}(std::forward<_Arg>(__arg)),
                       __node_gen, __uks);
    }

    template <typename _Arg, typename _NodeGenerator>
    iterator _M_insert(const_iterator, _Arg &&__arg,
                       const _NodeGenerator &__node_gen, true_type __uks) {
      return _M_insert(std::forward<_Arg>(__arg), __node_gen, __uks).first;
    }

    template <typename _Arg, typename _NodeGenerator>
    iterator _M_insert(const_iterator, _Arg &&, const _NodeGenerator &,
                       false_type __uks);

    size_type _M_erase(true_type __uks, const key_type &);

    size_type _M_erase(false_type __uks, const key_type &);

    iterator _M_erase(size_type __bkt, __node_base_ptr __prev_n,
                      __node_ptr __n);

  public:
    template <typename... _Args> __ireturn_type emplace(_Args &&...__args) {
      return _M_emplace(__unique_keys{}, std::forward<_Args>(__args)...);
    }

    template <typename... _Args>
    iterator emplace_hint(const_iterator __hint, _Args &&...__args) {
      return _M_emplace(__hint, __unique_keys{},
                        std::forward<_Args>(__args)...);
    }

    iterator erase(const_iterator);

    iterator erase(iterator __it) { return erase(const_iterator(__it)); }

    size_type erase(const key_type &__k) {
      return _M_erase(__unique_keys{}, __k);
    }

    iterator erase(const_iterator, const_iterator);

    void clear() noexcept;

    void rehash(size_type __bkt_count);

    insert_return_type _M_reinsert_node(node_type &&__nh) {
      insert_return_type __ret;
      if (__nh.empty())
        __ret.position = end();
      else {
        do {
          if (std::__is_constant_evaluated() &&
              !bool(get_allocator() == __nh.get_allocator()))
            __builtin_unreachable();
        } while (false);

        const key_type &__k = __nh._M_key();
        __hash_code __code = this->_M_hash_code(__k);
        size_type __bkt = _M_bucket_index(__code);
        if (__node_ptr __n = _M_find_node(__bkt, __k, __code)) {
          __ret.node = std::move(__nh);
          __ret.position = iterator(__n);
          __ret.inserted = false;
        } else {
          __ret.position = _M_insert_unique_node(__bkt, __code, __nh._M_ptr);
          __nh.release();
          __ret.inserted = true;
        }
      }
      return __ret;
    }

    iterator _M_reinsert_node_multi(const_iterator __hint, node_type &&__nh) {
      if (__nh.empty())
        return end();

      do {
        if (std::__is_constant_evaluated() &&
            !bool(get_allocator() == __nh.get_allocator()))
          __builtin_unreachable();
      } while (false);

      const key_type &__k = __nh._M_key();
      auto __code = this->_M_hash_code(__k);
      auto __ret = _M_insert_multi_node(__hint._M_cur, __code, __nh._M_ptr);
      __nh.release();
      return __ret;
    }

  private:
    node_type _M_extract_node(size_t __bkt, __node_base_ptr __prev_n) {
      __node_ptr __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
      if (__prev_n == _M_buckets[__bkt])
        _M_remove_bucket_begin(__bkt, __n->_M_next(),
                               __n->_M_nxt ? _M_bucket_index(*__n->_M_next())
                                           : 0);
      else if (__n->_M_nxt) {
        size_type __next_bkt = _M_bucket_index(*__n->_M_next());
        if (__next_bkt != __bkt)
          _M_buckets[__next_bkt] = __prev_n;
      }

      __prev_n->_M_nxt = __n->_M_nxt;
      __n->_M_nxt = nullptr;
      --_M_element_count;
      return {__n, this->_M_node_allocator()};
    }

    template <typename _H2>
    __hash_code _M_src_hash_code(const _H2 &, const key_type &__k,
                                 const __node_value_type &__src_n) const {
      if constexpr (std::is_same_v<_H2, _Hash>)
        if constexpr (std::is_empty_v<_Hash>)
          return this->_M_hash_code(__src_n);

      return this->_M_hash_code(__k);
    }

  public:
    node_type extract(const_iterator __pos) {
      size_t __bkt = _M_bucket_index(*__pos._M_cur);
      return _M_extract_node(__bkt, _M_get_previous_node(__bkt, __pos._M_cur));
    }

    node_type extract(const _Key &__k) {
      node_type __nh;
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__code);
      if (__node_base_ptr __prev_node = _M_find_before_node(__bkt, __k, __code))
        __nh = _M_extract_node(__bkt, __prev_node);
      return __nh;
    }

    template <typename _Compatible_Hashtable>
    void _M_merge_unique(_Compatible_Hashtable &__src) {
      static_assert(
          is_same_v<typename _Compatible_Hashtable::node_type, node_type>,
          "Node types are compatible");
      do {
        if (std::__is_constant_evaluated() &&
            !bool(get_allocator() == __src.get_allocator()))
          __builtin_unreachable();
      } while (false);

      auto __n_elt = __src.size();
      for (auto __i = __src.cbegin(), __end = __src.cend(); __i != __end;) {
        auto __pos = __i++;
        const key_type &__k = _ExtractKey{}(*__pos);
        __hash_code __code =
            _M_src_hash_code(__src.hash_function(), __k, *__pos._M_cur);
        size_type __bkt = _M_bucket_index(__code);
        if (_M_find_node(__bkt, __k, __code) == nullptr) {
          auto __nh = __src.extract(__pos);
          _M_insert_unique_node(__bkt, __code, __nh._M_ptr, __n_elt);
          __nh.release();
          __n_elt = 1;
        } else if (__n_elt != 1)
          --__n_elt;
      }
    }

    template <typename _Compatible_Hashtable>
    void _M_merge_multi(_Compatible_Hashtable &__src) {
      static_assert(
          is_same_v<typename _Compatible_Hashtable::node_type, node_type>,
          "Node types are compatible");
      do {
        if (std::__is_constant_evaluated() &&
            !bool(get_allocator() == __src.get_allocator()))
          __builtin_unreachable();
      } while (false);

      __node_ptr __hint = nullptr;
      this->reserve(size() + __src.size());
      for (auto __i = __src.cbegin(), __end = __src.cend(); __i != __end;) {
        auto __pos = __i++;
        const key_type &__k = _ExtractKey{}(*__pos);
        __hash_code __code =
            _M_src_hash_code(__src.hash_function(), __k, *__pos._M_cur);
        auto __nh = __src.extract(__pos);
        __hint = _M_insert_multi_node(__hint, __code, __nh._M_ptr)._M_cur;
        __nh.release();
      }
    }

  private:
    void _M_rehash_aux(size_type __bkt_count, true_type __uks);

    void _M_rehash_aux(size_type __bkt_count, false_type __uks);

    void _M_rehash(size_type __bkt_count, const __rehash_state &__state);
  };

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto
  _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
             _Unused, _RehashPolicy, _Traits>::_M_bucket_begin(size_type __bkt)
      const -> __node_ptr {
    __node_base_ptr __n = _M_buckets[__bkt];
    return __n ? static_cast<__node_ptr>(__n->_M_nxt) : nullptr;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
             _Unused, _RehashPolicy,
             _Traits>::_Hashtable(size_type __bkt_count_hint, const _Hash &__h,
                                  const _Equal &__eq, const allocator_type &__a)
      : _Hashtable(__h, __eq, __a) {
    auto __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count_hint);
    if (__bkt_count > _M_bucket_count) {
      _M_buckets = _M_allocate_buckets(__bkt_count);
      _M_bucket_count = __bkt_count;
    }
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  template <typename _InputIterator>
  _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
             _Unused, _RehashPolicy,
             _Traits>::_Hashtable(_InputIterator __f, _InputIterator __l,
                                  size_type __bkt_count_hint, const _Hash &__h,
                                  const _Equal &__eq, const allocator_type &__a,
                                  true_type)
      : _Hashtable(__bkt_count_hint, __h, __eq, __a) {
    this->insert(__f, __l);
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  template <typename _InputIterator>
  _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
             _Unused, _RehashPolicy,
             _Traits>::_Hashtable(_InputIterator __f, _InputIterator __l,
                                  size_type __bkt_count_hint, const _Hash &__h,
                                  const _Equal &__eq, const allocator_type &__a,
                                  false_type __uks)
      : _Hashtable(__h, __eq, __a) {
    auto __nb_elems = __detail::__distance_fw(__f, __l);
    auto __bkt_count = _M_rehash_policy._M_next_bkt(std::max(
        _M_rehash_policy._M_bkt_for_elements(__nb_elems), __bkt_count_hint));

    if (__bkt_count > _M_bucket_count) {
      _M_buckets = _M_allocate_buckets(__bkt_count);
      _M_bucket_count = __bkt_count;
    }

    __alloc_node_gen_t __node_gen(*this);
    for (; __f != __l; ++__f)
      _M_insert(*__f, __node_gen, __uks);
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::operator=(const _Hashtable &__ht) -> _Hashtable & {
    if (&__ht == this)
      return *this;

    if (__node_alloc_traits::_S_propagate_on_copy_assign()) {
      auto &__this_alloc = this->_M_node_allocator();
      auto &__that_alloc = __ht._M_node_allocator();
      if (!__node_alloc_traits::_S_always_equal() &&
          __this_alloc != __that_alloc) {

        this->_M_deallocate_nodes(_M_begin());
        _M_before_begin._M_nxt = nullptr;
        _M_deallocate_buckets();
        _M_buckets = nullptr;
        std::__alloc_on_copy(__this_alloc, __that_alloc);
        __hashtable_base::operator=(__ht);
        _M_bucket_count = __ht._M_bucket_count;
        _M_element_count = __ht._M_element_count;
        _M_rehash_policy = __ht._M_rehash_policy;
        __alloc_node_gen_t __alloc_node_gen(*this);
        try {
          _M_assign(__ht, __alloc_node_gen);
        } catch (...) {

          _M_reset();
          throw;
        }
        return *this;
      }
      std::__alloc_on_copy(__this_alloc, __that_alloc);
    }

    _M_assign_elements(__ht);
    return *this;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  template <typename _Ht>
  void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy, _Traits>::_M_assign_elements(_Ht &&
                                                                       __ht) {
    __buckets_ptr __former_buckets = nullptr;
    std::size_t __former_bucket_count = _M_bucket_count;
    const __rehash_state &__former_state = _M_rehash_policy._M_state();

    if (_M_bucket_count != __ht._M_bucket_count) {
      __former_buckets = _M_buckets;
      _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);
      _M_bucket_count = __ht._M_bucket_count;
    } else
      __builtin_memset(_M_buckets, 0,
                       _M_bucket_count * sizeof(__node_base_ptr));

    try {
      __hashtable_base::operator=(std::forward<_Ht>(__ht));
      _M_element_count = __ht._M_element_count;
      _M_rehash_policy = __ht._M_rehash_policy;
      __reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);
      _M_before_begin._M_nxt = nullptr;
      _M_assign(std::forward<_Ht>(__ht), __roan);
      if (__former_buckets)
        _M_deallocate_buckets(__former_buckets, __former_bucket_count);
    } catch (...) {
      if (__former_buckets) {

        _M_deallocate_buckets();
        _M_rehash_policy._M_reset(__former_state);
        _M_buckets = __former_buckets;
        _M_bucket_count = __former_bucket_count;
      }
      __builtin_memset(_M_buckets, 0,
                       _M_bucket_count * sizeof(__node_base_ptr));
      throw;
    }
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  template <typename _Ht, typename _NodeGenerator>
  void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_assign(_Ht && __ht,
                                      const _NodeGenerator &__node_gen) {
    __buckets_ptr __buckets = nullptr;
    if (!_M_buckets)
      _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);

    try {
      if (!__ht._M_before_begin._M_nxt)
        return;

      __node_ptr __ht_n = __ht._M_begin();
      __node_ptr __this_n = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));
      this->_M_copy_code(*__this_n, *__ht_n);
      _M_update_bbegin(__this_n);

      __node_ptr __prev_n = __this_n;
      for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next()) {
        __this_n = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));
        __prev_n->_M_nxt = __this_n;
        this->_M_copy_code(*__this_n, *__ht_n);
        size_type __bkt = _M_bucket_index(*__this_n);
        if (!_M_buckets[__bkt])
          _M_buckets[__bkt] = __prev_n;
        __prev_n = __this_n;
      }
    } catch (...) {
      clear();
      if (__buckets)
        _M_deallocate_buckets();
      throw;
    }
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy, _Traits>::_M_reset() noexcept {
    _M_rehash_policy._M_reset();
    _M_bucket_count = 1;
    _M_single_bucket = nullptr;
    _M_buckets = &_M_single_bucket;
    _M_before_begin._M_nxt = nullptr;
    _M_element_count = 0;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy, _Traits>::_M_move_assign(_Hashtable &&
                                                                       __ht,
                                                                   true_type) {
    if (__builtin_expect(std::__addressof(__ht) == this, false))
      return;

    this->_M_deallocate_nodes(_M_begin());
    _M_deallocate_buckets();
    __hashtable_base::operator=(std::move(__ht));
    _M_rehash_policy = __ht._M_rehash_policy;
    if (!__ht._M_uses_single_bucket())
      _M_buckets = __ht._M_buckets;
    else {
      _M_buckets = &_M_single_bucket;
      _M_single_bucket = __ht._M_single_bucket;
    }

    _M_bucket_count = __ht._M_bucket_count;
    _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;
    _M_element_count = __ht._M_element_count;
    std::__alloc_on_move(this->_M_node_allocator(), __ht._M_node_allocator());

    _M_update_bbegin();
    __ht._M_reset();
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy, _Traits>::_M_move_assign(_Hashtable &&
                                                                       __ht,
                                                                   false_type) {
    if (__ht._M_node_allocator() == this->_M_node_allocator())
      _M_move_assign(std::move(__ht), true_type{});
    else {

      _M_assign_elements(std::move(__ht));
      __ht.clear();
    }
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
             _Unused, _RehashPolicy, _Traits>::_Hashtable(const _Hashtable
                                                              &__ht)
      : __hashtable_base(__ht), __map_base(__ht), __rehash_base(__ht),
        __hashtable_alloc(
            __node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())),
        __enable_default_ctor(__ht), _M_buckets(nullptr),
        _M_bucket_count(__ht._M_bucket_count),
        _M_element_count(__ht._M_element_count),
        _M_rehash_policy(__ht._M_rehash_policy) {
    __alloc_node_gen_t __alloc_node_gen(*this);
    _M_assign(__ht, __alloc_node_gen);
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
             _Unused, _RehashPolicy,
             _Traits>::_Hashtable(_Hashtable && __ht, __node_alloc_type && __a,
                                  true_type) noexcept(_S_nothrow_move())
      : __hashtable_base(__ht), __map_base(__ht), __rehash_base(__ht),
        __hashtable_alloc(std::move(__a)), __enable_default_ctor(__ht),
        _M_buckets(__ht._M_buckets), _M_bucket_count(__ht._M_bucket_count),
        _M_before_begin(__ht._M_before_begin._M_nxt),
        _M_element_count(__ht._M_element_count),
        _M_rehash_policy(__ht._M_rehash_policy) {

    if (__ht._M_uses_single_bucket()) {
      _M_buckets = &_M_single_bucket;
      _M_single_bucket = __ht._M_single_bucket;
    }

    _M_update_bbegin();

    __ht._M_reset();
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
             _Unused, _RehashPolicy,
             _Traits>::_Hashtable(const _Hashtable &__ht,
                                  const allocator_type &__a)
      : __hashtable_base(__ht), __map_base(__ht), __rehash_base(__ht),
        __hashtable_alloc(__node_alloc_type(__a)), __enable_default_ctor(__ht),
        _M_buckets(), _M_bucket_count(__ht._M_bucket_count),
        _M_element_count(__ht._M_element_count),
        _M_rehash_policy(__ht._M_rehash_policy) {
    __alloc_node_gen_t __alloc_node_gen(*this);
    _M_assign(__ht, __alloc_node_gen);
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
             _Unused, _RehashPolicy, _Traits>::_Hashtable(_Hashtable && __ht,
                                                          __node_alloc_type &&
                                                              __a,
                                                          false_type)
      : __hashtable_base(__ht), __map_base(__ht), __rehash_base(__ht),
        __hashtable_alloc(std::move(__a)), __enable_default_ctor(__ht),
        _M_buckets(nullptr), _M_bucket_count(__ht._M_bucket_count),
        _M_element_count(__ht._M_element_count),
        _M_rehash_policy(__ht._M_rehash_policy) {
    if (__ht._M_node_allocator() == this->_M_node_allocator()) {
      if (__ht._M_uses_single_bucket()) {
        _M_buckets = &_M_single_bucket;
        _M_single_bucket = __ht._M_single_bucket;
      } else
        _M_buckets = __ht._M_buckets;

      _M_update_bbegin(__ht._M_begin());

      __ht._M_reset();
    } else {
      __alloc_node_gen_t __alloc_gen(*this);

      using _Fwd_Ht =
          __conditional_t<__move_if_noexcept_cond<value_type>::value,
                          const _Hashtable &, _Hashtable &&>;
      _M_assign(std::forward<_Fwd_Ht>(__ht), __alloc_gen);
      __ht.clear();
    }
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
             _Unused, _RehashPolicy, _Traits>::~_Hashtable() noexcept {

    static_assert(
        noexcept(declval<const __hash_code_base_access &>()._M_bucket_index(
            declval<const __node_value_type &>(), (std::size_t)0)),
        "Cache the hash code or qualify your functors involved"
        " in hash code and bucket index computation with noexcept");

    clear();
    _M_deallocate_buckets();
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy, _Traits>::
      swap(_Hashtable &
           __x) noexcept(__and_<__is_nothrow_swappable<_Hash>,
                                __is_nothrow_swappable<_Equal>>::value) {

    this->_M_swap(__x);

    std::__alloc_on_swap(this->_M_node_allocator(), __x._M_node_allocator());
    std::swap(_M_rehash_policy, __x._M_rehash_policy);

    if (this->_M_uses_single_bucket()) {
      if (!__x._M_uses_single_bucket()) {
        _M_buckets = __x._M_buckets;
        __x._M_buckets = &__x._M_single_bucket;
      }
    } else if (__x._M_uses_single_bucket()) {
      __x._M_buckets = _M_buckets;
      _M_buckets = &_M_single_bucket;
    } else
      std::swap(_M_buckets, __x._M_buckets);

    std::swap(_M_bucket_count, __x._M_bucket_count);
    std::swap(_M_before_begin._M_nxt, __x._M_before_begin._M_nxt);
    std::swap(_M_element_count, __x._M_element_count);
    std::swap(_M_single_bucket, __x._M_single_bucket);

    _M_update_bbegin();
    __x._M_update_bbegin();
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy, _Traits>::find(const key_type &__k)
      -> iterator {
    if (size() <= __small_size_threshold()) {
      for (auto __it = begin(); __it != end(); ++__it)
        if (this->_M_key_equals(__k, *__it._M_cur))
          return __it;
      return end();
    }

    __hash_code __code = this->_M_hash_code(__k);
    std::size_t __bkt = _M_bucket_index(__code);
    return iterator(_M_find_node(__bkt, __k, __code));
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy, _Traits>::find(const key_type &__k)
      const -> const_iterator {
    if (size() <= __small_size_threshold()) {
      for (auto __it = begin(); __it != end(); ++__it)
        if (this->_M_key_equals(__k, *__it._M_cur))
          return __it;
      return end();
    }

    __hash_code __code = this->_M_hash_code(__k);
    std::size_t __bkt = _M_bucket_index(__code);
    return const_iterator(_M_find_node(__bkt, __k, __code));
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  template <typename _Kt, typename, typename>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy, _Traits>::_M_find_tr(const _Kt &__k)
      -> iterator {
    __hash_code __code = this->_M_hash_code_tr(__k);
    std::size_t __bkt = _M_bucket_index(__code);
    return iterator(_M_find_node_tr(__bkt, __k, __code));
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  template <typename _Kt, typename, typename>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy, _Traits>::_M_find_tr(const _Kt &__k)
      const -> const_iterator {
    __hash_code __code = this->_M_hash_code_tr(__k);
    std::size_t __bkt = _M_bucket_index(__code);
    return const_iterator(_M_find_node_tr(__bkt, __k, __code));
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy, _Traits>::count(const key_type &__k)
      const -> size_type {
    auto __it = find(__k);
    if (!__it._M_cur)
      return 0;

    if (__unique_keys::value)
      return 1;

    size_type __result = 1;
    for (auto __ref = __it++;
         __it._M_cur && this->_M_node_equals(*__ref._M_cur, *__it._M_cur);
         ++__it)
      ++__result;

    return __result;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  template <typename _Kt, typename, typename>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy, _Traits>::_M_count_tr(const _Kt &__k)
      const -> size_type {
    __hash_code __code = this->_M_hash_code_tr(__k);
    std::size_t __bkt = _M_bucket_index(__code);
    auto __n = _M_find_node_tr(__bkt, __k, __code);
    if (!__n)
      return 0;

    iterator __it(__n);
    size_type __result = 1;
    for (++__it; __it._M_cur && this->_M_equals_tr(__k, __code, *__it._M_cur);
         ++__it)
      ++__result;

    return __result;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto
  _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
             _Unused, _RehashPolicy, _Traits>::equal_range(const key_type &__k)
      -> pair<iterator, iterator> {
    auto __ite = find(__k);
    if (!__ite._M_cur)
      return {__ite, __ite};

    auto __beg = __ite++;
    if (__unique_keys::value)
      return {__beg, __ite};

    while (__ite._M_cur && this->_M_node_equals(*__beg._M_cur, *__ite._M_cur))
      ++__ite;

    return {__beg, __ite};
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto
  _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
             _Unused, _RehashPolicy, _Traits>::equal_range(const key_type &__k)
      const -> pair<const_iterator, const_iterator> {
    auto __ite = find(__k);
    if (!__ite._M_cur)
      return {__ite, __ite};

    auto __beg = __ite++;
    if (__unique_keys::value)
      return {__beg, __ite};

    while (__ite._M_cur && this->_M_node_equals(*__beg._M_cur, *__ite._M_cur))
      ++__ite;

    return {__beg, __ite};
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  template <typename _Kt, typename, typename>
  auto
  _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
             _Unused, _RehashPolicy, _Traits>::_M_equal_range_tr(const _Kt &__k)
      -> pair<iterator, iterator> {
    __hash_code __code = this->_M_hash_code_tr(__k);
    std::size_t __bkt = _M_bucket_index(__code);
    auto __n = _M_find_node_tr(__bkt, __k, __code);
    iterator __ite(__n);
    if (!__n)
      return {__ite, __ite};

    auto __beg = __ite++;
    while (__ite._M_cur && this->_M_equals_tr(__k, __code, *__ite._M_cur))
      ++__ite;

    return {__beg, __ite};
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  template <typename _Kt, typename, typename>
  auto
  _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
             _Unused, _RehashPolicy, _Traits>::_M_equal_range_tr(const _Kt &__k)
      const -> pair<const_iterator, const_iterator> {
    __hash_code __code = this->_M_hash_code_tr(__k);
    std::size_t __bkt = _M_bucket_index(__code);
    auto __n = _M_find_node_tr(__bkt, __k, __code);
    const_iterator __ite(__n);
    if (!__n)
      return {__ite, __ite};

    auto __beg = __ite++;
    while (__ite._M_cur && this->_M_equals_tr(__k, __code, *__ite._M_cur))
      ++__ite;

    return {__beg, __ite};
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_find_before_node(const key_type &__k)
      -> __node_base_ptr {
    __node_base_ptr __prev_p = &_M_before_begin;
    if (!__prev_p->_M_nxt)
      return nullptr;

    for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);
         __p != nullptr; __p = __p->_M_next()) {
      if (this->_M_key_equals(__k, *__p))
        return __prev_p;

      __prev_p = __p;
    }

    return nullptr;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_find_before_node(size_type __bkt,
                                                const key_type &__k,
                                                __hash_code __code)
      const -> __node_base_ptr {
    __node_base_ptr __prev_p = _M_buckets[__bkt];
    if (!__prev_p)
      return nullptr;

    for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);;
         __p = __p->_M_next()) {
      if (this->_M_equals(__k, __code, *__p))
        return __prev_p;

      if (!__p->_M_nxt || _M_bucket_index(*__p->_M_next()) != __bkt)
        break;
      __prev_p = __p;
    }

    return nullptr;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  template <typename _Kt>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_find_before_node_tr(size_type __bkt,
                                                   const _Kt &__k,
                                                   __hash_code __code)
      const -> __node_base_ptr {
    __node_base_ptr __prev_p = _M_buckets[__bkt];
    if (!__prev_p)
      return nullptr;

    for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);;
         __p = __p->_M_next()) {
      if (this->_M_equals_tr(__k, __code, *__p))
        return __prev_p;

      if (!__p->_M_nxt || _M_bucket_index(*__p->_M_next()) != __bkt)
        break;
      __prev_p = __p;
    }

    return nullptr;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_insert_bucket_begin(size_type __bkt,
                                                   __node_ptr __node) {
    if (_M_buckets[__bkt]) {

      __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
      _M_buckets[__bkt]->_M_nxt = __node;
    } else {

      __node->_M_nxt = _M_before_begin._M_nxt;
      _M_before_begin._M_nxt = __node;

      if (__node->_M_nxt)

        _M_buckets[_M_bucket_index(*__node->_M_next())] = __node;

      _M_buckets[__bkt] = &_M_before_begin;
    }
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_remove_bucket_begin(size_type __bkt,
                                                   __node_ptr __next,
                                                   size_type __next_bkt) {
    if (!__next || __next_bkt != __bkt) {

      if (__next)
        _M_buckets[__next_bkt] = _M_buckets[__bkt];

      if (&_M_before_begin == _M_buckets[__bkt])
        _M_before_begin._M_nxt = __next;
      _M_buckets[__bkt] = nullptr;
    }
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_get_previous_node(size_type __bkt,
                                                 __node_ptr __n)
      -> __node_base_ptr {
    __node_base_ptr __prev_n = _M_buckets[__bkt];
    while (__prev_n->_M_nxt != __n)
      __prev_n = __prev_n->_M_nxt;
    return __prev_n;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  template <typename... _Args>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy, _Traits>::_M_emplace(true_type,
                                                               _Args &&
                                                                   ...__args)
      -> pair<iterator, bool> {

    _Scoped_node __node{this, std::forward<_Args>(__args)...};
    const key_type &__k = _ExtractKey{}(__node._M_node->_M_v());
    if (size() <= __small_size_threshold()) {
      for (auto __it = begin(); __it != end(); ++__it)
        if (this->_M_key_equals(__k, *__it._M_cur))

          return {__it, false};
    }

    __hash_code __code = this->_M_hash_code(__k);
    size_type __bkt = _M_bucket_index(__code);
    if (size() > __small_size_threshold())
      if (__node_ptr __p = _M_find_node(__bkt, __k, __code))

        return {iterator(__p), false};

    auto __pos = _M_insert_unique_node(__bkt, __code, __node._M_node);
    __node._M_node = nullptr;
    return {__pos, true};
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  template <typename... _Args>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_emplace(const_iterator __hint, false_type,
                                       _Args && ...__args) -> iterator {

    _Scoped_node __node{this, std::forward<_Args>(__args)...};
    const key_type &__k = _ExtractKey{}(__node._M_node->_M_v());

    auto __res = this->_M_compute_hash_code(__hint, __k);
    auto __pos =
        _M_insert_multi_node(__res.first._M_cur, __res.second, __node._M_node);
    __node._M_node = nullptr;
    return __pos;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_compute_hash_code(const_iterator __hint,
                                                 const key_type &__k)
      const -> pair<const_iterator, __hash_code> {
    if (size() <= __small_size_threshold()) {
      if (__hint != cend()) {
        for (auto __it = __hint; __it != cend(); ++__it)
          if (this->_M_key_equals(__k, *__it._M_cur))
            return {__it, this->_M_hash_code(*__it._M_cur)};
      }

      for (auto __it = cbegin(); __it != __hint; ++__it)
        if (this->_M_key_equals(__k, *__it._M_cur))
          return {__it, this->_M_hash_code(*__it._M_cur)};
    }

    return {__hint, this->_M_hash_code(__k)};
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_insert_unique_node(size_type __bkt,
                                                  __hash_code __code,
                                                  __node_ptr __node,
                                                  size_type __n_elt)
      -> iterator {
    const __rehash_state &__saved_state = _M_rehash_policy._M_state();
    std::pair<bool, std::size_t> __do_rehash = _M_rehash_policy._M_need_rehash(
        _M_bucket_count, _M_element_count, __n_elt);

    if (__do_rehash.first) {
      _M_rehash(__do_rehash.second, __saved_state);
      __bkt = _M_bucket_index(__code);
    }

    this->_M_store_code(*__node, __code);

    _M_insert_bucket_begin(__bkt, __node);
    ++_M_element_count;
    return iterator(__node);
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_insert_multi_node(__node_ptr __hint,
                                                 __hash_code __code,
                                                 __node_ptr __node)
      -> iterator {
    const __rehash_state &__saved_state = _M_rehash_policy._M_state();
    std::pair<bool, std::size_t> __do_rehash =
        _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);

    if (__do_rehash.first)
      _M_rehash(__do_rehash.second, __saved_state);

    this->_M_store_code(*__node, __code);
    const key_type &__k = _ExtractKey{}(__node->_M_v());
    size_type __bkt = _M_bucket_index(__code);

    __node_base_ptr __prev = __builtin_expect(__hint != nullptr, false) &&
                                     this->_M_equals(__k, __code, *__hint)
                                 ? __hint
                                 : _M_find_before_node(__bkt, __k, __code);

    if (__prev) {

      __node->_M_nxt = __prev->_M_nxt;
      __prev->_M_nxt = __node;
      if (__builtin_expect(__prev == __hint, false))

        if (__node->_M_nxt &&
            !this->_M_equals(__k, __code, *__node->_M_next())) {
          size_type __next_bkt = _M_bucket_index(*__node->_M_next());
          if (__next_bkt != __bkt)
            _M_buckets[__next_bkt] = __node;
        }
    } else

      _M_insert_bucket_begin(__bkt, __node);
    ++_M_element_count;
    return iterator(__node);
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  template <typename _Kt, typename _Arg, typename _NodeGenerator>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_insert_unique(_Kt && __k, _Arg && __v,
                                             const _NodeGenerator &__node_gen)
      -> pair<iterator, bool> {
    if (size() <= __small_size_threshold())
      for (auto __it = begin(); __it != end(); ++__it)
        if (this->_M_key_equals_tr(__k, *__it._M_cur))
          return {__it, false};

    __hash_code __code = this->_M_hash_code_tr(__k);
    size_type __bkt = _M_bucket_index(__code);

    if (size() > __small_size_threshold())
      if (__node_ptr __node = _M_find_node_tr(__bkt, __k, __code))
        return {iterator(__node), false};

    _Scoped_node __node{__node_builder_t::_S_build(std::forward<_Kt>(__k),
                                                   std::forward<_Arg>(__v),
                                                   __node_gen),
                        this};
    auto __pos = _M_insert_unique_node(__bkt, __code, __node._M_node);
    __node._M_node = nullptr;
    return {__pos, true};
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  template <typename _Arg, typename _NodeGenerator>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_insert(const_iterator __hint, _Arg && __v,
                                      const _NodeGenerator &__node_gen,
                                      false_type) -> iterator {

    _Scoped_node __node{__node_gen(std::forward<_Arg>(__v)), this};

    auto __res = this->_M_compute_hash_code(
        __hint, _ExtractKey{}(__node._M_node->_M_v()));

    auto __pos =
        _M_insert_multi_node(__res.first._M_cur, __res.second, __node._M_node);
    __node._M_node = nullptr;
    return __pos;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy, _Traits>::erase(const_iterator __it)
      -> iterator {
    __node_ptr __n = __it._M_cur;
    std::size_t __bkt = _M_bucket_index(*__n);

    __node_base_ptr __prev_n = _M_get_previous_node(__bkt, __n);
    return _M_erase(__bkt, __prev_n, __n);
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_erase(size_type __bkt, __node_base_ptr __prev_n,
                                     __node_ptr __n) -> iterator {
    if (__prev_n == _M_buckets[__bkt])
      _M_remove_bucket_begin(__bkt, __n->_M_next(),
                             __n->_M_nxt ? _M_bucket_index(*__n->_M_next())
                                         : 0);
    else if (__n->_M_nxt) {
      size_type __next_bkt = _M_bucket_index(*__n->_M_next());
      if (__next_bkt != __bkt)
        _M_buckets[__next_bkt] = __prev_n;
    }

    __prev_n->_M_nxt = __n->_M_nxt;
    iterator __result(__n->_M_next());
    this->_M_deallocate_node(__n);
    --_M_element_count;

    return __result;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_erase(true_type,
                                     const key_type &__k) -> size_type {
    __node_base_ptr __prev_n;
    __node_ptr __n;
    std::size_t __bkt;
    if (size() <= __small_size_threshold()) {
      __prev_n = _M_find_before_node(__k);
      if (!__prev_n)
        return 0;

      __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
      __bkt = _M_bucket_index(*__n);
    } else {
      __hash_code __code = this->_M_hash_code(__k);
      __bkt = _M_bucket_index(__code);

      __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
        return 0;

      __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
    }

    _M_erase(__bkt, __prev_n, __n);
    return 1;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_erase(false_type,
                                     const key_type &__k) -> size_type {
    std::size_t __bkt;
    __node_base_ptr __prev_n;
    __node_ptr __n;
    if (size() <= __small_size_threshold()) {
      __prev_n = _M_find_before_node(__k);
      if (!__prev_n)
        return 0;

      __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
      __bkt = _M_bucket_index(*__n);
    } else {
      __hash_code __code = this->_M_hash_code(__k);
      __bkt = _M_bucket_index(__code);

      __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
        return 0;

      __n = static_cast<__node_ptr>(__prev_n->_M_nxt);
    }

    __node_ptr __n_last = __n->_M_next();
    while (__n_last && this->_M_node_equals(*__n, *__n_last))
      __n_last = __n_last->_M_next();

    std::size_t __n_last_bkt = __n_last ? _M_bucket_index(*__n_last) : __bkt;

    size_type __result = 0;
    do {
      __node_ptr __p = __n->_M_next();
      this->_M_deallocate_node(__n);
      __n = __p;
      ++__result;
    } while (__n != __n_last);

    _M_element_count -= __result;
    if (__prev_n == _M_buckets[__bkt])
      _M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt);
    else if (__n_last_bkt != __bkt)
      _M_buckets[__n_last_bkt] = __prev_n;
    __prev_n->_M_nxt = __n_last;
    return __result;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  auto _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::erase(const_iterator __first,
                                  const_iterator __last) -> iterator {
    __node_ptr __n = __first._M_cur;
    __node_ptr __last_n = __last._M_cur;
    if (__n == __last_n)
      return iterator(__n);

    std::size_t __bkt = _M_bucket_index(*__n);

    __node_base_ptr __prev_n = _M_get_previous_node(__bkt, __n);
    bool __is_bucket_begin = __n == _M_bucket_begin(__bkt);
    std::size_t __n_bkt = __bkt;
    for (;;) {
      do {
        __node_ptr __tmp = __n;
        __n = __n->_M_next();
        this->_M_deallocate_node(__tmp);
        --_M_element_count;
        if (!__n)
          break;
        __n_bkt = _M_bucket_index(*__n);
      } while (__n != __last_n && __n_bkt == __bkt);
      if (__is_bucket_begin)
        _M_remove_bucket_begin(__bkt, __n, __n_bkt);
      if (__n == __last_n)
        break;
      __is_bucket_begin = true;
      __bkt = __n_bkt;
    }

    if (__n && (__n_bkt != __bkt || __is_bucket_begin))
      _M_buckets[__n_bkt] = __prev_n;
    __prev_n->_M_nxt = __n;
    return iterator(__n);
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy, _Traits>::clear() noexcept {
    this->_M_deallocate_nodes(_M_begin());
    __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__node_base_ptr));
    _M_element_count = 0;
    _M_before_begin._M_nxt = nullptr;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  void
  _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
             _Unused, _RehashPolicy, _Traits>::rehash(size_type __bkt_count) {
    const __rehash_state &__saved_state = _M_rehash_policy._M_state();
    __bkt_count =
        std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count + 1),
                 __bkt_count);
    __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count);

    if (__bkt_count != _M_bucket_count)
      _M_rehash(__bkt_count, __saved_state);
    else

      _M_rehash_policy._M_reset(__saved_state);
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_rehash(size_type __bkt_count,
                                      const __rehash_state &__state) {
    try {
      _M_rehash_aux(__bkt_count, __unique_keys{});
    } catch (...) {

      _M_rehash_policy._M_reset(__state);
      throw;
    }
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_rehash_aux(size_type __bkt_count, true_type) {
    __buckets_ptr __new_buckets = _M_allocate_buckets(__bkt_count);
    __node_ptr __p = _M_begin();
    _M_before_begin._M_nxt = nullptr;
    std::size_t __bbegin_bkt = 0;
    while (__p) {
      __node_ptr __next = __p->_M_next();
      std::size_t __bkt = __hash_code_base::_M_bucket_index(*__p, __bkt_count);
      if (!__new_buckets[__bkt]) {
        __p->_M_nxt = _M_before_begin._M_nxt;
        _M_before_begin._M_nxt = __p;
        __new_buckets[__bkt] = &_M_before_begin;
        if (__p->_M_nxt)
          __new_buckets[__bbegin_bkt] = __p;
        __bbegin_bkt = __bkt;
      } else {
        __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
        __new_buckets[__bkt]->_M_nxt = __p;
      }

      __p = __next;
    }

    _M_deallocate_buckets();
    _M_bucket_count = __bkt_count;
    _M_buckets = __new_buckets;
  }

  template <typename _Key, typename _Value, typename _Alloc,
            typename _ExtractKey, typename _Equal, typename _Hash,
            typename _RangeHash, typename _Unused, typename _RehashPolicy,
            typename _Traits>
  void _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _Hash, _RangeHash,
                  _Unused, _RehashPolicy,
                  _Traits>::_M_rehash_aux(size_type __bkt_count, false_type) {
    __buckets_ptr __new_buckets = _M_allocate_buckets(__bkt_count);
    __node_ptr __p = _M_begin();
    _M_before_begin._M_nxt = nullptr;
    std::size_t __bbegin_bkt = 0;
    std::size_t __prev_bkt = 0;
    __node_ptr __prev_p = nullptr;
    bool __check_bucket = false;

    while (__p) {
      __node_ptr __next = __p->_M_next();
      std::size_t __bkt = __hash_code_base::_M_bucket_index(*__p, __bkt_count);

      if (__prev_p && __prev_bkt == __bkt) {

        __p->_M_nxt = __prev_p->_M_nxt;
        __prev_p->_M_nxt = __p;

        __check_bucket = true;
      } else {
        if (__check_bucket) {

          if (__prev_p->_M_nxt) {
            std::size_t __next_bkt = __hash_code_base::_M_bucket_index(
                *__prev_p->_M_next(), __bkt_count);
            if (__next_bkt != __prev_bkt)
              __new_buckets[__next_bkt] = __prev_p;
          }
          __check_bucket = false;
        }

        if (!__new_buckets[__bkt]) {
          __p->_M_nxt = _M_before_begin._M_nxt;
          _M_before_begin._M_nxt = __p;
          __new_buckets[__bkt] = &_M_before_begin;
          if (__p->_M_nxt)
            __new_buckets[__bbegin_bkt] = __p;
          __bbegin_bkt = __bkt;
        } else {
          __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
          __new_buckets[__bkt]->_M_nxt = __p;
        }
      }
      __prev_p = __p;
      __prev_bkt = __bkt;
      __p = __next;
    }

    if (__check_bucket && __prev_p->_M_nxt) {
      std::size_t __next_bkt =
          __hash_code_base::_M_bucket_index(*__prev_p->_M_next(), __bkt_count);
      if (__next_bkt != __prev_bkt)
        __new_buckets[__next_bkt] = __prev_p;
    }

    _M_deallocate_buckets();
    _M_bucket_count = __bkt_count;
    _M_buckets = __new_buckets;
  }

  template <typename, typename, typename> class _Hash_merge_helper {};

  template <typename _Hash>
  using _RequireNotAllocatorOrIntegral =
      __enable_if_t<!__or_<is_integral<_Hash>, __is_allocator<_Hash>>::value>;

} // namespace std
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  template <bool _Cache>
  using __umap_traits = __detail::_Hashtable_traits<_Cache, false, true>;

  template <typename _Key, typename _Tp, typename _Hash = hash<_Key>,
            typename _Pred = std::equal_to<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp>>,
            typename _Tr = __umap_traits<__cache_default<_Key, _Hash>::value>>
  using __umap_hashtable =
      _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, __detail::_Select1st,
                 _Pred, _Hash, __detail::_Mod_range_hashing,
                 __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy,
                 _Tr>;

  template <bool _Cache>
  using __ummap_traits = __detail::_Hashtable_traits<_Cache, false, false>;

  template <typename _Key, typename _Tp, typename _Hash = hash<_Key>,
            typename _Pred = std::equal_to<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp>>,
            typename _Tr = __ummap_traits<__cache_default<_Key, _Hash>::value>>
  using __ummap_hashtable =
      _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc, __detail::_Select1st,
                 _Pred, _Hash, __detail::_Mod_range_hashing,
                 __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy,
                 _Tr>;

  template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
  class unordered_multimap;
# 105 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
  template <typename _Key, typename _Tp, typename _Hash = hash<_Key>,
            typename _Pred = equal_to<_Key>,
            typename _Alloc = allocator<std::pair<const _Key, _Tp>>>
  class unordered_map {
    typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
    _Hashtable _M_h;

  public:
    typedef typename _Hashtable::key_type key_type;
    typedef typename _Hashtable::value_type value_type;
    typedef typename _Hashtable::mapped_type mapped_type;
    typedef typename _Hashtable::hasher hasher;
    typedef typename _Hashtable::key_equal key_equal;
    typedef typename _Hashtable::allocator_type allocator_type;

    typedef typename _Hashtable::pointer pointer;
    typedef typename _Hashtable::const_pointer const_pointer;
    typedef typename _Hashtable::reference reference;
    typedef typename _Hashtable::const_reference const_reference;
    typedef typename _Hashtable::iterator iterator;
    typedef typename _Hashtable::const_iterator const_iterator;
    typedef typename _Hashtable::local_iterator local_iterator;
    typedef typename _Hashtable::const_local_iterator const_local_iterator;
    typedef typename _Hashtable::size_type size_type;
    typedef typename _Hashtable::difference_type difference_type;

    using node_type = typename _Hashtable::node_type;
    using insert_return_type = typename _Hashtable::insert_return_type;

    unordered_map() = default;
# 157 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    explicit unordered_map(size_type __n, const hasher &__hf = hasher(),
                           const key_equal &__eql = key_equal(),
                           const allocator_type &__a = allocator_type())
        : _M_h(__n, __hf, __eql, __a) {}
# 178 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    template <typename _InputIterator>
    unordered_map(_InputIterator __first, _InputIterator __last,
                  size_type __n = 0, const hasher &__hf = hasher(),
                  const key_equal &__eql = key_equal(),
                  const allocator_type &__a = allocator_type())
        : _M_h(__first, __last, __n, __hf, __eql, __a) {}

    unordered_map(const unordered_map &) = default;

    unordered_map(unordered_map &&) = default;

    explicit unordered_map(const allocator_type &__a) : _M_h(__a) {}

    unordered_map(const unordered_map &__umap, const allocator_type &__a)
        : _M_h(__umap._M_h, __a) {}

    unordered_map(unordered_map &&__umap, const allocator_type &__a) noexcept(
        noexcept(_Hashtable(std::move(__umap._M_h), __a)))
        : _M_h(std::move(__umap._M_h), __a) {}
# 234 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    unordered_map(initializer_list<value_type> __l, size_type __n = 0,
                  const hasher &__hf = hasher(),
                  const key_equal &__eql = key_equal(),
                  const allocator_type &__a = allocator_type())
        : _M_h(__l, __n, __hf, __eql, __a) {}

    unordered_map(size_type __n, const allocator_type &__a)
        : unordered_map(__n, hasher(), key_equal(), __a) {}

    unordered_map(size_type __n, const hasher &__hf, const allocator_type &__a)
        : unordered_map(__n, __hf, key_equal(), __a) {}

    template <typename _InputIterator>
    unordered_map(_InputIterator __first, _InputIterator __last, size_type __n,
                  const allocator_type &__a)
        : unordered_map(__first, __last, __n, hasher(), key_equal(), __a) {}

    template <typename _InputIterator>
    unordered_map(_InputIterator __first, _InputIterator __last, size_type __n,
                  const hasher &__hf, const allocator_type &__a)
        : unordered_map(__first, __last, __n, __hf, key_equal(), __a) {}

    unordered_map(initializer_list<value_type> __l, size_type __n,
                  const allocator_type &__a)
        : unordered_map(__l, __n, hasher(), key_equal(), __a) {}

    unordered_map(initializer_list<value_type> __l, size_type __n,
                  const hasher &__hf, const allocator_type &__a)
        : unordered_map(__l, __n, __hf, key_equal(), __a) {}

    unordered_map &operator=(const unordered_map &) = default;

    unordered_map &operator=(unordered_map &&) = default;
# 296 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    unordered_map &operator=(initializer_list<value_type> __l) {
      _M_h = __l;
      return *this;
    }

    allocator_type get_allocator() const noexcept {
      return _M_h.get_allocator();
    }

    [[__nodiscard__]] bool empty() const noexcept { return _M_h.empty(); }

    size_type size() const noexcept { return _M_h.size(); }

    size_type max_size() const noexcept { return _M_h.max_size(); }

    iterator begin() noexcept { return _M_h.begin(); }

    const_iterator begin() const noexcept { return _M_h.begin(); }

    const_iterator cbegin() const noexcept { return _M_h.begin(); }

    iterator end() noexcept { return _M_h.end(); }

    const_iterator end() const noexcept { return _M_h.end(); }

    const_iterator cend() const noexcept { return _M_h.end(); }
# 393 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    template <typename... _Args>
    std::pair<iterator, bool> emplace(_Args &&...__args) {
      return _M_h.emplace(std::forward<_Args>(__args)...);
    }
# 424 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    template <typename... _Args>
    iterator emplace_hint(const_iterator __pos, _Args &&...__args) {
      return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...);
    }

    node_type extract(const_iterator __pos) {
      do {
        if (std::__is_constant_evaluated() && !bool(__pos != end()))
          __builtin_unreachable();
      } while (false);
      return _M_h.extract(__pos);
    }

    node_type extract(const key_type &__key) { return _M_h.extract(__key); }

    insert_return_type insert(node_type &&__nh) {
      return _M_h._M_reinsert_node(std::move(__nh));
    }

    iterator insert(const_iterator, node_type &&__nh) {
      return _M_h._M_reinsert_node(std::move(__nh)).position;
    }
# 476 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    template <typename... _Args>
    pair<iterator, bool> try_emplace(const key_type &__k, _Args &&...__args) {
      return _M_h.try_emplace(cend(), __k, std::forward<_Args>(__args)...);
    }

    template <typename... _Args>
    pair<iterator, bool> try_emplace(key_type &&__k, _Args &&...__args) {
      return _M_h.try_emplace(cend(), std::move(__k),
                              std::forward<_Args>(__args)...);
    }
# 520 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    template <typename... _Args>
    iterator try_emplace(const_iterator __hint, const key_type &__k,
                         _Args &&...__args) {
      return _M_h.try_emplace(__hint, __k, std::forward<_Args>(__args)...)
          .first;
    }

    template <typename... _Args>
    iterator try_emplace(const_iterator __hint, key_type &&__k,
                         _Args &&...__args) {
      return _M_h
          .try_emplace(__hint, std::move(__k), std::forward<_Args>(__args)...)
          .first;
    }
# 557 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    std::pair<iterator, bool> insert(const value_type &__x) {
      return _M_h.insert(__x);
    }

    std::pair<iterator, bool> insert(value_type &&__x) {
      return _M_h.insert(std::move(__x));
    }

    template <typename _Pair>
    __enable_if_t<is_constructible<value_type, _Pair &&>::value,
                  pair<iterator, bool>>
    insert(_Pair &&__x) {
      return _M_h.emplace(std::forward<_Pair>(__x));
    }
# 596 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    iterator insert(const_iterator __hint, const value_type &__x) {
      return _M_h.insert(__hint, __x);
    }

    iterator insert(const_iterator __hint, value_type &&__x) {
      return _M_h.insert(__hint, std::move(__x));
    }

    template <typename _Pair>
    __enable_if_t<is_constructible<value_type, _Pair &&>::value, iterator>
    insert(const_iterator __hint, _Pair &&__x) {
      return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x));
    }
# 621 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    template <typename _InputIterator>
    void insert(_InputIterator __first, _InputIterator __last) {
      _M_h.insert(__first, __last);
    }
# 633 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    void insert(initializer_list<value_type> __l) { _M_h.insert(__l); }
# 659 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    template <typename _Obj>
    pair<iterator, bool> insert_or_assign(const key_type &__k, _Obj &&__obj) {
      auto __ret = _M_h.try_emplace(cend(), __k, std::forward<_Obj>(__obj));
      if (!__ret.second)
        __ret.first->second = std::forward<_Obj>(__obj);
      return __ret;
    }

    template <typename _Obj>
    pair<iterator, bool> insert_or_assign(key_type &&__k, _Obj &&__obj) {
      auto __ret =
          _M_h.try_emplace(cend(), std::move(__k), std::forward<_Obj>(__obj));
      if (!__ret.second)
        __ret.first->second = std::forward<_Obj>(__obj);
      return __ret;
    }
# 708 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    template <typename _Obj>
    iterator insert_or_assign(const_iterator __hint, const key_type &__k,
                              _Obj &&__obj) {
      auto __ret = _M_h.try_emplace(__hint, __k, std::forward<_Obj>(__obj));
      if (!__ret.second)
        __ret.first->second = std::forward<_Obj>(__obj);
      return __ret.first;
    }

    template <typename _Obj>
    iterator insert_or_assign(const_iterator __hint, key_type &&__k,
                              _Obj &&__obj) {
      auto __ret =
          _M_h.try_emplace(__hint, std::move(__k), std::forward<_Obj>(__obj));
      if (!__ret.second)
        __ret.first->second = std::forward<_Obj>(__obj);
      return __ret.first;
    }
# 746 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    iterator erase(const_iterator __position) { return _M_h.erase(__position); }

    iterator erase(iterator __position) { return _M_h.erase(__position); }
# 768 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    size_type erase(const key_type &__x) { return _M_h.erase(__x); }
# 786 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    iterator erase(const_iterator __first, const_iterator __last) {
      return _M_h.erase(__first, __last);
    }

    void clear() noexcept { _M_h.clear(); }
# 810 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    void swap(unordered_map &__x) noexcept(noexcept(_M_h.swap(__x._M_h))) {
      _M_h.swap(__x._M_h);
    }

    template <typename, typename, typename>
    friend class std::_Hash_merge_helper;

    template <typename _H2, typename _P2>
    void merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc> &__source) {
      using _Merge_helper = _Hash_merge_helper<unordered_map, _H2, _P2>;
      _M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));
    }

    template <typename _H2, typename _P2>
    void merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc> &&__source) {
      merge(__source);
    }

    template <typename _H2, typename _P2>
    void merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc> &__source) {
      using _Merge_helper = _Hash_merge_helper<unordered_map, _H2, _P2>;
      _M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));
    }

    template <typename _H2, typename _P2>
    void merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc> &&__source) {
      merge(__source);
    }

    hasher hash_function() const { return _M_h.hash_function(); }

    key_equal key_eq() const { return _M_h.key_eq(); }
# 874 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    iterator find(const key_type &__x) { return _M_h.find(__x); }

    template <typename _Kt>
    auto find(const _Kt &__x) -> decltype(_M_h._M_find_tr(__x)) {
      return _M_h._M_find_tr(__x);
    }

    const_iterator find(const key_type &__x) const { return _M_h.find(__x); }

    template <typename _Kt>
    auto find(const _Kt &__x) const -> decltype(_M_h._M_find_tr(__x)) {
      return _M_h._M_find_tr(__x);
    }
# 907 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    size_type count(const key_type &__x) const { return _M_h.count(__x); }

    template <typename _Kt>
    auto count(const _Kt &__x) const -> decltype(_M_h._M_count_tr(__x)) {
      return _M_h._M_count_tr(__x);
    }
# 926 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    bool contains(const key_type &__x) const {
      return _M_h.find(__x) != _M_h.end();
    }

    template <typename _Kt>
    auto contains(const _Kt &__x) const -> decltype(_M_h._M_find_tr(__x),
                                                    void(), true) {
      return _M_h._M_find_tr(__x) != _M_h.end();
    }
# 947 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    std::pair<iterator, iterator> equal_range(const key_type &__x) {
      return _M_h.equal_range(__x);
    }

    template <typename _Kt>
    auto equal_range(const _Kt &__x) -> decltype(_M_h._M_equal_range_tr(__x)) {
      return _M_h._M_equal_range_tr(__x);
    }

    std::pair<const_iterator, const_iterator>
    equal_range(const key_type &__x) const {
      return _M_h.equal_range(__x);
    }

    template <typename _Kt>
    auto
    equal_range(const _Kt &__x) const -> decltype(_M_h._M_equal_range_tr(__x)) {
      return _M_h._M_equal_range_tr(__x);
    }
# 985 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    mapped_type &operator[](const key_type &__k) { return _M_h[__k]; }

    mapped_type &operator[](key_type &&__k) { return _M_h[std::move(__k)]; }
# 1002 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    mapped_type &at(const key_type &__k) { return _M_h.at(__k); }

    const mapped_type &at(const key_type &__k) const { return _M_h.at(__k); }

    size_type bucket_count() const noexcept { return _M_h.bucket_count(); }

    size_type max_bucket_count() const noexcept {
      return _M_h.max_bucket_count();
    }

    size_type bucket_size(size_type __n) const { return _M_h.bucket_size(__n); }

    size_type bucket(const key_type &__key) const { return _M_h.bucket(__key); }

    local_iterator begin(size_type __n) { return _M_h.begin(__n); }
# 1058 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    const_local_iterator begin(size_type __n) const { return _M_h.begin(__n); }

    const_local_iterator cbegin(size_type __n) const {
      return _M_h.cbegin(__n);
    }
# 1073 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    local_iterator end(size_type __n) { return _M_h.end(__n); }
# 1084 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    const_local_iterator end(size_type __n) const { return _M_h.end(__n); }

    const_local_iterator cend(size_type __n) const { return _M_h.cend(__n); }

    float load_factor() const noexcept { return _M_h.load_factor(); }

    float max_load_factor() const noexcept { return _M_h.max_load_factor(); }

    void max_load_factor(float __z) { _M_h.max_load_factor(__z); }
# 1121 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    void rehash(size_type __n) { _M_h.rehash(__n); }
# 1132 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    void reserve(size_type __n) { _M_h.reserve(__n); }

    template <typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
              typename _Alloc1>
    friend bool
    operator==(const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &,
               const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &);
  };

  template <typename _InputIterator,
            typename _Hash = hash<__iter_key_t<_InputIterator>>,
            typename _Pred = equal_to<__iter_key_t<_InputIterator>>,
            typename _Allocator = allocator<__iter_to_alloc_t<_InputIterator>>,
            typename = _RequireInputIter<_InputIterator>,
            typename = _RequireNotAllocatorOrIntegral<_Hash>,
            typename = _RequireNotAllocator<_Pred>,
            typename = _RequireAllocator<_Allocator>>
  unordered_map(_InputIterator, _InputIterator,
                typename unordered_map<int, int>::size_type = {},
                _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
      -> unordered_map<__iter_key_t<_InputIterator>,
                       __iter_val_t<_InputIterator>, _Hash, _Pred, _Allocator>;

  template <typename _Key, typename _Tp, typename _Hash = hash<_Key>,
            typename _Pred = equal_to<_Key>,
            typename _Allocator = allocator<pair<const _Key, _Tp>>,
            typename = _RequireNotAllocatorOrIntegral<_Hash>,
            typename = _RequireNotAllocator<_Pred>,
            typename = _RequireAllocator<_Allocator>>
  unordered_map(initializer_list<pair<_Key, _Tp>>,
                typename unordered_map<int, int>::size_type = {},
                _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
      -> unordered_map<_Key, _Tp, _Hash, _Pred, _Allocator>;

  template <typename _InputIterator, typename _Allocator,
            typename = _RequireInputIter<_InputIterator>,
            typename = _RequireAllocator<_Allocator>>
  unordered_map(_InputIterator, _InputIterator,
                typename unordered_map<int, int>::size_type, _Allocator)
      -> unordered_map<__iter_key_t<_InputIterator>,
                       __iter_val_t<_InputIterator>,
                       hash<__iter_key_t<_InputIterator>>,
                       equal_to<__iter_key_t<_InputIterator>>, _Allocator>;

  template <typename _InputIterator, typename _Allocator,
            typename = _RequireInputIter<_InputIterator>,
            typename = _RequireAllocator<_Allocator>>
  unordered_map(_InputIterator, _InputIterator, _Allocator)
      -> unordered_map<__iter_key_t<_InputIterator>,
                       __iter_val_t<_InputIterator>,
                       hash<__iter_key_t<_InputIterator>>,
                       equal_to<__iter_key_t<_InputIterator>>, _Allocator>;

  template <typename _InputIterator, typename _Hash, typename _Allocator,
            typename = _RequireInputIter<_InputIterator>,
            typename = _RequireNotAllocatorOrIntegral<_Hash>,
            typename = _RequireAllocator<_Allocator>>
  unordered_map(_InputIterator, _InputIterator,
                typename unordered_map<int, int>::size_type, _Hash, _Allocator)
      -> unordered_map<__iter_key_t<_InputIterator>,
                       __iter_val_t<_InputIterator>, _Hash,
                       equal_to<__iter_key_t<_InputIterator>>, _Allocator>;

  template <typename _Key, typename _Tp, typename _Allocator,
            typename = _RequireAllocator<_Allocator>>
  unordered_map(initializer_list<pair<_Key, _Tp>>,
                typename unordered_map<int, int>::size_type, _Allocator)
      -> unordered_map<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>;

  template <typename _Key, typename _Tp, typename _Allocator,
            typename = _RequireAllocator<_Allocator>>
  unordered_map(initializer_list<pair<_Key, _Tp>>, _Allocator)
      -> unordered_map<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>;

  template <typename _Key, typename _Tp, typename _Hash, typename _Allocator,
            typename = _RequireNotAllocatorOrIntegral<_Hash>,
            typename = _RequireAllocator<_Allocator>>
  unordered_map(initializer_list<pair<_Key, _Tp>>,
                typename unordered_map<int, int>::size_type, _Hash, _Allocator)
      -> unordered_map<_Key, _Tp, _Hash, equal_to<_Key>, _Allocator>;
# 1250 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
  template <typename _Key, typename _Tp, typename _Hash = hash<_Key>,
            typename _Pred = equal_to<_Key>,
            typename _Alloc = allocator<std::pair<const _Key, _Tp>>>
  class unordered_multimap {
    typedef __ummap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
    _Hashtable _M_h;

  public:
    typedef typename _Hashtable::key_type key_type;
    typedef typename _Hashtable::value_type value_type;
    typedef typename _Hashtable::mapped_type mapped_type;
    typedef typename _Hashtable::hasher hasher;
    typedef typename _Hashtable::key_equal key_equal;
    typedef typename _Hashtable::allocator_type allocator_type;

    typedef typename _Hashtable::pointer pointer;
    typedef typename _Hashtable::const_pointer const_pointer;
    typedef typename _Hashtable::reference reference;
    typedef typename _Hashtable::const_reference const_reference;
    typedef typename _Hashtable::iterator iterator;
    typedef typename _Hashtable::const_iterator const_iterator;
    typedef typename _Hashtable::local_iterator local_iterator;
    typedef typename _Hashtable::const_local_iterator const_local_iterator;
    typedef typename _Hashtable::size_type size_type;
    typedef typename _Hashtable::difference_type difference_type;

    using node_type = typename _Hashtable::node_type;

    unordered_multimap() = default;
# 1301 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    explicit unordered_multimap(size_type __n, const hasher &__hf = hasher(),
                                const key_equal &__eql = key_equal(),
                                const allocator_type &__a = allocator_type())
        : _M_h(__n, __hf, __eql, __a) {}
# 1322 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    template <typename _InputIterator>
    unordered_multimap(_InputIterator __first, _InputIterator __last,
                       size_type __n = 0, const hasher &__hf = hasher(),
                       const key_equal &__eql = key_equal(),
                       const allocator_type &__a = allocator_type())
        : _M_h(__first, __last, __n, __hf, __eql, __a) {}

    unordered_multimap(const unordered_multimap &) = default;

    unordered_multimap(unordered_multimap &&) = default;

    explicit unordered_multimap(const allocator_type &__a) : _M_h(__a) {}

    unordered_multimap(const unordered_multimap &__ummap,
                       const allocator_type &__a)
        : _M_h(__ummap._M_h, __a) {}

    unordered_multimap(
        unordered_multimap &&__ummap,
        const allocator_type
            &__a) noexcept(noexcept(_Hashtable(std::move(__ummap._M_h), __a)))
        : _M_h(std::move(__ummap._M_h), __a) {}
# 1378 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    unordered_multimap(initializer_list<value_type> __l, size_type __n = 0,
                       const hasher &__hf = hasher(),
                       const key_equal &__eql = key_equal(),
                       const allocator_type &__a = allocator_type())
        : _M_h(__l, __n, __hf, __eql, __a) {}

    unordered_multimap(size_type __n, const allocator_type &__a)
        : unordered_multimap(__n, hasher(), key_equal(), __a) {}

    unordered_multimap(size_type __n, const hasher &__hf,
                       const allocator_type &__a)
        : unordered_multimap(__n, __hf, key_equal(), __a) {}

    template <typename _InputIterator>
    unordered_multimap(_InputIterator __first, _InputIterator __last,
                       size_type __n, const allocator_type &__a)
        : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a) {
    }

    template <typename _InputIterator>
    unordered_multimap(_InputIterator __first, _InputIterator __last,
                       size_type __n, const hasher &__hf,
                       const allocator_type &__a)
        : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a) {}

    unordered_multimap(initializer_list<value_type> __l, size_type __n,
                       const allocator_type &__a)
        : unordered_multimap(__l, __n, hasher(), key_equal(), __a) {}

    unordered_multimap(initializer_list<value_type> __l, size_type __n,
                       const hasher &__hf, const allocator_type &__a)
        : unordered_multimap(__l, __n, __hf, key_equal(), __a) {}

    unordered_multimap &operator=(const unordered_multimap &) = default;

    unordered_multimap &operator=(unordered_multimap &&) = default;
# 1440 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    unordered_multimap &operator=(initializer_list<value_type> __l) {
      _M_h = __l;
      return *this;
    }

    allocator_type get_allocator() const noexcept {
      return _M_h.get_allocator();
    }

    [[__nodiscard__]] bool empty() const noexcept { return _M_h.empty(); }

    size_type size() const noexcept { return _M_h.size(); }

    size_type max_size() const noexcept { return _M_h.max_size(); }

    iterator begin() noexcept { return _M_h.begin(); }

    const_iterator begin() const noexcept { return _M_h.begin(); }

    const_iterator cbegin() const noexcept { return _M_h.begin(); }

    iterator end() noexcept { return _M_h.end(); }

    const_iterator end() const noexcept { return _M_h.end(); }

    const_iterator cend() const noexcept { return _M_h.end(); }
# 1532 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    template <typename... _Args> iterator emplace(_Args &&...__args) {
      return _M_h.emplace(std::forward<_Args>(__args)...);
    }
# 1559 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    template <typename... _Args>
    iterator emplace_hint(const_iterator __pos, _Args &&...__args) {
      return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...);
    }
# 1574 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    iterator insert(const value_type &__x) { return _M_h.insert(__x); }

    iterator insert(value_type &&__x) { return _M_h.insert(std::move(__x)); }

    template <typename _Pair>
    __enable_if_t<is_constructible<value_type, _Pair &&>::value, iterator>
    insert(_Pair &&__x) {
      return _M_h.emplace(std::forward<_Pair>(__x));
    }
# 1608 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    iterator insert(const_iterator __hint, const value_type &__x) {
      return _M_h.insert(__hint, __x);
    }

    iterator insert(const_iterator __hint, value_type &&__x) {
      return _M_h.insert(__hint, std::move(__x));
    }

    template <typename _Pair>
    __enable_if_t<is_constructible<value_type, _Pair &&>::value, iterator>
    insert(const_iterator __hint, _Pair &&__x) {
      return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x));
    }
# 1633 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    template <typename _InputIterator>
    void insert(_InputIterator __first, _InputIterator __last) {
      _M_h.insert(__first, __last);
    }
# 1646 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    void insert(initializer_list<value_type> __l) { _M_h.insert(__l); }

    node_type extract(const_iterator __pos) {
      do {
        if (std::__is_constant_evaluated() && !bool(__pos != end()))
          __builtin_unreachable();
      } while (false);
      return _M_h.extract(__pos);
    }

    node_type extract(const key_type &__key) { return _M_h.extract(__key); }

    iterator insert(node_type &&__nh) {
      return _M_h._M_reinsert_node_multi(cend(), std::move(__nh));
    }

    iterator insert(const_iterator __hint, node_type &&__nh) {
      return _M_h._M_reinsert_node_multi(__hint, std::move(__nh));
    }
# 1689 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    iterator erase(const_iterator __position) { return _M_h.erase(__position); }

    iterator erase(iterator __position) { return _M_h.erase(__position); }
# 1710 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    size_type erase(const key_type &__x) { return _M_h.erase(__x); }
# 1729 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    iterator erase(const_iterator __first, const_iterator __last) {
      return _M_h.erase(__first, __last);
    }

    void clear() noexcept { _M_h.clear(); }
# 1753 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    void swap(unordered_multimap &__x) noexcept(noexcept(_M_h.swap(__x._M_h))) {
      _M_h.swap(__x._M_h);
    }

    template <typename, typename, typename>
    friend class std::_Hash_merge_helper;

    template <typename _H2, typename _P2>
    void merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc> &__source) {
      using _Merge_helper = _Hash_merge_helper<unordered_multimap, _H2, _P2>;
      _M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));
    }

    template <typename _H2, typename _P2>
    void merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc> &&__source) {
      merge(__source);
    }

    template <typename _H2, typename _P2>
    void merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc> &__source) {
      using _Merge_helper = _Hash_merge_helper<unordered_multimap, _H2, _P2>;
      _M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));
    }

    template <typename _H2, typename _P2>
    void merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc> &&__source) {
      merge(__source);
    }

    hasher hash_function() const { return _M_h.hash_function(); }

    key_equal key_eq() const { return _M_h.key_eq(); }
# 1819 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    iterator find(const key_type &__x) { return _M_h.find(__x); }

    template <typename _Kt>
    auto find(const _Kt &__x) -> decltype(_M_h._M_find_tr(__x)) {
      return _M_h._M_find_tr(__x);
    }

    const_iterator find(const key_type &__x) const { return _M_h.find(__x); }

    template <typename _Kt>
    auto find(const _Kt &__x) const -> decltype(_M_h._M_find_tr(__x)) {
      return _M_h._M_find_tr(__x);
    }
# 1848 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    size_type count(const key_type &__x) const { return _M_h.count(__x); }

    template <typename _Kt>
    auto count(const _Kt &__x) const -> decltype(_M_h._M_count_tr(__x)) {
      return _M_h._M_count_tr(__x);
    }
# 1867 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    bool contains(const key_type &__x) const {
      return _M_h.find(__x) != _M_h.end();
    }

    template <typename _Kt>
    auto contains(const _Kt &__x) const -> decltype(_M_h._M_find_tr(__x),
                                                    void(), true) {
      return _M_h._M_find_tr(__x) != _M_h.end();
    }
# 1886 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    std::pair<iterator, iterator> equal_range(const key_type &__x) {
      return _M_h.equal_range(__x);
    }

    template <typename _Kt>
    auto equal_range(const _Kt &__x) -> decltype(_M_h._M_equal_range_tr(__x)) {
      return _M_h._M_equal_range_tr(__x);
    }

    std::pair<const_iterator, const_iterator>
    equal_range(const key_type &__x) const {
      return _M_h.equal_range(__x);
    }

    template <typename _Kt>
    auto
    equal_range(const _Kt &__x) const -> decltype(_M_h._M_equal_range_tr(__x)) {
      return _M_h._M_equal_range_tr(__x);
    }

    size_type bucket_count() const noexcept { return _M_h.bucket_count(); }

    size_type max_bucket_count() const noexcept {
      return _M_h.max_bucket_count();
    }

    size_type bucket_size(size_type __n) const { return _M_h.bucket_size(__n); }

    size_type bucket(const key_type &__key) const { return _M_h.bucket(__key); }

    local_iterator begin(size_type __n) { return _M_h.begin(__n); }
# 1958 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    const_local_iterator begin(size_type __n) const { return _M_h.begin(__n); }

    const_local_iterator cbegin(size_type __n) const {
      return _M_h.cbegin(__n);
    }
# 1973 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    local_iterator end(size_type __n) { return _M_h.end(__n); }
# 1984 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    const_local_iterator end(size_type __n) const { return _M_h.end(__n); }

    const_local_iterator cend(size_type __n) const { return _M_h.cend(__n); }

    float load_factor() const noexcept { return _M_h.load_factor(); }

    float max_load_factor() const noexcept { return _M_h.max_load_factor(); }

    void max_load_factor(float __z) { _M_h.max_load_factor(__z); }
# 2021 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    void rehash(size_type __n) { _M_h.rehash(__n); }
# 2032 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
    void reserve(size_type __n) { _M_h.reserve(__n); }

    template <typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
              typename _Alloc1>
    friend bool operator==(
        const unordered_multimap<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &,
        const unordered_multimap<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &);
  };

  template <typename _InputIterator,
            typename _Hash = hash<__iter_key_t<_InputIterator>>,
            typename _Pred = equal_to<__iter_key_t<_InputIterator>>,
            typename _Allocator = allocator<__iter_to_alloc_t<_InputIterator>>,
            typename = _RequireInputIter<_InputIterator>,
            typename = _RequireNotAllocatorOrIntegral<_Hash>,
            typename = _RequireNotAllocator<_Pred>,
            typename = _RequireAllocator<_Allocator>>
  unordered_multimap(_InputIterator, _InputIterator,
                     unordered_multimap<int, int>::size_type = {},
                     _Hash = _Hash(), _Pred = _Pred(),
                     _Allocator = _Allocator())
      -> unordered_multimap<__iter_key_t<_InputIterator>,
                            __iter_val_t<_InputIterator>, _Hash, _Pred,
                            _Allocator>;

  template <typename _Key, typename _Tp, typename _Hash = hash<_Key>,
            typename _Pred = equal_to<_Key>,
            typename _Allocator = allocator<pair<const _Key, _Tp>>,
            typename = _RequireNotAllocatorOrIntegral<_Hash>,
            typename = _RequireNotAllocator<_Pred>,
            typename = _RequireAllocator<_Allocator>>
  unordered_multimap(initializer_list<pair<_Key, _Tp>>,
                     unordered_multimap<int, int>::size_type = {},
                     _Hash = _Hash(), _Pred = _Pred(),
                     _Allocator = _Allocator())
      -> unordered_multimap<_Key, _Tp, _Hash, _Pred, _Allocator>;

  template <typename _InputIterator, typename _Allocator,
            typename = _RequireInputIter<_InputIterator>,
            typename = _RequireAllocator<_Allocator>>
  unordered_multimap(_InputIterator, _InputIterator,
                     unordered_multimap<int, int>::size_type, _Allocator)
      -> unordered_multimap<__iter_key_t<_InputIterator>,
                            __iter_val_t<_InputIterator>,
                            hash<__iter_key_t<_InputIterator>>,
                            equal_to<__iter_key_t<_InputIterator>>, _Allocator>;

  template <typename _InputIterator, typename _Allocator,
            typename = _RequireInputIter<_InputIterator>,
            typename = _RequireAllocator<_Allocator>>
  unordered_multimap(_InputIterator, _InputIterator, _Allocator)
      -> unordered_multimap<__iter_key_t<_InputIterator>,
                            __iter_val_t<_InputIterator>,
                            hash<__iter_key_t<_InputIterator>>,
                            equal_to<__iter_key_t<_InputIterator>>, _Allocator>;

  template <typename _InputIterator, typename _Hash, typename _Allocator,
            typename = _RequireInputIter<_InputIterator>,
            typename = _RequireNotAllocatorOrIntegral<_Hash>,
            typename = _RequireAllocator<_Allocator>>
  unordered_multimap(_InputIterator, _InputIterator,
                     unordered_multimap<int, int>::size_type, _Hash, _Allocator)
      -> unordered_multimap<__iter_key_t<_InputIterator>,
                            __iter_val_t<_InputIterator>, _Hash,
                            equal_to<__iter_key_t<_InputIterator>>, _Allocator>;

  template <typename _Key, typename _Tp, typename _Allocator,
            typename = _RequireAllocator<_Allocator>>
  unordered_multimap(initializer_list<pair<_Key, _Tp>>,
                     unordered_multimap<int, int>::size_type, _Allocator)
      -> unordered_multimap<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>;

  template <typename _Key, typename _Tp, typename _Allocator,
            typename = _RequireAllocator<_Allocator>>
  unordered_multimap(initializer_list<pair<_Key, _Tp>>, _Allocator)
      -> unordered_multimap<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>;

  template <typename _Key, typename _Tp, typename _Hash, typename _Allocator,
            typename = _RequireNotAllocatorOrIntegral<_Hash>,
            typename = _RequireAllocator<_Allocator>>
  unordered_multimap(initializer_list<pair<_Key, _Tp>>,
                     unordered_multimap<int, int>::size_type, _Hash, _Allocator)
      -> unordered_multimap<_Key, _Tp, _Hash, equal_to<_Key>, _Allocator>;

  template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
  inline void swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> & __x,
                   unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &
                       __y) noexcept(noexcept(__x.swap(__y))) {
    __x.swap(__y);
  }

  template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
  inline void swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> & __x,
                   unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &
                       __y) noexcept(noexcept(__x.swap(__y))) {
    __x.swap(__y);
  }

  template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
  inline bool operator==(
      const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__x,
      const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &__y) {
    return __x._M_h._M_equal(__y._M_h);
  }
# 2155 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
  template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
  inline bool operator==(
      const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__x,
      const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &__y) {
    return __x._M_h._M_equal(__y._M_h);
  }
# 2173 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unordered_map.h" 3
  template <typename _Key, typename _Val, typename _Hash1, typename _Eq1,
            typename _Alloc, typename _Hash2, typename _Eq2>
  struct _Hash_merge_helper<
      std::unordered_map<_Key, _Val, _Hash1, _Eq1, _Alloc>, _Hash2, _Eq2> {
  private:
    template <typename... _Tp> using unordered_map = std::unordered_map<_Tp...>;
    template <typename... _Tp>
    using unordered_multimap = std::unordered_multimap<_Tp...>;

    friend unordered_map<_Key, _Val, _Hash1, _Eq1, _Alloc>;

    static auto &
    _S_get_table(unordered_map<_Key, _Val, _Hash2, _Eq2, _Alloc> &__map) {
      return __map._M_h;
    }

    static auto &
    _S_get_table(unordered_multimap<_Key, _Val, _Hash2, _Eq2, _Alloc> &__map) {
      return __map._M_h;
    }
  };

  template <typename _Key, typename _Val, typename _Hash1, typename _Eq1,
            typename _Alloc, typename _Hash2, typename _Eq2>
  struct _Hash_merge_helper<
      std::unordered_multimap<_Key, _Val, _Hash1, _Eq1, _Alloc>, _Hash2, _Eq2> {
  private:
    template <typename... _Tp> using unordered_map = std::unordered_map<_Tp...>;
    template <typename... _Tp>
    using unordered_multimap = std::unordered_multimap<_Tp...>;

    friend unordered_multimap<_Key, _Val, _Hash1, _Eq1, _Alloc>;

    static auto &
    _S_get_table(unordered_map<_Key, _Val, _Hash2, _Eq2, _Alloc> &__map) {
      return __map._M_h;
    }

    static auto &
    _S_get_table(unordered_multimap<_Key, _Val, _Hash2, _Eq2, _Alloc> &__map) {
      return __map._M_h;
    }
  };

} // namespace std
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/unordered_map" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/erase_if.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/erase_if.h" 3

namespace std {

namespace __detail {
template <typename _Container, typename _UnsafeContainer, typename _Predicate>
typename _Container::size_type __erase_nodes_if(_Container &__cont,
                                                _UnsafeContainer &__ucont,
                                                _Predicate __pred) {
  typename _Container::size_type __num = 0;
  for (auto __iter = __ucont.begin(), __last = __ucont.end();
       __iter != __last;) {
    if (__pred(*__iter)) {
      __iter = __cont.erase(__iter);
      ++__num;
    } else
      ++__iter;
  }
  return __num;
}
} // namespace __detail

} // namespace std
# 44 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/unordered_map" 2 3

namespace std __attribute__((__visibility__("default"))) {

  namespace pmr {
  template <typename _Key, typename _Tp, typename _Hash = std::hash<_Key>,
            typename _Pred = std::equal_to<_Key>>
  using unordered_map =
      std::unordered_map<_Key, _Tp, _Hash, _Pred,
                         polymorphic_allocator<pair<const _Key, _Tp>>>;
  template <typename _Key, typename _Tp, typename _Hash = std::hash<_Key>,
            typename _Pred = std::equal_to<_Key>>
  using unordered_multimap =
      std::unordered_multimap<_Key, _Tp, _Hash, _Pred,
                              polymorphic_allocator<pair<const _Key, _Tp>>>;
  } // namespace pmr

} // namespace std

namespace std __attribute__((__visibility__("default"))) {

  template <typename _Key, typename _Tp, typename _Hash, typename _CPred,
            typename _Alloc, typename _Predicate>
  inline typename unordered_map<_Key, _Tp, _Hash, _CPred, _Alloc>::size_type
  erase_if(unordered_map<_Key, _Tp, _Hash, _CPred, _Alloc> & __cont,
           _Predicate __pred) {
    std::unordered_map<_Key, _Tp, _Hash, _CPred, _Alloc> &__ucont = __cont;
    return __detail::__erase_nodes_if(__cont, __ucont, __pred);
  }

  template <typename _Key, typename _Tp, typename _Hash, typename _CPred,
            typename _Alloc, typename _Predicate>
  inline
      typename unordered_multimap<_Key, _Tp, _Hash, _CPred, _Alloc>::size_type
      erase_if(unordered_multimap<_Key, _Tp, _Hash, _CPred, _Alloc> & __cont,
               _Predicate __pred) {
    std::unordered_multimap<_Key, _Tp, _Hash, _CPred, _Alloc> &__ucont = __cont;
    return __detail::__erase_nodes_if(__cont, __ucont, __pred);
  }

} // namespace std
# 36 "./SparseMatrix.hpp" 2
using GlobalToLocalMap = std::unordered_map<global_int_t, local_int_t>;

struct SparseMatrix_STRUCT {
  char *title;
  Geometry *geom;
  global_int_t totalNumberOfRows;
  global_int_t totalNumberOfNonzeros;
  local_int_t localNumberOfRows;
  local_int_t localNumberOfColumns;
  local_int_t localNumberOfNonzeros;
  char *nonzerosInRow;
  global_int_t **mtxIndG;
  local_int_t **mtxIndL;
  double **matrixValues;
  double **matrixDiagonal;
  GlobalToLocalMap globalToLocalMap;
  std::vector<global_int_t> localToGlobalMap;
  mutable bool isDotProductOptimized;
  mutable bool isSpmvOptimized;
  mutable bool isMgOptimized;
  mutable bool isWaxpbyOptimized;

  mutable struct SparseMatrix_STRUCT *Ac;
  mutable MGData *mgData;
  void *optimizationData;
# 76 "./SparseMatrix.hpp"
};
typedef struct SparseMatrix_STRUCT SparseMatrix;

inline void InitializeSparseMatrix(SparseMatrix &A, Geometry *geom) {
  A.title = 0;
  A.geom = geom;
  A.totalNumberOfRows = 0;
  A.totalNumberOfNonzeros = 0;
  A.localNumberOfRows = 0;
  A.localNumberOfColumns = 0;
  A.localNumberOfNonzeros = 0;
  A.nonzerosInRow = 0;
  A.mtxIndG = 0;
  A.mtxIndL = 0;
  A.matrixValues = 0;
  A.matrixDiagonal = 0;

  A.isDotProductOptimized = true;
  A.isSpmvOptimized = true;
  A.isMgOptimized = true;
  A.isWaxpbyOptimized = true;
# 115 "./SparseMatrix.hpp"
  A.mgData = 0;
  A.Ac = 0;
  return;
}

inline void CopyMatrixDiagonal(SparseMatrix &A, Vector &diagonal) {
  double **curDiagA = A.matrixDiagonal;
  double *dv = diagonal.values;
  (static_cast<bool>(A.localNumberOfRows == diagonal.localLength)
       ? void(0)
       : __assert_fail("A.localNumberOfRows==diagonal.localLength",
                       __builtin_FILE(), __builtin_LINE(),
                       __extension__ __PRETTY_FUNCTION__));
  for (local_int_t i = 0; i < A.localNumberOfRows; ++i)
    dv[i] = *(curDiagA[i]);
  return;
}

inline void ReplaceMatrixDiagonal(SparseMatrix &A, Vector &diagonal) {
  double **curDiagA = A.matrixDiagonal;
  double *dv = diagonal.values;
  (static_cast<bool>(A.localNumberOfRows == diagonal.localLength)
       ? void(0)
       : __assert_fail("A.localNumberOfRows==diagonal.localLength",
                       __builtin_FILE(), __builtin_LINE(),
                       __extension__ __PRETTY_FUNCTION__));
  for (local_int_t i = 0; i < A.localNumberOfRows; ++i)
    *(curDiagA[i]) = dv[i];
  return;
}

inline void DeleteMatrix(SparseMatrix &A) {

  for (local_int_t i = 0; i < A.localNumberOfRows; ++i) {
    delete[] A.matrixValues[i];
    delete[] A.mtxIndG[i];
    delete[] A.mtxIndL[i];
  }

  if (A.title)
    delete[] A.title;
  if (A.nonzerosInRow)
    delete[] A.nonzerosInRow;
  if (A.mtxIndG)
    delete[] A.mtxIndG;
  if (A.mtxIndL)
    delete[] A.mtxIndL;
  if (A.matrixValues)
    delete[] A.matrixValues;
  if (A.matrixDiagonal)
    delete[] A.matrixDiagonal;
# 179 "./SparseMatrix.hpp"
  if (A.geom != 0) {
    DeleteGeometry(*A.geom);
    delete A.geom;
    A.geom = 0;
  }
  if (A.Ac != 0) {
    DeleteMatrix(*A.Ac);
    delete A.Ac;
    A.Ac = 0;
  }
  if (A.mgData != 0) {
    DeleteMGData(*A.mgData);
    delete A.mgData;
    A.mgData = 0;
  }
  return;
}
# 25 "./CGData.hpp" 2

struct CGData_STRUCT {
  Vector r;
  Vector z;
  Vector p;
  Vector Ap;
};
typedef struct CGData_STRUCT CGData;

inline void InitializeSparseCGData(SparseMatrix &A, CGData &data) {
  local_int_t nrow = A.localNumberOfRows;
  local_int_t ncol = A.localNumberOfColumns;
  InitializeVector(data.r, nrow);
  InitializeVector(data.z, ncol);
  InitializeVector(data.p, ncol);
  InitializeVector(data.Ap, nrow);
  return;
}

inline void DeleteCGData(CGData &data) {

  DeleteVector(data.r);
  DeleteVector(data.z);
  DeleteVector(data.p);
  DeleteVector(data.Ap);
  return;
}
# 5 "CG_stdexec.hpp" 2
# 1 "./hpcg.hpp" 1
# 27 "./hpcg.hpp"
extern std::ofstream HPCG_fout;

struct HPCG_Params_STRUCT {
  int comm_size;
  int comm_rank;
  int numThreads;
  local_int_t nx;
  local_int_t ny;
  local_int_t nz;
  int runningTime;
  int npx;
  int npy;
  int npz;
  int pz;
  local_int_t zl;
  local_int_t zu;
};

typedef HPCG_Params_STRUCT HPCG_Params;

extern int HPCG_Init(int *argc_p, char ***argv_p, HPCG_Params &params);
extern int HPCG_Finalize(void);
# 6 "CG_stdexec.hpp" 2
# 1 "./ComputeMG_stdexec.hpp" 1

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 1 3
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 2 3
# 4 "./ComputeMG_stdexec.hpp" 2

# 1 "./ComputeSYMGS_stdexec.hpp" 1

# 1 "./../stdexec/include/stdexec/execution.hpp" 1
# 18 "./../stdexec/include/stdexec/execution.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__execution_fwd.hpp" 1
# 18 "./../stdexec/include/stdexec/__detail/__execution_fwd.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__config.hpp" 1
# 32 "./../stdexec/include/stdexec/__detail/__config.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__preprocessor.hpp" 1
# 33 "./../stdexec/include/stdexec/__detail/__config.hpp" 2

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/version" 1 3
# 36 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/version" 3
# 36 "./../stdexec/include/stdexec/__detail/__config.hpp" 2

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 1 3
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 2 3
# 41 "./../stdexec/include/stdexec/__detail/__config.hpp" 2
# 131 "./../stdexec/include/stdexec/__detail/__config.hpp"
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/coroutine" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/coroutine" 3
# 54 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/coroutine" 3
namespace std __attribute__((__visibility__("default"))) {

  inline namespace __n4861 {

  template <typename _Result, typename... _ArgTypes> struct coroutine_traits;

  template <typename _Result, typename = void>
  struct __coroutine_traits_impl {};

  template <typename _Result>

    requires requires { typename _Result::promise_type; }
  struct __coroutine_traits_impl<_Result, void>

  {
    using promise_type = typename _Result::promise_type;
  };

  template <typename _Result, typename... _ArgTypes>
  struct coroutine_traits : __coroutine_traits_impl<_Result> {};

  template <typename _Promise = void> struct coroutine_handle;

  template <> struct coroutine_handle<void> {
  public:
    constexpr coroutine_handle() noexcept : _M_fr_ptr(0) {}

    constexpr coroutine_handle(std::nullptr_t __h) noexcept : _M_fr_ptr(__h) {}

    coroutine_handle &operator=(std::nullptr_t) noexcept {
      _M_fr_ptr = nullptr;
      return *this;
    }

  public:
    constexpr void *address() const noexcept { return _M_fr_ptr; }

    constexpr static coroutine_handle from_address(void *__a) noexcept {
      coroutine_handle __self;
      __self._M_fr_ptr = __a;
      return __self;
    }

  public:
    constexpr explicit operator bool() const noexcept {
      return bool(_M_fr_ptr);
    }

    bool done() const noexcept { return __builtin_coro_done(_M_fr_ptr); }

    void operator()() const { resume(); }

    void resume() const { __builtin_coro_resume(_M_fr_ptr); }

    void destroy() const { __builtin_coro_destroy(_M_fr_ptr); }

  protected:
    void *_M_fr_ptr;
  };

  constexpr bool operator==(coroutine_handle<> __a,
                            coroutine_handle<> __b) noexcept {
    return __a.address() == __b.address();
  }

  constexpr strong_ordering operator<=>(coroutine_handle<> __a,
                                        coroutine_handle<> __b) noexcept {
    return std::compare_three_way()(__a.address(), __b.address());
  }
# 190 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/coroutine" 3
  template <typename _Promise> struct coroutine_handle {

    constexpr coroutine_handle() noexcept {}

    constexpr coroutine_handle(nullptr_t) noexcept {}

    static coroutine_handle from_promise(_Promise &__p) {
      coroutine_handle __self;
      __self._M_fr_ptr =
          __builtin_coro_promise((char *)&__p, __alignof(_Promise), true);
      return __self;
    }

    coroutine_handle &operator=(nullptr_t) noexcept {
      _M_fr_ptr = nullptr;
      return *this;
    }

    constexpr void *address() const noexcept { return _M_fr_ptr; }

    constexpr static coroutine_handle from_address(void *__a) noexcept {
      coroutine_handle __self;
      __self._M_fr_ptr = __a;
      return __self;
    }

    constexpr operator coroutine_handle<>() const noexcept {
      return coroutine_handle<>::from_address(address());
    }

    constexpr explicit operator bool() const noexcept {
      return bool(_M_fr_ptr);
    }

    bool done() const noexcept { return __builtin_coro_done(_M_fr_ptr); }

    void operator()() const { resume(); }

    void resume() const { __builtin_coro_resume(_M_fr_ptr); }

    void destroy() const { __builtin_coro_destroy(_M_fr_ptr); }

    _Promise &promise() const {
      void *__t = __builtin_coro_promise(_M_fr_ptr, __alignof(_Promise), false);
      return *static_cast<_Promise *>(__t);
    }

  private:
    void *_M_fr_ptr = nullptr;
  };

  struct noop_coroutine_promise {};

  template <> struct coroutine_handle<noop_coroutine_promise> {

    constexpr operator coroutine_handle<>() const noexcept {
      return coroutine_handle<>::from_address(address());
    }

    constexpr explicit operator bool() const noexcept { return true; }

    constexpr bool done() const noexcept { return false; }

    void operator()() const noexcept {}

    void resume() const noexcept {}

    void destroy() const noexcept {}

    noop_coroutine_promise &promise() const noexcept { return _S_fr.__p; }

    constexpr void *address() const noexcept { return _M_fr_ptr; }

  private:
    friend coroutine_handle noop_coroutine() noexcept;

    struct __frame {
      static void __dummy_resume_destroy() {}

      void (*__r)() = __dummy_resume_destroy;
      void (*__d)() = __dummy_resume_destroy;
      struct noop_coroutine_promise __p;
    };

    static __frame _S_fr;

    explicit coroutine_handle() noexcept = default;

    void *_M_fr_ptr = &_S_fr;
  };

  using noop_coroutine_handle = coroutine_handle<noop_coroutine_promise>;

  inline noop_coroutine_handle::__frame noop_coroutine_handle::_S_fr{};

  inline noop_coroutine_handle noop_coroutine() noexcept {
    return noop_coroutine_handle();
  }

  struct suspend_always {
    constexpr bool await_ready() const noexcept { return false; }

    constexpr void await_suspend(coroutine_handle<>) const noexcept {}

    constexpr void await_resume() const noexcept {}
  };

  struct suspend_never {
    constexpr bool await_ready() const noexcept { return true; }

    constexpr void await_suspend(coroutine_handle<>) const noexcept {}

    constexpr void await_resume() const noexcept {}
  };

  } // namespace __n4861

  template <typename _Tp> struct hash;

  template <typename _Promise> struct hash<coroutine_handle<_Promise>> {
    size_t operator()(const coroutine_handle<_Promise> &__h) const noexcept {
      return reinterpret_cast<size_t>(__h.address());
    }
  };

} // namespace std
# 132 "./../stdexec/include/stdexec/__detail/__config.hpp" 2

namespace __coro = std;
# 343 "./../stdexec/include/stdexec/__detail/__config.hpp"
namespace stdexec {
template <class Ty> using _remove_reference_t = __remove_reference_t(Ty);
}

namespace stdexec {
template <class _Ap, class _Bp> inline constexpr bool __same_as_v = false;

template <class _Ap> inline constexpr bool __same_as_v<_Ap, _Ap> = true;
} // namespace stdexec
# 563 "./../stdexec/include/stdexec/__detail/__config.hpp"
namespace stdexec {}
# 19 "./../stdexec/include/stdexec/__detail/__execution_fwd.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__meta.hpp" 1
# 19 "./../stdexec/include/stdexec/__detail/__meta.hpp"
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 1 3
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 2 3
# 20 "./../stdexec/include/stdexec/__detail/__meta.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__concepts.hpp" 1
# 23 "./../stdexec/include/stdexec/__detail/__concepts.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__type_traits.hpp" 1
# 21 "./../stdexec/include/stdexec/__detail/__type_traits.hpp"
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/utility" 1 3
# 59 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/utility" 3
# 68 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/utility" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_relops.h" 1 3
# 62 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_relops.h" 3
namespace std __attribute__((__visibility__("default"))) {

  namespace rel_ops {
# 86 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_relops.h" 3
  template <class _Tp> inline bool operator!=(const _Tp &__x, const _Tp &__y) {
    return !(__x == __y);
  }
# 99 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_relops.h" 3
  template <class _Tp> inline bool operator>(const _Tp &__x, const _Tp &__y) {
    return __y < __x;
  }
# 112 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_relops.h" 3
  template <class _Tp> inline bool operator<=(const _Tp &__x, const _Tp &__y) {
    return !(__y < __x);
  }
# 125 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_relops.h" 3
  template <class _Tp> inline bool operator>=(const _Tp &__x, const _Tp &__y) {
    return !(__x < __y);
  }
  } // namespace rel_ops

} // namespace std
# 69 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/utility" 2 3
# 82 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/utility" 3
namespace std __attribute__((__visibility__("default"))) {
# 94 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/utility" 3
  template <typename _Tp, typename _Up = _Tp>
  constexpr inline _Tp exchange(_Tp & __obj, _Up && __new_val) noexcept(
      __and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_assignable<_Tp &, _Up>>::value) {
    return std::__exchange(__obj, std::forward<_Up>(__new_val));
  }

  template <typename _Tp>
  [[nodiscard]]
  constexpr add_const_t<_Tp> &as_const(_Tp & __t) noexcept {
    return __t;
  }

  template <typename _Tp> void as_const(const _Tp &&) = delete;

  template <typename _Tp, typename _Up>
  constexpr bool cmp_equal(_Tp __t, _Up __u) noexcept {
    static_assert(__is_standard_integer<_Tp>::value);
    static_assert(__is_standard_integer<_Up>::value);

    if constexpr (is_signed_v<_Tp> == is_signed_v<_Up>)
      return __t == __u;
    else if constexpr (is_signed_v<_Tp>)
      return __t >= 0 && make_unsigned_t<_Tp>(__t) == __u;
    else
      return __u >= 0 && __t == make_unsigned_t<_Up>(__u);
  }

  template <typename _Tp, typename _Up>
  constexpr bool cmp_not_equal(_Tp __t, _Up __u) noexcept {
    return !std::cmp_equal(__t, __u);
  }

  template <typename _Tp, typename _Up>
  constexpr bool cmp_less(_Tp __t, _Up __u) noexcept {
    static_assert(__is_standard_integer<_Tp>::value);
    static_assert(__is_standard_integer<_Up>::value);

    if constexpr (is_signed_v<_Tp> == is_signed_v<_Up>)
      return __t < __u;
    else if constexpr (is_signed_v<_Tp>)
      return __t < 0 || make_unsigned_t<_Tp>(__t) < __u;
    else
      return __u >= 0 && __t < make_unsigned_t<_Up>(__u);
  }

  template <typename _Tp, typename _Up>
  constexpr bool cmp_greater(_Tp __t, _Up __u) noexcept {
    return std::cmp_less(__u, __t);
  }

  template <typename _Tp, typename _Up>
  constexpr bool cmp_less_equal(_Tp __t, _Up __u) noexcept {
    return !std::cmp_less(__u, __t);
  }

  template <typename _Tp, typename _Up>
  constexpr bool cmp_greater_equal(_Tp __t, _Up __u) noexcept {
    return !std::cmp_less(__t, __u);
  }

  template <typename _Res, typename _Tp>
  constexpr bool in_range(_Tp __t) noexcept {
    static_assert(__is_standard_integer<_Res>::value);
    static_assert(__is_standard_integer<_Tp>::value);
    using __gnu_cxx::__int_traits;

    if constexpr (is_signed_v<_Tp> == is_signed_v<_Res>)
      return __int_traits<_Res>::__min <= __t &&
             __t <= __int_traits<_Res>::__max;
    else if constexpr (is_signed_v<_Tp>)
      return __t >= 0 && make_unsigned_t<_Tp>(__t) <= __int_traits<_Res>::__max;
    else
      return __t <= make_unsigned_t<_Res>(__int_traits<_Res>::__max);
  }
# 225 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/utility" 3
} // namespace std
# 22 "./../stdexec/include/stdexec/__detail/__type_traits.hpp" 2

namespace stdexec {

template <class _Tp> extern auto (*__declval)() noexcept -> _Tp &&;

namespace __tt {
template <class> struct __wrap;

template <bool> struct __decay_ {
  template <class _Ty> using __f = __decay(_Ty);
};
} // namespace __tt
template <class _Ty>
using __decay_t = typename __tt::__decay_<sizeof(__tt::__wrap<_Ty> *) ==
                                          ~0ul>::template __f<_Ty>;
# 135 "./../stdexec/include/stdexec/__detail/__type_traits.hpp"
struct __cp {
  template <class _Tp> using __f = _Tp;
};

struct __cpc {
  template <class _Tp> using __f = const _Tp;
};

struct __cplr {
  template <class _Tp> using __f = _Tp &;
};

struct __cprr {
  template <class _Tp> using __f = _Tp &&;
};

struct __cpclr {
  template <class _Tp> using __f = const _Tp &;
};

struct __cpcrr {
  template <class _Tp> using __f = const _Tp &&;
};

template <class> extern __cp __cpcvr;
template <class _Tp> extern __cpc __cpcvr<const _Tp>;
template <class _Tp> extern __cplr __cpcvr<_Tp &>;
template <class _Tp> extern __cprr __cpcvr<_Tp &&>;
template <class _Tp> extern __cpclr __cpcvr<const _Tp &>;
template <class _Tp> extern __cpcrr __cpcvr<const _Tp &&>;
template <class _Tp> using __copy_cvref_fn = decltype(__cpcvr<_Tp>);

template <class _From, class _To>
using __copy_cvref_t = typename __copy_cvref_fn<_From>::template __f<_To>;

template <class> inline constexpr bool __is_const_ = false;
template <class _Up> inline constexpr bool __is_const_<_Up const> = true;

namespace __tt {
template <class _Ty> auto __remove_rvalue_reference_fn(_Ty &&) -> _Ty;
}

template <class _Ty>
using __remove_rvalue_reference_t =
    decltype(__tt::__remove_rvalue_reference_fn(__declval<_Ty>()));

struct __cref_fn {
  template <class _Ty> auto operator()(const _Ty &) -> const _Ty &;
};
template <class _Ty> using __cref_t = decltype(__cref_fn{}(__declval<_Ty>()));

template <bool _Bp> struct __mbool : std::bool_constant<_Bp> {};

using __mtrue = __mbool<true>;
using __mfalse = __mbool<false>;

} // namespace stdexec
# 24 "./../stdexec/include/stdexec/__detail/__concepts.hpp" 2
# 40 "./../stdexec/include/stdexec/__detail/__concepts.hpp"
namespace stdexec {

template <class _Fun, class... _As>
concept __callable = requires(_Fun &&__fun, _As &&...__as) {
  static_cast<_Fun &&>(__fun)(static_cast<_As &&>(__as)...);
};
template <class _Fun, class... _As>
concept __nothrow_callable =
    __callable<_Fun, _As...> && requires(_Fun &&__fun, _As &&...__as) {
      { static_cast<_Fun &&>(__fun)(static_cast<_As &&>(__as)...) } noexcept;
    };

template <class...> struct __types;

template <class... _Ts>
concept __typename = requires { typename __types<_Ts...>; };

template <class _Ap, class _Bp>
concept __same_as = __is_same(_Ap, _Bp);

template <class _Ty, class _Up>
concept __decays_to = __same_as<__decay_t<_Ty>, _Up>;

template <class _Ty, class _Up>
concept __not_decays_to = !__decays_to<_Ty, _Up>;

template <bool _TrueOrFalse>
concept __satisfies = _TrueOrFalse;

template <class...>
concept __true = true;

template <class _Cp>
concept __class = __true<int _Cp::*> && (!__same_as<const _Cp, _Cp>);

template <class _Ty, class... _As>
concept __one_of = (__same_as<_Ty, _As> || ...);

template <class _Ty, class... _Us>
concept __all_of = (__same_as<_Ty, _Us> && ...);

template <class _Ty, class... _Us>
concept __none_of = ((!__same_as<_Ty, _Us>) && ...);

template <class, template <class...> class>
constexpr bool __is_instance_of_ = false;
template <class... _As, template <class...> class _Ty>
constexpr bool __is_instance_of_<_Ty<_As...>, _Ty> = true;

template <class _Ay, template <class...> class _Ty>
concept __is_instance_of = __is_instance_of_<_Ay, _Ty>;

template <class _Ay, template <class...> class _Ty>
concept __is_not_instance_of = !__is_instance_of<_Ay, _Ty>;
} // namespace stdexec

namespace stdexec::__std_concepts {

template <class _Ap, class _Bp>
concept same_as = __same_as<_Ap, _Bp> && __same_as<_Bp, _Ap>;

using std::convertible_to;
using std::derived_from;
using std::equality_comparable;
using std::integral;
# 132 "./../stdexec/include/stdexec/__detail/__concepts.hpp"
} // namespace stdexec::__std_concepts

namespace stdexec {
using namespace __std_concepts;

template <class _Ty>
concept destructible = __is_nothrow_destructible(_Ty);
# 158 "./../stdexec/include/stdexec/__detail/__concepts.hpp"
template <class _Ty, class... _As>
concept constructible_from =
    destructible<_Ty> && __is_constructible(_Ty, _As...);

template <class _Ty>
concept default_initializable =
    constructible_from<_Ty> && requires { _Ty{}; } && requires { ::new _Ty; };

template <class _Ty>
concept move_constructible = constructible_from<_Ty, _Ty>;

template <class _Ty>
concept copy_constructible =
    move_constructible<_Ty> && constructible_from<_Ty, _Ty const &>;

template <class _LHS, class _RHS>
concept assignable_from = same_as<_LHS, _LHS &> &&

                          requires(_LHS __lhs, _RHS &&__rhs) {
                            {
                              __lhs = static_cast<_RHS &&>(__rhs)
                            } -> same_as<_LHS>;
                          };

namespace __swap {
using std::swap;

template <class _Ty, class _Uy>
concept swappable_with = requires(_Ty &&__t, _Uy &&__u) {
  swap(static_cast<_Ty &&>(__t), static_cast<_Uy &&>(__u));
};

inline constexpr auto const __fn =
    []<class _Ty, swappable_with<_Ty> _Uy>(_Ty &&__t, _Uy &&__u) noexcept(
        noexcept(swap(static_cast<_Ty &&>(__t), static_cast<_Uy &&>(__u)))) {
      swap(static_cast<_Ty &&>(__t), static_cast<_Uy &&>(__u));
    };
} // namespace __swap

using __swap::swappable_with;
inline constexpr auto const &swap = __swap::__fn;

template <class _Ty>
concept swappable = requires(_Ty &a, _Ty &b) { swap(a, b); };

template <class _Ty>
concept movable = std::is_object_v<_Ty> && move_constructible<_Ty> &&
                  assignable_from<_Ty &, _Ty> && swappable<_Ty>;

template <class _Ty>
concept copyable =
    copy_constructible<_Ty> && movable<_Ty> && assignable_from<_Ty &, _Ty &> &&
    assignable_from<_Ty &, const _Ty &> && assignable_from<_Ty &, const _Ty>;

template <class _Ty>
concept semiregular = copyable<_Ty> && default_initializable<_Ty>;

template <class _Ty>
concept regular = semiregular<_Ty> && equality_comparable<_Ty>;

template <class _Ty>
concept __boolean_testable_ = convertible_to<_Ty, bool>;

template <class T, class U>
concept __partially_ordered_with = requires(__cref_t<T> t, __cref_t<U> u) {
  { t < u } -> __boolean_testable_;
  { t > u } -> __boolean_testable_;
  { t <= u } -> __boolean_testable_;
  { t >= u } -> __boolean_testable_;
  { u < t } -> __boolean_testable_;
  { u > t } -> __boolean_testable_;
  { u <= t } -> __boolean_testable_;
  { u >= t } -> __boolean_testable_;
};

template <class _Ty>
concept totally_ordered =
    equality_comparable<_Ty> && __partially_ordered_with<_Ty, _Ty>;

template <class _Ty>
concept __movable_value = move_constructible<__decay_t<_Ty>> &&
                          constructible_from<__decay_t<_Ty>, _Ty>;

template <class _Ty>
concept __nothrow_movable_value = __movable_value<_Ty> && requires(_Ty &&__t) {
  { __decay_t<_Ty>{__decay_t<_Ty>{static_cast<_Ty &&>(__t)}} } noexcept;
};

template <class _Ty, class... _As>
concept __nothrow_constructible_from =
    constructible_from<_Ty, _As...> && __is_nothrow_constructible(_Ty, _As...);

template <class _Ty>
concept __nothrow_move_constructible = __nothrow_constructible_from<_Ty, _Ty>;

template <class _Ty>
concept __nothrow_copy_constructible =
    __nothrow_constructible_from<_Ty, const _Ty &>;

template <class... _Ts>
concept __decay_copyable = (constructible_from<__decay_t<_Ts>, _Ts> && ...);

template <class... _Ts>
using __decay_copyable_t = __mbool<__decay_copyable<_Ts...>>;

template <class... _Ts>
concept __nothrow_decay_copyable =
    (__nothrow_constructible_from<__decay_t<_Ts>, _Ts> && ...);

template <class... _Ts>
using __nothrow_decay_copyable_t = __mbool<__nothrow_decay_copyable<_Ts...>>;

template <class _Ty, class _Up>
concept __decays_to_derived_from = derived_from<__decay_t<_Ty>, _Up>;
} // namespace stdexec
# 25 "./../stdexec/include/stdexec/__detail/__meta.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__utility.hpp" 1
# 25 "./../stdexec/include/stdexec/__detail/__utility.hpp"
namespace stdexec {
constexpr std::size_t __npos = ~0UL;

template <class...> struct __undefined;

struct __ {};

struct __ignore {
  __ignore() = default;

  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr __ignore(auto &&...) noexcept {}
};
# 51 "./../stdexec/include/stdexec/__detail/__utility.hpp"
template <std::size_t> using __ignore_t = __ignore;

struct __none_such {};

namespace {
struct __anon {};
} // namespace

struct __immovable {
  __immovable() = default;

private:
  __immovable(__immovable &&) = delete;
};

struct __move_only {
  __move_only() = default;

  __move_only(__move_only &&) noexcept = default;
  auto operator=(__move_only &&) noexcept -> __move_only & = default;

  __move_only(const __move_only &) = delete;
  auto operator=(const __move_only &) -> __move_only & = delete;
};

inline constexpr auto
__umax(std::initializer_list<std::size_t> __il) noexcept -> std::size_t {
  std::size_t __m = 0;
  for (std::size_t __i : __il) {
    if (__i > __m) {
      __m = __i;
    }
  }
  return __m;
}

inline constexpr auto
__pos_of(const bool *const __first,
         const bool *const __last) noexcept -> std::size_t {
  for (const bool *__where = __first; __where != __last; ++__where) {
    if (*__where) {
      return static_cast<std::size_t>(__where - __first);
    }
  }
  return __npos;
}

template <class _Ty, class... _Ts>
inline constexpr auto __index_of() noexcept -> std::size_t {
  constexpr bool __same[] = {__is_same(_Ty, _Ts)..., false};
  return __pos_of(__same, __same + sizeof...(_Ts));
}

namespace __detail {
template <class _Cpcvref> struct __forward_like_fn {
  template <class _Uy>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr auto
  operator()(_Uy &&__uy) const noexcept -> auto && {
    return static_cast<
        typename _Cpcvref::template __f<std::remove_reference_t<_Uy>>>(__uy);
  }
};
} // namespace __detail

template <class _Ty>
inline constexpr __detail::__forward_like_fn<__copy_cvref_fn<_Ty &&>>
    __forward_like{};

#pragma GCC diagnostic push
# 117 "./../stdexec/include/stdexec/__detail/__utility.hpp"
#pragma GCC diagnostic ignored "-Wpragmas"
# 117 "./../stdexec/include/stdexec/__detail/__utility.hpp"
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
# 117 "./../stdexec/include/stdexec/__detail/__utility.hpp"
#pragma GCC diagnostic ignored "-Wunknown-warning-option"
# 117 "./../stdexec/include/stdexec/__detail/__utility.hpp"
#pragma GCC diagnostic ignored "-Wunknown-attributes"
# 117 "./../stdexec/include/stdexec/__detail/__utility.hpp"
#pragma GCC diagnostic ignored "-Wattributes"
#pragma GCC diagnostic ignored "-Wold-style-cast"

template <class _Tp, class _Up>

auto __c_upcast(_Up &&u) noexcept -> __copy_cvref_t<_Up &&, _Tp>
  requires __decays_to<_Tp, _Tp>
{
  static_assert(__is_base_of(_Tp, __decay_t<_Up>));
  return (__copy_cvref_t<_Up &&, _Tp>)static_cast<_Up &&>(u);
}

template <class _Tp, class _Up>

auto __c_downcast(_Up &&u) noexcept -> __copy_cvref_t<_Up &&, _Tp>
  requires __decays_to<_Tp, _Tp>
{
  static_assert(__is_base_of(__decay_t<_Up>, _Tp));
  return (__copy_cvref_t<_Up &&, _Tp>)static_cast<_Up &&>(u);
}

#pragma GCC diagnostic pop

template <class _Ty> auto __decay_copy(_Ty) noexcept -> _Ty;

template <class _Ty> struct __indestructible {
  template <class... _Us>
  constexpr __indestructible(_Us &&...__us) noexcept(
      __nothrow_constructible_from<_Ty, _Us...>)
      : __value(static_cast<_Us &&>(__us)...) {}

  constexpr ~__indestructible() {}

  auto get() noexcept -> _Ty & { return __value; }

  auto get() const noexcept -> const _Ty & { return __value; }

  union {
    _Ty __value;
  };
};
} // namespace stdexec
# 27 "./../stdexec/include/stdexec/__detail/__meta.hpp" 2

namespace stdexec {

template <class _Tp> using __t = typename _Tp::__t;

template <class _Ty> struct __mtype {
  using __t = _Ty;
};

template <class...> inline constexpr bool __mnever = false;

template <auto _Value> using __mtypeof = decltype(_Value);

template <class...> struct __types;

template <class _Tp> using __midentity = _Tp;

template <auto _Np> struct __mconstant {
  using type = __mconstant;
  using value_type = __mtypeof<_Np>;
  static constexpr auto value = _Np;

  constexpr operator value_type() const noexcept { return value; }

  constexpr auto operator()() const noexcept -> value_type { return value; }
};

enum class __u8 : unsigned char {};
# 79 "./../stdexec/include/stdexec/__detail/__meta.hpp"
template <std::size_t _Np> using __msize_t = __u8 (*)[_Np + 1];

template <class _Tp, class _Up> using __mfirst = _Tp;

template <class _Tp, class _Up> using __msecond = _Up;

template <class...> struct __undefined;

template <class _Tp> extern const __undefined<_Tp> __v;

template <class _Tp>
  requires __typename<__mtypeof<_Tp::value>>
inline constexpr auto __v<_Tp> = _Tp::value;

template <class _Tp, class _Up>
inline constexpr bool __v<std::is_same<_Tp, _Up>> = false;

template <class _Tp> inline constexpr bool __v<std::is_same<_Tp, _Tp>> = true;

template <class _Tp, _Tp _Ip>
inline constexpr _Tp __v<std::integral_constant<_Tp, _Ip>> = _Ip;

template <auto _Np> inline constexpr __mtypeof<_Np> __v<__mconstant<_Np>> = _Np;

template <std::size_t _Np>
inline constexpr std::size_t __v<__u8 (*)[_Np]> = _Np - 1;

template <std::size_t... _Is> struct __iota;

template <std::size_t... _Is> using __indices = __iota<_Is...> *;
# 141 "./../stdexec/include/stdexec/__detail/__meta.hpp"
namespace __pack {
template <class _Ty, _Ty... _Is> using __idx = __indices<_Is...>;
}

template <std::size_t _Np>
using __make_indices = __make_integer_seq<__pack::__idx, std::size_t, _Np>;
# 170 "./../stdexec/include/stdexec/__detail/__meta.hpp"
template <class... _Ts> using __indices_for = __make_indices<sizeof...(_Ts)>;

#pragma GCC diagnostic push
# 173 "./../stdexec/include/stdexec/__detail/__meta.hpp"
#pragma GCC diagnostic ignored "-Wpragmas"
# 173 "./../stdexec/include/stdexec/__detail/__meta.hpp"
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
# 173 "./../stdexec/include/stdexec/__detail/__meta.hpp"
#pragma GCC diagnostic ignored "-Wunknown-warning-option"
# 173 "./../stdexec/include/stdexec/__detail/__meta.hpp"
#pragma GCC diagnostic ignored "-Wunknown-attributes"
# 173 "./../stdexec/include/stdexec/__detail/__meta.hpp"
#pragma GCC diagnostic ignored "-Wattributes"

constexpr auto __mpow2(std::size_t __size) noexcept -> std::size_t {
  --__size;
  __size |= __size >> 1;
  __size |= __size >> 2;
  __size |= __size >> 4;
  __size |= __size >> 8;
  if constexpr (sizeof(__size) >= 4)
    __size |= __size >> 16;
  if constexpr (sizeof(__size) >= 8)
    __size |= __size >> 32;
  return ++__size;
}

#pragma GCC diagnostic pop

template <std::size_t _Len> struct __mstring {
# 204 "./../stdexec/include/stdexec/__detail/__meta.hpp"
  template <std::size_t _Ny>
  constexpr __mstring(const char (&__str)[_Ny], int = 0) noexcept {
    for (auto __i = 0ull; char __ch : __str) {
      __what_[__i++] = __ch;
    }
  }

  static constexpr auto __length() noexcept -> std::size_t { return _Len; }

  constexpr auto operator==(const __mstring &) const noexcept -> bool = default;

  template <std::size_t _OtherLen>
  constexpr auto
  operator==(const __mstring<_OtherLen> &) const noexcept -> bool {
    return false;
  }

  constexpr auto operator<=>(const __mstring &) const noexcept
      -> std::strong_ordering = default;

  template <std::size_t _OtherLen>
  constexpr auto operator<=>(const __mstring<_OtherLen> &__other) const noexcept
      -> std::strong_ordering {
    constexpr std::size_t __len = _Len < _OtherLen ? _Len : _OtherLen;
    for (std::size_t __i = 0; __i < __len; ++__i) {
      auto __cmp = (__what_[__i] <=> __other.__what_[__i]);
      if (__cmp != 0) {
        return __cmp;
      }
    }
    if constexpr (_Len == _OtherLen) {
      return std::strong_ordering::equal;
    }
    return (_Len < _OtherLen) ? std::strong_ordering::less
                              : std::strong_ordering::greater;
  }

  char __what_[_Len]{};
};

template <std::size_t _Len>
__mstring(const char (&__str)[_Len]) -> __mstring<_Len>;

template <std::size_t _Len>
__mstring(const char (&__str)[_Len], int) -> __mstring<__mpow2(_Len)>;

#pragma GCC diagnostic push
# 252 "./../stdexec/include/stdexec/__detail/__meta.hpp"
#pragma GCC diagnostic ignored "-Wpragmas"
# 252 "./../stdexec/include/stdexec/__detail/__meta.hpp"
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
# 252 "./../stdexec/include/stdexec/__detail/__meta.hpp"
#pragma GCC diagnostic ignored "-Wunknown-warning-option"
# 252 "./../stdexec/include/stdexec/__detail/__meta.hpp"
#pragma GCC diagnostic ignored "-Wunknown-attributes"
# 252 "./../stdexec/include/stdexec/__detail/__meta.hpp"
#pragma GCC diagnostic ignored "-Wattributes"
#pragma GCC diagnostic ignored "-Wuser-defined-literals"

template <__mstring _Str>
[[deprecated("Use _mstr instead")]]
constexpr auto operator""__csz() noexcept -> __mtypeof<_Str> {
  return _Str;
}

template <__mstring _Str>
constexpr auto operator""_mstr() noexcept -> __mtypeof<_Str> {
  return _Str;
}

#pragma GCC diagnostic pop

template <class T> constexpr auto __mnameof() noexcept {

  return __mstring{__PRETTY_FUNCTION__, 0};
}

using __msuccess = int;

template <class _What, class... _With> struct _WARNING_ {};

template <class _What, class... _With> struct _ERROR_ {
  auto operator,(__msuccess) const noexcept -> _ERROR_;
};

template <__mstring... _What> struct _WHAT_ {};

template <class _What, class... _With>
using __mexception = _ERROR_<_What, _With...>;

template <class> extern __msuccess __ok_v;

template <class _What, class... _With>
extern _ERROR_<_What, _With...> __ok_v<__mexception<_What, _With...>>;

template <class _Ty> using __ok_t = decltype(__ok_v<_Ty>);

template <class... _Ts>
using __disp = decltype((__msuccess(), ..., __ok_t<_Ts>()));

template <class _Arg>
concept __ok = __is_same(__ok_t<_Arg>, __msuccess);

template <class _Arg>
concept __merror = !__is_same(__ok_t<_Arg>, __msuccess);

template <class... _Args>
concept _Ok = (__is_same(__ok_t<_Args>, __msuccess) && ...);
# 325 "./../stdexec/include/stdexec/__detail/__meta.hpp"
template <bool _ArgsOK, bool _FnOK = true> struct __i;
# 365 "./../stdexec/include/stdexec/__detail/__meta.hpp"
template <template <class...> class _Fn, class... _Args>
using __meval = typename __i<_Ok<_Args...>>::template __g<_Fn, _Args...>;

template <class _Fn, class... _Args>
using __minvoke =
    typename __i<_Ok<_Args...>,
                 _Ok<_Fn>>::template __f<_Fn>::template __f<_Args...>;

template <class _Fn, class... _Args>
using __mcall = typename _Fn::template __f<_Args...>;

struct __disp_q {
  template <class... _Args> using __f = __disp<_Args...>;
};

template <> struct __i<true, true> {
  template <template <class...> class _Fn, class... _Args>
  using __g = _Fn<_Args...>;

  template <class _Fn> using __f = _Fn;
};

template <> struct __i<false, true> {
  template <template <class...> class, class... _Args>
  using __g = __disp<_Args...>;

  template <class> using __f = __disp_q;
};

template <bool _ArgsOK> struct __i<_ArgsOK, false> {
  template <class _Fn> using __f = _Fn;
};
# 417 "./../stdexec/include/stdexec/__detail/__meta.hpp"
template <template <class...> class _Fn> struct __q {
  template <class... _Args>
  using __f = typename __i<_Ok<_Args...>>::template __g<_Fn, _Args...>;
};

template <template <class...> class _Fn> struct __qq {
  template <class... _Args> using __f = _Fn<_Args...>;
};

template <template <class> class _Fn> struct __q1 {
  template <class _Ty> using __f = _Fn<_Ty>;
};

template <template <class, class> class _Fn> struct __q2 {
  template <class _Ty, class _Uy> using __f = _Fn<_Ty, _Uy>;
};

template <template <class...> class _Fn> using __mtry_q = __q<_Fn>;

template <class _Fn> struct __mtry : __mtry_q<_Fn::template __f> {};

template <template <class...> class _Fn, class... _Front>
struct __mbind_front_q {
  template <class... _Args> using __f = __meval<_Fn, _Front..., _Args...>;
};

template <class _Fn, class... _Front>
using __mbind_front = __mbind_front_q<_Fn::template __f, _Front...>;

template <template <class...> class _Fn, class... _Back> struct __mbind_back_q {
  template <class... _Args> using __f = __meval<_Fn, _Args..., _Back...>;
};

template <class _Fn, class... _Back>
using __mbind_back = __mbind_back_q<_Fn::template __f, _Back...>;

template <template <class...> class _Tp, class... _Args>
concept __mvalid = requires { typename __meval<_Tp, _Args...>; };

template <class _Fn, class... _Args>
concept __minvocable = __mvalid<_Fn::template __f, _Args...>;

template <template <class...> class _Tp, class... _Args>
concept __msucceeds = __mvalid<_Tp, _Args...> && __ok<__meval<_Tp, _Args...>>;

template <class _Fn, class... _Args>
concept __minvocable_succeeds =
    __minvocable<_Fn, _Args...> && __ok<__minvoke<_Fn, _Args...>>;

template <class _Fn, class... _Args> struct __minvoke_force_ {
  using __t = __minvoke<_Fn, _Args...>;
};
template <class _Fn, class... _Args>
using __minvoke_force = __t<__minvoke_force_<_Fn, _Args...>>;

template <class _Fn, class... _Args> struct __mdefer_ {};

template <class _Fn, class... _Args>
  requires __minvocable<_Fn, _Args...>
struct __mdefer_<_Fn, _Args...> {
  using __t = __minvoke<_Fn, _Args...>;
};

template <class _Fn, class... _Args>
struct __mdefer : __mdefer_<_Fn, _Args...> {};

template <class _Fn, class... _Args>
using __mmemoize = __t<__mdefer<_Fn, _Args...>>;

template <template <class...> class _Fn, class... _Args>
using __mmemoize_q = __mmemoize<__q<_Fn>, _Args...>;

struct __if_ {

  template <bool> struct __ {
    template <class _True, class...> using __f = _True;
  };

  template <class _Pred, class _True, class... _False>
  using __f = __minvoke<__<static_cast<bool>(__v<_Pred>)>, _True, _False...>;
};

template <> struct __if_::__<false> {
  template <class, class _False> using __f = _False;
};

template <class _Pred, class _True = void, class... _False>
  requires(sizeof...(_False) <= 1)
using __if = __minvoke<__if_, _Pred, _True, _False...>;

template <bool _Pred, class _True = void, class... _False>
  requires(sizeof...(_False) <= 1)
using __if_c = __minvoke<__if_::__<_Pred>, _True, _False...>;

template <class _Pred, class _True, class _False, class... _Args>
using __minvoke_if = __minvoke<__if<_Pred, _True, _False>, _Args...>;

template <bool _Pred, class _True, class _False, class... _Args>
using __minvoke_if_c = __minvoke<__if_c<_Pred, _True, _False>, _Args...>;

template <class _Tp> struct __mconst {
  template <class...> using __f = _Tp;
};

inline constexpr __mstring __mbad_substitution =
    "The specified meta-function could not be evaluated with the types provided."_mstr;

template <__mstring _Diagnostic = __mbad_substitution>
struct _BAD_SUBSTITUTION_ {};

template <class... _Args> struct _WITH_TYPES_;

template <template <class...> class _Fun> struct _WITH_META_FUNCTION_T_ {
  template <class... _Args>
  using __f = __mexception<_BAD_SUBSTITUTION_<>, _WITH_META_FUNCTION_T_,
                           _WITH_TYPES_<_Args...>>;
};

template <class _Fun> struct _WITH_META_FUNCTION_ {
  template <class... _Args>
  using __f = __mexception<_BAD_SUBSTITUTION_<>, _WITH_META_FUNCTION_,
                           _WITH_TYPES_<_Args...>>;
};

template <template <class...> class _Try, class _Catch> struct __mtry_catch_q {
  template <class... _Args>
  using __f =
      __minvoke<__if_c<__mvalid<_Try, _Args...>, __q<_Try>, _Catch>, _Args...>;
};

template <class _Try, class _Catch> struct __mtry_catch {
  template <class... _Args>
  using __f =
      __minvoke<__if_c<__minvocable<_Try, _Args...>, _Try, _Catch>, _Args...>;
};

template <class _Fn, class _Default>
using __with_default = __mtry_catch<_Fn, __mconst<_Default>>;

template <template <class...> class _Fn, class _Default>
using __with_default_q = __mtry_catch_q<_Fn, __mconst<_Default>>;

template <class _Fn, class _Default, class... _Args>
using __minvoke_or = __minvoke<__with_default<_Fn, _Default>, _Args...>;

template <template <class...> class _Fn, class _Default, class... _Args>
using __meval_or = __minvoke<__with_default_q<_Fn, _Default>, _Args...>;

template <template <class...> class _Fn> struct __mtry_eval_ {
  template <class... _Args> using __f = __meval<_Fn, _Args...>;
};

template <template <class...> class _Fn, class... _Args>
using __mtry_eval =
    __minvoke<__mtry_catch<__mtry_eval_<_Fn>, _WITH_META_FUNCTION_T_<_Fn>>,
              _Args...>;

template <class _Fn, class... _Args>
using __mtry_invoke =
    __minvoke<__mtry_catch<_Fn, _WITH_META_FUNCTION_<_Fn>>, _Args...>;

template <class _Ty, class... _Default>
using __msuccess_or_t = __if_c<__ok<_Ty>, _Ty, _Default...>;

template <class _Ty, class... _Default>
using __merror_or_t = __if_c<__merror<_Ty>, _Ty, _Default...>;

template <class _Fn, class _Continuation = __q<__types>> struct __mtransform {
  template <class... _Args>
  using __f = __minvoke<_Continuation, __minvoke<_Fn, _Args>...>;
};

template <bool> struct __mfold_right_ {
  template <class _Fn, class _State, class _Head, class... _Tail>
  using __f = __minvoke<__mfold_right_<sizeof...(_Tail) == 0>, _Fn,
                        __minvoke<_Fn, _State, _Head>, _Tail...>;
};

template <> struct __mfold_right_<true> {
  template <class _Fn, class _State, class...> using __f = _State;
};

template <class _Init, class _Fn> struct __mfold_right {
  template <class... _Args>
  using __f =
      __minvoke<__mfold_right_<sizeof...(_Args) == 0>, _Fn, _Init, _Args...>;
};

template <bool> struct __mfold_left_ {
  template <class _Fn, class _State, class _Head, class... _Tail>
  using __f = __minvoke<
      _Fn, __mcall<__mfold_left_<sizeof...(_Tail) == 0>, _Fn, _State, _Tail...>,
      _Head>;
};

template <> struct __mfold_left_<true> {
  template <class _Fn, class _State, class...> using __f = _State;
};

template <class _Init, class _Fn> struct __mfold_left {
  template <class... _Args>
  using __f =
      __minvoke<__mfold_left_<sizeof...(_Args) == 0>, _Fn, _Init, _Args...>;
};

template <class _Fn> struct __mcurry {
  template <class... _Ts> using __f = __minvoke<_Fn, _Ts...>;
};

template <class _Tp> struct __muncurry_;

template <template <class...> class _Ap, class... _As>
struct __muncurry_<_Ap<_As...>> {
  template <class _Fn> using __f = __minvoke<_Fn, _As...>;
};

template <std::size_t... _Ns> struct __muncurry_<__indices<_Ns...>> {
  template <class _Fn> using __f = __minvoke<_Fn, __msize_t<_Ns>...>;
};

template <template <class _Np, _Np...> class _Cp, class _Np, _Np... _Ns>
struct __muncurry_<_Cp<_Np, _Ns...>> {
  template <class _Fn>
  using __f = __minvoke<_Fn, std::integral_constant<_Np, _Ns>...>;
};

template <class _What, class... _With>
struct __muncurry_<_ERROR_<_What, _With...>> {
  template <class _Fn> using __f = _ERROR_<_What, _With...>;
};

template <class _Fn> struct __muncurry {
  template <class _Tp> using __f = typename __muncurry_<_Tp>::template __f<_Fn>;
};

template <class _Fn, class _List>
using __mapply = __minvoke<__muncurry<_Fn>, _List>;

template <bool> struct __mconcat_ {
  template <class... _Ts, template <class...> class _Ap = __types, class... _As,
            template <class...> class _Bp = __types, class... _Bs,
            template <class...> class _Cp = __types, class... _Cs,
            template <class...> class _Dp = __types, class... _Ds,
            class... _Tail>
  static auto __f(__types<_Ts...> *, _Ap<_As...> *, _Bp<_Bs...> * = nullptr,
                  _Cp<_Cs...> * = nullptr, _Dp<_Ds...> * = nullptr,
                  _Tail *...__tail)
      -> __midentity<decltype(__mconcat_<(sizeof...(_Tail) == 0)>::__f(
          static_cast<__types<_Ts..., _As..., _Bs..., _Cs..., _Ds...> *>(
              nullptr),
          __tail...))>;
};

template <> struct __mconcat_<true> {
  template <class... _As> static auto __f(__types<_As...> *) -> __types<_As...>;
};

template <class _Continuation = __qq<__types>> struct __mconcat {
  template <class... _Args>
  using __f =
      __mapply<_Continuation, decltype(__mconcat_<(sizeof...(_Args) == 0)>::__f(
                                  {}, static_cast<_Args *>(nullptr)...))>;
};

struct __msize {
  template <class... _Ts> using __f = __msize_t<sizeof...(_Ts)>;
};

template <class _Ty> struct __mcount {
  template <class... _Ts>
  using __f = __msize_t<(__same_as<_Ts, _Ty> + ... + 0)>;
};

template <class _Fn> struct __mcount_if {
  template <class... _Ts>
  using __f = __msize_t<(bool(__v<__minvoke<_Fn, _Ts>>) + ... + 0)>;
};

template <class _Tp> struct __mcontains {
  template <class... _Args> using __f = __mbool<(__same_as<_Tp, _Args> || ...)>;
};

template <class _Continuation = __q<__types>> struct __mpush_back {
  template <class _List, class _Item>
  using __f = __mapply<__mbind_back<_Continuation, _Item>, _List>;
};

template <class...> struct __mcompose {};

template <class _First> struct __mcompose<_First> : _First {};

template <class _Second, class _First> struct __mcompose<_Second, _First> {
  template <class... _Args>
  using __f = __minvoke<_Second, __minvoke<_First, _Args...>>;
};

template <class _Last, class _Penultimate, class... _Rest>
struct __mcompose<_Last, _Penultimate, _Rest...> {
  template <class... _Args>
  using __f =
      __minvoke<_Last, __minvoke<__mcompose<_Penultimate, _Rest...>, _Args...>>;
};

template <template <class...> class _Second, template <class...> class _First>
struct __mcompose_q {
  template <class... _Args> using __f = _Second<_First<_Args...>>;
};

template <class _Old, class _New, class _Continuation = __q<__types>>
struct __mreplace {
  template <class... _Args>
  using __f =
      __minvoke<_Continuation, __if_c<__same_as<_Args, _Old>, _New, _Args>...>;
};

template <class _Old, class _Continuation = __q<__types>> struct __mremove {
  template <class... _Args>
  using __f =
      __minvoke<__mconcat<_Continuation>,
                __if_c<__same_as<_Args, _Old>, __types<>, __types<_Args>>...>;
};

template <class _Pred, class _Continuation = __q<__types>> struct __mremove_if {
  template <class... _Args>
  using __f =
      __minvoke<__mconcat<_Continuation>,
                __if<__minvoke<_Pred, _Args>, __types<>, __types<_Args>>...>;
};

template <class _Return> struct __qf {
  template <class... _Args> using __f = _Return(_Args...);
};

template <class _Ty, class...> using __mfront_ = _Ty;
template <class... _As> using __mfront = __meval<__mfront_, _As...>;
template <class... _As>
  requires(sizeof...(_As) == 1)
using __msingle = __mfront<_As...>;
template <class _Default, class... _As>
  requires(sizeof...(_As) <= 1)
using __msingle_or_ = __mfront<_As..., _Default>;
template <class _Default>
using __msingle_or = __mbind_front_q<__msingle_or_, _Default>;

template <class _Ty>
concept __has_id = requires { typename _Ty::__id; };

template <class _Ty> struct _Id {
  using __t = _Ty;
};

template <bool = true> struct __id_ {
  template <class _Ty> using __f = typename _Ty::__id;
};

template <> struct __id_<false> {
  template <class _Ty> using __f = _Id<_Ty>;
};

template <class _Ty> using __id = __minvoke<__id_<__has_id<_Ty>>, _Ty>;

template <class _From, class _To = __decay_t<_From>>
using __cvref_t = __copy_cvref_t<_From, __t<_To>>;

template <class _From, class _To = __decay_t<_From>>
using __cvref_id = __copy_cvref_t<_From, __id<_To>>;
# 884 "./../stdexec/include/stdexec/__detail/__meta.hpp"
template <class _Fun, class... _As>
using __call_result_t = decltype(__declval<_Fun>()(__declval<_As>()...));

template <const auto &_Fun, class... _As>
using __result_of = decltype(_Fun(__declval<_As>()...));

template <const auto &_Fun, class... _As>
inline constexpr bool __noexcept_of = noexcept(_Fun(__declval<_As>()...));

template <class _Fn>
  requires std::is_nothrow_move_constructible_v<_Fn>
struct __emplace_from {
  _Fn __fn_;
  using __t = __call_result_t<_Fn>;

  operator __t() && noexcept(__nothrow_callable<_Fn>) {
    return static_cast<_Fn &&>(__fn_)();
  }

  auto operator()() && noexcept(__nothrow_callable<_Fn>) -> __t {
    return static_cast<_Fn &&>(__fn_)();
  }
};

template <class _Fn> __emplace_from(_Fn) -> __emplace_from<_Fn>;

template <class _Fn, class _Continuation, class _List1, class _List2>
struct __mzip_with2_
    : __mzip_with2_<_Fn, _Continuation, __mapply<__qq<__types>, _List1>,
                    __mapply<__qq<__types>, _List2>> {};

template <class _Fn, class _Continuation, template <class...> class _Cp,
          class... _Cs, template <class...> class _Dp, class... _Ds>
  requires requires {
    typename __minvoke<_Continuation, __minvoke<_Fn, _Cs, _Ds>...>;
  }
struct __mzip_with2_<_Fn, _Continuation, _Cp<_Cs...>, _Dp<_Ds...>> {
  using __t = __minvoke<_Continuation, __minvoke<_Fn, _Cs, _Ds>...>;
};

template <class _Fn, class _Continuation = __q<__types>> struct __mzip_with2 {
  template <class _Cp, class _Dp>
  using __f = __t<__mzip_with2_<_Fn, _Continuation, _Cp, _Dp>>;
};

template <bool> struct __mfind_if_ {
  template <class _Fn, class _Continuation, class _Head, class... _Tail>
  using __f = __minvoke<
      __if_c<__v<__minvoke<_Fn, _Head>>, __mbind_front<_Continuation, _Head>,
             __mbind_front<__mfind_if_<(sizeof...(_Tail) != 0)>, _Fn,
                           _Continuation>>,
      _Tail...>;
};

template <> struct __mfind_if_<false> {
  template <class _Fn, class _Continuation>
  using __f = __minvoke<_Continuation>;
};

template <class _Fn, class _Continuation = __q<__types>> struct __mfind_if {
  template <class... _Args>
  using __f = __minvoke<__mfind_if_<(sizeof...(_Args) != 0)>, _Fn,
                        _Continuation, _Args...>;
};

template <class _Fn> struct __mfind_if_i {
  template <class... _Args>
  using __f = __msize_t<(sizeof...(_Args) -
                         __v<__minvoke<__mfind_if<_Fn, __msize>, _Args...>>)>;
};

template <class... _Booleans> using __mand_t = __mbool<(__v<_Booleans> && ...)>;
template <class... _Booleans> using __mand = __meval<__mand_t, _Booleans...>;

template <class... _Booleans> using __mor_t = __mbool<(__v<_Booleans> || ...)>;
template <class... _Booleans> using __mor = __meval<__mor_t, _Booleans...>;

template <class _Boolean> using __mnot_t = __mbool<!__v<_Boolean>>;
template <class _Boolean> using __mnot = __meval<__mnot_t, _Boolean>;

template <class... _Ints> using __mplus_t = __mconstant<(__v<_Ints> + ...)>;

template <class _Fn> struct __mall_of {
  template <class... _Args> using __f = __mand<__minvoke<_Fn, _Args>...>;
};

template <class _Fn> struct __mnone_of {
  template <class... _Args>
  using __f = __mand<__mnot<__minvoke<_Fn, _Args>>...>;
};

template <class _Fn> struct __many_of {
  template <class... _Args> using __f = __mor<__minvoke<_Fn, _Args>...>;
};
# 1042 "./../stdexec/include/stdexec/__detail/__meta.hpp"
template <bool> struct __m_at_ {
  template <class _Np, class... _Ts>
  using __f = __type_pack_element<__v<_Np>, _Ts...>;
};

template <class _Np, class... _Ts>
using __m_at = __minvoke<__m_at_<__v<_Np> == ~0ul>, _Np, _Ts...>;

template <std::size_t _Np, class... _Ts>
using __m_at_c = __minvoke<__m_at_<_Np == ~0ul>, __msize_t<_Np>, _Ts...>;
# 1078 "./../stdexec/include/stdexec/__detail/__meta.hpp"
template <class... _Ts> using __mback = __m_at_c<sizeof...(_Ts) - 1, _Ts...>;

template <class _Continuation = __q<__types>> struct __mpop_back {
  template <class> struct __impl;

  template <std::size_t... _Idx> struct __impl<__indices<_Idx...>> {
    template <class... _Ts>
    using __f = __minvoke<_Continuation, __m_at_c<_Idx, _Ts...>...>;
  };

  template <class... _Ts>
    requires(sizeof...(_Ts) != 0)
  using __f = __minvoke<__impl<__make_indices<sizeof...(_Ts) - 1>>, _Ts...>;
};

template <std::size_t _Np> struct __placeholder {
  __placeholder() = default;

  constexpr __placeholder(void *) noexcept {}

  constexpr friend auto
  __get_placeholder_offset(__placeholder) noexcept -> std::size_t {
    return _Np;
  }
};

using __0 = __placeholder<0>;
using __1 = __placeholder<1>;
using __2 = __placeholder<2>;
using __3 = __placeholder<3>;
# 1130 "./../stdexec/include/stdexec/__detail/__meta.hpp"
template <class... _Ignore> struct __nth_pack_element_impl {
  template <class _Ty, class... _Us>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr _Ty &&
  operator()(_Ignore..., _Ty &&__t, _Us &&...) const noexcept {
    return static_cast<decltype(__t) &&>(__t);
  }
};

template <std::size_t _Np> struct __nth_pack_element_t {
  template <std::size_t... _Is>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static constexpr auto
  __impl(__indices<_Is...>) noexcept {
    return __nth_pack_element_impl<__ignore_t<_Is>...>();
  }

  template <class... _Ts>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr decltype(auto)
  operator()(_Ts &&...__ts) const noexcept {
    static_assert(_Np < sizeof...(_Ts));
    return __impl(__make_indices<_Np>())(static_cast<_Ts &&>(__ts)...);
  }
};

template <std::size_t _Np>
inline constexpr __nth_pack_element_t<_Np> __nth_pack_element{};

template <auto... _Vs> struct __mliterals {
  template <std::size_t _Np>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static constexpr auto
  __nth() noexcept {
    return stdexec::__nth_pack_element<_Np>(_Vs...);
  }
};

template <std::size_t _Np> struct __nth_member {
  template <class _Ty>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr auto
  operator()(_Ty &&__ty) const noexcept -> decltype(auto) {
    return static_cast<_Ty &&>(__ty).*(__ty.__mbrs_.template __nth<_Np>());
  }
};

template <class _Set, class... _Ty>
concept __mset_contains = (__is_base_of(__mtype<_Ty>, _Set) && ...);

struct __mset_nil;

namespace __set {
template <class... _Ts> struct __inherit : __mtype<__mset_nil> {
  template <template <class...> class _Fn> using rebind = _Fn<_Ts...>;
};

template <class _Ty, class... _Ts>
struct __inherit<_Ty, _Ts...> : __mtype<_Ty>, __inherit<_Ts...> {
  template <template <class...> class _Fn> using rebind = _Fn<_Ty, _Ts...>;
};

template <class... _Set>
auto operator+(__inherit<_Set...> &) -> __inherit<_Set...>;

template <class... _Set, class _Ty>
auto operator%(__inherit<_Set...> &, __mtype<_Ty> &)
    -> __if_c<__mset_contains<__inherit<_Set...>, _Ty>, __inherit<_Set...>,
              __inherit<_Ty, _Set...>> &;

template <class _ExpectedSet, class... _Ts>
concept __mset_eq = (sizeof...(_Ts) == __v<__mapply<__msize, _ExpectedSet>>) &&
                    __mset_contains<_ExpectedSet, _Ts...>;

template <class _ExpectedSet> struct __eq {
  template <class... _Ts> using __f = __mbool<__mset_eq<_ExpectedSet, _Ts...>>;
};
} // namespace __set

template <class... _Ts> using __mset = __set::__inherit<_Ts...>;

template <class _Set, class... _Ts>
using __mset_insert =
    decltype(+(__declval<_Set &>() % ... % __declval<__mtype<_Ts> &>()));

template <class... _Ts> using __mmake_set = __mset_insert<__mset<>, _Ts...>;

template <class _Set1, class _Set2>
concept __mset_eq = __v<__mapply<__set::__eq<_Set1>, _Set2>>;

template <class _Continuation = __q<__types>> struct __munique {
  template <class... _Ts>
  using __f = __mapply<_Continuation, __mmake_set<_Ts...>>;
};
} // namespace stdexec
# 20 "./../stdexec/include/stdexec/__detail/__execution_fwd.hpp" 2

namespace stdexec {
struct __none_such;

struct default_domain;

namespace __rcvrs {
struct set_value_t;
struct set_error_t;
struct set_stopped_t;
} // namespace __rcvrs

using __rcvrs::set_error_t;
using __rcvrs::set_stopped_t;
using __rcvrs::set_value_t;
extern const set_value_t set_value;
extern const set_error_t set_error;
extern const set_stopped_t set_stopped;

template <class _Tag>
concept __completion_tag =
    __one_of<_Tag, set_value_t, set_error_t, set_stopped_t>;

struct receiver_t;

template <class _Sender> extern const bool enable_receiver;

namespace __env {
template <class _Query, class _Value> struct prop;

template <class... _Envs> struct env;
} // namespace __env

using __env::env;
using __env::prop;
using empty_env
    [[deprecated("stdexec::empty_env is now spelled stdexec::env<>")]] = env<>;

namespace __get_env {
struct get_env_t;
}

using __get_env::get_env_t;
extern const get_env_t get_env;

template <class _EnvProvider>
using env_of_t = __call_result_t<get_env_t, _EnvProvider>;

enum class forward_progress_guarantee { concurrent, parallel, weakly_parallel };

namespace __queries {
struct forwarding_query_t;
struct execute_may_block_caller_t;
struct get_forward_progress_guarantee_t;
struct get_scheduler_t;
struct get_delegation_scheduler_t;
struct get_allocator_t;
struct get_stop_token_t;
template <__completion_tag _CPO> struct get_completion_scheduler_t;
struct get_domain_t;
} // namespace __queries

using __queries::execute_may_block_caller_t;
using __queries::forwarding_query_t;
using __queries::get_allocator_t;
using __queries::get_completion_scheduler_t;
using __queries::get_delegation_scheduler_t;
using __queries::get_domain_t;
using __queries::get_forward_progress_guarantee_t;
using __queries::get_scheduler_t;
using __queries::get_stop_token_t;

extern const forwarding_query_t forwarding_query;
extern const execute_may_block_caller_t execute_may_block_caller;
extern const get_forward_progress_guarantee_t get_forward_progress_guarantee;
extern const get_scheduler_t get_scheduler;
extern const get_delegation_scheduler_t get_delegation_scheduler;
extern const get_allocator_t get_allocator;
extern const get_stop_token_t get_stop_token;
template <__completion_tag _CPO>
extern const get_completion_scheduler_t<_CPO> get_completion_scheduler;
extern const get_domain_t get_domain;

struct never_stop_token;
class inplace_stop_source;
class inplace_stop_token;
template <class _Fn> class inplace_stop_callback;

template <class _Tp>
using stop_token_of_t = __decay_t<__call_result_t<get_stop_token_t, _Tp>>;

template <class _Sender, class _CPO>
concept __has_completion_scheduler =
    __callable<get_completion_scheduler_t<_CPO>, env_of_t<const _Sender &>>;

template <class _Sender, class _CPO>
using __completion_scheduler_for =
    __call_result_t<get_completion_scheduler_t<_CPO>,
                    env_of_t<const _Sender &>>;

template <class _Env>
using __domain_of_t = __decay_t<__call_result_t<get_domain_t, _Env>>;

namespace __sigs {
template <class _Sig> inline constexpr bool __is_compl_sig = false;

struct get_completion_signatures_t;
} // namespace __sigs

template <class _Sig>
concept __completion_signature = __sigs::__is_compl_sig<_Sig>;

template <class... _Sigs> struct completion_signatures;

using __sigs::get_completion_signatures_t;
extern const get_completion_signatures_t get_completion_signatures;

template <class _Sender, class... _Env>
using __completion_signatures_of_t =
    __call_result_t<get_completion_signatures_t, _Sender, _Env...>;

namespace __connect {
struct connect_t;
}

using __connect::connect_t;
extern const connect_t connect;

template <class _Sender, class _Receiver>
concept __nothrow_connectable =
    __nothrow_callable<connect_t, _Sender, _Receiver>;

struct sender_t;

template <class _Sender> extern const bool enable_sender;

namespace __start {
struct start_t;
}

using __start::start_t;
extern const start_t start;

namespace __sched {
struct schedule_t;
}

using __sched::schedule_t;
extern const schedule_t schedule;

namespace __as_awaitable {
struct as_awaitable_t;
}

using __as_awaitable::as_awaitable_t;
extern const as_awaitable_t as_awaitable;

namespace __starts_on_ns {
struct starts_on_t;
}

using __starts_on_ns::starts_on_t;
extern const starts_on_t starts_on;

using on_t [[deprecated("on_t has been renamed starts_on_t")]] = starts_on_t;
[[deprecated("on has been renamed starts_on")]]
extern const starts_on_t on;

using start_on_t [[deprecated("start_on_t has been renamed starts_on_t")]] =
    starts_on_t;
[[deprecated("start_on has been renamed starts_on")]]
extern const starts_on_t start_on;

namespace __schfr {
struct schedule_from_t;
}

using __schfr::schedule_from_t;
extern const schedule_from_t schedule_from;

namespace __continues_on {
struct continues_on_t;
}

using __continues_on::continues_on_t;
extern const continues_on_t continues_on;

using transfer_t [[deprecated("transfer_t has been renamed continues_on_t")]] =
    continues_on_t;
[[deprecated("transfer has been renamed continues_on")]]
extern const continues_on_t transfer;

using continue_t
    [[deprecated("continue_on_t has been renamed continues_on_t")]] =
        continues_on_t;
[[deprecated("continue_on has been renamed continues_on")]]
extern const continues_on_t continue_on;

namespace __transfer_just {
struct transfer_just_t;
}

using __transfer_just::transfer_just_t;
extern const transfer_just_t transfer_just;

namespace __bulk {
struct bulk_t;
struct bulk_chunked_t;
struct bulk_unchunked_t;
} // namespace __bulk

using __bulk::bulk_chunked_t;
using __bulk::bulk_t;
using __bulk::bulk_unchunked_t;
extern const bulk_t bulk;
extern const bulk_chunked_t bulk_chunked;
extern const bulk_unchunked_t bulk_unchunked;

namespace __split {
struct split_t;
struct __split_t;
} // namespace __split

using __split::split_t;
extern const split_t split;

namespace __ensure_started {
struct ensure_started_t;
struct __ensure_started_t;
} // namespace __ensure_started

using __ensure_started::ensure_started_t;
extern const ensure_started_t ensure_started;

namespace __on_v2 {
struct on_t;
}

namespace v2 {
using __on_v2::on_t;
}

namespace __detail {
struct __sexpr_apply_t;
}

using __detail::__sexpr_apply_t;
extern const __sexpr_apply_t __sexpr_apply;
} // namespace stdexec

template <class...>
[[deprecated]]
void __print() {}

template <class...> struct __undef;
# 19 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__as_awaitable.hpp" 1
# 20 "./../stdexec/include/stdexec/__detail/__as_awaitable.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__awaitable.hpp" 1
# 22 "./../stdexec/include/stdexec/__detail/__awaitable.hpp"
namespace stdexec {

template <class _Tp>
concept __await_suspend_result =
    __one_of<_Tp, void, bool> ||
    __is_instance_of<_Tp, __coro::coroutine_handle>;

template <class _Awaiter, class... _Promise>
concept __awaiter =
    requires(_Awaiter &__awaiter, __coro::coroutine_handle<_Promise...> __h) {
      __awaiter.await_ready() ? 1 : 0;
      { __awaiter.await_suspend(__h) } -> __await_suspend_result;
      __awaiter.await_resume();
    };
# 44 "./../stdexec/include/stdexec/__detail/__awaitable.hpp"
template <class _Awaitable>
auto __get_awaiter(_Awaitable &&__awaitable, __ignore = {}) -> decltype(auto) {
  if constexpr (requires {
                  static_cast<_Awaitable &&>(__awaitable).operator co_await();
                }) {
    return static_cast<_Awaitable &&>(__awaitable).operator co_await();
  } else if constexpr (requires {
                         operator co_await(
                             static_cast<_Awaitable &&>(__awaitable));
                       }) {
    return operator co_await(static_cast<_Awaitable &&>(__awaitable));
  } else {
    return static_cast<_Awaitable &&>(__awaitable);
  }
}

template <class _Awaitable, class _Promise>
auto __get_awaiter(_Awaitable &&__awaitable,
                   _Promise *__promise) -> decltype(auto)
  requires requires {
    __promise->await_transform(static_cast<_Awaitable &&>(__awaitable));
  }
{
  if constexpr (requires {
                  __promise
                      ->await_transform(static_cast<_Awaitable &&>(__awaitable))
                      .operator co_await();
                }) {
    return __promise->await_transform(static_cast<_Awaitable &&>(__awaitable))
        .operator co_await();
  } else if constexpr (requires {
                         operator co_await(__promise->await_transform(
                             static_cast<_Awaitable &&>(__awaitable)));
                       }) {
    return operator co_await(
        __promise->await_transform(static_cast<_Awaitable &&>(__awaitable)));
  } else {
    return __promise->await_transform(static_cast<_Awaitable &&>(__awaitable));
  }
}

template <class _Awaitable, class... _Promise>
concept __awaitable =
    requires(_Awaitable &&__awaitable, _Promise *...__promise) {
      {
        stdexec::__get_awaiter(static_cast<_Awaitable &&>(__awaitable),
                               __promise...)
      } -> __awaiter<_Promise...>;
    };

template <class _Tp> auto __as_lvalue(_Tp &&) -> _Tp &;

template <class _Awaitable, class... _Promise>
  requires __awaitable<_Awaitable, _Promise...>
using __await_result_t =
    decltype(stdexec::__as_lvalue(
                 stdexec::__get_awaiter(std::declval<_Awaitable>(),
                                        static_cast<_Promise *>(nullptr)...))
                 .await_resume());
# 112 "./../stdexec/include/stdexec/__detail/__awaitable.hpp"
} // namespace stdexec
# 21 "./../stdexec/include/stdexec/__detail/__as_awaitable.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__receivers.hpp" 1
# 21 "./../stdexec/include/stdexec/__detail/__receivers.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__diagnostics.hpp" 1
# 20 "./../stdexec/include/stdexec/__detail/__diagnostics.hpp"
namespace stdexec {
namespace __detail {
template <class _Ty> extern __q<__midentity> __name_of_v;

template <class _Ty> using __name_of_fn = decltype(__name_of_v<_Ty>);

template <class _Ty> using __name_of = __minvoke<__name_of_fn<_Ty>, _Ty>;
} // namespace __detail

template <class _Ty> using __name_of = __detail::__name_of<_Ty>;

namespace __errs {
inline constexpr __mstring __unrecognized_sender_type_diagnostic =
    "The given type cannot be used as a sender with the given environment "
    "because the attempt to compute the completion signatures failed."_mstr;

template <class _Sender> struct _WITH_SENDER_;

template <class... _Senders> struct _WITH_SENDERS_;
} // namespace __errs

struct _WHERE_;

struct _IN_ALGORITHM_;

template <__mstring _Diagnostic = __errs::__unrecognized_sender_type_diagnostic>
struct _UNRECOGNIZED_SENDER_TYPE_;

template <class _Sender>
using _WITH_SENDER_ = __errs::_WITH_SENDER_<__name_of<_Sender>>;

template <class... _Senders>
using _WITH_SENDERS_ = __errs::_WITH_SENDERS_<__name_of<_Senders>...>;

template <class _Env> struct _WITH_ENVIRONMENT_;

template <class _Ty> struct _WITH_TYPE_;

template <class _Receiver> struct _WITH_RECEIVER_;

template <class _Sig> struct _MISSING_COMPLETION_SIGNAL_;

template <class _Sig> struct _WITH_COMPLETION_SIGNATURE_;

template <class _Fun> struct _WITH_FUNCTION_;

template <class... _Args> struct _WITH_ARGUMENTS_;

template <class _Tag> struct _WITH_QUERY_;

struct _SENDER_TYPE_IS_NOT_COPYABLE_;

inline constexpr __mstring __not_callable_diag =
    "The specified function is not callable with the arguments provided."_mstr;

template <__mstring _Context, __mstring _Diagnostic = __not_callable_diag>
struct _NOT_CALLABLE_;

template <auto _Reason = "You cannot pipe one sender into another."_mstr>
struct _CANNOT_PIPE_INTO_A_SENDER_ {};

template <class _Sender>
using __bad_pipe_sink_t =
    __mexception<_CANNOT_PIPE_INTO_A_SENDER_<>, _WITH_SENDER_<_Sender>>;

template <__mstring _Context> struct __callable_error {
  template <class _Fun, class... _Args>
  using __f = __mexception<_NOT_CALLABLE_<_Context>, _WITH_FUNCTION_<_Fun>,
                           _WITH_ARGUMENTS_<_Args...>>;
};
} // namespace stdexec
# 22 "./../stdexec/include/stdexec/__detail/__receivers.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__env.hpp" 1
# 21 "./../stdexec/include/stdexec/__detail/__env.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__cpo.hpp" 1
# 97 "./../stdexec/include/stdexec/__detail/__cpo.hpp"
namespace stdexec {
template <class> struct __arg_type;

template <class _Arg> struct __arg_type<void(_Arg (*)())> {
  using type = _Arg;
};

template <class _Fn> using __arg_type_t = typename __arg_type<_Fn>::type;

template <class> struct __tag_type;

template <class _Ret, class _Tag> struct __tag_type<_Ret _Tag::*> {
  using type = _Tag;
};

template <class _Fn> using __tag_type_t = typename __tag_type<_Fn>::type;

namespace tags {
using stdexec::connect_t;
using stdexec::get_completion_signatures_t;
using stdexec::get_env_t;
using stdexec::set_error_t;
using stdexec::set_stopped_t;
using stdexec::set_value_t;
using stdexec::start_t;
} // namespace tags
} // namespace stdexec
# 22 "./../stdexec/include/stdexec/__detail/__env.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__stop_token.hpp" 1
# 23 "./../stdexec/include/stdexec/__detail/__stop_token.hpp"
namespace stdexec {
namespace __stok {
template <template <class> class> struct __check_type_alias_exists;
}

template <class _Token, class _Callback>
using stop_callback_for_t = typename _Token::template callback_type<_Callback>;

template <class _Token>
concept stoppable_token =
    __nothrow_copy_constructible<_Token> &&
    __nothrow_move_constructible<_Token> && equality_comparable<_Token> &&
    requires(const _Token &__token) {
      { __token.stop_requested() } noexcept -> __boolean_testable_;
      { __token.stop_possible() } noexcept -> __boolean_testable_;
    };

template <class _Token, typename _Callback, typename _Initializer = _Callback>
concept stoppable_token_for =
    stoppable_token<_Token> && __callable<_Callback> &&
    requires { typename stop_callback_for_t<_Token, _Callback>; } &&
    constructible_from<_Callback, _Initializer> &&
    constructible_from<stop_callback_for_t<_Token, _Callback>, const _Token &,
                       _Initializer>;

template <class _Token>
concept unstoppable_token = stoppable_token<_Token> && requires {
  { _Token::stop_possible() } -> __boolean_testable_;
} && (!_Token::stop_possible());
} // namespace stdexec
# 24 "./../stdexec/include/stdexec/__detail/__env.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__tag_invoke.hpp" 1
# 21 "./../stdexec/include/stdexec/__detail/__tag_invoke.hpp"
namespace stdexec::__std_concepts {

using std::invocable;

}

namespace std {
using namespace stdexec::__std_concepts;
}

namespace stdexec {

namespace __tag_invoke {
void tag_invoke();

template <class _Tag, class _Env>
  requires true
__attribute__((__always_inline__, __artificial__,
               __nodebug__)) inline constexpr auto
tag_invoke(_Tag, const _Env &) noexcept -> __mconstant<_Env::query(_Tag())> {
  return {};
}

template <class _Tag, class _Env>
__attribute__((__always_inline__, __artificial__,
               __nodebug__)) inline constexpr auto
tag_invoke(_Tag, const _Env &__env) noexcept(noexcept(__env.query(_Tag())))
    -> decltype(__env.query(_Tag())) {
  return __env.query(_Tag());
}

template <class _Tag, class... _Args>
concept tag_invocable = requires(_Tag __tag, _Args &&...__args) {
  tag_invoke(static_cast<_Tag &&>(__tag), static_cast<_Args &&>(__args)...);
};

template <class _Ret, class _Tag, class... _Args>
concept __tag_invocable_r = requires(_Tag __tag, _Args &&...__args) {
  {
    static_cast<_Ret>(tag_invoke(static_cast<_Tag &&>(__tag),
                                 static_cast<_Args &&>(__args)...))
  };
};

template <class _Tag, class... _Args>
concept nothrow_tag_invocable =
    tag_invocable<_Tag, _Args...> && requires(_Tag __tag, _Args &&...__args) {
      {
        tag_invoke(static_cast<_Tag &&>(__tag),
                   static_cast<_Args &&>(__args)...)
      } noexcept;
    };

template <class _Tag, class... _Args>
using tag_invoke_result_t =
    decltype(tag_invoke(__declval<_Tag>(), __declval<_Args>()...));

template <class _Tag, class... _Args> struct tag_invoke_result {};

template <class _Tag, class... _Args>
  requires tag_invocable<_Tag, _Args...>
struct tag_invoke_result<_Tag, _Args...> {
  using type = tag_invoke_result_t<_Tag, _Args...>;
};

struct tag_invoke_t {
  template <class _Tag, class... _Args>
    requires tag_invocable<_Tag, _Args...>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr auto
  operator()(_Tag __tag, _Args &&...__args) const
      noexcept(nothrow_tag_invocable<_Tag, _Args...>)
          -> tag_invoke_result_t<_Tag, _Args...> {
    return tag_invoke(static_cast<_Tag &&>(__tag),
                      static_cast<_Args &&>(__args)...);
  }
};

} // namespace __tag_invoke

using __tag_invoke::tag_invoke_t;

namespace __ti {
inline constexpr tag_invoke_t tag_invoke{};
}

using namespace __ti;

template <auto &_Tag> using tag_t = __decay_t<decltype(_Tag)>;

using __tag_invoke::__tag_invocable_r;
using __tag_invoke::nothrow_tag_invocable;
using __tag_invoke::tag_invocable;
using __tag_invoke::tag_invoke_result;
using __tag_invoke::tag_invoke_result_t;
} // namespace stdexec
# 25 "./../stdexec/include/stdexec/__detail/__env.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__tuple.hpp" 1
# 38 "./../stdexec/include/stdexec/__detail/__tuple.hpp"
namespace stdexec {
namespace __tup {
template <class _Ty, std::size_t _Idx> struct __box {

  _Ty __value;
};

template <class _Ty>
concept __empty = __is_empty(_Ty) && __is_trivially_constructible(_Ty) &&
                  __is_trivially_copyable(_Ty);

template <__empty _Ty> inline _Ty __value{};

template <__empty _Ty, std::size_t _Idx> struct __box<_Ty, _Idx> {
  __box() = default;

  constexpr __box(__not_decays_to<__box> auto &&) noexcept {}

  static constexpr _Ty &__value = __tup::__value<_Ty>;
};

template <std::size_t _Idx, class _Ty>
__attribute__((__always_inline__, __artificial__,
               __nodebug__)) inline constexpr auto
__get(__box<_Ty, _Idx> &&__self) noexcept -> _Ty && {
  return static_cast<_Ty &&>(__self.__value);
}

template <std::size_t _Idx, class _Ty>
__attribute__((__always_inline__, __artificial__,
               __nodebug__)) inline constexpr auto
__get(__box<_Ty, _Idx> &__self) noexcept -> _Ty & {
  return __self.__value;
}

template <std::size_t _Idx, class _Ty>
__attribute__((__always_inline__, __artificial__,
               __nodebug__)) inline constexpr auto
__get(const __box<_Ty, _Idx> &__self) noexcept -> const _Ty & {
  return __self.__value;
}

template <auto _Idx, class... _Ts> struct __tuple;

template <std::size_t... _Is, __indices<_Is...> _Idx, class... _Ts>
  requires(sizeof...(_Ts) - 1 > 3)
struct __tuple<_Idx, _Ts...> : __box<_Ts, _Is>... {
  template <class... _Us>
  static auto __convert_from(__tuple<_Idx, _Us...> &&__tup) -> __tuple {
    return __tuple{
        {static_cast<_Us &&>(__tup.template __box<_Us, _Is>::__value)}...};
  }

  template <class... _Us>
  static auto __convert_from(__tuple<_Idx, _Us...> const &__tup) -> __tuple {
    return __tuple{{__tup.template __box<_Us, _Is>::__value}...};
  }

  template <std::size_t _Np, class _Self>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  __get(_Self &&__self) noexcept
      -> decltype(__tup::__get<_Np>(static_cast<_Self &&>(__self))) {
    return __tup::__get<_Np>(static_cast<_Self &&>(__self));
  }

  template <class _Fn, class _Self, class... _Us>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  apply(_Fn &&__fn, _Self &&__self, _Us &&...__us) noexcept(
      noexcept(static_cast<_Fn &&>(__fn)(
          static_cast<_Us &&>(__us)...,
          static_cast<_Self &&>(__self).template __box<_Ts, _Is>::__value...)))
      -> decltype(static_cast<_Fn &&>(__fn)(
          static_cast<_Us &&>(__us)...,
          static_cast<_Self &&>(__self).template __box<_Ts, _Is>::__value...)) {
    return static_cast<_Fn &&>(__fn)(
        static_cast<_Us &&>(__us)...,
        static_cast<_Self &&>(__self).template __box<_Ts, _Is>::__value...);
  }

  template <class _Fn, class _Self, class... _Us>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  for_each(_Fn &&__fn, _Self &&__self) noexcept(noexcept(
      (static_cast<void>(__fn(
           static_cast<_Self &&>(__self).template __box<_Ts, _Is>::__value)),
       ...)))
      -> decltype((
          static_cast<void>(__fn(
              static_cast<_Self &&>(__self).template __box<_Ts, _Is>::__value)),
          ...)) {
    return (
        static_cast<void>(__fn(
            static_cast<_Self &&>(__self).template __box<_Ts, _Is>::__value)),
        ...);
  }
};
# 180 "./../stdexec/include/stdexec/__detail/__tuple.hpp"
template <std::size_t... _Is, __indices<_Is...> _Idx, class _T0>
struct __tuple<_Idx, _T0> {
  _T0 __elem0;
  template <class _U0>
  static auto __convert_from(__tuple<_Idx, _U0> &&__tup) -> __tuple {
    return __tuple{static_cast<_U0 &&>(__tup.__elem0)};
  }
  template <class _U0>
  static auto __convert_from(__tuple<_Idx, _U0> const &__tup) -> __tuple {
    return __tuple{__tup.__elem0};
  }
  template <std::size_t _Np, class _Self>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  __get(_Self &&__self) noexcept -> decltype(auto)
    requires(_Np < 1)
  {
    if constexpr (_Np == 0)
      return (static_cast<_Self &&>(__self).__elem0);
    else
      ;
  }
  template <class _Fn, class _Self, class... _Us>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  apply(_Fn &&__fn, _Self &&__self, _Us &&...__us) noexcept(noexcept(
      static_cast<_Fn &&>(__fn)(static_cast<_Us &&>(__us)...,
                                static_cast<_Self &&>(__self).__elem0)))
      -> decltype(static_cast<_Fn &&>(__fn)(
          static_cast<_Us &&>(__us)...,
          static_cast<_Self &&>(__self).__elem0)) {
    return static_cast<_Fn &&>(__fn)(static_cast<_Us &&>(__us)...,
                                     static_cast<_Self &&>(__self).__elem0);
  }
  template <class _Fn, class _Self>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  for_each(_Fn &&__fn, _Self &&__self) noexcept(
      noexcept(static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem0))))
      -> decltype(static_cast<void>(
          static_cast<_Fn &&>(__fn)(__self.__elem0))) {
    return static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem0));
  }
};
template <std::size_t... _Is, __indices<_Is...> _Idx, class _T0, class _T1>
struct __tuple<_Idx, _T0, _T1> {
  _T0 __elem0;
  _T1 __elem1;
  template <class _U0, class _U1>
  static auto __convert_from(__tuple<_Idx, _U0, _U1> &&__tup) -> __tuple {
    return __tuple{static_cast<_U0 &&>(__tup.__elem0),
                   static_cast<_U1 &&>(__tup.__elem1)};
  }
  template <class _U0, class _U1>
  static auto __convert_from(__tuple<_Idx, _U0, _U1> const &__tup) -> __tuple {
    return __tuple{__tup.__elem0, __tup.__elem1};
  }
  template <std::size_t _Np, class _Self>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  __get(_Self &&__self) noexcept -> decltype(auto)
    requires(_Np < 2)
  {
    if constexpr (_Np == 0)
      return (static_cast<_Self &&>(__self).__elem0);
    else if constexpr (_Np == 1)
      return (static_cast<_Self &&>(__self).__elem1);
    else
      ;
  }
  template <class _Fn, class _Self, class... _Us>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  apply(_Fn &&__fn, _Self &&__self, _Us &&...__us) noexcept(noexcept(
      static_cast<_Fn &&>(__fn)(static_cast<_Us &&>(__us)...,
                                static_cast<_Self &&>(__self).__elem0,
                                static_cast<_Self &&>(__self).__elem1)))
      -> decltype(static_cast<_Fn &&>(__fn)(
          static_cast<_Us &&>(__us)..., static_cast<_Self &&>(__self).__elem0,
          static_cast<_Self &&>(__self).__elem1)) {
    return static_cast<_Fn &&>(__fn)(static_cast<_Us &&>(__us)...,
                                     static_cast<_Self &&>(__self).__elem0,
                                     static_cast<_Self &&>(__self).__elem1);
  }
  template <class _Fn, class _Self>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  for_each(_Fn &&__fn, _Self &&__self) noexcept(
      noexcept(static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem0)),
               static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem1))))
      -> decltype(static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem0)),
                  static_cast<void>(
                      static_cast<_Fn &&>(__fn)(__self.__elem1))) {
    return static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem0)),
           static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem1));
  }
};
template <std::size_t... _Is, __indices<_Is...> _Idx, class _T0, class _T1,
          class _T2>
struct __tuple<_Idx, _T0, _T1, _T2> {
  _T0 __elem0;
  _T1 __elem1;
  _T2 __elem2;
  template <class _U0, class _U1, class _U2>
  static auto __convert_from(__tuple<_Idx, _U0, _U1, _U2> &&__tup) -> __tuple {
    return __tuple{static_cast<_U0 &&>(__tup.__elem0),
                   static_cast<_U1 &&>(__tup.__elem1),
                   static_cast<_U2 &&>(__tup.__elem2)};
  }
  template <class _U0, class _U1, class _U2>
  static auto
  __convert_from(__tuple<_Idx, _U0, _U1, _U2> const &__tup) -> __tuple {
    return __tuple{__tup.__elem0, __tup.__elem1, __tup.__elem2};
  }
  template <std::size_t _Np, class _Self>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  __get(_Self &&__self) noexcept -> decltype(auto)
    requires(_Np < 3)
  {
    if constexpr (_Np == 0)
      return (static_cast<_Self &&>(__self).__elem0);
    else if constexpr (_Np == 1)
      return (static_cast<_Self &&>(__self).__elem1);
    else if constexpr (_Np == 2)
      return (static_cast<_Self &&>(__self).__elem2);
    else
      ;
  }
  template <class _Fn, class _Self, class... _Us>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  apply(_Fn &&__fn, _Self &&__self, _Us &&...__us) noexcept(noexcept(
      static_cast<_Fn &&>(__fn)(static_cast<_Us &&>(__us)...,
                                static_cast<_Self &&>(__self).__elem0,
                                static_cast<_Self &&>(__self).__elem1,
                                static_cast<_Self &&>(__self).__elem2)))
      -> decltype(static_cast<_Fn &&>(__fn)(
          static_cast<_Us &&>(__us)..., static_cast<_Self &&>(__self).__elem0,
          static_cast<_Self &&>(__self).__elem1,
          static_cast<_Self &&>(__self).__elem2)) {
    return static_cast<_Fn &&>(__fn)(static_cast<_Us &&>(__us)...,
                                     static_cast<_Self &&>(__self).__elem0,
                                     static_cast<_Self &&>(__self).__elem1,
                                     static_cast<_Self &&>(__self).__elem2);
  }
  template <class _Fn, class _Self>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  for_each(_Fn &&__fn, _Self &&__self) noexcept(
      noexcept(static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem0)),
               static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem1)),
               static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem2))))
      -> decltype(static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem0)),
                  static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem1)),
                  static_cast<void>(
                      static_cast<_Fn &&>(__fn)(__self.__elem2))) {
    return static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem0)),
           static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem1)),
           static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem2));
  }
};
template <std::size_t... _Is, __indices<_Is...> _Idx, class _T0, class _T1,
          class _T2, class _T3>
struct __tuple<_Idx, _T0, _T1, _T2, _T3> {
  _T0 __elem0;
  _T1 __elem1;
  _T2 __elem2;
  _T3 __elem3;
  template <class _U0, class _U1, class _U2, class _U3>
  static auto
  __convert_from(__tuple<_Idx, _U0, _U1, _U2, _U3> &&__tup) -> __tuple {
    return __tuple{
        static_cast<_U0 &&>(__tup.__elem0), static_cast<_U1 &&>(__tup.__elem1),
        static_cast<_U2 &&>(__tup.__elem2), static_cast<_U3 &&>(__tup.__elem3)};
  }
  template <class _U0, class _U1, class _U2, class _U3>
  static auto
  __convert_from(__tuple<_Idx, _U0, _U1, _U2, _U3> const &__tup) -> __tuple {
    return __tuple{__tup.__elem0, __tup.__elem1, __tup.__elem2, __tup.__elem3};
  }
  template <std::size_t _Np, class _Self>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  __get(_Self &&__self) noexcept -> decltype(auto)
    requires(_Np < 4)
  {
    if constexpr (_Np == 0)
      return (static_cast<_Self &&>(__self).__elem0);
    else if constexpr (_Np == 1)
      return (static_cast<_Self &&>(__self).__elem1);
    else if constexpr (_Np == 2)
      return (static_cast<_Self &&>(__self).__elem2);
    else if constexpr (_Np == 3)
      return (static_cast<_Self &&>(__self).__elem3);
    else
      ;
  }
  template <class _Fn, class _Self, class... _Us>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  apply(_Fn &&__fn, _Self &&__self, _Us &&...__us) noexcept(noexcept(
      static_cast<_Fn &&>(__fn)(static_cast<_Us &&>(__us)...,
                                static_cast<_Self &&>(__self).__elem0,
                                static_cast<_Self &&>(__self).__elem1,
                                static_cast<_Self &&>(__self).__elem2,
                                static_cast<_Self &&>(__self).__elem3)))
      -> decltype(static_cast<_Fn &&>(__fn)(
          static_cast<_Us &&>(__us)..., static_cast<_Self &&>(__self).__elem0,
          static_cast<_Self &&>(__self).__elem1,
          static_cast<_Self &&>(__self).__elem2,
          static_cast<_Self &&>(__self).__elem3)) {
    return static_cast<_Fn &&>(__fn)(static_cast<_Us &&>(__us)...,
                                     static_cast<_Self &&>(__self).__elem0,
                                     static_cast<_Self &&>(__self).__elem1,
                                     static_cast<_Self &&>(__self).__elem2,
                                     static_cast<_Self &&>(__self).__elem3);
  }
  template <class _Fn, class _Self>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  for_each(_Fn &&__fn, _Self &&__self) noexcept(
      noexcept(static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem0)),
               static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem1)),
               static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem2)),
               static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem3))))
      -> decltype(static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem0)),
                  static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem1)),
                  static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem2)),
                  static_cast<void>(
                      static_cast<_Fn &&>(__fn)(__self.__elem3))) {
    return static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem0)),
           static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem1)),
           static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem2)),
           static_cast<void>(static_cast<_Fn &&>(__fn)(__self.__elem3));
  }
};

template <class... _Ts>

__tuple(_Ts...) -> __tuple<__indices_for<_Ts...>{}, _Ts...>;

template <class _Fn, class _Tuple, class... _Us>
using __apply_result_t = decltype(__declval<_Tuple>().apply(
    __declval<_Fn>(), __declval<_Tuple>(), __declval<_Us>()...));

template <class _Fn, class _Tuple, class... _Us>
concept __applicable =
    requires { typename __apply_result_t<_Fn, _Tuple, _Us...>; };

template <class _Fn, class _Tuple, class... _Us>
concept __nothrow_applicable =
    __applicable<_Fn, _Tuple, _Us...> &&
    noexcept(__declval<_Tuple>().apply(__declval<_Fn>(), __declval<_Tuple>(),
                                       __declval<_Us>()...));
# 210 "./../stdexec/include/stdexec/__detail/__tuple.hpp"
template <class _Fn, class _Tuple>
__attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
operator<<(_Tuple &&__tup,
           _Fn __fn) noexcept(__nothrow_move_constructible<_Fn>) {
  return [&__tup, __fn = static_cast<_Fn &&>(__fn)]<class... _Us>(
             _Us &&...__us) noexcept(__nothrow_applicable<_Fn, _Tuple, _Us...>)
             -> __apply_result_t<_Fn, _Tuple, _Us...> {
    return __tup.apply(__fn, static_cast<_Tuple &&>(__tup),
                       static_cast<_Us &&>(__us)...);
  };
}

template <class _Fn, class... _Tuples>
auto __cat_apply(_Fn __fn, _Tuples &&...__tups) noexcept(
    noexcept((static_cast<_Tuples &&>(__tups) << ... << __fn)()))
    -> decltype((static_cast<_Tuples &&>(__tups) << ... << __fn)()) {
  return (static_cast<_Tuples &&>(__tups) << ... << __fn)();
}

#pragma GCC diagnostic push
# 223 "./../stdexec/include/stdexec/__detail/__tuple.hpp"
#pragma GCC diagnostic ignored "-Wpragmas"
# 223 "./../stdexec/include/stdexec/__detail/__tuple.hpp"
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
# 223 "./../stdexec/include/stdexec/__detail/__tuple.hpp"
#pragma GCC diagnostic ignored "-Wunknown-warning-option"
# 223 "./../stdexec/include/stdexec/__detail/__tuple.hpp"
#pragma GCC diagnostic ignored "-Wunknown-attributes"
# 223 "./../stdexec/include/stdexec/__detail/__tuple.hpp"
#pragma GCC diagnostic ignored "-Wattributes"
# 223 "./../stdexec/include/stdexec/__detail/__tuple.hpp"
#pragma GCC diagnostic ignored "-Wmissing-braces"

inline constexpr struct __mktuple_t {
  template <class... _Ts>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Ts &&...__ts) const
      noexcept(noexcept(__tuple{static_cast<_Ts &&>(__ts)...}))
          -> decltype(__tuple{static_cast<_Ts &&>(__ts)...}) {
    return __tuple{static_cast<_Ts &&>(__ts)...};
  }
} __mktuple{};

#pragma GCC diagnostic pop
} // namespace __tup

using __tup::__tuple;

template <class... _Ts>
using __tuple_for = __tuple<__indices_for<_Ts...>{}, _Ts...>;

template <class... _Ts> using __decayed_tuple = __tuple_for<__decay_t<_Ts>...>;

template <auto _Idx, class... _Ts> struct __muncurry_<__tuple<_Idx, _Ts...>> {
  template <class _Fn> using __f = __minvoke<_Fn, _Ts...>;
};
} // namespace stdexec
# 26 "./../stdexec/include/stdexec/__detail/__env.hpp" 2

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 1 3
# 47 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
# 59 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
namespace std __attribute__((__visibility__("default"))) {

  class bad_function_call : public std::exception {
  public:
    virtual ~bad_function_call() noexcept;

    const char *what() const noexcept;
  };

  template <typename _Tp>
  struct __is_location_invariant : is_trivially_copyable<_Tp>::type {};

  class _Undefined_class;

  union _Nocopy_types {
    void *_M_object;
    const void *_M_const_object;
    void (*_M_function_pointer)();
    void (_Undefined_class::*_M_member_pointer)();
  };

  union [[gnu::may_alias]] _Any_data {
    void *_M_access() noexcept { return &_M_pod_data[0]; }
    const void *_M_access() const noexcept { return &_M_pod_data[0]; }

    template <typename _Tp> _Tp &_M_access() noexcept {
      return *static_cast<_Tp *>(_M_access());
    }

    template <typename _Tp> const _Tp &_M_access() const noexcept {
      return *static_cast<const _Tp *>(_M_access());
    }

    _Nocopy_types _M_unused;
    char _M_pod_data[sizeof(_Nocopy_types)];
  };

  enum _Manager_operation {
    __get_type_info,
    __get_functor_ptr,
    __clone_functor,
    __destroy_functor
  };

  template <typename _Signature> class function;

  class _Function_base {
  public:
    static const size_t _M_max_size = sizeof(_Nocopy_types);
    static const size_t _M_max_align = __alignof__(_Nocopy_types);

    template <typename _Functor> class _Base_manager {
    protected:
      static const bool __stored_locally =
          (__is_location_invariant<_Functor>::value &&
           sizeof(_Functor) <= _M_max_size &&
           __alignof__(_Functor) <= _M_max_align &&
           (_M_max_align % __alignof__(_Functor) == 0));

      using _Local_storage = integral_constant<bool, __stored_locally>;

      static _Functor *_M_get_pointer(const _Any_data &__source) noexcept {
        if constexpr (__stored_locally) {
          const _Functor &__f = __source._M_access<_Functor>();
          return const_cast<_Functor *>(std::__addressof(__f));
        } else
          return __source._M_access<_Functor *>();
      }

    private:
      template <typename _Fn>
      static void _M_create(_Any_data &__dest, _Fn &&__f, true_type) {
        ::new (__dest._M_access()) _Functor(std::forward<_Fn>(__f));
      }

      template <typename _Fn>
      static void _M_create(_Any_data &__dest, _Fn &&__f, false_type) {
        __dest._M_access<_Functor *>() = new _Functor(std::forward<_Fn>(__f));
      }

      static void _M_destroy(_Any_data &__victim, true_type) {
        __victim._M_access<_Functor>().~_Functor();
      }

      static void _M_destroy(_Any_data &__victim, false_type) {
        delete __victim._M_access<_Functor *>();
      }

    public:
      static bool _M_manager(_Any_data &__dest, const _Any_data &__source,
                             _Manager_operation __op) {
        switch (__op) {
        case __get_type_info:

          __dest._M_access<const type_info *>() = &typeid(_Functor);

          break;

        case __get_functor_ptr:
          __dest._M_access<_Functor *>() = _M_get_pointer(__source);
          break;

        case __clone_functor:
          _M_init_functor(
              __dest, *const_cast<const _Functor *>(_M_get_pointer(__source)));
          break;

        case __destroy_functor:
          _M_destroy(__dest, _Local_storage());
          break;
        }
        return false;
      }

      template <typename _Fn>
      static void _M_init_functor(_Any_data &__functor, _Fn &&__f) noexcept(
          __and_<_Local_storage,
                 is_nothrow_constructible<_Functor, _Fn>>::value) {
        _M_create(__functor, std::forward<_Fn>(__f), _Local_storage());
      }

      template <typename _Signature>
      static bool
      _M_not_empty_function(const function<_Signature> &__f) noexcept {
        return static_cast<bool>(__f);
      }

      template <typename _Tp>
      static bool _M_not_empty_function(_Tp *__fp) noexcept {
        return __fp != nullptr;
      }

      template <typename _Class, typename _Tp>
      static bool _M_not_empty_function(_Tp _Class::*__mp) noexcept {
        return __mp != nullptr;
      }

      template <typename _Tp>
      static bool _M_not_empty_function(const _Tp &) noexcept {
        return true;
      }
    };

    _Function_base() = default;

    ~_Function_base() {
      if (_M_manager)
        _M_manager(_M_functor, _M_functor, __destroy_functor);
    }

    bool _M_empty() const { return !_M_manager; }

    using _Manager_type = bool (*)(_Any_data &, const _Any_data &,
                                   _Manager_operation);

    _Any_data _M_functor{};
    _Manager_type _M_manager{};
  };

  template <typename _Signature, typename _Functor> class _Function_handler;

  template <typename _Res, typename _Functor, typename... _ArgTypes>
  class _Function_handler<_Res(_ArgTypes...), _Functor>
      : public _Function_base::_Base_manager<_Functor> {
    using _Base = _Function_base::_Base_manager<_Functor>;

  public:
    static bool _M_manager(_Any_data &__dest, const _Any_data &__source,
                           _Manager_operation __op) {
      switch (__op) {

      case __get_type_info:
        __dest._M_access<const type_info *>() = &typeid(_Functor);
        break;

      case __get_functor_ptr:
        __dest._M_access<_Functor *>() = _Base::_M_get_pointer(__source);
        break;

      default:
        _Base::_M_manager(__dest, __source, __op);
      }
      return false;
    }

    static _Res _M_invoke(const _Any_data &__functor, _ArgTypes &&...__args) {
      return std::__invoke_r<_Res>(*_Base::_M_get_pointer(__functor),
                                   std::forward<_ArgTypes>(__args)...);
    }

    template <typename _Fn> static constexpr bool _S_nothrow_init() noexcept {
      return __and_<typename _Base::_Local_storage,
                    is_nothrow_constructible<_Functor, _Fn>>::value;
    }
  };

  template <> class _Function_handler<void, void> {
  public:
    static bool _M_manager(_Any_data &, const _Any_data &, _Manager_operation) {
      return false;
    }
  };

  template <typename _Signature, typename _Functor,
            bool __valid = is_object<_Functor>::value>
  struct _Target_handler
      : _Function_handler<_Signature, typename remove_cv<_Functor>::type> {};

  template <typename _Signature, typename _Functor>
  struct _Target_handler<_Signature, _Functor, false>
      : _Function_handler<void, void> {};

  template <typename _Res, typename... _ArgTypes>
  class function<_Res(_ArgTypes...)>
      : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
        private _Function_base {

    template <typename _Func,
              bool _Self = is_same<__remove_cvref_t<_Func>, function>::value>
    using _Decay_t = typename __enable_if_t<!_Self, decay<_Func>>::type;

    template <typename _Func, typename _DFunc = _Decay_t<_Func>,
              typename _Res2 = __invoke_result<_DFunc &, _ArgTypes...>>
    struct _Callable : __is_invocable_impl<_Res2, _Res>::type {};

    template <typename _Cond, typename _Tp = void>
    using _Requires = __enable_if_t<_Cond::value, _Tp>;

    template <typename _Functor>
    using _Handler = _Function_handler<_Res(_ArgTypes...), __decay_t<_Functor>>;

  public:
    typedef _Res result_type;

    function() noexcept : _Function_base() {}

    function(nullptr_t) noexcept : _Function_base() {}
# 386 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
    function(const function &__x) : _Function_base() {
      if (static_cast<bool>(__x)) {
        __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
        _M_invoker = __x._M_invoker;
        _M_manager = __x._M_manager;
      }
    }
# 404 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
    function(function &&__x) noexcept
        : _Function_base(), _M_invoker(__x._M_invoker) {
      if (static_cast<bool>(__x)) {
        _M_functor = __x._M_functor;
        _M_manager = __x._M_manager;
        __x._M_manager = nullptr;
        __x._M_invoker = nullptr;
      }
    }
# 433 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
    template <typename _Functor,
              typename _Constraints = _Requires<_Callable<_Functor>>>
    function(_Functor &&__f) noexcept(
        _Handler<_Functor>::template _S_nothrow_init<_Functor>())
        : _Function_base() {
      static_assert(is_copy_constructible<__decay_t<_Functor>>::value,
                    "std::function target must be copy-constructible");
      static_assert(is_constructible<__decay_t<_Functor>, _Functor>::value,
                    "std::function target must be constructible from the "
                    "constructor argument");

      using _My_handler = _Handler<_Functor>;

      if (_My_handler::_M_not_empty_function(__f)) {
        _My_handler::_M_init_functor(_M_functor, std::forward<_Functor>(__f));
        _M_invoker = &_My_handler::_M_invoke;
        _M_manager = &_My_handler::_M_manager;
      }
    }
# 468 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
    function &operator=(const function &__x) {
      function(__x).swap(*this);
      return *this;
    }
# 486 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
    function &operator=(function &&__x) noexcept {
      function(std::move(__x)).swap(*this);
      return *this;
    }
# 500 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
    function &operator=(nullptr_t) noexcept {
      if (_M_manager) {
        _M_manager(_M_functor, _M_functor, __destroy_functor);
        _M_manager = nullptr;
        _M_invoker = nullptr;
      }
      return *this;
    }
# 529 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
    template <typename _Functor>
    _Requires<_Callable<_Functor>, function &>
    operator=(_Functor &&__f) noexcept(
        _Handler<_Functor>::template _S_nothrow_init<_Functor>()) {
      function(std::forward<_Functor>(__f)).swap(*this);
      return *this;
    }

    template <typename _Functor>
    function &operator=(reference_wrapper<_Functor> __f) noexcept {
      function(__f).swap(*this);
      return *this;
    }
# 556 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
    void swap(function &__x) noexcept {
      std::swap(_M_functor, __x._M_functor);
      std::swap(_M_manager, __x._M_manager);
      std::swap(_M_invoker, __x._M_invoker);
    }
# 573 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
    explicit operator bool() const noexcept { return !_M_empty(); }
# 586 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
    _Res operator()(_ArgTypes... __args) const {
      if (_M_empty())
        __throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
    }
# 605 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
    const type_info &target_type() const noexcept {
      if (_M_manager) {
        _Any_data __typeinfo_result;
        _M_manager(__typeinfo_result, _M_functor, __get_type_info);
        if (auto __ti = __typeinfo_result._M_access<const type_info *>())
          return *__ti;
      }
      return typeid(void);
    }
# 630 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
    template <typename _Functor> _Functor *target() noexcept {
      const function *__const_this = this;
      const _Functor *__func = __const_this->template target<_Functor>();

      return *const_cast<_Functor **>(&__func);
    }

    template <typename _Functor> const _Functor *target() const noexcept {
      if constexpr (is_object<_Functor>::value) {

        using _Handler = _Target_handler<_Res(_ArgTypes...), _Functor>;

        if (_M_manager == &_Handler::_M_manager

            || (_M_manager && typeid(_Functor) == target_type())

        ) {
          _Any_data __ptr;
          _M_manager(__ptr, _M_functor, __get_functor_ptr);
          return __ptr._M_access<const _Functor *>();
        }
      }
      return nullptr;
    }

  private:
    using _Invoker_type = _Res (*)(const _Any_data &, _ArgTypes &&...);
    _Invoker_type _M_invoker = nullptr;
  };

  template <typename> struct __function_guide_helper {};

  template <typename _Res, typename _Tp, bool _Nx, typename... _Args>
  struct __function_guide_helper<_Res (_Tp::*)(_Args...) noexcept(_Nx)> {
    using type = _Res(_Args...);
  };

  template <typename _Res, typename _Tp, bool _Nx, typename... _Args>
  struct __function_guide_helper<_Res (_Tp::*)(_Args...) & noexcept(_Nx)> {
    using type = _Res(_Args...);
  };

  template <typename _Res, typename _Tp, bool _Nx, typename... _Args>
  struct __function_guide_helper<_Res (_Tp::*)(_Args...) const noexcept(_Nx)> {
    using type = _Res(_Args...);
  };

  template <typename _Res, typename _Tp, bool _Nx, typename... _Args>
  struct __function_guide_helper<_Res (_Tp::*)(_Args...) const &
                                 noexcept(_Nx)> {
    using type = _Res(_Args...);
  };
# 715 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
  template <typename _Fn, typename _Op>
  using __function_guide_t = typename __function_guide_helper<_Op>::type;

  template <typename _Res, typename... _ArgTypes>
  function(_Res(*)(_ArgTypes...)) -> function<_Res(_ArgTypes...)>;

  template <typename _Fn,
            typename _Signature =
                __function_guide_t<_Fn, decltype(&_Fn::operator())>>
  function(_Fn) -> function<_Signature>;
# 735 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
  template <typename _Res, typename... _Args>
  inline bool operator==(const function<_Res(_Args...)> &__f,
                         nullptr_t) noexcept {
    return !static_cast<bool>(__f);
  }
# 774 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_function.h" 3
  template <typename _Res, typename... _Args>
  inline void swap(function<_Res(_Args...)> & __x,
                   function<_Res(_Args...)> & __y) noexcept {
    __x.swap(__y);
  }

  namespace __detail::__variant {
  template <typename> struct _Never_valueless_alt;

  template <typename _Signature>
  struct _Never_valueless_alt<std::function<_Signature>> : std::true_type {};
  } // namespace __detail::__variant

} // namespace std
# 60 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/array" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/array" 3
# 48 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/array" 3
namespace std __attribute__((__visibility__("default"))) {

  template <typename _Tp, size_t _Nm> struct __array_traits {
    using _Type = _Tp[_Nm];
    using _Is_swappable = __is_swappable<_Tp>;
    using _Is_nothrow_swappable = __is_nothrow_swappable<_Tp>;
  };

  template <typename _Tp> struct __array_traits<_Tp, 0> {

    struct _Type {

      __attribute__((__always_inline__, __noreturn__)) _Tp &
      operator[](size_t) const noexcept {
        __builtin_trap();
      }

      __attribute__((__always_inline__)) constexpr explicit
      operator _Tp *() const noexcept {
        return nullptr;
      }
    };

    using _Is_swappable = true_type;
    using _Is_nothrow_swappable = true_type;
  };
# 93 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/array" 3
  template <typename _Tp, std::size_t _Nm> struct array {
    typedef _Tp value_type;
    typedef value_type *pointer;
    typedef const value_type *const_pointer;
    typedef value_type &reference;
    typedef const value_type &const_reference;
    typedef value_type *iterator;
    typedef const value_type *const_iterator;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    typename __array_traits<_Tp, _Nm>::_Type _M_elems;

    constexpr void fill(const value_type &__u) {
      std::fill_n(begin(), size(), __u);
    }

    constexpr void swap(array &__other) noexcept(
        __array_traits<_Tp, _Nm>::_Is_nothrow_swappable::value) {
      std::swap_ranges(begin(), end(), __other.begin());
    }

    [[__gnu__::__const__, __nodiscard__]]
    constexpr iterator begin() noexcept {
      return iterator(data());
    }

    [[__nodiscard__]]
    constexpr const_iterator begin() const noexcept {
      return const_iterator(data());
    }

    [[__gnu__::__const__, __nodiscard__]]
    constexpr iterator end() noexcept {
      return iterator(data() + _Nm);
    }

    [[__nodiscard__]]
    constexpr const_iterator end() const noexcept {
      return const_iterator(data() + _Nm);
    }

    [[__gnu__::__const__, __nodiscard__]]
    constexpr reverse_iterator rbegin() noexcept {
      return reverse_iterator(end());
    }

    [[__nodiscard__]]
    constexpr const_reverse_iterator rbegin() const noexcept {
      return const_reverse_iterator(end());
    }

    [[__gnu__::__const__, __nodiscard__]]
    constexpr reverse_iterator rend() noexcept {
      return reverse_iterator(begin());
    }

    [[__nodiscard__]]
    constexpr const_reverse_iterator rend() const noexcept {
      return const_reverse_iterator(begin());
    }

    [[__nodiscard__]]
    constexpr const_iterator cbegin() const noexcept {
      return const_iterator(data());
    }

    [[__nodiscard__]]
    constexpr const_iterator cend() const noexcept {
      return const_iterator(data() + _Nm);
    }

    [[__nodiscard__]]
    constexpr const_reverse_iterator crbegin() const noexcept {
      return const_reverse_iterator(end());
    }

    [[__nodiscard__]]
    constexpr const_reverse_iterator crend() const noexcept {
      return const_reverse_iterator(begin());
    }

    [[__nodiscard__, __gnu__::__const__, __gnu__::__always_inline__]]
    constexpr size_type size() const noexcept {
      return _Nm;
    }

    [[__nodiscard__, __gnu__::__const__, __gnu__::__always_inline__]]
    constexpr size_type max_size() const noexcept {
      return _Nm;
    }

    [[__nodiscard__, __gnu__::__const__, __gnu__::__always_inline__]]
    constexpr bool empty() const noexcept {
      return size() == 0;
    }

    [[__nodiscard__]]
    constexpr reference operator[](size_type __n) noexcept {
      ;
      return _M_elems[__n];
    }

    [[__nodiscard__]]
    constexpr const_reference operator[](size_type __n) const noexcept {

      ;

      return _M_elems[__n];
    }

    constexpr reference at(size_type __n) {
      if (__n >= _Nm)
        std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) "
                                       ">= _Nm (which is %zu)"),

                                      __n, _Nm);
      return _M_elems[__n];
    }

    constexpr const_reference at(size_type __n) const {

      return __n < _Nm ? _M_elems[__n]
                       : (std::__throw_out_of_range_fmt(
                              ("array::at: __n (which is %zu) "
                               ">= _Nm (which is %zu)"),

                              __n, _Nm),
                          _M_elems[__n]);
    }

    [[__nodiscard__]]
    constexpr reference front() noexcept {
      ;
      return _M_elems[(size_type)0];
    }

    [[__nodiscard__]]
    constexpr const_reference front() const noexcept {

      ;

      return _M_elems[(size_type)0];
    }

    [[__nodiscard__]]
    constexpr reference back() noexcept {
      ;
      return _M_elems[_Nm - 1];
    }

    [[__nodiscard__]]
    constexpr const_reference back() const noexcept {

      ;

      return _M_elems[_Nm - 1];
    }

    [[__nodiscard__, __gnu__::__const__, __gnu__::__always_inline__]]
    constexpr pointer data() noexcept {
      return static_cast<pointer>(_M_elems);
    }

    [[__nodiscard__]]
    constexpr const_pointer data() const noexcept {
      return static_cast<const_pointer>(_M_elems);
    }
  };

  template <typename _Tp, typename... _Up>
  array(_Tp, _Up...) -> array<enable_if_t<(is_same_v<_Tp, _Up> && ...), _Tp>,
                              1 + sizeof...(_Up)>;

  template <typename _Tp, std::size_t _Nm>
  [[__nodiscard__]]
  constexpr inline bool operator==(const array<_Tp, _Nm> &__one,
                                   const array<_Tp, _Nm> &__two) {
    return std::equal(__one.begin(), __one.end(), __two.begin());
  }

  template <typename _Tp, size_t _Nm>
  [[nodiscard]]
  constexpr __detail::__synth3way_t<_Tp> operator<=>(
      const array<_Tp, _Nm> &__a, const array<_Tp, _Nm> &__b) {
    if constexpr (_Nm && __is_memcmp_ordered<_Tp>::__value)
      if (!std::__is_constant_evaluated()) {
        constexpr size_t __n = _Nm * sizeof(_Tp);
        return __builtin_memcmp(__a.data(), __b.data(), __n) <=> 0;
      }

    for (size_t __i = 0; __i < _Nm; ++__i) {
      auto __c = __detail::__synth3way(__a[__i], __b[__i]);
      if (__c != 0)
        return __c;
    }
    return strong_ordering::equal;
  }
# 362 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/array" 3
  template <typename _Tp, std::size_t _Nm>
  constexpr inline

      __enable_if_t<__array_traits<_Tp, _Nm>::_Is_swappable::value>

      swap(array<_Tp, _Nm> & __one,
           array<_Tp, _Nm> & __two) noexcept(noexcept(__one.swap(__two))) {
    __one.swap(__two);
  }

  template <typename _Tp, std::size_t _Nm>
  __enable_if_t<!__array_traits<_Tp, _Nm>::_Is_swappable::value> swap(
      array<_Tp, _Nm> &, array<_Tp, _Nm> &) = delete;

  template <std::size_t _Int, typename _Tp, std::size_t _Nm>
  [[__nodiscard__]]
  constexpr _Tp &get(array<_Tp, _Nm> & __arr) noexcept {
    static_assert(_Int < _Nm, "array index is within bounds");
    return __arr._M_elems[_Int];
  }

  template <std::size_t _Int, typename _Tp, std::size_t _Nm>
  [[__nodiscard__]]
  constexpr _Tp &&get(array<_Tp, _Nm> && __arr) noexcept {
    static_assert(_Int < _Nm, "array index is within bounds");
    return std::move(std::get<_Int>(__arr));
  }

  template <std::size_t _Int, typename _Tp, std::size_t _Nm>
  [[__nodiscard__]]
  constexpr const _Tp &get(const array<_Tp, _Nm> &__arr) noexcept {
    static_assert(_Int < _Nm, "array index is within bounds");
    return __arr._M_elems[_Int];
  }

  template <std::size_t _Int, typename _Tp, std::size_t _Nm>
  [[__nodiscard__]]
  constexpr const _Tp &&get(const array<_Tp, _Nm> &&__arr) noexcept {
    static_assert(_Int < _Nm, "array index is within bounds");
    return std::move(std::get<_Int>(__arr));
  }

  template <typename _Tp, size_t _Nm>
  [[nodiscard]]
  constexpr array<remove_cv_t<_Tp>, _Nm> to_array(_Tp(&__a)[_Nm]) noexcept(
      is_nothrow_constructible_v<_Tp, _Tp &>) {
    static_assert(!is_array_v<_Tp>);
    static_assert(is_constructible_v<_Tp, _Tp &>);
    if constexpr (is_constructible_v<_Tp, _Tp &>) {
      if constexpr (is_trivially_copyable_v<_Tp> &&
                    is_trivially_default_constructible_v<_Tp> &&
                    is_copy_assignable_v<_Tp>) {
        array<remove_cv_t<_Tp>, _Nm> __arr;
        if (!__is_constant_evaluated() && _Nm != 0)
          __builtin_memcpy((void *)__arr.data(), (void *)__a, sizeof(__a));
        else
          for (size_t __i = 0; __i < _Nm; ++__i)
            __arr._M_elems[__i] = __a[__i];
        return __arr;
      } else
        return [&__a]<size_t... _Idx>(index_sequence<_Idx...>) {
          return array<remove_cv_t<_Tp>, _Nm>{{__a[_Idx]...}};
        }(make_index_sequence<_Nm>{});
    } else
      __builtin_unreachable();
  }

  template <typename _Tp, size_t _Nm>
  [[nodiscard]]
  constexpr array<remove_cv_t<_Tp>, _Nm> to_array(_Tp(&&__a)[_Nm]) noexcept(
      is_nothrow_move_constructible_v<_Tp>) {
    static_assert(!is_array_v<_Tp>);
    static_assert(is_move_constructible_v<_Tp>);
    if constexpr (is_move_constructible_v<_Tp>) {
      if constexpr (is_trivially_copyable_v<_Tp> &&
                    is_trivially_default_constructible_v<_Tp> &&
                    is_copy_assignable_v<_Tp>) {
        array<remove_cv_t<_Tp>, _Nm> __arr;
        if (!__is_constant_evaluated() && _Nm != 0)
          __builtin_memcpy((void *)__arr.data(), (void *)__a, sizeof(__a));
        else
          for (size_t __i = 0; __i < _Nm; ++__i)
            __arr._M_elems[__i] = __a[__i];
        return __arr;
      } else
        return [&__a]<size_t... _Idx>(index_sequence<_Idx...>) {
          return array<remove_cv_t<_Tp>, _Nm>{{std::move(__a[_Idx])...}};
        }(make_index_sequence<_Nm>{});
    } else
      __builtin_unreachable();
  }

  template <typename _Tp, size_t _Nm>
  struct tuple_size<array<_Tp, _Nm>> : public integral_constant<size_t, _Nm> {};

  template <size_t _Ind, typename _Tp, size_t _Nm>
  struct tuple_element<_Ind, array<_Tp, _Nm>> {
    static_assert(_Ind < _Nm, "array index is in range");
    using type = _Tp;
  };

  template <typename _Tp, size_t _Nm>
  inline constexpr size_t tuple_size_v<array<_Tp, _Nm>> = _Nm;

  template <typename _Tp, size_t _Nm>
  inline constexpr size_t tuple_size_v<const array<_Tp, _Nm>> = _Nm;

  template <typename _Tp, size_t _Nm>
  struct __is_tuple_like_impl<array<_Tp, _Nm>> : true_type {};

} // namespace std
# 66 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 1 3
# 59 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/algorithmfwd.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/algorithmfwd.h" 3

namespace std __attribute__((__visibility__("default"))) {
# 199 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/algorithmfwd.h" 3
  template <typename _IIter, typename _Predicate>
  constexpr bool all_of(_IIter, _IIter, _Predicate);

  template <typename _IIter, typename _Predicate>
  constexpr bool any_of(_IIter, _IIter, _Predicate);

  template <typename _FIter, typename _Tp>
  constexpr bool binary_search(_FIter, _FIter, const _Tp &);

  template <typename _FIter, typename _Tp, typename _Compare>
  constexpr bool binary_search(_FIter, _FIter, const _Tp &, _Compare);

  template <typename _Tp>
  constexpr const _Tp &clamp(const _Tp &, const _Tp &, const _Tp &);

  template <typename _Tp, typename _Compare>
  constexpr const _Tp &clamp(const _Tp &, const _Tp &, const _Tp &, _Compare);

  template <typename _IIter, typename _OIter>
  constexpr _OIter copy(_IIter, _IIter, _OIter);

  template <typename _BIter1, typename _BIter2>
  constexpr _BIter2 copy_backward(_BIter1, _BIter1, _BIter2);

  template <typename _IIter, typename _OIter, typename _Predicate>
  constexpr _OIter copy_if(_IIter, _IIter, _OIter, _Predicate);

  template <typename _IIter, typename _Size, typename _OIter>
  constexpr _OIter copy_n(_IIter, _Size, _OIter);

  template <typename _FIter, typename _Tp>
  constexpr pair<_FIter, _FIter> equal_range(_FIter, _FIter, const _Tp &);

  template <typename _FIter, typename _Tp, typename _Compare>
  constexpr pair<_FIter, _FIter> equal_range(_FIter, _FIter, const _Tp &,
                                             _Compare);

  template <typename _FIter, typename _Tp>
  constexpr void fill(_FIter, _FIter, const _Tp &);

  template <typename _OIter, typename _Size, typename _Tp>
  constexpr _OIter fill_n(_OIter, _Size, const _Tp &);

  template <typename _FIter1, typename _FIter2>
  constexpr _FIter1 find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template <typename _FIter1, typename _FIter2, typename _BinaryPredicate>
  constexpr _FIter1 find_end(_FIter1, _FIter1, _FIter2, _FIter2,
                             _BinaryPredicate);

  template <typename _IIter, typename _Predicate>
  constexpr _IIter find_if_not(_IIter, _IIter, _Predicate);

  template <typename _IIter1, typename _IIter2>
  constexpr bool includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template <typename _IIter1, typename _IIter2, typename _Compare>
  constexpr bool includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template <typename _BIter> void inplace_merge(_BIter, _BIter, _BIter);

  template <typename _BIter, typename _Compare>
  void inplace_merge(_BIter, _BIter, _BIter, _Compare);

  template <typename _RAIter> constexpr bool is_heap(_RAIter, _RAIter);

  template <typename _RAIter, typename _Compare>
  constexpr bool is_heap(_RAIter, _RAIter, _Compare);

  template <typename _RAIter> constexpr _RAIter is_heap_until(_RAIter, _RAIter);

  template <typename _RAIter, typename _Compare>
  constexpr _RAIter is_heap_until(_RAIter, _RAIter, _Compare);

  template <typename _IIter, typename _Predicate>
  constexpr bool is_partitioned(_IIter, _IIter, _Predicate);

  template <typename _FIter1, typename _FIter2>
  constexpr bool is_permutation(_FIter1, _FIter1, _FIter2);

  template <typename _FIter1, typename _FIter2, typename _BinaryPredicate>
  constexpr bool is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template <typename _FIter> constexpr bool is_sorted(_FIter, _FIter);

  template <typename _FIter, typename _Compare>
  constexpr bool is_sorted(_FIter, _FIter, _Compare);

  template <typename _FIter> constexpr _FIter is_sorted_until(_FIter, _FIter);

  template <typename _FIter, typename _Compare>
  constexpr _FIter is_sorted_until(_FIter, _FIter, _Compare);

  template <typename _FIter1, typename _FIter2>
  constexpr void iter_swap(_FIter1, _FIter2);

  template <typename _FIter, typename _Tp>
  constexpr _FIter lower_bound(_FIter, _FIter, const _Tp &);

  template <typename _FIter, typename _Tp, typename _Compare>
  constexpr _FIter lower_bound(_FIter, _FIter, const _Tp &, _Compare);

  template <typename _RAIter> constexpr void make_heap(_RAIter, _RAIter);

  template <typename _RAIter, typename _Compare>
  constexpr void make_heap(_RAIter, _RAIter, _Compare);

  template <typename _Tp> constexpr const _Tp &max(const _Tp &, const _Tp &);

  template <typename _Tp, typename _Compare>
  constexpr const _Tp &max(const _Tp &, const _Tp &, _Compare);

  template <typename _Tp> constexpr const _Tp &min(const _Tp &, const _Tp &);

  template <typename _Tp, typename _Compare>
  constexpr const _Tp &min(const _Tp &, const _Tp &, _Compare);

  template <typename _Tp>
  constexpr pair<const _Tp &, const _Tp &> minmax(const _Tp &, const _Tp &);

  template <typename _Tp, typename _Compare>
  constexpr pair<const _Tp &, const _Tp &> minmax(const _Tp &, const _Tp &,
                                                  _Compare);

  template <typename _FIter>
  constexpr pair<_FIter, _FIter> minmax_element(_FIter, _FIter);

  template <typename _FIter, typename _Compare>
  constexpr pair<_FIter, _FIter> minmax_element(_FIter, _FIter, _Compare);

  template <typename _Tp> constexpr _Tp min(initializer_list<_Tp>);

  template <typename _Tp, typename _Compare>
  constexpr _Tp min(initializer_list<_Tp>, _Compare);

  template <typename _Tp> constexpr _Tp max(initializer_list<_Tp>);

  template <typename _Tp, typename _Compare>
  constexpr _Tp max(initializer_list<_Tp>, _Compare);

  template <typename _Tp>
  constexpr pair<_Tp, _Tp> minmax(initializer_list<_Tp>);

  template <typename _Tp, typename _Compare>
  constexpr pair<_Tp, _Tp> minmax(initializer_list<_Tp>, _Compare);

  template <typename _BIter> constexpr bool next_permutation(_BIter, _BIter);

  template <typename _BIter, typename _Compare>
  constexpr bool next_permutation(_BIter, _BIter, _Compare);

  template <typename _IIter, typename _Predicate>
  constexpr bool none_of(_IIter, _IIter, _Predicate);

  template <typename _IIter, typename _RAIter>
  constexpr _RAIter partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template <typename _IIter, typename _RAIter, typename _Compare>
  constexpr _RAIter partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter,
                                      _Compare);

  template <typename _IIter, typename _OIter1, typename _OIter2,
            typename _Predicate>
  constexpr pair<_OIter1, _OIter2> partition_copy(_IIter, _IIter, _OIter1,
                                                  _OIter2, _Predicate);

  template <typename _FIter, typename _Predicate>
  constexpr _FIter partition_point(_FIter, _FIter, _Predicate);

  template <typename _RAIter> constexpr void pop_heap(_RAIter, _RAIter);

  template <typename _RAIter, typename _Compare>
  constexpr void pop_heap(_RAIter, _RAIter, _Compare);

  template <typename _BIter> constexpr bool prev_permutation(_BIter, _BIter);

  template <typename _BIter, typename _Compare>
  constexpr bool prev_permutation(_BIter, _BIter, _Compare);

  template <typename _RAIter> constexpr void push_heap(_RAIter, _RAIter);

  template <typename _RAIter, typename _Compare>
  constexpr void push_heap(_RAIter, _RAIter, _Compare);

  template <typename _FIter, typename _Tp>
  constexpr _FIter remove(_FIter, _FIter, const _Tp &);

  template <typename _FIter, typename _Predicate>
  constexpr _FIter remove_if(_FIter, _FIter, _Predicate);

  template <typename _IIter, typename _OIter, typename _Tp>
  constexpr _OIter remove_copy(_IIter, _IIter, _OIter, const _Tp &);

  template <typename _IIter, typename _OIter, typename _Predicate>
  constexpr _OIter remove_copy_if(_IIter, _IIter, _OIter, _Predicate);

  template <typename _IIter, typename _OIter, typename _Tp>
  constexpr _OIter replace_copy(_IIter, _IIter, _OIter, const _Tp &,
                                const _Tp &);

  template <typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
  constexpr _OIter replace_copy_if(_Iter, _Iter, _OIter, _Predicate,
                                   const _Tp &);

  template <typename _BIter> constexpr void reverse(_BIter, _BIter);

  template <typename _BIter, typename _OIter>
  constexpr _OIter reverse_copy(_BIter, _BIter, _OIter);

  inline namespace _V2 {

  template <typename _FIter> constexpr _FIter rotate(_FIter, _FIter, _FIter);

  }

  template <typename _FIter, typename _OIter>
  constexpr _OIter rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 626 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/algorithmfwd.h" 3
  template <typename _RAIter, typename _UGenerator>
  void shuffle(_RAIter, _RAIter, _UGenerator &&);

  template <typename _RAIter> constexpr void sort_heap(_RAIter, _RAIter);

  template <typename _RAIter, typename _Compare>
  constexpr void sort_heap(_RAIter, _RAIter, _Compare);

  template <typename _BIter, typename _Predicate>
  _BIter stable_partition(_BIter, _BIter, _Predicate);
# 661 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/algorithmfwd.h" 3
  template <typename _FIter1, typename _FIter2>
  constexpr _FIter2 swap_ranges(_FIter1, _FIter1, _FIter2);

  template <typename _FIter> constexpr _FIter unique(_FIter, _FIter);

  template <typename _FIter, typename _BinaryPredicate>
  constexpr _FIter unique(_FIter, _FIter, _BinaryPredicate);

  template <typename _FIter, typename _Tp>
  constexpr _FIter upper_bound(_FIter, _FIter, const _Tp &);

  template <typename _FIter, typename _Tp, typename _Compare>
  constexpr _FIter upper_bound(_FIter, _FIter, const _Tp &, _Compare);

  template <typename _FIter> constexpr _FIter adjacent_find(_FIter, _FIter);

  template <typename _FIter, typename _BinaryPredicate>
  constexpr _FIter adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template <typename _IIter, typename _Tp>
  constexpr typename iterator_traits<_IIter>::difference_type count(
      _IIter, _IIter, const _Tp &);

  template <typename _IIter, typename _Predicate>
  constexpr typename iterator_traits<_IIter>::difference_type count_if(
      _IIter, _IIter, _Predicate);

  template <typename _IIter1, typename _IIter2>
  constexpr bool equal(_IIter1, _IIter1, _IIter2);

  template <typename _IIter1, typename _IIter2, typename _BinaryPredicate>
  constexpr bool equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template <typename _IIter, typename _Tp>
  constexpr _IIter find(_IIter, _IIter, const _Tp &);

  template <typename _FIter1, typename _FIter2>
  constexpr _FIter1 find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template <typename _FIter1, typename _FIter2, typename _BinaryPredicate>
  constexpr _FIter1 find_first_of(_FIter1, _FIter1, _FIter2, _FIter2,
                                  _BinaryPredicate);

  template <typename _IIter, typename _Predicate>
  constexpr _IIter find_if(_IIter, _IIter, _Predicate);

  template <typename _IIter, typename _Funct>
  constexpr _Funct for_each(_IIter, _IIter, _Funct);

  template <typename _FIter, typename _Generator>
  constexpr void generate(_FIter, _FIter, _Generator);

  template <typename _OIter, typename _Size, typename _Generator>
  constexpr _OIter generate_n(_OIter, _Size, _Generator);

  template <typename _IIter1, typename _IIter2>
  constexpr bool lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template <typename _IIter1, typename _IIter2, typename _Compare>
  constexpr bool lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2,
                                         _Compare);

  template <typename _FIter> constexpr _FIter max_element(_FIter, _FIter);

  template <typename _FIter, typename _Compare>
  constexpr _FIter max_element(_FIter, _FIter, _Compare);

  template <typename _IIter1, typename _IIter2, typename _OIter>
  constexpr _OIter merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template <typename _IIter1, typename _IIter2, typename _OIter,
            typename _Compare>
  constexpr _OIter merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template <typename _FIter> constexpr _FIter min_element(_FIter, _FIter);

  template <typename _FIter, typename _Compare>
  constexpr _FIter min_element(_FIter, _FIter, _Compare);

  template <typename _IIter1, typename _IIter2>
  constexpr pair<_IIter1, _IIter2> mismatch(_IIter1, _IIter1, _IIter2);

  template <typename _IIter1, typename _IIter2, typename _BinaryPredicate>
  constexpr pair<_IIter1, _IIter2> mismatch(_IIter1, _IIter1, _IIter2,
                                            _BinaryPredicate);

  template <typename _RAIter>
  constexpr void nth_element(_RAIter, _RAIter, _RAIter);

  template <typename _RAIter, typename _Compare>
  constexpr void nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template <typename _RAIter>
  constexpr void partial_sort(_RAIter, _RAIter, _RAIter);

  template <typename _RAIter, typename _Compare>
  constexpr void partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template <typename _BIter, typename _Predicate>
  constexpr _BIter partition(_BIter, _BIter, _Predicate);

  template <typename _RAIter>
  __attribute__((__deprecated__("use '"
                                "std::shuffle"
                                "' instead"))) void random_shuffle(_RAIter,
                                                                   _RAIter);

  template <typename _RAIter, typename _Generator>
  __attribute__((__deprecated__("use '"
                                "std::shuffle"
                                "' instead"))) void
  random_shuffle(_RAIter, _RAIter,

                 _Generator &&);

  template <typename _FIter, typename _Tp>
  constexpr void replace(_FIter, _FIter, const _Tp &, const _Tp &);

  template <typename _FIter, typename _Predicate, typename _Tp>
  constexpr void replace_if(_FIter, _FIter, _Predicate, const _Tp &);

  template <typename _FIter1, typename _FIter2>
  constexpr _FIter1 search(_FIter1, _FIter1, _FIter2, _FIter2);

  template <typename _FIter1, typename _FIter2, typename _BinaryPredicate>
  constexpr _FIter1 search(_FIter1, _FIter1, _FIter2, _FIter2,
                           _BinaryPredicate);

  template <typename _FIter, typename _Size, typename _Tp>
  constexpr _FIter search_n(_FIter, _FIter, _Size, const _Tp &);

  template <typename _FIter, typename _Size, typename _Tp,
            typename _BinaryPredicate>
  constexpr _FIter search_n(_FIter, _FIter, _Size, const _Tp &,
                            _BinaryPredicate);

  template <typename _IIter1, typename _IIter2, typename _OIter>
  constexpr _OIter set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template <typename _IIter1, typename _IIter2, typename _OIter,
            typename _Compare>
  constexpr _OIter set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,
                                  _Compare);

  template <typename _IIter1, typename _IIter2, typename _OIter>
  constexpr _OIter set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template <typename _IIter1, typename _IIter2, typename _OIter,
            typename _Compare>
  constexpr _OIter set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,
                                    _Compare);

  template <typename _IIter1, typename _IIter2, typename _OIter>
  constexpr _OIter set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
                                            _OIter);

  template <typename _IIter1, typename _IIter2, typename _OIter,
            typename _Compare>
  constexpr _OIter set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
                                            _OIter, _Compare);

  template <typename _IIter1, typename _IIter2, typename _OIter>
  constexpr _OIter set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template <typename _IIter1, typename _IIter2, typename _OIter,
            typename _Compare>
  constexpr _OIter set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter,
                             _Compare);

  template <typename _RAIter> constexpr void sort(_RAIter, _RAIter);

  template <typename _RAIter, typename _Compare>
  constexpr void sort(_RAIter, _RAIter, _Compare);

  template <typename _RAIter> void stable_sort(_RAIter, _RAIter);

  template <typename _RAIter, typename _Compare>
  void stable_sort(_RAIter, _RAIter, _Compare);

  template <typename _IIter, typename _OIter, typename _UnaryOperation>
  constexpr _OIter transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template <typename _IIter1, typename _IIter2, typename _OIter,
            typename _BinaryOperation>
  constexpr _OIter transform(_IIter1, _IIter1, _IIter2, _OIter,
                             _BinaryOperation);

  template <typename _IIter, typename _OIter>
  constexpr _OIter unique_copy(_IIter, _IIter, _OIter);

  template <typename _IIter, typename _OIter, typename _BinaryPredicate>
  constexpr _OIter unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);

} // namespace std
# 60 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_heap.h" 1 3
# 63 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_heap.h" 3
namespace std __attribute__((__visibility__("default"))) {

  template <typename _RandomAccessIterator, typename _Distance,
            typename _Compare>
  constexpr _Distance __is_heap_until(_RandomAccessIterator __first,
                                      _Distance __n, _Compare & __comp) {
    _Distance __parent = 0;
    for (_Distance __child = 1; __child < __n; ++__child) {
      if (__comp(__first + __parent, __first + __child))
        return __child;
      if ((__child & 1) == 0)
        ++__parent;
    }
    return __n;
  }

  template <typename _RandomAccessIterator, typename _Distance>
  constexpr inline bool __is_heap(_RandomAccessIterator __first,
                                  _Distance __n) {
    __gnu_cxx::__ops::_Iter_less_iter __comp;
    return std::__is_heap_until(__first, __n, __comp) == __n;
  }

  template <typename _RandomAccessIterator, typename _Compare,
            typename _Distance>
  constexpr inline bool __is_heap(_RandomAccessIterator __first,
                                  _Compare __comp, _Distance __n) {
    typedef __decltype(__comp) _Cmp;
    __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
    return std::__is_heap_until(__first, __n, __cmp) == __n;
  }

  template <typename _RandomAccessIterator>
  constexpr inline bool __is_heap(_RandomAccessIterator __first,
                                  _RandomAccessIterator __last) {
    return std::__is_heap(__first, std::distance(__first, __last));
  }

  template <typename _RandomAccessIterator, typename _Compare>
  constexpr inline bool __is_heap(_RandomAccessIterator __first,
                                  _RandomAccessIterator __last,
                                  _Compare __comp) {
    return std::__is_heap(__first, std::move(__comp),
                          std::distance(__first, __last));
  }

  template <typename _RandomAccessIterator, typename _Distance, typename _Tp,
            typename _Compare>
  constexpr void __push_heap(_RandomAccessIterator __first,
                             _Distance __holeIndex, _Distance __topIndex,
                             _Tp __value, _Compare & __comp) {
    _Distance __parent = (__holeIndex - 1) / 2;
    while (__holeIndex > __topIndex && __comp(__first + __parent, __value)) {
      *(__first + __holeIndex) = std::move(*(__first + __parent));
      __holeIndex = __parent;
      __parent = (__holeIndex - 1) / 2;
    }
    *(__first + __holeIndex) = std::move(__value);
  }
# 159 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_heap.h" 3
  template <typename _RandomAccessIterator>
  constexpr inline void push_heap(_RandomAccessIterator __first,
                                  _RandomAccessIterator __last) {
    typedef
        typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type
        _DistanceType;

    ;
    ;
    ;

    __gnu_cxx::__ops::_Iter_less_val __comp;
    _ValueType __value = std::move(*(__last - 1));
    std::__push_heap(__first, _DistanceType((__last - __first) - 1),
                     _DistanceType(0), std::move(__value), __comp);
  }
# 195 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_heap.h" 3
  template <typename _RandomAccessIterator, typename _Compare>
  constexpr inline void push_heap(_RandomAccessIterator __first,
                                  _RandomAccessIterator __last,
                                  _Compare __comp) {
    typedef
        typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type
        _DistanceType;

    ;
    ;
    ;

    __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp))) __cmp(
        std::move(__comp));
    _ValueType __value = std::move(*(__last - 1));
    std::__push_heap(__first, _DistanceType((__last - __first) - 1),
                     _DistanceType(0), std::move(__value), __cmp);
  }

  template <typename _RandomAccessIterator, typename _Distance, typename _Tp,
            typename _Compare>
  constexpr void __adjust_heap(_RandomAccessIterator __first,
                               _Distance __holeIndex, _Distance __len,
                               _Tp __value, _Compare __comp) {
    const _Distance __topIndex = __holeIndex;
    _Distance __secondChild = __holeIndex;
    while (__secondChild < (__len - 1) / 2) {
      __secondChild = 2 * (__secondChild + 1);
      if (__comp(__first + __secondChild, __first + (__secondChild - 1)))
        __secondChild--;
      *(__first + __holeIndex) = std::move(*(__first + __secondChild));
      __holeIndex = __secondChild;
    }
    if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2) {
      __secondChild = 2 * (__secondChild + 1);
      *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)));

      __holeIndex = __secondChild - 1;
    }
    __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp))) __cmp(
        std::move(__comp));
    std::__push_heap(__first, __holeIndex, __topIndex, std::move(__value),
                     __cmp);
  }

  template <typename _RandomAccessIterator, typename _Compare>
  constexpr inline void __pop_heap(
      _RandomAccessIterator __first, _RandomAccessIterator __last,
      _RandomAccessIterator __result, _Compare & __comp) {
    typedef
        typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type
        _DistanceType;

    _ValueType __value = std::move(*__result);
    *__result = std::move(*__first);
    std::__adjust_heap(__first, _DistanceType(0),
                       _DistanceType(__last - __first), std::move(__value),
                       __comp);
  }
# 280 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_heap.h" 3
  template <typename _RandomAccessIterator>
  constexpr inline void pop_heap(_RandomAccessIterator __first,
                                 _RandomAccessIterator __last) {

    ;
    ;
    ;
    ;

    if (__last - __first > 1) {
      --__last;
      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__pop_heap(__first, __last, __last, __comp);
    }
  }
# 314 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_heap.h" 3
  template <typename _RandomAccessIterator, typename _Compare>
  constexpr inline void pop_heap(_RandomAccessIterator __first,
                                 _RandomAccessIterator __last,
                                 _Compare __comp) {

    ;
    ;
    ;
    ;

    if (__last - __first > 1) {
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      --__last;
      std::__pop_heap(__first, __last, __last, __cmp);
    }
  }

  template <typename _RandomAccessIterator, typename _Compare>
  constexpr void __make_heap(_RandomAccessIterator __first,
                             _RandomAccessIterator __last, _Compare & __comp) {
    typedef
        typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type
        _DistanceType;

    if (__last - __first < 2)
      return;

    const _DistanceType __len = __last - __first;
    _DistanceType __parent = (__len - 2) / 2;
    while (true) {
      _ValueType __value = std::move(*(__first + __parent));
      std::__adjust_heap(__first, __parent, __len, std::move(__value), __comp);
      if (__parent == 0)
        return;
      __parent--;
    }
  }
# 372 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_heap.h" 3
  template <typename _RandomAccessIterator>
  constexpr inline void make_heap(_RandomAccessIterator __first,
                                  _RandomAccessIterator __last) {

    ;
    ;

    __gnu_cxx::__ops::_Iter_less_iter __comp;
    std::__make_heap(__first, __last, __comp);
  }
# 399 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_heap.h" 3
  template <typename _RandomAccessIterator, typename _Compare>
  constexpr inline void make_heap(_RandomAccessIterator __first,
                                  _RandomAccessIterator __last,
                                  _Compare __comp) {

    ;
    ;

    typedef __decltype(__comp) _Cmp;
    __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
    std::__make_heap(__first, __last, __cmp);
  }

  template <typename _RandomAccessIterator, typename _Compare>
  constexpr void __sort_heap(_RandomAccessIterator __first,
                             _RandomAccessIterator __last, _Compare & __comp) {
    while (__last - __first > 1) {
      --__last;
      std::__pop_heap(__first, __last, __last, __comp);
    }
  }
# 437 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_heap.h" 3
  template <typename _RandomAccessIterator>
  constexpr inline void sort_heap(_RandomAccessIterator __first,
                                  _RandomAccessIterator __last) {

    ;
    ;
    ;

    __gnu_cxx::__ops::_Iter_less_iter __comp;
    std::__sort_heap(__first, __last, __comp);
  }
# 465 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_heap.h" 3
  template <typename _RandomAccessIterator, typename _Compare>
  constexpr inline void sort_heap(_RandomAccessIterator __first,
                                  _RandomAccessIterator __last,
                                  _Compare __comp) {

    ;
    ;
    ;

    typedef __decltype(__comp) _Cmp;
    __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
    std::__sort_heap(__first, __last, __cmp);
  }
# 494 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_heap.h" 3
  template <typename _RandomAccessIterator>
  constexpr inline _RandomAccessIterator is_heap_until(
      _RandomAccessIterator __first, _RandomAccessIterator __last) {

    ;
    ;

    __gnu_cxx::__ops::_Iter_less_iter __comp;
    return __first + std::__is_heap_until(
                         __first, std::distance(__first, __last), __comp);
  }
# 523 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_heap.h" 3
  template <typename _RandomAccessIterator, typename _Compare>
  constexpr inline _RandomAccessIterator is_heap_until(
      _RandomAccessIterator __first, _RandomAccessIterator __last,
      _Compare __comp) {

    ;
    ;

    typedef __decltype(__comp) _Cmp;
    __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
    return __first +
           std::__is_heap_until(__first, std::distance(__first, __last), __cmp);
  }
# 548 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_heap.h" 3
  template <typename _RandomAccessIterator>
  constexpr inline bool is_heap(_RandomAccessIterator __first,
                                _RandomAccessIterator __last) {
    return std::is_heap_until(__first, __last) == __last;
  }
# 562 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_heap.h" 3
  template <typename _RandomAccessIterator, typename _Compare>
  constexpr inline bool is_heap(_RandomAccessIterator __first,
                                _RandomAccessIterator __last, _Compare __comp) {

    ;
    ;

    const auto __dist = std::distance(__first, __last);
    typedef __decltype(__comp) _Cmp;
    __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
    return std::__is_heap_until(__first, __dist, __cmp) == __dist;
  }

} // namespace std
# 62 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/uniform_int_dist.h" 1 3
# 41 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/uniform_int_dist.h" 3
namespace std __attribute__((__visibility__("default"))) {
# 52 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/uniform_int_dist.h" 3
  template <typename _Gen>
  concept uniform_random_bit_generator =
      invocable<_Gen &> && unsigned_integral<invoke_result_t<_Gen &>> &&
      requires {
        { _Gen::min() } -> same_as<invoke_result_t<_Gen &>>;
        { _Gen::max() } -> same_as<invoke_result_t<_Gen &>>;
        requires bool_constant<(_Gen::min() < _Gen::max())>::value;
      };

  namespace __detail {

  template <typename _Tp> constexpr bool _Power_of_2(_Tp __x) {
    return ((__x - 1) & __x) == 0;
  }
  } // namespace __detail
# 87 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/uniform_int_dist.h" 3
  template <typename _IntType = int> class uniform_int_distribution {
    static_assert(std::is_integral<_IntType>::value,
                  "template argument must be an integral type");

  public:
    typedef _IntType result_type;

    struct param_type {
      typedef uniform_int_distribution<_IntType> distribution_type;

      param_type() : param_type(0) {}

      explicit param_type(
          _IntType __a, _IntType __b = __gnu_cxx::__int_traits<_IntType>::__max)
          : _M_a(__a), _M_b(__b) {
        do {
          if (std::__is_constant_evaluated() && !bool(_M_a <= _M_b))
            __builtin_unreachable();
        } while (false);
      }

      result_type a() const { return _M_a; }

      result_type b() const { return _M_b; }

      friend bool operator==(const param_type &__p1, const param_type &__p2) {
        return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b;
      }

      friend bool operator!=(const param_type &__p1, const param_type &__p2) {
        return !(__p1 == __p2);
      }

    private:
      _IntType _M_a;
      _IntType _M_b;
    };

  public:
    uniform_int_distribution() : uniform_int_distribution(0) {}

    explicit uniform_int_distribution(
        _IntType __a, _IntType __b = __gnu_cxx::__int_traits<_IntType>::__max)
        : _M_param(__a, __b) {}

    explicit uniform_int_distribution(const param_type &__p) : _M_param(__p) {}

    void reset() {}

    result_type a() const { return _M_param.a(); }

    result_type b() const { return _M_param.b(); }

    param_type param() const { return _M_param; }

    void param(const param_type &__param) { _M_param = __param; }

    result_type min() const { return this->a(); }

    result_type max() const { return this->b(); }

    template <typename _UniformRandomBitGenerator>
    result_type operator()(_UniformRandomBitGenerator &__urng) {
      return this->operator()(__urng, _M_param);
    }

    template <typename _UniformRandomBitGenerator>
    result_type operator()(_UniformRandomBitGenerator &__urng,
                           const param_type &__p);

    template <typename _ForwardIterator, typename _UniformRandomBitGenerator>
    void __generate(_ForwardIterator __f, _ForwardIterator __t,
                    _UniformRandomBitGenerator &__urng) {
      this->__generate(__f, __t, __urng, _M_param);
    }

    template <typename _ForwardIterator, typename _UniformRandomBitGenerator>
    void __generate(_ForwardIterator __f, _ForwardIterator __t,
                    _UniformRandomBitGenerator &__urng, const param_type &__p) {
      this->__generate_impl(__f, __t, __urng, __p);
    }

    template <typename _UniformRandomBitGenerator>
    void __generate(result_type *__f, result_type *__t,
                    _UniformRandomBitGenerator &__urng, const param_type &__p) {
      this->__generate_impl(__f, __t, __urng, __p);
    }

    friend bool operator==(const uniform_int_distribution &__d1,
                           const uniform_int_distribution &__d2) {
      return __d1._M_param == __d2._M_param;
    }

  private:
    template <typename _ForwardIterator, typename _UniformRandomBitGenerator>
    void __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
                         _UniformRandomBitGenerator &__urng,
                         const param_type &__p);

    param_type _M_param;

    template <typename _Wp, typename _Urbg, typename _Up>
    static _Up _S_nd(_Urbg &__g, _Up __range) {
      using _Up_traits = __gnu_cxx::__int_traits<_Up>;
      using _Wp_traits = __gnu_cxx::__int_traits<_Wp>;
      static_assert(!_Up_traits::__is_signed, "U must be unsigned");
      static_assert(!_Wp_traits::__is_signed, "W must be unsigned");
      static_assert(_Wp_traits::__digits == (2 * _Up_traits::__digits),
                    "W must be twice as wide as U");

      _Wp __product = _Wp(__g()) * _Wp(__range);
      _Up __low = _Up(__product);
      if (__low < __range) {
        _Up __threshold = -__range % __range;
        while (__low < __threshold) {
          __product = _Wp(__g()) * _Wp(__range);
          __low = _Up(__product);
        }
      }
      return __product >> _Up_traits::__digits;
    }
  };

  template <typename _IntType>
  template <typename _UniformRandomBitGenerator>
  typename uniform_int_distribution<_IntType>::result_type
  uniform_int_distribution<_IntType>::operator()(
      _UniformRandomBitGenerator &__urng, const param_type &__param) {
    typedef typename _UniformRandomBitGenerator::result_type _Gresult_type;
    typedef typename make_unsigned<result_type>::type __utype;
    typedef typename common_type<_Gresult_type, __utype>::type __uctype;

    constexpr __uctype __urngmin = _UniformRandomBitGenerator::min();
    constexpr __uctype __urngmax = _UniformRandomBitGenerator::max();
    static_assert(__urngmin < __urngmax,
                  "Uniform random bit generator must define min() < max()");
    constexpr __uctype __urngrange = __urngmax - __urngmin;

    const __uctype __urange = __uctype(__param.b()) - __uctype(__param.a());

    __uctype __ret;
    if (__urngrange > __urange) {

      const __uctype __uerange = __urange + 1;

      if constexpr (__urngrange == 18446744073709551615UL) {

        long unsigned int __u64erange = __uerange;
        __ret = __extension__ _S_nd<unsigned __int128>(__urng, __u64erange);
      } else

          if constexpr (__urngrange == 4294967295U) {

        unsigned int __u32erange = __uerange;
        __ret = _S_nd<long unsigned int>(__urng, __u32erange);
      } else

      {

        const __uctype __scaling = __urngrange / __uerange;
        const __uctype __past = __uerange * __scaling;
        do
          __ret = __uctype(__urng()) - __urngmin;
        while (__ret >= __past);
        __ret /= __scaling;
      }
    } else if (__urngrange < __urange) {
# 359 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/uniform_int_dist.h" 3
      __uctype __tmp;
      do {
        const __uctype __uerngrange = __urngrange + 1;
        __tmp =
            (__uerngrange * operator()(__urng,
                                       param_type(0, __urange / __uerngrange)));
        __ret = __tmp + (__uctype(__urng()) - __urngmin);
      } while (__ret > __urange || __ret < __tmp);
    } else
      __ret = __uctype(__urng()) - __urngmin;

    return __ret + __param.a();
  }

  template <typename _IntType>
  template <typename _ForwardIterator, typename _UniformRandomBitGenerator>
  void uniform_int_distribution<_IntType>::__generate_impl(
      _ForwardIterator __f, _ForwardIterator __t,
      _UniformRandomBitGenerator & __urng, const param_type &__param) {

    typedef typename _UniformRandomBitGenerator::result_type _Gresult_type;
    typedef typename make_unsigned<result_type>::type __utype;
    typedef typename common_type<_Gresult_type, __utype>::type __uctype;

    static_assert(__urng.min() < __urng.max(),
                  "Uniform random bit generator must define min() < max()");

    constexpr __uctype __urngmin = __urng.min();
    constexpr __uctype __urngmax = __urng.max();
    constexpr __uctype __urngrange = __urngmax - __urngmin;
    const __uctype __urange = __uctype(__param.b()) - __uctype(__param.a());

    __uctype __ret;

    if (__urngrange > __urange) {
      if (__detail::_Power_of_2(__urngrange + 1) &&
          __detail::_Power_of_2(__urange + 1)) {
        while (__f != __t) {
          __ret = __uctype(__urng()) - __urngmin;
          *__f++ = (__ret & __urange) + __param.a();
        }
      } else {

        const __uctype __uerange = __urange + 1;
        const __uctype __scaling = __urngrange / __uerange;
        const __uctype __past = __uerange * __scaling;
        while (__f != __t) {
          do
            __ret = __uctype(__urng()) - __urngmin;
          while (__ret >= __past);
          *__f++ = __ret / __scaling + __param.a();
        }
      }
    } else if (__urngrange < __urange) {
# 444 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/uniform_int_dist.h" 3
      __uctype __tmp;
      while (__f != __t) {
        do {
          constexpr __uctype __uerngrange = __urngrange + 1;
          __tmp = (__uerngrange * operator()(
                                      __urng,
                                      param_type(0, __urange / __uerngrange)));
          __ret = __tmp + (__uctype(__urng()) - __urngmin);
        } while (__ret > __urange || __ret < __tmp);
        *__f++ = __ret;
      }
    } else
      while (__f != __t)
        *__f++ = __uctype(__urng()) - __urngmin + __param.a();
  }

} // namespace std
# 66 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_tempbuf.h" 1 3
# 65 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_tempbuf.h" 3
namespace std __attribute__((__visibility__("default"))) {

  namespace __detail {
  template <typename _Tp>
  inline void __return_temporary_buffer(_Tp *__p, size_t __len
                                        __attribute__((__unused__))) {

    ::operator delete(__p);
  }
  } // namespace __detail
# 101 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_tempbuf.h" 3
  template <typename _Tp>
  [[__deprecated__]]
  pair<_Tp *, ptrdiff_t> get_temporary_buffer(ptrdiff_t __len) noexcept {
    const ptrdiff_t __max =
        __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
    if (__len > __max)
      __len = __max;

    while (__len > 0) {
      _Tp *__tmp =
          static_cast<_Tp *>(::operator new(__len * sizeof(_Tp), std::nothrow));
      if (__tmp != 0)
        return std::pair<_Tp *, ptrdiff_t>(__tmp, __len);
      __len = __len == 1 ? 0 : ((__len + 1) / 2);
    }
    return std::pair<_Tp *, ptrdiff_t>(static_cast<_Tp *>(0), 0);
  }
# 129 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_tempbuf.h" 3
  template <typename _Tp> inline void return_temporary_buffer(_Tp * __p) {
    ::operator delete(__p);
  }

  template <typename _ForwardIterator, typename _Tp> class _Temporary_buffer {

  public:
    typedef _Tp value_type;
    typedef value_type *pointer;
    typedef pointer iterator;
    typedef ptrdiff_t size_type;

  protected:
    size_type _M_original_len;
    size_type _M_len;
    pointer _M_buffer;

  public:
    size_type size() const { return _M_len; }

    size_type requested_size() const { return _M_original_len; }

    iterator begin() { return _M_buffer; }

    iterator end() { return _M_buffer + _M_len; }

    _Temporary_buffer(_ForwardIterator __seed, size_type __original_len);

    ~_Temporary_buffer() {
      std::_Destroy(_M_buffer, _M_buffer + _M_len);
      std::__detail::__return_temporary_buffer(_M_buffer, _M_len);
    }

  private:
    _Temporary_buffer(const _Temporary_buffer &);

    void operator=(const _Temporary_buffer &);
  };

  template <bool> struct __uninitialized_construct_buf_dispatch {
    template <typename _Pointer, typename _ForwardIterator>
    static void __ucr(_Pointer __first, _Pointer __last,
                      _ForwardIterator __seed) {
      if (__first == __last)
        return;

      _Pointer __cur = __first;
      try {
        std::_Construct(std::__addressof(*__first), std::move(*__seed));
        _Pointer __prev = __cur;
        ++__cur;
        for (; __cur != __last; ++__cur, ++__prev)
          std::_Construct(std::__addressof(*__cur), std::move(*__prev));
        *__seed = std::move(*__prev);
      } catch (...) {
        std::_Destroy(__first, __cur);
        throw;
      }
    }
  };

  template <> struct __uninitialized_construct_buf_dispatch<true> {
    template <typename _Pointer, typename _ForwardIterator>
    static void __ucr(_Pointer, _Pointer, _ForwardIterator) {}
  };
# 247 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_tempbuf.h" 3
  template <typename _Pointer, typename _ForwardIterator>
  inline void __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
                                            _ForwardIterator __seed) {
    typedef typename std::iterator_traits<_Pointer>::value_type _ValueType;

    std::__uninitialized_construct_buf_dispatch<__has_trivial_constructor(
        _ValueType)>::__ucr(__first, __last, __seed);
  }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template <typename _ForwardIterator, typename _Tp>
  _Temporary_buffer<_ForwardIterator, _Tp>::_Temporary_buffer(
      _ForwardIterator __seed, size_type __original_len)
      : _M_original_len(__original_len), _M_len(0), _M_buffer(0) {
    std::pair<pointer, size_type> __p(
        std::get_temporary_buffer<value_type>(_M_original_len));

    if (__p.first) {
      try {
        std::__uninitialized_construct_buf(__p.first, __p.first + __p.second,
                                           __seed);
        _M_buffer = __p.first;
        _M_len = __p.second;
      } catch (...) {
        std::__detail::__return_temporary_buffer(__p.first, __p.second);
        throw;
      }
    }
  }
#pragma GCC diagnostic pop

} // namespace std
# 70 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdlib" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdlib" 3
# 72 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  template <typename _Iterator, typename _Compare>
  constexpr void __move_median_to_first(_Iterator __result, _Iterator __a,
                                        _Iterator __b, _Iterator __c,
                                        _Compare __comp) {
    if (__comp(__a, __b)) {
      if (__comp(__b, __c))
        std::iter_swap(__result, __b);
      else if (__comp(__a, __c))
        std::iter_swap(__result, __c);
      else
        std::iter_swap(__result, __a);
    } else if (__comp(__a, __c))
      std::iter_swap(__result, __a);
    else if (__comp(__b, __c))
      std::iter_swap(__result, __c);
    else
      std::iter_swap(__result, __b);
  }

  template <typename _InputIterator, typename _Predicate>
  constexpr inline _InputIterator __find_if_not(
      _InputIterator __first, _InputIterator __last, _Predicate __pred) {
    return std::__find_if(__first, __last, __gnu_cxx::__ops::__negate(__pred),
                          std::__iterator_category(__first));
  }

  template <typename _InputIterator, typename _Predicate, typename _Distance>
  constexpr _InputIterator __find_if_not_n(
      _InputIterator __first, _Distance & __len, _Predicate __pred) {
    for (; __len; --__len, (void)++__first)
      if (!__pred(__first))
        break;
    return __first;
  }
# 144 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator1, typename _ForwardIterator2,
            typename _BinaryPredicate>
  constexpr _ForwardIterator1 __search(
      _ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate) {

    if (__first1 == __last1 || __first2 == __last2)
      return __first1;

    _ForwardIterator2 __p1(__first2);
    if (++__p1 == __last2)
      return std::__find_if(
          __first1, __last1,
          __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

    _ForwardIterator1 __current = __first1;

    for (;;) {
      __first1 = std::__find_if(
          __first1, __last1,
          __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

      if (__first1 == __last1)
        return __last1;

      _ForwardIterator2 __p = __p1;
      __current = __first1;
      if (++__current == __last1)
        return __last1;

      while (__predicate(__current, __p)) {
        if (++__p == __last2)
          return __first1;
        if (++__current == __last1)
          return __last1;
      }
      ++__first1;
    }
    return __first1;
  }

  template <typename _ForwardIterator, typename _Integer,
            typename _UnaryPredicate>
  constexpr _ForwardIterator __search_n_aux(
      _ForwardIterator __first, _ForwardIterator __last, _Integer __count,
      _UnaryPredicate __unary_pred, std::forward_iterator_tag) {
    __first = std::__find_if(__first, __last, __unary_pred);
    while (__first != __last) {
      typename iterator_traits<_ForwardIterator>::difference_type __n = __count;
      _ForwardIterator __i = __first;
      ++__i;
      while (__i != __last && __n != 1 && __unary_pred(__i)) {
        ++__i;
        --__n;
      }
      if (__n == 1)
        return __first;
      if (__i == __last)
        return __last;
      __first = std::__find_if(++__i, __last, __unary_pred);
    }
    return __last;
  }

  template <typename _RandomAccessIter, typename _Integer,
            typename _UnaryPredicate>
  constexpr _RandomAccessIter __search_n_aux(
      _RandomAccessIter __first, _RandomAccessIter __last, _Integer __count,
      _UnaryPredicate __unary_pred, std::random_access_iterator_tag) {
    typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
        _DistanceType;

    _DistanceType __tailSize = __last - __first;
    _DistanceType __remainder = __count;

    while (__remainder <= __tailSize) {
      __first += __remainder;
      __tailSize -= __remainder;

      _RandomAccessIter __backTrack = __first;
      while (__unary_pred(--__backTrack)) {
        if (--__remainder == 0)
          return (__first - __count);
      }
      __remainder = __count + 1 - (__first - __backTrack);
    }
    return __last;
  }

  template <typename _ForwardIterator, typename _Integer,
            typename _UnaryPredicate>
  constexpr _ForwardIterator __search_n(
      _ForwardIterator __first, _ForwardIterator __last, _Integer __count,
      _UnaryPredicate __unary_pred) {
    if (__count <= 0)
      return __first;

    if (__count == 1)
      return std::__find_if(__first, __last, __unary_pred);

    return std::__search_n_aux(__first, __last, __count, __unary_pred,
                               std::__iterator_category(__first));
  }

  template <typename _ForwardIterator1, typename _ForwardIterator2,
            typename _BinaryPredicate>
  constexpr _ForwardIterator1 __find_end(
      _ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      forward_iterator_tag, forward_iterator_tag, _BinaryPredicate __comp) {
    if (__first2 == __last2)
      return __last1;

    _ForwardIterator1 __result = __last1;
    while (1) {
      _ForwardIterator1 __new_result =
          std::__search(__first1, __last1, __first2, __last2, __comp);
      if (__new_result == __last1)
        return __result;
      else {
        __result = __new_result;
        __first1 = __new_result;
        ++__first1;
      }
    }
  }

  template <typename _BidirectionalIterator1, typename _BidirectionalIterator2,
            typename _BinaryPredicate>
  constexpr _BidirectionalIterator1 __find_end(
      _BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,
      _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2,
      bidirectional_iterator_tag, bidirectional_iterator_tag,
      _BinaryPredicate __comp) {

    typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
    typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

    _RevIterator1 __rlast1(__first1);
    _RevIterator2 __rlast2(__first2);
    _RevIterator1 __rresult =
        std::__search(_RevIterator1(__last1), __rlast1, _RevIterator2(__last2),
                      __rlast2, __comp);

    if (__rresult == __rlast1)
      return __last1;
    else {
      _BidirectionalIterator1 __result = __rresult.base();
      std::advance(__result, -std::distance(__first2, __last2));
      return __result;
    }
  }
# 370 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator1, typename _ForwardIterator2>
  constexpr inline _ForwardIterator1 find_end(
      _ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2) {

    ;
    ;

    return std::__find_end(__first1, __last1, __first2, __last2,
                           std::__iterator_category(__first1),
                           std::__iterator_category(__first2),
                           __gnu_cxx::__ops::__iter_equal_to_iter());
  }
# 419 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator1, typename _ForwardIterator2,
            typename _BinaryPredicate>
  constexpr inline _ForwardIterator1 find_end(
      _ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp) {

    ;
    ;

    return std::__find_end(__first1, __last1, __first2, __last2,
                           std::__iterator_category(__first1),
                           std::__iterator_category(__first2),
                           __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }
# 455 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _Predicate>
  constexpr inline bool all_of(_InputIterator __first, _InputIterator __last,
                               _Predicate __pred) {
    return __last == std::find_if_not(__first, __last, __pred);
  }
# 473 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _Predicate>
  constexpr inline bool none_of(_InputIterator __first, _InputIterator __last,
                                _Predicate __pred) {
    return __last == std::find_if(__first, __last, __pred);
  }
# 492 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _Predicate>
  constexpr inline bool any_of(_InputIterator __first, _InputIterator __last,
                               _Predicate __pred) {
    return !std::none_of(__first, __last, __pred);
  }
# 508 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _Predicate>
  constexpr inline _InputIterator find_if_not(
      _InputIterator __first, _InputIterator __last, _Predicate __pred) {

    ;
    return std::__find_if_not(__first, __last,
                              __gnu_cxx::__ops::__pred_iter(__pred));
  }
# 533 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _Predicate>
  constexpr inline bool is_partitioned(
      _InputIterator __first, _InputIterator __last, _Predicate __pred) {
    __first = std::find_if_not(__first, __last, __pred);
    if (__first == __last)
      return true;
    ++__first;
    return std::none_of(__first, __last, __pred);
  }
# 555 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Predicate>
  constexpr _ForwardIterator partition_point(
      _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {

    ;

    typedef typename iterator_traits<_ForwardIterator>::difference_type
        _DistanceType;

    _DistanceType __len = std::distance(__first, __last);

    while (__len > 0) {
      _DistanceType __half = __len >> 1;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __half);
      if (__pred(*__middle)) {
        __first = __middle;
        ++__first;
        __len = __len - __half - 1;
      } else
        __len = __half;
    }
    return __first;
  }

  template <typename _InputIterator, typename _OutputIterator,
            typename _Predicate>
  constexpr _OutputIterator __remove_copy_if(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _Predicate __pred) {
    for (; __first != __last; ++__first)
      if (!__pred(__first)) {
        *__result = *__first;
        ++__result;
      }
    return __result;
  }
# 622 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _OutputIterator, typename _Tp>
  constexpr inline _OutputIterator remove_copy(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      const _Tp &__value) {

    ;

    return std::__remove_copy_if(__first, __last, __result,
                                 __gnu_cxx::__ops::__iter_equals_val(__value));
  }
# 655 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _OutputIterator,
            typename _Predicate>
  constexpr inline _OutputIterator remove_copy_if(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _Predicate __pred) {

    ;

    return std::__remove_copy_if(__first, __last, __result,
                                 __gnu_cxx::__ops::__pred_iter(__pred));
  }
# 690 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _OutputIterator,
            typename _Predicate>
  constexpr _OutputIterator copy_if(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _Predicate __pred) {

    ;

    for (; __first != __last; ++__first)
      if (__pred(*__first)) {
        *__result = *__first;
        ++__result;
      }
    return __result;
  }

  template <typename _InputIterator, typename _Size, typename _OutputIterator>
  constexpr _OutputIterator __copy_n(_InputIterator __first, _Size __n,
                                     _OutputIterator __result,
                                     input_iterator_tag) {
    return std::__niter_wrap(
        __result, __copy_n_a(__first, __n, std::__niter_base(__result), true));
  }

  template <typename _RandomAccessIterator, typename _Size,
            typename _OutputIterator>
  constexpr inline _OutputIterator __copy_n(_RandomAccessIterator __first,
                                            _Size __n, _OutputIterator __result,
                                            random_access_iterator_tag) {
    return std::copy(__first, __first + __n, __result);
  }
# 746 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _Size, typename _OutputIterator>
  constexpr inline _OutputIterator copy_n(_InputIterator __first, _Size __n,
                                          _OutputIterator __result) {

    const auto __n2 = std::__size_to_integer(__n);
    if (__n2 <= 0)
      return __result;

    ;
    ;

    return std::__copy_n(__first, __n2, __result,
                         std::__iterator_category(__first));
  }
# 782 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _OutputIterator1,
            typename _OutputIterator2, typename _Predicate>
  constexpr pair<_OutputIterator1, _OutputIterator2> partition_copy(
      _InputIterator __first, _InputIterator __last,
      _OutputIterator1 __out_true, _OutputIterator2 __out_false,
      _Predicate __pred) {
# 798 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
    ;

    for (; __first != __last; ++__first)
      if (__pred(*__first)) {
        *__out_true = *__first;
        ++__out_true;
      } else {
        *__out_false = *__first;
        ++__out_false;
      }

    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
  }
# 833 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Tp>
  constexpr inline _ForwardIterator remove(
      _ForwardIterator __first, _ForwardIterator __last, const _Tp &__value) {

    ;

    return std::__remove_if(__first, __last,
                            __gnu_cxx::__ops::__iter_equals_val(__value));
  }
# 867 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Predicate>
  constexpr inline _ForwardIterator remove_if(
      _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {

    ;

    return std::__remove_if(__first, __last,
                            __gnu_cxx::__ops::__pred_iter(__pred));
  }

  template <typename _ForwardIterator, typename _BinaryPredicate>
  constexpr _ForwardIterator __adjacent_find(_ForwardIterator __first,
                                             _ForwardIterator __last,
                                             _BinaryPredicate __binary_pred) {
    if (__first == __last)
      return __last;
    _ForwardIterator __next = __first;
    while (++__next != __last) {
      if (__binary_pred(__first, __next))
        return __first;
      __first = __next;
    }
    return __last;
  }

  template <typename _ForwardIterator, typename _BinaryPredicate>
  constexpr _ForwardIterator __unique(_ForwardIterator __first,
                                      _ForwardIterator __last,
                                      _BinaryPredicate __binary_pred) {

    __first = std::__adjacent_find(__first, __last, __binary_pred);
    if (__first == __last)
      return __last;

    _ForwardIterator __dest = __first;
    ++__first;
    while (++__first != __last)
      if (!__binary_pred(__dest, __first))
        *++__dest = std::move(*__first);
    return ++__dest;
  }
# 936 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator>
  constexpr inline _ForwardIterator unique(_ForwardIterator __first,
                                           _ForwardIterator __last) {

    ;

    return std::__unique(__first, __last,
                         __gnu_cxx::__ops::__iter_equal_to_iter());
  }
# 967 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _BinaryPredicate>
  constexpr inline _ForwardIterator unique(_ForwardIterator __first,
                                           _ForwardIterator __last,
                                           _BinaryPredicate __binary_pred) {

    ;

    return std::__unique(__first, __last,
                         __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
  }

  template <typename _ForwardIterator, typename _OutputIterator,
            typename _BinaryPredicate>
  constexpr _OutputIterator __unique_copy(
      _ForwardIterator __first, _ForwardIterator __last,
      _OutputIterator __result, _BinaryPredicate __binary_pred,
      forward_iterator_tag, output_iterator_tag) {

    _ForwardIterator __next = __first;
    *__result = *__first;
    while (++__next != __last)
      if (!__binary_pred(__first, __next)) {
        __first = __next;
        *++__result = *__first;
      }
    return ++__result;
  }

  template <typename _InputIterator, typename _OutputIterator,
            typename _BinaryPredicate>
  constexpr _OutputIterator __unique_copy(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _BinaryPredicate __binary_pred, input_iterator_tag, output_iterator_tag) {

    typename iterator_traits<_InputIterator>::value_type __value = *__first;
    __decltype(__gnu_cxx::__ops::__iter_comp_val(
        __binary_pred)) __rebound_pred =
        __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
    *__result = __value;
    while (++__first != __last)
      if (!__rebound_pred(__first, __value)) {
        __value = *__first;
        *++__result = __value;
      }
    return ++__result;
  }

  template <typename _InputIterator, typename _ForwardIterator,
            typename _BinaryPredicate>
  constexpr _ForwardIterator __unique_copy(
      _InputIterator __first, _InputIterator __last, _ForwardIterator __result,
      _BinaryPredicate __binary_pred, input_iterator_tag,
      forward_iterator_tag) {

    *__result = *__first;
    while (++__first != __last)
      if (!__binary_pred(__result, __first))
        *++__result = *__first;
    return ++__result;
  }

  template <typename _BidirectionalIterator>
  constexpr void __reverse(_BidirectionalIterator __first,
                           _BidirectionalIterator __last,
                           bidirectional_iterator_tag) {
    while (true)
      if (__first == __last || __first == --__last)
        return;
      else {
        std::iter_swap(__first, __last);
        ++__first;
      }
  }

  template <typename _RandomAccessIterator>
  constexpr void __reverse(_RandomAccessIterator __first,
                           _RandomAccessIterator __last,
                           random_access_iterator_tag) {
    if (__first == __last)
      return;
    --__last;
    while (__first < __last) {
      std::iter_swap(__first, __last);
      ++__first;
      --__last;
    }
  }
# 1128 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _BidirectionalIterator>
  constexpr inline void reverse(_BidirectionalIterator __first,
                                _BidirectionalIterator __last) {

    ;
    std::__reverse(__first, __last, std::__iterator_category(__first));
  }
# 1156 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _BidirectionalIterator, typename _OutputIterator>
  constexpr _OutputIterator reverse_copy(_BidirectionalIterator __first,
                                         _BidirectionalIterator __last,
                                         _OutputIterator __result) {

    ;

    while (__first != __last) {
      --__last;
      *__result = *__last;
      ++__result;
    }
    return __result;
  }

  template <typename _EuclideanRingElement>
  constexpr _EuclideanRingElement __gcd(_EuclideanRingElement __m,
                                        _EuclideanRingElement __n) {
    while (__n != 0) {
      _EuclideanRingElement __t = __m % __n;
      __m = __n;
      __n = __t;
    }
    return __m;
  }

  inline namespace _V2 {

  template <typename _ForwardIterator>
  constexpr _ForwardIterator
  __rotate(_ForwardIterator __first, _ForwardIterator __middle,
           _ForwardIterator __last, forward_iterator_tag) {
    if (__first == __middle)
      return __last;
    else if (__last == __middle)
      return __first;

    _ForwardIterator __first2 = __middle;
    do {
      std::iter_swap(__first, __first2);
      ++__first;
      ++__first2;
      if (__first == __middle)
        __middle = __first2;
    } while (__first2 != __last);

    _ForwardIterator __ret = __first;

    __first2 = __middle;

    while (__first2 != __last) {
      std::iter_swap(__first, __first2);
      ++__first;
      ++__first2;
      if (__first == __middle)
        __middle = __first2;
      else if (__first2 == __last)
        __first2 = __middle;
    }
    return __ret;
  }

  template <typename _BidirectionalIterator>
  constexpr _BidirectionalIterator
  __rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle,
           _BidirectionalIterator __last, bidirectional_iterator_tag) {

    if (__first == __middle)
      return __last;
    else if (__last == __middle)
      return __first;

    std::__reverse(__first, __middle, bidirectional_iterator_tag());
    std::__reverse(__middle, __last, bidirectional_iterator_tag());

    while (__first != __middle && __middle != __last) {
      std::iter_swap(__first, --__last);
      ++__first;
    }

    if (__first == __middle) {
      std::__reverse(__middle, __last, bidirectional_iterator_tag());
      return __last;
    } else {
      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      return __first;
    }
  }

  template <typename _RandomAccessIterator>
  constexpr _RandomAccessIterator
  __rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle,
           _RandomAccessIterator __last, random_access_iterator_tag) {

    if (__first == __middle)
      return __last;
    else if (__last == __middle)
      return __first;

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type
        _Distance;
    typedef
        typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;

    _Distance __n = __last - __first;
    _Distance __k = __middle - __first;

    if (__k == __n - __k) {
      std::swap_ranges(__first, __middle, __middle);
      return __middle;
    }

    _RandomAccessIterator __p = __first;
    _RandomAccessIterator __ret = __first + (__last - __middle);

    for (;;) {
      if (__k < __n - __k) {
        if (__is_pod(_ValueType) && __k == 1) {
          _ValueType __t = std::move(*__p);
          std::move(__p + 1, __p + __n, __p);
          *(__p + __n - 1) = std::move(__t);
          return __ret;
        }
        _RandomAccessIterator __q = __p + __k;
        for (_Distance __i = 0; __i < __n - __k; ++__i) {
          std::iter_swap(__p, __q);
          ++__p;
          ++__q;
        }
        __n %= __k;
        if (__n == 0)
          return __ret;
        std::swap(__n, __k);
        __k = __n - __k;
      } else {
        __k = __n - __k;
        if (__is_pod(_ValueType) && __k == 1) {
          _ValueType __t = std::move(*(__p + __n - 1));
          std::move_backward(__p, __p + __n - 1, __p + __n);
          *__p = std::move(__t);
          return __ret;
        }
        _RandomAccessIterator __q = __p + __n;
        __p = __q - __k;
        for (_Distance __i = 0; __i < __n - __k; ++__i) {
          --__p;
          --__q;
          std::iter_swap(__p, __q);
        }
        __n %= __k;
        if (__n == 0)
          return __ret;
        std::swap(__n, __k);
      }
    }
  }
# 1387 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator>
  constexpr inline _ForwardIterator rotate(_ForwardIterator __first,
                                           _ForwardIterator __middle,
                                           _ForwardIterator __last) {

    ;
    ;

    return std::__rotate(__first, __middle, __last,
                         std::__iterator_category(__first));
  }

  } // namespace _V2
# 1425 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _OutputIterator>
  constexpr inline _OutputIterator rotate_copy(
      _ForwardIterator __first, _ForwardIterator __middle,
      _ForwardIterator __last, _OutputIterator __result) {

    ;
    ;

    return std::copy(__first, __middle, std::copy(__middle, __last, __result));
  }

  template <typename _ForwardIterator, typename _Predicate>
  constexpr _ForwardIterator __partition(
      _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
      forward_iterator_tag) {
    if (__first == __last)
      return __first;

    while (__pred(*__first))
      if (++__first == __last)
        return __first;

    _ForwardIterator __next = __first;

    while (++__next != __last)
      if (__pred(*__next)) {
        std::iter_swap(__first, __next);
        ++__first;
      }

    return __first;
  }

  template <typename _BidirectionalIterator, typename _Predicate>
  constexpr _BidirectionalIterator __partition(
      _BidirectionalIterator __first, _BidirectionalIterator __last,
      _Predicate __pred, bidirectional_iterator_tag) {
    while (true) {
      while (true)
        if (__first == __last)
          return __first;
        else if (__pred(*__first))
          ++__first;
        else
          break;
      --__last;
      while (true)
        if (__first == __last)
          return __first;
        else if (!bool(__pred(*__last)))
          --__last;
        else
          break;
      std::iter_swap(__first, __last);
      ++__first;
    }
  }
# 1506 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Pointer, typename _Predicate,
            typename _Distance>
  _ForwardIterator __stable_partition_adaptive(
      _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
      _Distance __len, _Pointer __buffer, _Distance __buffer_size) {
    if (__len == 1)
      return __first;

    if (__len <= __buffer_size) {
      _ForwardIterator __result1 = __first;
      _Pointer __result2 = __buffer;

      *__result2 = std::move(*__first);
      ++__result2;
      ++__first;
      for (; __first != __last; ++__first)
        if (__pred(__first)) {
          *__result1 = std::move(*__first);
          ++__result1;
        } else {
          *__result2 = std::move(*__first);
          ++__result2;
        }

      std::move(__buffer, __result2, __result1);
      return __result1;
    }

    _ForwardIterator __middle = __first;
    std::advance(__middle, __len / 2);
    _ForwardIterator __left_split = std::__stable_partition_adaptive(
        __first, __middle, __pred, __len / 2, __buffer, __buffer_size);

    _Distance __right_len = __len - __len / 2;
    _ForwardIterator __right_split =
        std::__find_if_not_n(__middle, __right_len, __pred);

    if (__right_len)
      __right_split = std::__stable_partition_adaptive(
          __right_split, __last, __pred, __right_len, __buffer, __buffer_size);

    return std::rotate(__left_split, __middle, __right_split);
  }

  template <typename _ForwardIterator, typename _Predicate>
  _ForwardIterator __stable_partition(
      _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
    __first = std::__find_if_not(__first, __last, __pred);

    if (__first == __last)
      return __first;

    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
    typedef typename iterator_traits<_ForwardIterator>::difference_type
        _DistanceType;

    _Temporary_buffer<_ForwardIterator, _ValueType> __buf(
        __first, std::distance(__first, __last));
    return std::__stable_partition_adaptive(
        __first, __last, __pred, _DistanceType(__buf.requested_size()),
        __buf.begin(), _DistanceType(__buf.size()));
  }
# 1608 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Predicate>
  inline _ForwardIterator stable_partition(
      _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {

    ;

    return std::__stable_partition(__first, __last,
                                   __gnu_cxx::__ops::__pred_iter(__pred));
  }

  template <typename _RandomAccessIterator, typename _Compare>
  constexpr void __heap_select(_RandomAccessIterator __first,
                               _RandomAccessIterator __middle,
                               _RandomAccessIterator __last, _Compare __comp) {
    std::__make_heap(__first, __middle, __comp);
    for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
      if (__comp(__i, __first))
        std::__pop_heap(__first, __middle, __i, __comp);
  }

  template <typename _InputIterator, typename _RandomAccessIterator,
            typename _Compare>
  constexpr _RandomAccessIterator __partial_sort_copy(
      _InputIterator __first, _InputIterator __last,
      _RandomAccessIterator __result_first, _RandomAccessIterator __result_last,
      _Compare __comp) {
    typedef
        typename iterator_traits<_InputIterator>::value_type _InputValueType;
    typedef iterator_traits<_RandomAccessIterator> _RItTraits;
    typedef typename _RItTraits::difference_type _DistanceType;

    if (__result_first == __result_last)
      return __result_last;
    _RandomAccessIterator __result_real_last = __result_first;
    while (__first != __last && __result_real_last != __result_last) {
      *__result_real_last = *__first;
      ++__result_real_last;
      ++__first;
    }

    std::__make_heap(__result_first, __result_real_last, __comp);
    while (__first != __last) {
      if (__comp(__first, __result_first))
        std::__adjust_heap(__result_first, _DistanceType(0),
                           _DistanceType(__result_real_last - __result_first),
                           _InputValueType(*__first), __comp);
      ++__first;
    }
    std::__sort_heap(__result_first, __result_real_last, __comp);
    return __result_real_last;
  }
# 1701 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _RandomAccessIterator>
  constexpr inline _RandomAccessIterator partial_sort_copy(
      _InputIterator __first, _InputIterator __last,
      _RandomAccessIterator __result_first,
      _RandomAccessIterator __result_last) {
# 1722 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
    ;
    ;
    ;

    return std::__partial_sort_copy(__first, __last, __result_first,
                                    __result_last,
                                    __gnu_cxx::__ops::__iter_less_iter());
  }
# 1751 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _RandomAccessIterator,
            typename _Compare>
  constexpr inline _RandomAccessIterator partial_sort_copy(
      _InputIterator __first, _InputIterator __last,
      _RandomAccessIterator __result_first, _RandomAccessIterator __result_last,
      _Compare __comp) {
# 1777 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
    ;
    ;
    ;

    return std::__partial_sort_copy(__first, __last, __result_first,
                                    __result_last,
                                    __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _RandomAccessIterator, typename _Compare>
  constexpr void __unguarded_linear_insert(_RandomAccessIterator __last,
                                           _Compare __comp) {
    typename iterator_traits<_RandomAccessIterator>::value_type __val =
        std::move(*__last);
    _RandomAccessIterator __next = __last;
    --__next;
    while (__comp(__val, __next)) {
      *__last = std::move(*__next);
      __last = __next;
      --__next;
    }
    *__last = std::move(__val);
  }

  template <typename _RandomAccessIterator, typename _Compare>
  constexpr void __insertion_sort(_RandomAccessIterator __first,
                                  _RandomAccessIterator __last,
                                  _Compare __comp) {
    if (__first == __last)
      return;

    for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) {
      if (__comp(__i, __first)) {
        typename iterator_traits<_RandomAccessIterator>::value_type __val =
            std::move(*__i);
        std::move_backward(__first, __i, __i + 1);
        *__first = std::move(__val);
      } else
        std::__unguarded_linear_insert(
            __i, __gnu_cxx::__ops::__val_comp_iter(__comp));
    }
  }

  template <typename _RandomAccessIterator, typename _Compare>
  constexpr inline void __unguarded_insertion_sort(
      _RandomAccessIterator __first, _RandomAccessIterator __last,
      _Compare __comp) {
    for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
      std::__unguarded_linear_insert(__i,
                                     __gnu_cxx::__ops::__val_comp_iter(__comp));
  }

  enum { _S_threshold = 16 };

  template <typename _RandomAccessIterator, typename _Compare>
  constexpr void __final_insertion_sort(_RandomAccessIterator __first,
                                        _RandomAccessIterator __last,
                                        _Compare __comp) {
    if (__last - __first > int(_S_threshold)) {
      std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
      std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
                                      __comp);
    } else
      std::__insertion_sort(__first, __last, __comp);
  }

  template <typename _RandomAccessIterator, typename _Compare>
  constexpr _RandomAccessIterator __unguarded_partition(
      _RandomAccessIterator __first, _RandomAccessIterator __last,
      _RandomAccessIterator __pivot, _Compare __comp) {
    while (true) {
      while (__comp(__first, __pivot))
        ++__first;
      --__last;
      while (__comp(__pivot, __last))
        --__last;
      if (!(__first < __last))
        return __first;
      std::iter_swap(__first, __last);
      ++__first;
    }
  }

  template <typename _RandomAccessIterator, typename _Compare>
  constexpr inline _RandomAccessIterator __unguarded_partition_pivot(
      _RandomAccessIterator __first, _RandomAccessIterator __last,
      _Compare __comp) {
    _RandomAccessIterator __mid = __first + (__last - __first) / 2;
    std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
                                __comp);
    return std::__unguarded_partition(__first + 1, __last, __first, __comp);
  }

  template <typename _RandomAccessIterator, typename _Compare>
  constexpr inline void __partial_sort(
      _RandomAccessIterator __first, _RandomAccessIterator __middle,
      _RandomAccessIterator __last, _Compare __comp) {
    std::__heap_select(__first, __middle, __last, __comp);
    std::__sort_heap(__first, __middle, __comp);
  }

  template <typename _RandomAccessIterator, typename _Size, typename _Compare>
  constexpr void __introsort_loop(_RandomAccessIterator __first,
                                  _RandomAccessIterator __last,
                                  _Size __depth_limit, _Compare __comp) {
    while (__last - __first > int(_S_threshold)) {
      if (__depth_limit == 0) {
        std::__partial_sort(__first, __last, __last, __comp);
        return;
      }
      --__depth_limit;
      _RandomAccessIterator __cut =
          std::__unguarded_partition_pivot(__first, __last, __comp);
      std::__introsort_loop(__cut, __last, __depth_limit, __comp);
      __last = __cut;
    }
  }

  template <typename _RandomAccessIterator, typename _Compare>
  constexpr inline void __sort(_RandomAccessIterator __first,
                               _RandomAccessIterator __last, _Compare __comp) {
    if (__first != __last) {
      std::__introsort_loop(__first, __last, std::__lg(__last - __first) * 2,
                            __comp);
      std::__final_insertion_sort(__first, __last, __comp);
    }
  }

  template <typename _RandomAccessIterator, typename _Size, typename _Compare>
  constexpr void __introselect(
      _RandomAccessIterator __first, _RandomAccessIterator __nth,
      _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp) {
    while (__last - __first > 3) {
      if (__depth_limit == 0) {
        std::__heap_select(__first, __nth + 1, __last, __comp);

        std::iter_swap(__first, __nth);
        return;
      }
      --__depth_limit;
      _RandomAccessIterator __cut =
          std::__unguarded_partition_pivot(__first, __last, __comp);
      if (__cut <= __nth)
        __first = __cut;
      else
        __last = __cut;
    }
    std::__insertion_sort(__first, __last, __comp);
  }
# 2002 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Tp, typename _Compare>
  constexpr inline _ForwardIterator lower_bound(
      _ForwardIterator __first, _ForwardIterator __last, const _Tp &__val,
      _Compare __comp) {

    ;

    return std::__lower_bound(__first, __last, __val,
                              __gnu_cxx::__ops::__iter_comp_val(__comp));
  }

  template <typename _ForwardIterator, typename _Tp, typename _Compare>
  constexpr _ForwardIterator __upper_bound(_ForwardIterator __first,
                                           _ForwardIterator __last,
                                           const _Tp &__val, _Compare __comp) {
    typedef typename iterator_traits<_ForwardIterator>::difference_type
        _DistanceType;

    _DistanceType __len = std::distance(__first, __last);

    while (__len > 0) {
      _DistanceType __half = __len >> 1;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __half);
      if (__comp(__val, __middle))
        __len = __half;
      else {
        __first = __middle;
        ++__first;
        __len = __len - __half - 1;
      }
    }
    return __first;
  }
# 2058 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Tp>
  constexpr inline _ForwardIterator upper_bound(
      _ForwardIterator __first, _ForwardIterator __last, const _Tp &__val) {

    ;

    return std::__upper_bound(__first, __last, __val,
                              __gnu_cxx::__ops::__val_less_iter());
  }
# 2089 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Tp, typename _Compare>
  constexpr inline _ForwardIterator upper_bound(
      _ForwardIterator __first, _ForwardIterator __last, const _Tp &__val,
      _Compare __comp) {

    ;

    return std::__upper_bound(__first, __last, __val,
                              __gnu_cxx::__ops::__val_comp_iter(__comp));
  }

  template <typename _ForwardIterator, typename _Tp, typename _CompareItTp,
            typename _CompareTpIt>
  constexpr pair<_ForwardIterator, _ForwardIterator> __equal_range(
      _ForwardIterator __first, _ForwardIterator __last, const _Tp &__val,
      _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it) {
    typedef typename iterator_traits<_ForwardIterator>::difference_type
        _DistanceType;

    _DistanceType __len = std::distance(__first, __last);

    while (__len > 0) {
      _DistanceType __half = __len >> 1;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __half);
      if (__comp_it_val(__middle, __val)) {
        __first = __middle;
        ++__first;
        __len = __len - __half - 1;
      } else if (__comp_val_it(__val, __middle))
        __len = __half;
      else {
        _ForwardIterator __left =
            std::__lower_bound(__first, __middle, __val, __comp_it_val);
        std::advance(__first, __len);
        _ForwardIterator __right =
            std::__upper_bound(++__middle, __first, __val, __comp_val_it);
        return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
      }
    }
    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
  }
# 2162 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Tp>
  constexpr inline pair<_ForwardIterator, _ForwardIterator> equal_range(
      _ForwardIterator __first, _ForwardIterator __last, const _Tp &__val) {

    ;
    ;

    return std::__equal_range(__first, __last, __val,
                              __gnu_cxx::__ops::__iter_less_val(),
                              __gnu_cxx::__ops::__val_less_iter());
  }
# 2199 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Tp, typename _Compare>
  constexpr inline pair<_ForwardIterator, _ForwardIterator> equal_range(
      _ForwardIterator __first, _ForwardIterator __last, const _Tp &__val,
      _Compare __comp) {

    ;

    ;

    return std::__equal_range(__first, __last, __val,
                              __gnu_cxx::__ops::__iter_comp_val(__comp),
                              __gnu_cxx::__ops::__val_comp_iter(__comp));
  }
# 2233 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Tp>
  constexpr bool binary_search(_ForwardIterator __first,
                               _ForwardIterator __last, const _Tp &__val) {

    ;
    ;

    _ForwardIterator __i = std::__lower_bound(
        __first, __last, __val, __gnu_cxx::__ops::__iter_less_val());
    return __i != __last && !(__val < *__i);
  }
# 2267 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Tp, typename _Compare>
  constexpr bool binary_search(_ForwardIterator __first,
                               _ForwardIterator __last, const _Tp &__val,
                               _Compare __comp) {

    ;

    ;

    _ForwardIterator __i = std::__lower_bound(
        __first, __last, __val, __gnu_cxx::__ops::__iter_comp_val(__comp));
    return __i != __last && !bool(__comp(__val, *__i));
  }

  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator, typename _Compare>
  void __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
                             _InputIterator2 __first2, _InputIterator2 __last2,
                             _OutputIterator __result, _Compare __comp) {
    while (__first1 != __last1 && __first2 != __last2) {
      if (__comp(__first2, __first1)) {
        *__result = std::move(*__first2);
        ++__first2;
      } else {
        *__result = std::move(*__first1);
        ++__first1;
      }
      ++__result;
    }
    if (__first1 != __last1)
      std::move(__first1, __last1, __result);
  }

  template <typename _BidirectionalIterator1, typename _BidirectionalIterator2,
            typename _BidirectionalIterator3, typename _Compare>
  void __move_merge_adaptive_backward(
      _BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,
      _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2,
      _BidirectionalIterator3 __result, _Compare __comp) {
    if (__first1 == __last1) {
      std::move_backward(__first2, __last2, __result);
      return;
    } else if (__first2 == __last2)
      return;

    --__last1;
    --__last2;
    while (true) {
      if (__comp(__last2, __last1)) {
        *--__result = std::move(*__last1);
        if (__first1 == __last1) {
          std::move_backward(__first2, ++__last2, __result);
          return;
        }
        --__last1;
      } else {
        *--__result = std::move(*__last2);
        if (__first2 == __last2)
          return;
        --__last2;
      }
    }
  }

  template <typename _BidirectionalIterator1, typename _BidirectionalIterator2,
            typename _Distance>
  _BidirectionalIterator1 __rotate_adaptive(
      _BidirectionalIterator1 __first, _BidirectionalIterator1 __middle,
      _BidirectionalIterator1 __last, _Distance __len1, _Distance __len2,
      _BidirectionalIterator2 __buffer, _Distance __buffer_size) {
    _BidirectionalIterator2 __buffer_end;
    if (__len1 > __len2 && __len2 <= __buffer_size) {
      if (__len2) {
        __buffer_end = std::move(__middle, __last, __buffer);
        std::move_backward(__first, __middle, __last);
        return std::move(__buffer, __buffer_end, __first);
      } else
        return __first;
    } else if (__len1 <= __buffer_size) {
      if (__len1) {
        __buffer_end = std::move(__first, __middle, __buffer);
        std::move(__middle, __last, __first);
        return std::move_backward(__buffer, __buffer_end, __last);
      } else
        return __last;
    } else
      return std::rotate(__first, __middle, __last);
  }

  template <typename _BidirectionalIterator, typename _Distance,
            typename _Pointer, typename _Compare>
  void __merge_adaptive(_BidirectionalIterator __first,
                        _BidirectionalIterator __middle,
                        _BidirectionalIterator __last, _Distance __len1,
                        _Distance __len2, _Pointer __buffer, _Compare __comp) {
    if (__len1 <= __len2) {
      _Pointer __buffer_end = std::move(__first, __middle, __buffer);
      std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
                                 __first, __comp);
    } else {
      _Pointer __buffer_end = std::move(__middle, __last, __buffer);
      std::__move_merge_adaptive_backward(__first, __middle, __buffer,
                                          __buffer_end, __last, __comp);
    }
  }

  template <typename _BidirectionalIterator, typename _Distance,
            typename _Pointer, typename _Compare>
  void __merge_adaptive_resize(
      _BidirectionalIterator __first, _BidirectionalIterator __middle,
      _BidirectionalIterator __last, _Distance __len1, _Distance __len2,
      _Pointer __buffer, _Distance __buffer_size, _Compare __comp) {
    if (__len1 <= __buffer_size || __len2 <= __buffer_size)
      std::__merge_adaptive(__first, __middle, __last, __len1, __len2, __buffer,
                            __comp);
    else {
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2) {
        __len11 = __len1 / 2;
        std::advance(__first_cut, __len11);
        __second_cut =
            std::__lower_bound(__middle, __last, *__first_cut,
                               __gnu_cxx::__ops::__iter_comp_val(__comp));
        __len22 = std::distance(__middle, __second_cut);
      } else {
        __len22 = __len2 / 2;
        std::advance(__second_cut, __len22);
        __first_cut =
            std::__upper_bound(__first, __middle, *__second_cut,
                               __gnu_cxx::__ops::__val_comp_iter(__comp));
        __len11 = std::distance(__first, __first_cut);
      }

      _BidirectionalIterator __new_middle = std::__rotate_adaptive(
          __first_cut, __middle, __second_cut, _Distance(__len1 - __len11),
          __len22, __buffer, __buffer_size);
      std::__merge_adaptive_resize(__first, __first_cut, __new_middle, __len11,
                                   __len22, __buffer, __buffer_size, __comp);
      std::__merge_adaptive_resize(
          __new_middle, __second_cut, __last, _Distance(__len1 - __len11),
          _Distance(__len2 - __len22), __buffer, __buffer_size, __comp);
    }
  }

  template <typename _BidirectionalIterator, typename _Distance,
            typename _Compare>
  void __merge_without_buffer(_BidirectionalIterator __first,
                              _BidirectionalIterator __middle,
                              _BidirectionalIterator __last, _Distance __len1,
                              _Distance __len2, _Compare __comp) {
    if (__len1 == 0 || __len2 == 0)
      return;

    if (__len1 + __len2 == 2) {
      if (__comp(__middle, __first))
        std::iter_swap(__first, __middle);
      return;
    }

    _BidirectionalIterator __first_cut = __first;
    _BidirectionalIterator __second_cut = __middle;
    _Distance __len11 = 0;
    _Distance __len22 = 0;
    if (__len1 > __len2) {
      __len11 = __len1 / 2;
      std::advance(__first_cut, __len11);
      __second_cut =
          std::__lower_bound(__middle, __last, *__first_cut,
                             __gnu_cxx::__ops::__iter_comp_val(__comp));
      __len22 = std::distance(__middle, __second_cut);
    } else {
      __len22 = __len2 / 2;
      std::advance(__second_cut, __len22);
      __first_cut =
          std::__upper_bound(__first, __middle, *__second_cut,
                             __gnu_cxx::__ops::__val_comp_iter(__comp));
      __len11 = std::distance(__first, __first_cut);
    }

    _BidirectionalIterator __new_middle =
        std::rotate(__first_cut, __middle, __second_cut);
    std::__merge_without_buffer(__first, __first_cut, __new_middle, __len11,
                                __len22, __comp);
    std::__merge_without_buffer(__new_middle, __second_cut, __last,
                                __len1 - __len11, __len2 - __len22, __comp);
  }

  template <typename _BidirectionalIterator, typename _Compare>
  void __inplace_merge(_BidirectionalIterator __first,
                       _BidirectionalIterator __middle,
                       _BidirectionalIterator __last, _Compare __comp) {
    typedef
        typename iterator_traits<_BidirectionalIterator>::value_type _ValueType;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type
        _DistanceType;

    if (__first == __middle || __middle == __last)
      return;

    const _DistanceType __len1 = std::distance(__first, __middle);
    const _DistanceType __len2 = std::distance(__middle, __last);

    typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;

    _TmpBuf __buf(__first, std::min(__len1, __len2));

    if (__builtin_expect(__buf.size() == __buf.requested_size(), true))
      std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
                            __buf.begin(), __comp);
    else if (__builtin_expect(__buf.begin() == 0, false))
      std::__merge_without_buffer(__first, __middle, __last, __len1, __len2,
                                  __comp);
    else
      std::__merge_adaptive_resize(__first, __middle, __last, __len1, __len2,
                                   __buf.begin(), _DistanceType(__buf.size()),
                                   __comp);
  }
# 2582 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _BidirectionalIterator>
  inline void inplace_merge(_BidirectionalIterator __first,
                            _BidirectionalIterator __middle,
                            _BidirectionalIterator __last) {

    ;
    ;
    ;

    std::__inplace_merge(__first, __middle, __last,
                         __gnu_cxx::__ops::__iter_less_iter());
  }
# 2623 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _BidirectionalIterator, typename _Compare>
  inline void inplace_merge(_BidirectionalIterator __first,
                            _BidirectionalIterator __middle,
                            _BidirectionalIterator __last, _Compare __comp) {

    ;
    ;
    ;

    std::__inplace_merge(__first, __middle, __last,
                         __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _InputIterator, typename _OutputIterator,
            typename _Compare>
  _OutputIterator __move_merge(_InputIterator __first1, _InputIterator __last1,
                               _InputIterator __first2, _InputIterator __last2,
                               _OutputIterator __result, _Compare __comp) {
    while (__first1 != __last1 && __first2 != __last2) {
      if (__comp(__first2, __first1)) {
        *__result = std::move(*__first2);
        ++__first2;
      } else {
        *__result = std::move(*__first1);
        ++__first1;
      }
      ++__result;
    }
    return std::move(__first2, __last2, std::move(__first1, __last1, __result));
  }

  template <typename _RandomAccessIterator1, typename _RandomAccessIterator2,
            typename _Distance, typename _Compare>
  void __merge_sort_loop(
      _RandomAccessIterator1 __first, _RandomAccessIterator1 __last,
      _RandomAccessIterator2 __result, _Distance __step_size, _Compare __comp) {
    const _Distance __two_step = 2 * __step_size;

    while (__last - __first >= __two_step) {
      __result = std::__move_merge(__first, __first + __step_size,
                                   __first + __step_size, __first + __two_step,
                                   __result, __comp);
      __first += __two_step;
    }
    __step_size = std::min(_Distance(__last - __first), __step_size);

    std::__move_merge(__first, __first + __step_size, __first + __step_size,
                      __last, __result, __comp);
  }

  template <typename _RandomAccessIterator, typename _Distance,
            typename _Compare>
  constexpr void __chunk_insertion_sort(
      _RandomAccessIterator __first, _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp) {
    while (__last - __first >= __chunk_size) {
      std::__insertion_sort(__first, __first + __chunk_size, __comp);
      __first += __chunk_size;
    }
    std::__insertion_sort(__first, __last, __comp);
  }

  enum { _S_chunk_size = 7 };

  template <typename _RandomAccessIterator, typename _Pointer,
            typename _Compare>
  void __merge_sort_with_buffer(_RandomAccessIterator __first,
                                _RandomAccessIterator __last, _Pointer __buffer,
                                _Compare __comp) {
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type
        _Distance;

    const _Distance __len = __last - __first;
    const _Pointer __buffer_last = __buffer + __len;

    _Distance __step_size = _S_chunk_size;
    std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

    while (__step_size < __len) {
      std::__merge_sort_loop(__first, __last, __buffer, __step_size, __comp);
      __step_size *= 2;
      std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size,
                             __comp);
      __step_size *= 2;
    }
  }

  template <typename _RandomAccessIterator, typename _Pointer,
            typename _Compare>
  void __stable_sort_adaptive(
      _RandomAccessIterator __first, _RandomAccessIterator __middle,
      _RandomAccessIterator __last, _Pointer __buffer, _Compare __comp) {
    std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
    std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);

    std::__merge_adaptive(__first, __middle, __last, __middle - __first,
                          __last - __middle, __buffer, __comp);
  }

  template <typename _RandomAccessIterator, typename _Pointer,
            typename _Distance, typename _Compare>
  void __stable_sort_adaptive_resize(
      _RandomAccessIterator __first, _RandomAccessIterator __last,
      _Pointer __buffer, _Distance __buffer_size, _Compare __comp) {
    const _Distance __len = (__last - __first + 1) / 2;
    const _RandomAccessIterator __middle = __first + __len;
    if (__len > __buffer_size) {
      std::__stable_sort_adaptive_resize(__first, __middle, __buffer,
                                         __buffer_size, __comp);
      std::__stable_sort_adaptive_resize(__middle, __last, __buffer,
                                         __buffer_size, __comp);
      std::__merge_adaptive_resize(
          __first, __middle, __last, _Distance(__middle - __first),
          _Distance(__last - __middle), __buffer, __buffer_size, __comp);
    } else
      std::__stable_sort_adaptive(__first, __middle, __last, __buffer, __comp);
  }

  template <typename _RandomAccessIterator, typename _Compare>
  void __inplace_stable_sort(_RandomAccessIterator __first,
                             _RandomAccessIterator __last, _Compare __comp) {
    if (__last - __first < 15) {
      std::__insertion_sort(__first, __last, __comp);
      return;
    }
    _RandomAccessIterator __middle = __first + (__last - __first) / 2;
    std::__inplace_stable_sort(__first, __middle, __comp);
    std::__inplace_stable_sort(__middle, __last, __comp);
    std::__merge_without_buffer(__first, __middle, __last, __middle - __first,
                                __last - __middle, __comp);
  }
# 2809 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator1, typename _InputIterator2,
            typename _Compare>
  constexpr bool __includes(_InputIterator1 __first1, _InputIterator1 __last1,
                            _InputIterator2 __first2, _InputIterator2 __last2,
                            _Compare __comp) {
    while (__first1 != __last1 && __first2 != __last2) {
      if (__comp(__first2, __first1))
        return false;
      if (!__comp(__first1, __first2))
        ++__first2;
      ++__first1;
    }

    return __first2 == __last2;
  }
# 2847 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator1, typename _InputIterator2>
  constexpr inline bool includes(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2) {
# 2862 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
    ;
    ;
    ;
    ;

    return std::__includes(__first1, __last1, __first2, __last2,
                           __gnu_cxx::__ops::__iter_less_iter());
  }
# 2892 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator1, typename _InputIterator2,
            typename _Compare>
  constexpr inline bool includes(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp) {
# 2909 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
    ;
    ;
    ;
    ;

    return std::__includes(__first1, __last1, __first2, __last2,
                           __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }
# 2928 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _BidirectionalIterator, typename _Compare>
  constexpr bool __next_permutation(_BidirectionalIterator __first,
                                    _BidirectionalIterator __last,
                                    _Compare __comp) {
    if (__first == __last)
      return false;
    _BidirectionalIterator __i = __first;
    ++__i;
    if (__i == __last)
      return false;
    __i = __last;
    --__i;

    for (;;) {
      _BidirectionalIterator __ii = __i;
      --__i;
      if (__comp(__i, __ii)) {
        _BidirectionalIterator __j = __last;
        while (!__comp(__i, --__j)) {
        }
        std::iter_swap(__i, __j);
        std::__reverse(__ii, __last, std::__iterator_category(__first));
        return true;
      }
      if (__i == __first) {
        std::__reverse(__first, __last, std::__iterator_category(__first));
        return false;
      }
    }
  }
# 2978 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _BidirectionalIterator>
  constexpr inline bool next_permutation(_BidirectionalIterator __first,
                                         _BidirectionalIterator __last) {

    ;
    ;

    return std::__next_permutation(__first, __last,
                                   __gnu_cxx::__ops::__iter_less_iter());
  }
# 3011 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _BidirectionalIterator, typename _Compare>
  constexpr inline bool next_permutation(_BidirectionalIterator __first,
                                         _BidirectionalIterator __last,
                                         _Compare __comp) {

    ;
    ;

    return std::__next_permutation(__first, __last,
                                   __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _BidirectionalIterator, typename _Compare>
  constexpr bool __prev_permutation(_BidirectionalIterator __first,
                                    _BidirectionalIterator __last,
                                    _Compare __comp) {
    if (__first == __last)
      return false;
    _BidirectionalIterator __i = __first;
    ++__i;
    if (__i == __last)
      return false;
    __i = __last;
    --__i;

    for (;;) {
      _BidirectionalIterator __ii = __i;
      --__i;
      if (__comp(__ii, __i)) {
        _BidirectionalIterator __j = __last;
        while (!__comp(--__j, __i)) {
        }
        std::iter_swap(__i, __j);
        std::__reverse(__ii, __last, std::__iterator_category(__first));
        return true;
      }
      if (__i == __first) {
        std::__reverse(__first, __last, std::__iterator_category(__first));
        return false;
      }
    }
  }
# 3081 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _BidirectionalIterator>
  constexpr inline bool prev_permutation(_BidirectionalIterator __first,
                                         _BidirectionalIterator __last) {

    ;
    ;

    return std::__prev_permutation(__first, __last,
                                   __gnu_cxx::__ops::__iter_less_iter());
  }
# 3114 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _BidirectionalIterator, typename _Compare>
  constexpr inline bool prev_permutation(_BidirectionalIterator __first,
                                         _BidirectionalIterator __last,
                                         _Compare __comp) {

    ;
    ;

    return std::__prev_permutation(__first, __last,
                                   __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _InputIterator, typename _OutputIterator,
            typename _Predicate, typename _Tp>
  constexpr _OutputIterator __replace_copy_if(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _Predicate __pred, const _Tp &__new_value) {
    for (; __first != __last; ++__first, (void)++__result)
      if (__pred(__first))
        *__result = __new_value;
      else
        *__result = *__first;
    return __result;
  }
# 3166 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _OutputIterator, typename _Tp>
  constexpr inline _OutputIterator replace_copy(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      const _Tp &__old_value, const _Tp &__new_value) {

    ;

    return std::__replace_copy_if(
        __first, __last, __result,
        __gnu_cxx::__ops::__iter_equals_val(__old_value), __new_value);
  }
# 3201 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _OutputIterator,
            typename _Predicate, typename _Tp>
  constexpr inline _OutputIterator replace_copy_if(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _Predicate __pred, const _Tp &__new_value) {

    ;

    return std::__replace_copy_if(__first, __last, __result,
                                  __gnu_cxx::__ops::__pred_iter(__pred),
                                  __new_value);
  }
# 3230 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator>
  constexpr inline bool is_sorted(_ForwardIterator __first,
                                  _ForwardIterator __last) {
    return std::is_sorted_until(__first, __last) == __last;
  }
# 3245 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Compare>
  constexpr inline bool is_sorted(_ForwardIterator __first,
                                  _ForwardIterator __last, _Compare __comp) {
    return std::is_sorted_until(__first, __last, __comp) == __last;
  }

  template <typename _ForwardIterator, typename _Compare>
  constexpr _ForwardIterator __is_sorted_until(
      _ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
    if (__first == __last)
      return __last;

    _ForwardIterator __next = __first;
    for (++__next; __next != __last; __first = __next, (void)++__next)
      if (__comp(__next, __first))
        return __next;
    return __next;
  }
# 3276 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator>
  constexpr inline _ForwardIterator is_sorted_until(_ForwardIterator __first,
                                                    _ForwardIterator __last) {

    ;
    ;

    return std::__is_sorted_until(__first, __last,
                                  __gnu_cxx::__ops::__iter_less_iter());
  }
# 3301 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Compare>
  constexpr inline _ForwardIterator is_sorted_until(
      _ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {

    ;
    ;

    return std::__is_sorted_until(__first, __last,
                                  __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }
# 3327 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _Tp>
  constexpr inline pair<const _Tp &, const _Tp &> minmax(const _Tp &__a,
                                                         const _Tp &__b) {

    return __b < __a ? pair<const _Tp &, const _Tp &>(__b, __a)
                     : pair<const _Tp &, const _Tp &>(__a, __b);
  }
# 3348 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _Tp, typename _Compare>
  constexpr inline pair<const _Tp &, const _Tp &> minmax(
      const _Tp &__a, const _Tp &__b, _Compare __comp) {
    return __comp(__b, __a) ? pair<const _Tp &, const _Tp &>(__b, __a)
                            : pair<const _Tp &, const _Tp &>(__a, __b);
  }

  template <typename _ForwardIterator, typename _Compare>
  constexpr pair<_ForwardIterator, _ForwardIterator> __minmax_element(
      _ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
    _ForwardIterator __next = __first;
    if (__first == __last || ++__next == __last)
      return std::make_pair(__first, __first);

    _ForwardIterator __min{}, __max{};
    if (__comp(__next, __first)) {
      __min = __next;
      __max = __first;
    } else {
      __min = __first;
      __max = __next;
    }

    __first = __next;
    ++__first;

    while (__first != __last) {
      __next = __first;
      if (++__next == __last) {
        if (__comp(__first, __min))
          __min = __first;
        else if (!__comp(__first, __max))
          __max = __first;
        break;
      }

      if (__comp(__next, __first)) {
        if (__comp(__next, __min))
          __min = __next;
        if (!__comp(__first, __max))
          __max = __first;
      } else {
        if (__comp(__first, __min))
          __min = __first;
        if (!__comp(__next, __max))
          __max = __next;
      }

      __first = __next;
      ++__first;
    }

    return std::make_pair(__min, __max);
  }
# 3428 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator>
  constexpr inline pair<_ForwardIterator, _ForwardIterator> minmax_element(
      _ForwardIterator __first, _ForwardIterator __last) {

    ;
    ;

    return std::__minmax_element(__first, __last,
                                 __gnu_cxx::__ops::__iter_less_iter());
  }
# 3456 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Compare>
  constexpr inline pair<_ForwardIterator, _ForwardIterator> minmax_element(
      _ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {

    ;
    ;

    return std::__minmax_element(__first, __last,
                                 __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _Tp>
  constexpr inline pair<_Tp, _Tp> minmax(initializer_list<_Tp> __l) {
    ;
    pair<const _Tp *, const _Tp *> __p = std::__minmax_element(
        __l.begin(), __l.end(), __gnu_cxx::__ops::__iter_less_iter());
    return std::make_pair(*__p.first, *__p.second);
  }

  template <typename _Tp, typename _Compare>
  constexpr inline pair<_Tp, _Tp> minmax(initializer_list<_Tp> __l,
                                         _Compare __comp) {
    ;
    pair<const _Tp *, const _Tp *> __p = std::__minmax_element(
        __l.begin(), __l.end(), __gnu_cxx::__ops::__iter_comp_iter(__comp));
    return std::make_pair(*__p.first, *__p.second);
  }
# 3512 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator1, typename _ForwardIterator2,
            typename _BinaryPredicate>
  constexpr inline bool is_permutation(
      _ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _BinaryPredicate __pred) {

    ;

    return std::__is_permutation(__first1, __last1, __first2,
                                 __gnu_cxx::__ops::__iter_comp_iter(__pred));
  }

  template <typename _ForwardIterator1, typename _ForwardIterator2,
            typename _BinaryPredicate>
  constexpr bool __is_permutation(
      _ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __pred) {
    using _Cat1 =
        typename iterator_traits<_ForwardIterator1>::iterator_category;
    using _Cat2 =
        typename iterator_traits<_ForwardIterator2>::iterator_category;
    using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
    using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
    constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
    if (__ra_iters) {
      auto __d1 = std::distance(__first1, __last1);
      auto __d2 = std::distance(__first2, __last2);
      if (__d1 != __d2)
        return false;
    }

    for (; __first1 != __last1 && __first2 != __last2;
         ++__first1, (void)++__first2)
      if (!__pred(__first1, __first2))
        break;

    if (__ra_iters) {
      if (__first1 == __last1)
        return true;
    } else {
      auto __d1 = std::distance(__first1, __last1);
      auto __d2 = std::distance(__first2, __last2);
      if (__d1 == 0 && __d2 == 0)
        return true;
      if (__d1 != __d2)
        return false;
    }

    for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan) {
      if (__scan !=
          std::__find_if(__first1, __scan,
                         __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
        continue;

      auto __matches =
          std::__count_if(__first2, __last2,
                          __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
      if (0 == __matches || std::__count_if(__scan, __last1,
                                            __gnu_cxx::__ops::__iter_comp_iter(
                                                __pred, __scan)) != __matches)
        return false;
    }
    return true;
  }
# 3607 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator1, typename _ForwardIterator2>
  constexpr inline bool is_permutation(
      _ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
    ;
    ;

    return std::__is_permutation(__first1, __last1, __first2, __last2,
                                 __gnu_cxx::__ops::__iter_equal_to_iter());
  }
# 3635 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator1, typename _ForwardIterator2,
            typename _BinaryPredicate>
  constexpr inline bool is_permutation(
      _ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __pred) {
    ;
    ;

    return std::__is_permutation(__first1, __last1, __first2, __last2,
                                 __gnu_cxx::__ops::__iter_comp_iter(__pred));
  }
# 3665 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _Tp>
  constexpr const _Tp &clamp(const _Tp &__val, const _Tp &__lo,
                             const _Tp &__hi) {
    do {
      if (std::__is_constant_evaluated() && !bool(!(__hi < __lo)))
        __builtin_unreachable();
    } while (false);
    return std::min(std::max(__val, __lo), __hi);
  }
# 3685 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _Tp, typename _Compare>
  constexpr const _Tp &clamp(const _Tp &__val, const _Tp &__lo, const _Tp &__hi,
                             _Compare __comp) {
    do {
      if (std::__is_constant_evaluated() && !bool(!__comp(__hi, __lo)))
        __builtin_unreachable();
    } while (false);
    return std::min(std::max(__val, __lo, __comp), __hi, __comp);
  }
# 3717 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _IntType, typename _UniformRandomBitGenerator>
  pair<_IntType, _IntType> __gen_two_uniform_ints(
      _IntType __b0, _IntType __b1, _UniformRandomBitGenerator && __g) {
    _IntType __x =
        uniform_int_distribution<_IntType>{0, (__b0 * __b1) - 1}(__g);
    return std::make_pair(__x / __b1, __x % __b1);
  }
# 3739 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _RandomAccessIterator,
            typename _UniformRandomNumberGenerator>
  void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
               _UniformRandomNumberGenerator && __g) {

    ;

    if (__first == __last)
      return;

    typedef typename iterator_traits<_RandomAccessIterator>::difference_type
        _DistanceType;

    typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
    typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
    typedef typename __distr_type::param_type __p_type;

    typedef typename remove_reference<_UniformRandomNumberGenerator>::type _Gen;
    typedef typename common_type<typename _Gen::result_type, __ud_type>::type
        __uc_type;

    const __uc_type __urngrange = __g.max() - __g.min();
    const __uc_type __urange = __uc_type(__last - __first);

    if (__urngrange / __urange >= __urange)

    {
      _RandomAccessIterator __i = __first + 1;

      if ((__urange % 2) == 0) {
        __distr_type __d{0, 1};
        std::iter_swap(__i++, __first + __d(__g));
      }

      while (__i != __last) {
        const __uc_type __swap_range = __uc_type(__i - __first) + 1;

        const pair<__uc_type, __uc_type> __pospos =
            __gen_two_uniform_ints(__swap_range, __swap_range + 1, __g);

        std::iter_swap(__i++, __first + __pospos.first);
        std::iter_swap(__i++, __first + __pospos.second);
      }

      return;
    }

    __distr_type __d;

    for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
      std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
  }
# 3824 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _Function>
  constexpr _Function for_each(_InputIterator __first, _InputIterator __last,
                               _Function __f) {

    ;
    for (; __first != __last; ++__first)
      __f(*__first);
    return __f;
  }
# 3850 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _Size, typename _Function>
  constexpr _InputIterator for_each_n(_InputIterator __first, _Size __n,
                                      _Function __f) {
    auto __n2 = std::__size_to_integer(__n);
    using _Cat = typename iterator_traits<_InputIterator>::iterator_category;
    if constexpr (is_base_of_v<random_access_iterator_tag, _Cat>) {
      if (__n2 <= 0)
        return __first;
      auto __last = __first + __n2;
      std::for_each(__first, __last, std::move(__f));
      return __last;
    } else {
      while (__n2-- > 0) {
        __f(*__first);
        ++__first;
      }
      return __first;
    }
  }
# 3886 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _Tp>
  constexpr inline _InputIterator find(
      _InputIterator __first, _InputIterator __last, const _Tp &__val) {

    ;
    return std::__find_if(__first, __last,
                          __gnu_cxx::__ops::__iter_equals_val(__val));
  }
# 3911 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _Predicate>
  constexpr inline _InputIterator find_if(
      _InputIterator __first, _InputIterator __last, _Predicate __pred) {

    ;

    return std::__find_if(__first, __last,
                          __gnu_cxx::__ops::__pred_iter(__pred));
  }
# 3943 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _ForwardIterator>
  constexpr _InputIterator find_first_of(
      _InputIterator __first1, _InputIterator __last1,
      _ForwardIterator __first2, _ForwardIterator __last2) {

    ;
    ;

    for (; __first1 != __last1; ++__first1)
      for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
        if (*__first1 == *__iter)
          return __first1;
    return __last1;
  }
# 3984 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _ForwardIterator,
            typename _BinaryPredicate>
  constexpr _InputIterator find_first_of(
      _InputIterator __first1, _InputIterator __last1,
      _ForwardIterator __first2, _ForwardIterator __last2,
      _BinaryPredicate __comp) {

    ;
    ;

    for (; __first1 != __last1; ++__first1)
      for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
        if (__comp(*__first1, *__iter))
          return __first1;
    return __last1;
  }
# 4017 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator>
  constexpr inline _ForwardIterator adjacent_find(_ForwardIterator __first,
                                                  _ForwardIterator __last) {

    ;

    return std::__adjacent_find(__first, __last,
                                __gnu_cxx::__ops::__iter_equal_to_iter());
  }
# 4043 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _BinaryPredicate>
  constexpr inline _ForwardIterator adjacent_find(
      _ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred) {

    ;

    return std::__adjacent_find(
        __first, __last, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
  }
# 4069 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _Tp>
  constexpr inline typename iterator_traits<_InputIterator>::difference_type
  count(_InputIterator __first, _InputIterator __last, const _Tp &__value) {

    ;

    return std::__count_if(__first, __last,
                           __gnu_cxx::__ops::__iter_equals_val(__value));
  }
# 4093 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _Predicate>
  constexpr inline typename iterator_traits<_InputIterator>::difference_type
  count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {

    ;

    return std::__count_if(__first, __last,
                           __gnu_cxx::__ops::__pred_iter(__pred));
  }
# 4134 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator1, typename _ForwardIterator2>
  constexpr inline _ForwardIterator1 search(
      _ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2) {

    ;
    ;

    return std::__search(__first1, __last1, __first2, __last2,
                         __gnu_cxx::__ops::__iter_equal_to_iter());
  }
# 4174 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator1, typename _ForwardIterator2,
            typename _BinaryPredicate>
  constexpr inline _ForwardIterator1 search(
      _ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate) {

    ;
    ;

    return std::__search(__first1, __last1, __first2, __last2,
                         __gnu_cxx::__ops::__iter_comp_iter(__predicate));
  }
# 4210 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Integer, typename _Tp>
  constexpr inline _ForwardIterator search_n(
      _ForwardIterator __first, _ForwardIterator __last, _Integer __count,
      const _Tp &__val) {

    ;

    return std::__search_n(__first, __last, __count,
                           __gnu_cxx::__ops::__iter_equals_val(__val));
  }
# 4244 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Integer, typename _Tp,
            typename _BinaryPredicate>
  constexpr inline _ForwardIterator search_n(
      _ForwardIterator __first, _ForwardIterator __last, _Integer __count,
      const _Tp &__val, _BinaryPredicate __binary_pred) {

    ;

    return std::__search_n(
        __first, __last, __count,
        __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
  }
# 4270 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Searcher>
  constexpr inline _ForwardIterator search(_ForwardIterator __first,
                                           _ForwardIterator __last,
                                           const _Searcher &__searcher) {
    return __searcher(__first, __last).first;
  }
# 4294 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _OutputIterator,
            typename _UnaryOperation>
  constexpr _OutputIterator transform(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _UnaryOperation __unary_op) {

    ;

    for (; __first != __last; ++__first, (void)++__result)
      *__result = __unary_op(*__first);
    return __result;
  }
# 4332 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator, typename _BinaryOperation>
  constexpr _OutputIterator transform(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _OutputIterator __result,
      _BinaryOperation __binary_op) {

    ;

    for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
      *__result = __binary_op(*__first1, *__first2);
    return __result;
  }
# 4366 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Tp>
  constexpr void replace(_ForwardIterator __first, _ForwardIterator __last,
                         const _Tp &__old_value, const _Tp &__new_value) {

    ;

    for (; __first != __last; ++__first)
      if (*__first == __old_value)
        *__first = __new_value;
  }
# 4399 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Predicate, typename _Tp>
  constexpr void replace_if(_ForwardIterator __first, _ForwardIterator __last,
                            _Predicate __pred, const _Tp &__new_value) {

    ;

    for (; __first != __last; ++__first)
      if (__pred(*__first))
        *__first = __new_value;
  }
# 4431 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Generator>
  constexpr void generate(_ForwardIterator __first, _ForwardIterator __last,
                          _Generator __gen) {

    ;

    for (; __first != __last; ++__first)
      *__first = __gen();
  }
# 4464 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _OutputIterator, typename _Size, typename _Generator>
  constexpr _OutputIterator generate_n(_OutputIterator __first, _Size __n,
                                       _Generator __gen) {

    typedef __decltype(std::__size_to_integer(__n)) _IntSize;
    for (_IntSize __niter = std::__size_to_integer(__n); __niter > 0;
         --__niter, (void)++__first)
      *__first = __gen();
    return __first;
  }
# 4499 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _OutputIterator>
  constexpr inline _OutputIterator unique_copy(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result) {

    ;

    if (__first == __last)
      return __result;
    return std::__unique_copy(
        __first, __last, __result, __gnu_cxx::__ops::__iter_equal_to_iter(),
        std::__iterator_category(__first), std::__iterator_category(__result));
  }
# 4539 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator, typename _OutputIterator,
            typename _BinaryPredicate>
  constexpr inline _OutputIterator unique_copy(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _BinaryPredicate __binary_pred) {

    ;

    if (__first == __last)
      return __result;
    return std::__unique_copy(__first, __last, __result,
                              __gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
                              std::__iterator_category(__first),
                              std::__iterator_category(__result));
  }
# 4578 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _RandomAccessIterator>
  __attribute__((__deprecated__("use '"
                                "std::shuffle"
                                "' instead"))) inline void
  random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last) {

    ;

    if (__first != __last)
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) {

        _RandomAccessIterator __j =
            __first + std::rand() % ((__i - __first) + 1);
        if (__i != __j)
          std::iter_swap(__i, __j);
      }
  }
# 4617 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _RandomAccessIterator, typename _RandomNumberGenerator>
  __attribute__((__deprecated__("use '"
                                "std::shuffle"
                                "' instead"))) void
  random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

                 _RandomNumberGenerator && __rand)

  {

    ;

    if (__first == __last)
      return;
    for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) {
      _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
      if (__i != __j)
        std::iter_swap(__i, __j);
    }
  }
# 4659 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Predicate>
  constexpr inline _ForwardIterator partition(
      _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {

    ;

    return std::__partition(__first, __last, __pred,
                            std::__iterator_category(__first));
  }
# 4694 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _RandomAccessIterator>
  constexpr inline void partial_sort(_RandomAccessIterator __first,
                                     _RandomAccessIterator __middle,
                                     _RandomAccessIterator __last) {

    ;
    ;
    ;

    std::__partial_sort(__first, __middle, __last,
                        __gnu_cxx::__ops::__iter_less_iter());
  }
# 4733 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _RandomAccessIterator, typename _Compare>
  constexpr inline void partial_sort(
      _RandomAccessIterator __first, _RandomAccessIterator __middle,
      _RandomAccessIterator __last, _Compare __comp) {

    ;
    ;
    ;

    std::__partial_sort(__first, __middle, __last,
                        __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }
# 4770 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _RandomAccessIterator>
  constexpr inline void nth_element(_RandomAccessIterator __first,
                                    _RandomAccessIterator __nth,
                                    _RandomAccessIterator __last) {

    ;
    ;
    ;

    if (__first == __last || __nth == __last)
      return;

    std::__introselect(__first, __nth, __last, std::__lg(__last - __first) * 2,
                       __gnu_cxx::__ops::__iter_less_iter());
  }
# 4810 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _RandomAccessIterator, typename _Compare>
  constexpr inline void nth_element(
      _RandomAccessIterator __first, _RandomAccessIterator __nth,
      _RandomAccessIterator __last, _Compare __comp) {

    ;
    ;
    ;

    if (__first == __last || __nth == __last)
      return;

    std::__introselect(__first, __nth, __last, std::__lg(__last - __first) * 2,
                       __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }
# 4848 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _RandomAccessIterator>
  constexpr inline void sort(_RandomAccessIterator __first,
                             _RandomAccessIterator __last) {

    ;
    ;

    std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
  }
# 4879 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _RandomAccessIterator, typename _Compare>
  constexpr inline void sort(_RandomAccessIterator __first,
                             _RandomAccessIterator __last, _Compare __comp) {

    ;
    ;

    std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator, typename _Compare>
  constexpr _OutputIterator __merge(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result, _Compare __comp) {
    while (__first1 != __last1 && __first2 != __last2) {
      if (__comp(__first2, __first1)) {
        *__result = *__first2;
        ++__first2;
      } else {
        *__result = *__first1;
        ++__first1;
      }
      ++__result;
    }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
# 4942 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator>
  constexpr inline _OutputIterator merge(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result) {
# 4960 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
    ;
    ;
    ;
    ;

    return std::__merge(__first1, __last1, __first2, __last2, __result,
                        __gnu_cxx::__ops::__iter_less_iter());
  }
# 4993 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator, typename _Compare>
  constexpr inline _OutputIterator merge(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result, _Compare __comp) {
# 5011 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
    ;
    ;
    ;
    ;

    return std::__merge(__first1, __last1, __first2, __last2, __result,
                        __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _RandomAccessIterator, typename _Compare>
  inline void __stable_sort(_RandomAccessIterator __first,
                            _RandomAccessIterator __last, _Compare __comp) {
    typedef
        typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type
        _DistanceType;

    if (__first == __last)
      return;

    typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;

    _TmpBuf __buf(__first, (__last - __first + 1) / 2);

    if (__builtin_expect(__buf.requested_size() == __buf.size(), true))
      std::__stable_sort_adaptive(__first,
                                  __first + _DistanceType(__buf.size()), __last,
                                  __buf.begin(), __comp);
    else if (__builtin_expect(__buf.begin() == 0, false))
      std::__inplace_stable_sort(__first, __last, __comp);
    else
      std::__stable_sort_adaptive_resize(__first, __last, __buf.begin(),
                                         _DistanceType(__buf.size()), __comp);
  }
# 5071 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _RandomAccessIterator>
  inline void stable_sort(_RandomAccessIterator __first,
                          _RandomAccessIterator __last) {

    ;
    ;

    std::__stable_sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
  }
# 5105 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _RandomAccessIterator, typename _Compare>
  inline void stable_sort(_RandomAccessIterator __first,
                          _RandomAccessIterator __last, _Compare __comp) {

    ;
    ;

    std::__stable_sort(__first, __last,
                       __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator, typename _Compare>
  constexpr _OutputIterator __set_union(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result, _Compare __comp) {
    while (__first1 != __last1 && __first2 != __last2) {
      if (__comp(__first1, __first2)) {
        *__result = *__first1;
        ++__first1;
      } else if (__comp(__first2, __first1)) {
        *__result = *__first2;
        ++__first2;
      } else {
        *__result = *__first1;
        ++__first1;
        ++__first2;
      }
      ++__result;
    }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
# 5175 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator>
  constexpr inline _OutputIterator set_union(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result) {
# 5196 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
    ;
    ;
    ;
    ;

    return std::__set_union(__first1, __last1, __first2, __last2, __result,
                            __gnu_cxx::__ops::__iter_less_iter());
  }
# 5226 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator, typename _Compare>
  constexpr inline _OutputIterator set_union(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result, _Compare __comp) {
# 5247 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
    ;
    ;
    ;
    ;

    return std::__set_union(__first1, __last1, __first2, __last2, __result,
                            __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator, typename _Compare>
  constexpr _OutputIterator __set_intersection(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result, _Compare __comp) {
    while (__first1 != __last1 && __first2 != __last2)
      if (__comp(__first1, __first2))
        ++__first1;
      else if (__comp(__first2, __first1))
        ++__first2;
      else {
        *__result = *__first1;
        ++__first1;
        ++__first2;
        ++__result;
      }
    return __result;
  }
# 5299 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator>
  constexpr inline _OutputIterator set_intersection(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result) {
# 5318 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
    ;
    ;
    ;
    ;

    return std::__set_intersection(__first1, __last1, __first2, __last2,
                                   __result,
                                   __gnu_cxx::__ops::__iter_less_iter());
  }
# 5349 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator, typename _Compare>
  constexpr inline _OutputIterator set_intersection(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result, _Compare __comp) {
# 5368 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
    ;
    ;
    ;
    ;

    return std::__set_intersection(__first1, __last1, __first2, __last2,
                                   __result,
                                   __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator, typename _Compare>
  constexpr _OutputIterator __set_difference(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result, _Compare __comp) {
    while (__first1 != __last1 && __first2 != __last2)
      if (__comp(__first1, __first2)) {
        *__result = *__first1;
        ++__first1;
        ++__result;
      } else if (__comp(__first2, __first1))
        ++__first2;
      else {
        ++__first1;
        ++__first2;
      }
    return std::copy(__first1, __last1, __result);
  }
# 5424 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator>
  constexpr inline _OutputIterator set_difference(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result) {
# 5443 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
    ;
    ;
    ;
    ;

    return std::__set_difference(__first1, __last1, __first2, __last2, __result,
                                 __gnu_cxx::__ops::__iter_less_iter());
  }
# 5476 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator, typename _Compare>
  constexpr inline _OutputIterator set_difference(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result, _Compare __comp) {
# 5495 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
    ;
    ;
    ;
    ;

    return std::__set_difference(__first1, __last1, __first2, __last2, __result,
                                 __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator, typename _Compare>
  constexpr _OutputIterator __set_symmetric_difference(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result, _Compare __comp) {
    while (__first1 != __last1 && __first2 != __last2)
      if (__comp(__first1, __first2)) {
        *__result = *__first1;
        ++__first1;
        ++__result;
      } else if (__comp(__first2, __first1)) {
        *__result = *__first2;
        ++__first2;
        ++__result;
      } else {
        ++__first1;
        ++__first2;
      }
    return std::copy(__first2, __last2, std::copy(__first1, __last1, __result));
  }
# 5557 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator>
  constexpr inline _OutputIterator set_symmetric_difference(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result) {
# 5578 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
    ;
    ;
    ;
    ;

    return std::__set_symmetric_difference(
        __first1, __last1, __first2, __last2, __result,
        __gnu_cxx::__ops::__iter_less_iter());
  }
# 5609 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _InputIterator1, typename _InputIterator2,
            typename _OutputIterator, typename _Compare>
  constexpr inline _OutputIterator set_symmetric_difference(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result, _Compare __comp) {
# 5631 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
    ;
    ;
    ;
    ;

    return std::__set_symmetric_difference(
        __first1, __last1, __first2, __last2, __result,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _ForwardIterator, typename _Compare>
  constexpr _ForwardIterator __min_element(
      _ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
    if (__first == __last)
      return __first;
    _ForwardIterator __result = __first;
    while (++__first != __last)
      if (__comp(__first, __result))
        __result = __first;
    return __result;
  }
# 5663 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator>
  constexpr _ForwardIterator inline min_element(_ForwardIterator __first,
                                                _ForwardIterator __last) {

    ;
    ;

    return std::__min_element(__first, __last,
                              __gnu_cxx::__ops::__iter_less_iter());
  }
# 5688 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Compare>
  constexpr inline _ForwardIterator min_element(
      _ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {

    ;
    ;

    return std::__min_element(__first, __last,
                              __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _ForwardIterator, typename _Compare>
  constexpr _ForwardIterator __max_element(
      _ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
    if (__first == __last)
      return __first;
    _ForwardIterator __result = __first;
    while (++__first != __last)
      if (__comp(__result, __first))
        __result = __first;
    return __result;
  }
# 5727 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator>
  constexpr inline _ForwardIterator max_element(_ForwardIterator __first,
                                                _ForwardIterator __last) {

    ;
    ;

    return std::__max_element(__first, __last,
                              __gnu_cxx::__ops::__iter_less_iter());
  }
# 5752 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_algo.h" 3
  template <typename _ForwardIterator, typename _Compare>
  constexpr inline _ForwardIterator max_element(
      _ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {

    ;
    ;

    return std::__max_element(__first, __last,
                              __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _Tp> constexpr inline _Tp min(initializer_list<_Tp> __l) {
    ;
    return *std::__min_element(__l.begin(), __l.end(),
                               __gnu_cxx::__ops::__iter_less_iter());
  }

  template <typename _Tp, typename _Compare>
  constexpr inline _Tp min(initializer_list<_Tp> __l, _Compare __comp) {
    ;
    return *std::__min_element(__l.begin(), __l.end(),
                               __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _Tp> constexpr inline _Tp max(initializer_list<_Tp> __l) {
    ;
    return *std::__max_element(__l.begin(), __l.end(),
                               __gnu_cxx::__ops::__iter_less_iter());
  }

  template <typename _Tp, typename _Compare>
  constexpr inline _Tp max(initializer_list<_Tp> __l, _Compare __comp) {
    ;
    return *std::__max_element(__l.begin(), __l.end(),
                               __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }

  template <typename _InputIterator, typename _RandomAccessIterator,
            typename _Size, typename _UniformRandomBitGenerator>
  _RandomAccessIterator __sample(
      _InputIterator __first, _InputIterator __last, input_iterator_tag,
      _RandomAccessIterator __out, random_access_iterator_tag, _Size __n,
      _UniformRandomBitGenerator && __g) {
    using __distrib_type = uniform_int_distribution<_Size>;
    using __param_type = typename __distrib_type::param_type;
    __distrib_type __d{};
    _Size __sample_sz = 0;
    while (__first != __last && __sample_sz != __n) {
      __out[__sample_sz++] = *__first;
      ++__first;
    }
    for (auto __pop_sz = __sample_sz; __first != __last;
         ++__first, (void)++__pop_sz) {
      const auto __k = __d(__g, __param_type{0, __pop_sz});
      if (__k < __n)
        __out[__k] = *__first;
    }
    return __out + __sample_sz;
  }

  template <typename _ForwardIterator, typename _OutputIterator, typename _Cat,
            typename _Size, typename _UniformRandomBitGenerator>
  _OutputIterator __sample(_ForwardIterator __first, _ForwardIterator __last,
                           forward_iterator_tag, _OutputIterator __out, _Cat,
                           _Size __n, _UniformRandomBitGenerator && __g) {
    using __distrib_type = uniform_int_distribution<_Size>;
    using __param_type = typename __distrib_type::param_type;
    using _USize = make_unsigned_t<_Size>;
    using _Gen = remove_reference_t<_UniformRandomBitGenerator>;
    using __uc_type = common_type_t<typename _Gen::result_type, _USize>;

    if (__first == __last)
      return __out;

    __distrib_type __d{};
    _Size __unsampled_sz = std::distance(__first, __last);
    __n = std::min(__n, __unsampled_sz);

    const __uc_type __urngrange = __g.max() - __g.min();
    if (__urngrange / __uc_type(__unsampled_sz) >= __uc_type(__unsampled_sz))

    {
      while (__n != 0 && __unsampled_sz >= 2) {
        const pair<_Size, _Size> __p =
            __gen_two_uniform_ints(__unsampled_sz, __unsampled_sz - 1, __g);

        --__unsampled_sz;
        if (__p.first < __n) {
          *__out++ = *__first;
          --__n;
        }

        ++__first;

        if (__n == 0)
          break;

        --__unsampled_sz;
        if (__p.second < __n) {
          *__out++ = *__first;
          --__n;
        }

        ++__first;
      }
    }

    for (; __n != 0; ++__first)
      if (__d(__g, __param_type{0, --__unsampled_sz}) < __n) {
        *__out++ = *__first;
        --__n;
      }
    return __out;
  }

  template <typename _PopulationIterator, typename _SampleIterator,
            typename _Distance, typename _UniformRandomBitGenerator>
  _SampleIterator sample(_PopulationIterator __first,
                         _PopulationIterator __last, _SampleIterator __out,
                         _Distance __n, _UniformRandomBitGenerator && __g) {
    using __pop_cat =
        typename std::iterator_traits<_PopulationIterator>::iterator_category;
    using __samp_cat =
        typename std::iterator_traits<_SampleIterator>::iterator_category;

    static_assert(
        __or_<is_convertible<__pop_cat, forward_iterator_tag>,
              is_convertible<__samp_cat, random_access_iterator_tag>>::value,
        "output range must use a RandomAccessIterator when input range"
        " does not meet the ForwardIterator requirements");

    static_assert(is_integral<_Distance>::value,
                  "sample size must be an integer type");

    typename iterator_traits<_PopulationIterator>::difference_type __d = __n;
    return std::__sample(__first, __last, __pop_cat{}, __out, __samp_cat{}, __d,
                         std::forward<_UniformRandomBitGenerator>(__g));
  }

} // namespace std
# 68 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 2 3
# 79 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
namespace std __attribute__((__visibility__("default"))) {

  template <int _Num> struct _Placeholder {};
# 108 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
  template <typename _Callable, typename... _Args>
  inline constexpr invoke_result_t<_Callable, _Args...> invoke(
      _Callable && __fn,
      _Args &&
          ...__args) noexcept(is_nothrow_invocable_v<_Callable, _Args...>) {
    return std::__invoke(std::forward<_Callable>(__fn),
                         std::forward<_Args>(__args)...);
  }
# 141 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
  template <typename _MemFunPtr,
            bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>
  class _Mem_fn_base : public _Mem_fn_traits<_MemFunPtr>::__maybe_type {
    using _Traits = _Mem_fn_traits<_MemFunPtr>;

    using _Arity = typename _Traits::__arity;
    using _Varargs = typename _Traits::__vararg;

    template <typename _Func, typename... _BoundArgs>
    friend struct _Bind_check_arity;

    _MemFunPtr _M_pmf;

  public:
    using result_type = typename _Traits::__result_type;

    explicit constexpr _Mem_fn_base(_MemFunPtr __pmf) noexcept
        : _M_pmf(__pmf) {}

    template <typename... _Args>
    constexpr auto operator()(_Args &&...__args) const
        noexcept(noexcept(std::__invoke(_M_pmf,
                                        std::forward<_Args>(__args)...)))
            -> decltype(std::__invoke(_M_pmf, std::forward<_Args>(__args)...)) {
      return std::__invoke(_M_pmf, std::forward<_Args>(__args)...);
    }
  };

  template <typename _MemObjPtr> class _Mem_fn_base<_MemObjPtr, false> {
    using _Arity = integral_constant<size_t, 0>;
    using _Varargs = false_type;

    template <typename _Func, typename... _BoundArgs>
    friend struct _Bind_check_arity;

    _MemObjPtr _M_pm;

  public:
    explicit constexpr _Mem_fn_base(_MemObjPtr __pm) noexcept : _M_pm(__pm) {}

    template <typename _Tp>
    constexpr auto operator()(_Tp &&__obj) const
        noexcept(noexcept(std::__invoke(_M_pm, std::forward<_Tp>(__obj))))
            -> decltype(std::__invoke(_M_pm, std::forward<_Tp>(__obj))) {
      return std::__invoke(_M_pm, std::forward<_Tp>(__obj));
    }
  };

  template <typename _MemberPointer> struct _Mem_fn;

  template <typename _Res, typename _Class>
  struct _Mem_fn<_Res _Class::*> : _Mem_fn_base<_Res _Class::*> {
    using _Mem_fn_base<_Res _Class::*>::_Mem_fn_base;
  };
# 234 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
  template <typename _Tp, typename _Class>
  constexpr inline _Mem_fn<_Tp _Class::*> mem_fn(_Tp _Class::*__pm) noexcept {
    return _Mem_fn<_Tp _Class::*>(__pm);
  }
# 253 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
  template <typename _Tp> struct is_bind_expression : public false_type {};
# 265 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
  template <typename _Tp>
  struct is_placeholder : public integral_constant<int, 0> {};

  template <typename _Tp>
  inline constexpr bool is_bind_expression_v = is_bind_expression<_Tp>::value;
  template <typename _Tp>
  inline constexpr int is_placeholder_v = is_placeholder<_Tp>::value;

  namespace placeholders {
# 294 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
  inline const _Placeholder<1> _1;
  inline const _Placeholder<2> _2;
  inline const _Placeholder<3> _3;
  inline const _Placeholder<4> _4;
  inline const _Placeholder<5> _5;
  inline const _Placeholder<6> _6;
  inline const _Placeholder<7> _7;
  inline const _Placeholder<8> _8;
  inline const _Placeholder<9> _9;
  inline const _Placeholder<10> _10;
  inline const _Placeholder<11> _11;
  inline const _Placeholder<12> _12;
  inline const _Placeholder<13> _13;
  inline const _Placeholder<14> _14;
  inline const _Placeholder<15> _15;
  inline const _Placeholder<16> _16;
  inline const _Placeholder<17> _17;
  inline const _Placeholder<18> _18;
  inline const _Placeholder<19> _19;
  inline const _Placeholder<20> _20;
  inline const _Placeholder<21> _21;
  inline const _Placeholder<22> _22;
  inline const _Placeholder<23> _23;
  inline const _Placeholder<24> _24;
  inline const _Placeholder<25> _25;
  inline const _Placeholder<26> _26;
  inline const _Placeholder<27> _27;
  inline const _Placeholder<28> _28;
  inline const _Placeholder<29> _29;

  } // namespace placeholders

  template <int _Num>
  struct is_placeholder<_Placeholder<_Num>>
      : public integral_constant<int, _Num> {};

  template <int _Num>
  struct is_placeholder<const _Placeholder<_Num>>
      : public integral_constant<int, _Num> {};

  template <std::size_t __i, typename _Tuple>
  using _Safe_tuple_element_t =
      typename enable_if<(__i < tuple_size<_Tuple>::value),
                         tuple_element<__i, _Tuple>>::type::type;
# 362 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
  template <typename _Arg, bool _IsBindExp = is_bind_expression<_Arg>::value,
            bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
  class _Mu;

  template <typename _Tp> class _Mu<reference_wrapper<_Tp>, false, false> {
  public:
    template <typename _CVRef, typename _Tuple>
    constexpr _Tp &operator()(_CVRef &__arg, _Tuple &) const volatile {
      return __arg.get();
    }
  };

  template <typename _Arg> class _Mu<_Arg, true, false> {
  public:
    template <typename _CVArg, typename... _Args>
    constexpr auto operator()(_CVArg &__arg, tuple<_Args...> &__tuple) const
        volatile -> decltype(__arg(declval<_Args>()...)) {

      typedef typename _Build_index_tuple<sizeof...(_Args)>::__type _Indexes;
      return this->__call(__arg, __tuple, _Indexes());
    }

  private:
    template <typename _CVArg, typename... _Args, std::size_t... _Indexes>
    constexpr auto __call(_CVArg &__arg, tuple<_Args...> &__tuple,
                          const _Index_tuple<_Indexes...> &) const
        volatile -> decltype(__arg(declval<_Args>()...)) {
      return __arg(std::get<_Indexes>(std::move(__tuple))...);
    }
  };

  template <typename _Arg> class _Mu<_Arg, false, true> {
  public:
    template <typename _Tuple>
    constexpr _Safe_tuple_element_t<(is_placeholder<_Arg>::value - 1),
                                    _Tuple> &&
    operator()(const volatile _Arg &, _Tuple &__tuple) const volatile {
      return ::std::get<(is_placeholder<_Arg>::value - 1)>(std::move(__tuple));
    }
  };

  template <typename _Arg> class _Mu<_Arg, false, false> {
  public:
    template <typename _CVArg, typename _Tuple>
    constexpr _CVArg &&operator()(_CVArg &&__arg, _Tuple &) const volatile {
      return std::forward<_CVArg>(__arg);
    }
  };

  template <std::size_t _Ind, typename... _Tp>
  inline auto __volget(volatile tuple<_Tp...> & __tuple)
      -> __tuple_element_t<_Ind, tuple<_Tp...>> volatile & {
    return std::get<_Ind>(const_cast<tuple<_Tp...> &>(__tuple));
  }

  template <std::size_t _Ind, typename... _Tp>
  inline auto __volget(const volatile tuple<_Tp...> &__tuple)
      -> __tuple_element_t<_Ind, tuple<_Tp...>> const volatile & {
    return std::get<_Ind>(const_cast<const tuple<_Tp...> &>(__tuple));
  }
# 487 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
  template <typename _Signature> class _Bind;

  template <typename _Functor, typename... _Bound_args>
  class _Bind<_Functor(_Bound_args...)> : public _Weak_result_type<_Functor> {
    typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
        _Bound_indexes;

    _Functor _M_f;
    tuple<_Bound_args...> _M_bound_args;

    template <typename _Result, typename... _Args, std::size_t... _Indexes>
    constexpr _Result __call(tuple<_Args...> &&__args,
                             _Index_tuple<_Indexes...>) {
      return std::__invoke(
          _M_f,
          _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...);
    }

    template <typename _Result, typename... _Args, std::size_t... _Indexes>
    constexpr _Result __call_c(tuple<_Args...> &&__args,
                               _Index_tuple<_Indexes...>) const {
      return std::__invoke(
          _M_f,
          _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...);
    }
# 546 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
    template <typename _BoundArg, typename _CallArgs>
    using _Mu_type = decltype(_Mu<typename remove_cv<_BoundArg>::type>()(
        std::declval<_BoundArg &>(), std::declval<_CallArgs &>()));

    template <typename _Fn, typename _CallArgs, typename... _BArgs>
    using _Res_type_impl =
        typename result_of<_Fn &(_Mu_type<_BArgs, _CallArgs> &&...)>::type;

    template <typename _CallArgs>
    using _Res_type = _Res_type_impl<_Functor, _CallArgs, _Bound_args...>;

    template <typename _CallArgs>
    using __dependent =
        typename enable_if<bool(tuple_size<_CallArgs>::value + 1),
                           _Functor>::type;

    template <typename _CallArgs, template <class> class __cv_quals>
    using _Res_type_cv =
        _Res_type_impl<typename __cv_quals<__dependent<_CallArgs>>::type,
                       _CallArgs, typename __cv_quals<_Bound_args>::type...>;

  public:
    template <typename... _Args>
    explicit constexpr _Bind(const _Functor &__f, _Args &&...__args)
        : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...) {}

    template <typename... _Args>
    explicit constexpr _Bind(_Functor &&__f, _Args &&...__args)
        : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...) {}

    _Bind(const _Bind &) = default;
    _Bind(_Bind &&) = default;

    template <typename... _Args, typename _Result = _Res_type<tuple<_Args...>>>
    constexpr _Result operator()(_Args &&...__args) {
      return this->__call<_Result>(
          std::forward_as_tuple(std::forward<_Args>(__args)...),
          _Bound_indexes());
    }

    template <typename... _Args,
              typename _Result = _Res_type_cv<tuple<_Args...>, add_const>>
    constexpr _Result operator()(_Args &&...__args) const {
      return this->__call_c<_Result>(
          std::forward_as_tuple(std::forward<_Args>(__args)...),
          _Bound_indexes());
    }
# 633 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
  };

  template <typename _Result, typename _Signature> class _Bind_result;

  template <typename _Result, typename _Functor, typename... _Bound_args>
  class _Bind_result<_Result, _Functor(_Bound_args...)> {
    typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
        _Bound_indexes;

    _Functor _M_f;
    tuple<_Bound_args...> _M_bound_args;

    template <typename _Res, typename... _Args, std::size_t... _Indexes>
    constexpr _Res __call(tuple<_Args...> &&__args, _Index_tuple<_Indexes...>) {
      return std::__invoke_r<_Res>(
          _M_f,
          _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...);
    }

    template <typename _Res, typename... _Args, std::size_t... _Indexes>
    constexpr _Res __call(tuple<_Args...> &&__args,
                          _Index_tuple<_Indexes...>) const {
      return std::__invoke_r<_Res>(
          _M_f,
          _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...);
    }
# 689 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
  public:
    typedef _Result result_type;

    template <typename... _Args>
    explicit constexpr _Bind_result(const _Functor &__f, _Args &&...__args)
        : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...) {}

    template <typename... _Args>
    explicit constexpr _Bind_result(_Functor &&__f, _Args &&...__args)
        : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...) {}

    _Bind_result(const _Bind_result &) = default;
    _Bind_result(_Bind_result &&) = default;

    template <typename... _Args>
    constexpr result_type operator()(_Args &&...__args) {
      return this->__call<_Result>(
          std::forward_as_tuple(std::forward<_Args>(__args)...),
          _Bound_indexes());
    }

    template <typename... _Args>
    constexpr result_type operator()(_Args &&...__args) const {
      return this->__call<_Result>(
          std::forward_as_tuple(std::forward<_Args>(__args)...),
          _Bound_indexes());
    }
# 752 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
    template <typename... _Args>
    void operator()(_Args &&...) const volatile = delete;
  };
# 764 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
  template <typename _Signature>
  struct is_bind_expression<_Bind<_Signature>> : public true_type {};

  template <typename _Signature>
  struct is_bind_expression<const _Bind<_Signature>> : public true_type {};

  template <typename _Signature>
  struct is_bind_expression<volatile _Bind<_Signature>> : public true_type {};

  template <typename _Signature>
  struct is_bind_expression<const volatile _Bind<_Signature>>
      : public true_type {};

  template <typename _Result, typename _Signature>
  struct is_bind_expression<_Bind_result<_Result, _Signature>>
      : public true_type {};

  template <typename _Result, typename _Signature>
  struct is_bind_expression<const _Bind_result<_Result, _Signature>>
      : public true_type {};

  template <typename _Result, typename _Signature>
  struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
      : public true_type {};

  template <typename _Result, typename _Signature>
  struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
      : public true_type {};

  template <typename _Func, typename... _BoundArgs> struct _Bind_check_arity {};

  template <typename _Ret, typename... _Args, typename... _BoundArgs>
  struct _Bind_check_arity<_Ret (*)(_Args...), _BoundArgs...> {
    static_assert(sizeof...(_BoundArgs) == sizeof...(_Args),
                  "Wrong number of arguments for function");
  };

  template <typename _Ret, typename... _Args, typename... _BoundArgs>
  struct _Bind_check_arity<_Ret (*)(_Args......), _BoundArgs...> {
    static_assert(sizeof...(_BoundArgs) >= sizeof...(_Args),
                  "Wrong number of arguments for function");
  };

  template <typename _Tp, typename _Class, typename... _BoundArgs>
  struct _Bind_check_arity<_Tp _Class::*, _BoundArgs...> {
    using _Arity = typename _Mem_fn<_Tp _Class::*>::_Arity;
    using _Varargs = typename _Mem_fn<_Tp _Class::*>::_Varargs;
    static_assert(_Varargs::value ? sizeof...(_BoundArgs) >= _Arity::value + 1
                                  : sizeof...(_BoundArgs) == _Arity::value + 1,
                  "Wrong number of arguments for pointer-to-member");
  };

  template <typename _Tp, typename _Tp2 = typename decay<_Tp>::type>
  using __is_socketlike = __or_<is_integral<_Tp2>, is_enum<_Tp2>>;

  template <bool _SocketLike, typename _Func, typename... _BoundArgs>
  struct _Bind_helper
      : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...> {
    typedef typename decay<_Func>::type __func_type;
    typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
  };

  template <typename _Func, typename... _BoundArgs>
  struct _Bind_helper<true, _Func, _BoundArgs...> {};

  template <typename _Func, typename... _BoundArgs>
  inline constexpr typename _Bind_helper<__is_socketlike<_Func>::value, _Func,
                                         _BoundArgs...>::type
  bind(_Func && __f, _BoundArgs && ...__args) {
    typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
    return typename __helper_type::type(std::forward<_Func>(__f),
                                        std::forward<_BoundArgs>(__args)...);
  }

  template <typename _Result, typename _Func, typename... _BoundArgs>
  struct _Bindres_helper
      : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...> {
    typedef typename decay<_Func>::type __functor_type;
    typedef _Bind_result<_Result,
                         __functor_type(typename decay<_BoundArgs>::type...)>
        type;
  };

  template <typename _Result, typename _Func, typename... _BoundArgs>
  inline constexpr typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
  bind(_Func && __f, _BoundArgs && ...__args) {
    typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;
    return typename __helper_type::type(std::forward<_Func>(__f),
                                        std::forward<_BoundArgs>(__args)...);
  }

  template <typename _Fd, typename... _BoundArgs> struct _Bind_front {
    static_assert(is_move_constructible_v<_Fd>);
    static_assert((is_move_constructible_v<_BoundArgs> && ...));

    template <typename _Fn, typename... _Args>
    explicit constexpr _Bind_front(int, _Fn &&__fn, _Args &&...__args) noexcept(
        __and_<is_nothrow_constructible<_Fd, _Fn>,
               is_nothrow_constructible<_BoundArgs, _Args>...>::value)
        : _M_fd(std::forward<_Fn>(__fn)),
          _M_bound_args(std::forward<_Args>(__args)...) {
      static_assert(sizeof...(_Args) == sizeof...(_BoundArgs));
    }

    _Bind_front(const _Bind_front &) = default;
    _Bind_front(_Bind_front &&) = default;
    _Bind_front &operator=(const _Bind_front &) = default;
    _Bind_front &operator=(_Bind_front &&) = default;
    ~_Bind_front() = default;

    template <typename... _CallArgs>
    constexpr invoke_result_t<_Fd &, _BoundArgs &..., _CallArgs...>
    operator()(_CallArgs &&...__call_args) & noexcept(
        is_nothrow_invocable_v<_Fd &, _BoundArgs &..., _CallArgs...>) {
      return _S_call(*this, _BoundIndices(),
                     std::forward<_CallArgs>(__call_args)...);
    }

    template <typename... _CallArgs>
    constexpr invoke_result_t<const _Fd &, const _BoundArgs &..., _CallArgs...>
    operator()(_CallArgs &&...__call_args) const & noexcept(
        is_nothrow_invocable_v<const _Fd &, const _BoundArgs &...,
                               _CallArgs...>) {
      return _S_call(*this, _BoundIndices(),
                     std::forward<_CallArgs>(__call_args)...);
    }

    template <typename... _CallArgs>
    constexpr invoke_result_t<_Fd, _BoundArgs..., _CallArgs...>
    operator()(_CallArgs &&...__call_args) && noexcept(
        is_nothrow_invocable_v<_Fd, _BoundArgs..., _CallArgs...>) {
      return _S_call(std::move(*this), _BoundIndices(),
                     std::forward<_CallArgs>(__call_args)...);
    }

    template <typename... _CallArgs>
    constexpr invoke_result_t<const _Fd, const _BoundArgs..., _CallArgs...>
    operator()(_CallArgs &&...__call_args) const && noexcept(
        is_nothrow_invocable_v<const _Fd, const _BoundArgs..., _CallArgs...>) {
      return _S_call(std::move(*this), _BoundIndices(),
                     std::forward<_CallArgs>(__call_args)...);
    }

  private:
    using _BoundIndices = index_sequence_for<_BoundArgs...>;

    template <typename _Tp, size_t... _Ind, typename... _CallArgs>
    static constexpr decltype(auto) _S_call(_Tp &&__g, index_sequence<_Ind...>,
                                            _CallArgs &&...__call_args) {
      return std::invoke(
          std::forward<_Tp>(__g)._M_fd,
          std::get<_Ind>(std::forward<_Tp>(__g)._M_bound_args)...,
          std::forward<_CallArgs>(__call_args)...);
    }

    [[no_unique_address]] _Fd _M_fd;
    [[no_unique_address]] std::tuple<_BoundArgs...> _M_bound_args;
  };

  template <typename _Fd> struct _Bind_front0 {
    static_assert(is_move_constructible_v<_Fd>);

    template <typename _Fn>
    explicit constexpr _Bind_front0(int, _Fn &&__fn) noexcept(
        is_nothrow_constructible_v<_Fd, _Fn>)
        : _M_fd(std::forward<_Fn>(__fn)) {}

    _Bind_front0(const _Bind_front0 &) = default;
    _Bind_front0(_Bind_front0 &&) = default;
    _Bind_front0 &operator=(const _Bind_front0 &) = default;
    _Bind_front0 &operator=(_Bind_front0 &&) = default;
    ~_Bind_front0() = default;

    template <typename... _CallArgs>
    constexpr invoke_result_t<_Fd &, _CallArgs...>
    operator()(_CallArgs &&...__call_args) & noexcept(
        is_nothrow_invocable_v<_Fd &, _CallArgs...>) {
      return std::invoke(_M_fd, std::forward<_CallArgs>(__call_args)...);
    }

    template <typename... _CallArgs>
    constexpr invoke_result_t<const _Fd &, _CallArgs...>
    operator()(_CallArgs &&...__call_args) const & noexcept(
        is_nothrow_invocable_v<const _Fd &, _CallArgs...>) {
      return std::invoke(_M_fd, std::forward<_CallArgs>(__call_args)...);
    }

    template <typename... _CallArgs>
    constexpr invoke_result_t<_Fd, _CallArgs...>
    operator()(_CallArgs &&...__call_args) && noexcept(
        is_nothrow_invocable_v<_Fd, _CallArgs...>) {
      return std::invoke(std::move(_M_fd),
                         std::forward<_CallArgs>(__call_args)...);
    }

    template <typename... _CallArgs>
    constexpr invoke_result_t<const _Fd, _CallArgs...>
    operator()(_CallArgs &&...__call_args) const && noexcept(
        is_nothrow_invocable_v<const _Fd, _CallArgs...>) {
      return std::invoke(std::move(_M_fd),
                         std::forward<_CallArgs>(__call_args)...);
    }

  private:
    [[no_unique_address]] _Fd _M_fd;
  };

  template <typename _Fn, typename... _Args>
  using _Bind_front_t =
      __conditional_t<sizeof...(_Args) == 0, _Bind_front0<decay_t<_Fn>>,
                      _Bind_front<decay_t<_Fn>, decay_t<_Args>...>>;
# 1071 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
  template <typename _Fn, typename... _Args>
  constexpr _Bind_front_t<_Fn, _Args...>
  bind_front(_Fn && __fn, _Args && ...__args) noexcept(
      is_nothrow_constructible_v<_Bind_front_t<_Fn, _Args...>, int, _Fn,
                                 _Args...>) {
    return _Bind_front_t<_Fn, _Args...>(0, std::forward<_Fn>(__fn),
                                        std::forward<_Args>(__args)...);
  }

  template <typename _Fn> class _Not_fn {
    template <typename _Fn2, typename... _Args>
    using __inv_res_t = typename __invoke_result<_Fn2, _Args...>::type;

    template <typename _Tp>
    static decltype(!std::declval<_Tp>())
    _S_not() noexcept(noexcept(!std::declval<_Tp>()));

  public:
    template <typename _Fn2>
    constexpr _Not_fn(_Fn2 &&__fn, int) : _M_fn(std::forward<_Fn2>(__fn)) {}

    _Not_fn(const _Not_fn &__fn) = default;
    _Not_fn(_Not_fn &&__fn) = default;
    ~_Not_fn() = default;
# 1118 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
    template <typename... _Args>
    constexpr decltype(_S_not<__inv_res_t<_Fn &, _Args...>>())
    operator()(_Args &&...__args) & noexcept(
        __is_nothrow_invocable<_Fn &, _Args...>::value &&
        noexcept(_S_not<__inv_res_t<_Fn &, _Args...>>())) {
      return !std::__invoke(std::forward<_Fn &>(_M_fn),
                            std::forward<_Args>(__args)...);
    }
    template <typename... _Args>
    constexpr decltype(_S_not<__inv_res_t<_Fn const &, _Args...>>())
    operator()(_Args &&...__args) const & noexcept(
        __is_nothrow_invocable<_Fn const &, _Args...>::value &&
        noexcept(_S_not<__inv_res_t<_Fn const &, _Args...>>())) {
      return !std::__invoke(std::forward<_Fn const &>(_M_fn),
                            std::forward<_Args>(__args)...);
    }
    template <typename... _Args>
    constexpr decltype(_S_not<__inv_res_t<_Fn &&, _Args...>>())
    operator()(_Args &&...__args) && noexcept(
        __is_nothrow_invocable<_Fn &&, _Args...>::value &&
        noexcept(_S_not<__inv_res_t<_Fn &&, _Args...>>())) {
      return !std::__invoke(std::forward<_Fn &&>(_M_fn),
                            std::forward<_Args>(__args)...);
    }
    template <typename... _Args>
    constexpr decltype(_S_not<__inv_res_t<_Fn const &&, _Args...>>())
    operator()(_Args &&...__args) const && noexcept(
        __is_nothrow_invocable<_Fn const &&, _Args...>::value &&
        noexcept(_S_not<__inv_res_t<_Fn const &&, _Args...>>())) {
      return !std::__invoke(std::forward<_Fn const &&>(_M_fn),
                            std::forward<_Args>(__args)...);
    }

  private:
    _Fn _M_fn;
  };

  template <typename _Tp, typename _Pred> struct __is_byte_like : false_type {};

  template <typename _Tp>
  struct __is_byte_like<_Tp, equal_to<_Tp>>
      : __bool_constant<sizeof(_Tp) == 1 && is_integral<_Tp>::value> {};

  template <typename _Tp>
  struct __is_byte_like<_Tp, equal_to<void>>
      : __bool_constant<sizeof(_Tp) == 1 && is_integral<_Tp>::value> {};

  enum class byte : unsigned char;

  template <> struct __is_byte_like<byte, equal_to<byte>> : true_type {};

  template <> struct __is_byte_like<byte, equal_to<void>> : true_type {};
# 1165 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/functional" 3
  template <typename _Fn>
  constexpr inline auto not_fn(_Fn && __fn) noexcept(
      std::is_nothrow_constructible<std::decay_t<_Fn>, _Fn &&>::value) {
    return _Not_fn<std::decay_t<_Fn>>{std::forward<_Fn>(__fn), 0};
  }

  template <typename _ForwardIterator1, typename _BinaryPredicate = equal_to<>>
  class default_searcher {
  public:
    constexpr default_searcher(_ForwardIterator1 __pat_first,
                               _ForwardIterator1 __pat_last,
                               _BinaryPredicate __pred = _BinaryPredicate())
        : _M_m(__pat_first, __pat_last, std::move(__pred)) {}

    template <typename _ForwardIterator2>
    constexpr pair<_ForwardIterator2, _ForwardIterator2>
    operator()(_ForwardIterator2 __first, _ForwardIterator2 __last) const {
      _ForwardIterator2 __first_ret =
          std::search(__first, __last, std::get<0>(_M_m), std::get<1>(_M_m),
                      std::get<2>(_M_m));
      auto __ret = std::make_pair(__first_ret, __first_ret);
      if (__ret.first != __last)
        std::advance(__ret.second,
                     std::distance(std::get<0>(_M_m), std::get<1>(_M_m)));
      return __ret;
    }

  private:
    tuple<_ForwardIterator1, _ForwardIterator1, _BinaryPredicate> _M_m;
  };

  template <typename _Key, typename _Tp, typename _Hash, typename _Pred>
  struct __boyer_moore_map_base {
    template <typename _RAIter>
    __boyer_moore_map_base(_RAIter __pat, size_t __patlen, _Hash &&__hf,
                           _Pred &&__pred)
        : _M_bad_char{__patlen, std::move(__hf), std::move(__pred)} {
      if (__patlen > 0)
        for (__diff_type __i = 0; __i < __patlen - 1; ++__i)
          _M_bad_char[__pat[__i]] = __patlen - 1 - __i;
    }

    using __diff_type = _Tp;

    __diff_type _M_lookup(_Key __key, __diff_type __not_found) const {
      auto __iter = _M_bad_char.find(__key);
      if (__iter == _M_bad_char.end())
        return __not_found;
      return __iter->second;
    }

    _Pred _M_pred() const { return _M_bad_char.key_eq(); }

    std::unordered_map<_Key, _Tp, _Hash, _Pred> _M_bad_char;
  };

  template <typename _Tp, size_t _Len, typename _Pred>
  struct __boyer_moore_array_base {
    template <typename _RAIter, typename _Unused>
    __boyer_moore_array_base(_RAIter __pat, size_t __patlen, _Unused &&,
                             _Pred &&__pred)
        : _M_bad_char{array<_Tp, _Len>{}, std::move(__pred)} {
      std::get<0>(_M_bad_char).fill(__patlen);
      if (__patlen > 0)
        for (__diff_type __i = 0; __i < __patlen - 1; ++__i) {
          auto __ch = __pat[__i];
          using _UCh = make_unsigned_t<decltype(__ch)>;
          auto __uch = static_cast<_UCh>(__ch);
          std::get<0>(_M_bad_char)[__uch] = __patlen - 1 - __i;
        }
    }

    using __diff_type = _Tp;

    template <typename _Key>
    __diff_type _M_lookup(_Key __key, __diff_type __not_found) const {
      auto __ukey = static_cast<make_unsigned_t<_Key>>(__key);
      if (__ukey >= _Len)
        return __not_found;
      return std::get<0>(_M_bad_char)[__ukey];
    }

    const _Pred &_M_pred() const { return std::get<1>(_M_bad_char); }

    tuple<array<_Tp, _Len>, _Pred> _M_bad_char;
  };

  template <typename _RAIter, typename _Hash, typename _Pred,
            typename _Val = typename iterator_traits<_RAIter>::value_type,
            typename _Diff = typename iterator_traits<_RAIter>::difference_type>
  using __boyer_moore_base_t =
      __conditional_t<__is_byte_like<_Val, _Pred>::value,
                      __boyer_moore_array_base<_Diff, 256, _Pred>,
                      __boyer_moore_map_base<_Val, _Diff, _Hash, _Pred>>;

  template <typename _RAIter,
            typename _Hash =
                hash<typename iterator_traits<_RAIter>::value_type>,
            typename _BinaryPredicate = equal_to<>>
  class boyer_moore_searcher
      : __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate> {
    using _Base = __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>;
    using typename _Base::__diff_type;

  public:
    boyer_moore_searcher(_RAIter __pat_first, _RAIter __pat_last,
                         _Hash __hf = _Hash(),
                         _BinaryPredicate __pred = _BinaryPredicate());

    template <typename _RandomAccessIterator2>
    pair<_RandomAccessIterator2, _RandomAccessIterator2>
    operator()(_RandomAccessIterator2 __first,
               _RandomAccessIterator2 __last) const;

  private:
    bool _M_is_prefix(_RAIter __word, __diff_type __len, __diff_type __pos) {
      const auto &__pred = this->_M_pred();
      __diff_type __suffixlen = __len - __pos;
      for (__diff_type __i = 0; __i < __suffixlen; ++__i)
        if (!__pred(__word[__i], __word[__pos + __i]))
          return false;
      return true;
    }

    __diff_type _M_suffix_length(_RAIter __word, __diff_type __len,
                                 __diff_type __pos) {
      const auto &__pred = this->_M_pred();
      __diff_type __i = 0;
      while (__pred(__word[__pos - __i], __word[__len - 1 - __i]) &&
             __i < __pos) {
        ++__i;
      }
      return __i;
    }

    template <typename _Tp> __diff_type _M_bad_char_shift(_Tp __c) const {
      return this->_M_lookup(__c, _M_pat_end - _M_pat);
    }

    _RAIter _M_pat;
    _RAIter _M_pat_end;
    std::vector<__diff_type> _M_good_suffix;
  };

  template <typename _RAIter,
            typename _Hash =
                hash<typename iterator_traits<_RAIter>::value_type>,
            typename _BinaryPredicate = equal_to<>>
  class boyer_moore_horspool_searcher
      : __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate> {
    using _Base = __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>;
    using typename _Base::__diff_type;

  public:
    boyer_moore_horspool_searcher(_RAIter __pat, _RAIter __pat_end,
                                  _Hash __hf = _Hash(),
                                  _BinaryPredicate __pred = _BinaryPredicate())
        : _Base(__pat, __pat_end - __pat, std::move(__hf), std::move(__pred)),
          _M_pat(__pat), _M_pat_end(__pat_end) {}

    template <typename _RandomAccessIterator2>
    pair<_RandomAccessIterator2, _RandomAccessIterator2>
    operator()(_RandomAccessIterator2 __first,
               _RandomAccessIterator2 __last) const {
      const auto &__pred = this->_M_pred();
      auto __patlen = _M_pat_end - _M_pat;
      if (__patlen == 0)
        return std::make_pair(__first, __first);
      auto __len = __last - __first;
      while (__len >= __patlen) {
        for (auto __scan = __patlen - 1;
             __pred(__first[__scan], _M_pat[__scan]); --__scan)
          if (__scan == 0)
            return std::make_pair(__first, __first + __patlen);
        auto __shift = _M_bad_char_shift(__first[__patlen - 1]);
        __len -= __shift;
        __first += __shift;
      }
      return std::make_pair(__last, __last);
    }

  private:
    template <typename _Tp> __diff_type _M_bad_char_shift(_Tp __c) const {
      return this->_M_lookup(__c, _M_pat_end - _M_pat);
    }

    _RAIter _M_pat;
    _RAIter _M_pat_end;
  };

  template <typename _RAIter, typename _Hash, typename _BinaryPredicate>
  boyer_moore_searcher<_RAIter, _Hash, _BinaryPredicate>::boyer_moore_searcher(
      _RAIter __pat, _RAIter __pat_end, _Hash __hf, _BinaryPredicate __pred)
      : _Base(__pat, __pat_end - __pat, std::move(__hf), std::move(__pred)),
        _M_pat(__pat), _M_pat_end(__pat_end),
        _M_good_suffix(__pat_end - __pat) {
    auto __patlen = __pat_end - __pat;
    if (__patlen == 0)
      return;
    __diff_type __last_prefix = __patlen - 1;
    for (__diff_type __p = __patlen - 1; __p >= 0; --__p) {
      if (_M_is_prefix(__pat, __patlen, __p + 1))
        __last_prefix = __p + 1;
      _M_good_suffix[__p] = __last_prefix + (__patlen - 1 - __p);
    }
    for (__diff_type __p = 0; __p < __patlen - 1; ++__p) {
      auto __slen = _M_suffix_length(__pat, __patlen, __p);
      auto __pos = __patlen - 1 - __slen;
      if (!__pred(__pat[__p - __slen], __pat[__pos]))
        _M_good_suffix[__pos] = __patlen - 1 - __p + __slen;
    }
  }

  template <typename _RAIter, typename _Hash, typename _BinaryPredicate>
  template <typename _RandomAccessIterator2>
  pair<_RandomAccessIterator2, _RandomAccessIterator2>
  boyer_moore_searcher<_RAIter, _Hash, _BinaryPredicate>::operator()(
      _RandomAccessIterator2 __first, _RandomAccessIterator2 __last) const {
    auto __patlen = _M_pat_end - _M_pat;
    if (__patlen == 0)
      return std::make_pair(__first, __first);
    const auto &__pred = this->_M_pred();
    __diff_type __i = __patlen - 1;
    auto __stringlen = __last - __first;
    while (__i < __stringlen) {
      __diff_type __j = __patlen - 1;
      while (__j >= 0 && __pred(__first[__i], _M_pat[__j])) {
        --__i;
        --__j;
      }
      if (__j < 0) {
        const auto __match = __first + __i + 1;
        return std::make_pair(__match, __match + __patlen);
      }
      __i += std::max(_M_bad_char_shift(__first[__i]), _M_good_suffix[__j]);
    }
    return std::make_pair(__last, __last);
  }

} // namespace std
# 28 "./../stdexec/include/stdexec/__detail/__env.hpp" 2

#pragma GCC diagnostic push
# 31 "./../stdexec/include/stdexec/__detail/__env.hpp"
#pragma GCC diagnostic ignored "-Wpragmas"
# 31 "./../stdexec/include/stdexec/__detail/__env.hpp"
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
# 31 "./../stdexec/include/stdexec/__detail/__env.hpp"
#pragma GCC diagnostic ignored "-Wunknown-warning-option"
# 31 "./../stdexec/include/stdexec/__detail/__env.hpp"
#pragma GCC diagnostic ignored "-Wunknown-attributes"
# 31 "./../stdexec/include/stdexec/__detail/__env.hpp"
#pragma GCC diagnostic ignored "-Wattributes"

namespace stdexec {

template <class T>
concept queryable = destructible<T>;

template <class Tag> struct __query {
  template <class Sig> static inline constexpr Tag (*signature)(Sig) = nullptr;
};

namespace __queries {
template <class _Tp>
concept __is_bool_constant = requires { typename __mbool<_Tp::value>; };

struct forwarding_query_t {
  template <class _Query>
  consteval auto operator()(_Query __query) const noexcept -> bool {
    if constexpr (tag_invocable<forwarding_query_t, _Query>) {
      using __result_t = tag_invoke_result_t<forwarding_query_t, _Query>;

      if constexpr (__is_bool_constant<__result_t>) {
        return __result_t::value;
      } else {
        return tag_invoke(*this, static_cast<_Query &&>(__query));
      }
    } else if constexpr (derived_from<_Query, forwarding_query_t>) {
      return true;
    } else {
      return false;
    }
  }
};

struct query_or_t {
  template <class _Query, class _Queryable, class _Default>
  constexpr auto operator()(_Query, _Queryable &&, _Default &&__default) const
      noexcept(__nothrow_constructible_from<_Default, _Default &&>)
          -> _Default {
    return static_cast<_Default &&>(__default);
  }

  template <class _Query, class _Queryable, class _Default>
    requires __callable<_Query, _Queryable>
  constexpr auto operator()(_Query __query, _Queryable &&__queryable,
                            _Default &&) const
      noexcept(__nothrow_callable<_Query, _Queryable>)
          -> __call_result_t<_Query, _Queryable> {
    return static_cast<_Query &&>(__query)(
        static_cast<_Queryable &&>(__queryable));
  }
};

struct execute_may_block_caller_t : __query<execute_may_block_caller_t> {
  template <class _Tp>
    requires tag_invocable<execute_may_block_caller_t, __cref_t<_Tp>>
  constexpr auto operator()(_Tp &&__t) const noexcept -> bool {
    static_assert(same_as<bool, tag_invoke_result_t<execute_may_block_caller_t,
                                                    __cref_t<_Tp>>>);
    static_assert(
        nothrow_tag_invocable<execute_may_block_caller_t, __cref_t<_Tp>>);
    return tag_invoke(execute_may_block_caller_t{}, std::as_const(__t));
  }

  constexpr auto operator()(auto &&) const noexcept -> bool { return true; }
};

struct get_forward_progress_guarantee_t
    : __query<get_forward_progress_guarantee_t> {
  template <class _Tp>
    requires tag_invocable<get_forward_progress_guarantee_t, __cref_t<_Tp>>
  constexpr auto operator()(_Tp &&__t) const noexcept(
      nothrow_tag_invocable<get_forward_progress_guarantee_t, __cref_t<_Tp>>)
      -> __decay_t<tag_invoke_result_t<get_forward_progress_guarantee_t,
                                       __cref_t<_Tp>>> {
    return tag_invoke(get_forward_progress_guarantee_t{}, std::as_const(__t));
  }

  constexpr auto
  operator()(auto &&) const noexcept -> stdexec::forward_progress_guarantee {
    return stdexec::forward_progress_guarantee::weakly_parallel;
  }
};

template <class _T0>
concept __allocator_c = true;

struct get_scheduler_t : __query<get_scheduler_t> {
  static constexpr auto query(forwarding_query_t) noexcept -> bool {
    return true;
  }

  template <class _Env>
    requires tag_invocable<get_scheduler_t, const _Env &>
  auto operator()(const _Env &__env) const noexcept
      -> tag_invoke_result_t<get_scheduler_t, const _Env &>;

  template <class _Tag = get_scheduler_t> auto operator()() const noexcept;
};

struct get_delegation_scheduler_t : __query<get_delegation_scheduler_t> {
  static constexpr auto query(forwarding_query_t) noexcept -> bool {
    return true;
  }

  template <class _Env>
    requires tag_invocable<get_delegation_scheduler_t, const _Env &>
  auto operator()(const _Env &__t) const noexcept
      -> tag_invoke_result_t<get_delegation_scheduler_t, const _Env &>;

  template <class _Tag = get_delegation_scheduler_t>
  auto operator()() const noexcept;
};

struct get_allocator_t : __query<get_allocator_t> {
  static constexpr auto query(forwarding_query_t) noexcept -> bool {
    return true;
  }

  template <class _Env>
    requires tag_invocable<get_allocator_t, const _Env &>
  auto operator()(const _Env &__env) const noexcept
      -> tag_invoke_result_t<get_allocator_t, const _Env &> {
    static_assert(nothrow_tag_invocable<get_allocator_t, const _Env &>);
    static_assert(
        __allocator_c<tag_invoke_result_t<get_allocator_t, const _Env &>>);
    return tag_invoke(get_allocator_t{}, __env);
  }

  template <class _Tag = get_allocator_t> auto operator()() const noexcept;
};

struct get_stop_token_t : __query<get_stop_token_t> {
  static constexpr auto query(forwarding_query_t) noexcept -> bool {
    return true;
  }

  template <class _Env, class _Token = never_stop_token>
  auto operator()(const _Env &) const noexcept -> _Token {
    return {};
  }

  template <class _Env, class = void>
    requires tag_invocable<get_stop_token_t, const _Env &>
  auto operator()(const _Env &__env) const noexcept
      -> tag_invoke_result_t<get_stop_token_t, const _Env &> {
    static_assert(nothrow_tag_invocable<get_stop_token_t, const _Env &>);
    static_assert(
        stoppable_token<
            __decay_t<tag_invoke_result_t<get_stop_token_t, const _Env &>>>);
    return tag_invoke(get_stop_token_t{}, __env);
  }

  template <class _Tag = get_stop_token_t> auto operator()() const noexcept;
};

template <class _Queryable, class _Tag>
concept __has_completion_scheduler_for =
    queryable<_Queryable> &&
    tag_invocable<get_completion_scheduler_t<_Tag>, const _Queryable &>;

template <__completion_tag _Tag>
struct get_completion_scheduler_t : __query<get_completion_scheduler_t<_Tag>> {
  static constexpr auto query(forwarding_query_t) noexcept -> bool {
    return true;
  }

  template <__has_completion_scheduler_for<_Tag> _Queryable>
  auto operator()(const _Queryable &__queryable) const noexcept
      -> tag_invoke_result_t<get_completion_scheduler_t<_Tag>,
                             const _Queryable &>;
};

struct get_domain_t {
  template <class _Ty>
    requires tag_invocable<get_domain_t, const _Ty &>
  constexpr auto operator()(const _Ty &) const noexcept
      -> __decay_t<tag_invoke_result_t<get_domain_t, const _Ty &>> {
    static_assert(nothrow_tag_invocable<get_domain_t, const _Ty &>,
                  "Customizations of get_domain must be noexcept.");
    static_assert(
        __class<__decay_t<tag_invoke_result_t<get_domain_t, const _Ty &>>>,
        "Customizations of get_domain must return a class type.");
    return {};
  }

  static constexpr auto query(forwarding_query_t) noexcept -> bool {
    return true;
  }
};

struct get_domain_late_t {
  template <class _Ty>
    requires tag_invocable<get_domain_late_t, const _Ty &>
  constexpr auto operator()(const _Ty &) const noexcept
      -> __decay_t<tag_invoke_result_t<get_domain_late_t, const _Ty &>> {
    static_assert(nothrow_tag_invocable<get_domain_late_t, const _Ty &>,
                  "Customizations of get_domain_late must be noexcept.");
    static_assert(
        __class<__decay_t<tag_invoke_result_t<get_domain_late_t, const _Ty &>>>,
        "Customizations of get_domain_late must return a class type.");
    return {};
  }

  static constexpr auto query(forwarding_query_t) noexcept -> bool {
    return false;
  }
};

struct __is_scheduler_affine_t {
  template <class _Env> constexpr auto operator()(const _Env &) const noexcept {
    if constexpr (tag_invocable<__is_scheduler_affine_t, const _Env &>) {
      using _Result =
          __decay_t<tag_invoke_result_t<__is_scheduler_affine_t, const _Env &>>;
      static_assert(__same_as<decltype(__v<_Result>), const bool>);
      return _Result();
    } else {
      return std::false_type();
    }
  }

  static constexpr auto query(forwarding_query_t) noexcept -> bool {
    return false;
  }
};

struct __root_t {
  template <class _Env>
    requires tag_invocable<__root_t, const _Env &>
  constexpr auto operator()(const _Env &__env) const noexcept -> bool {
    do {
      static_assert(noexcept(tag_invoke(__root_t{}, __env) == true));
      (static_cast<bool>(tag_invoke(__root_t{}, __env) == true)
           ? void(0)
           : __assert_fail("tag_invoke(__root_t{}, __env) == true",
                           __builtin_FILE(), __builtin_LINE(),
                           __extension__ __PRETTY_FUNCTION__));
    } while (false);
    return true;
  }

  static constexpr auto query(forwarding_query_t) noexcept -> bool {
    return false;
  }
};

struct __root_env {
  using __t = __root_env;
  using __id = __root_env;

  constexpr friend auto tag_invoke(const __root_t &,
                                   const __root_env &) noexcept -> bool {
    return true;
  }
};
} // namespace __queries

using __queries::execute_may_block_caller_t;
using __queries::forwarding_query_t;
using __queries::get_allocator_t;
using __queries::get_delegation_scheduler_t;
using __queries::get_forward_progress_guarantee_t;
using __queries::get_scheduler_t;
using __queries::query_or_t;
using get_delegatee_scheduler_t [[deprecated(
    "get_delegatee_scheduler_t has been renamed get_delegation_scheduler_t")]] =
    get_delegation_scheduler_t;
using __queries::__is_scheduler_affine_t;
using __queries::__root_env;
using __queries::__root_t;
using __queries::get_completion_scheduler_t;
using __queries::get_domain_late_t;
using __queries::get_domain_t;
using __queries::get_stop_token_t;

inline constexpr forwarding_query_t forwarding_query{};
inline constexpr query_or_t query_or{};
inline constexpr execute_may_block_caller_t execute_may_block_caller{};
inline constexpr get_forward_progress_guarantee_t
    get_forward_progress_guarantee{};
inline constexpr get_scheduler_t get_scheduler{};
inline constexpr get_delegation_scheduler_t get_delegation_scheduler{};
inline constexpr auto &get_delegatee_scheduler [[deprecated(
    "get_delegatee_scheduler has been renamed get_delegation_scheduler")]]
= get_delegation_scheduler;
inline constexpr get_allocator_t get_allocator{};
inline constexpr get_stop_token_t get_stop_token{};

template <__completion_tag _Tag>
inline constexpr get_completion_scheduler_t<_Tag> get_completion_scheduler{};
# 328 "./../stdexec/include/stdexec/__detail/__env.hpp"
template <class _Tag>
concept __forwarding_query = forwarding_query(_Tag{});

inline constexpr get_domain_t get_domain{};
inline constexpr get_domain_late_t get_domain_late{};

template <class _Tag, class _Queryable, class _Default>
using __query_result_or_t =
    __call_result_t<query_or_t, _Tag, _Queryable, _Default>;

namespace __env {

template <class _Env> struct __promise {
  template <class _Ty> auto await_transform(_Ty &&__value) noexcept -> _Ty && {
    return static_cast<_Ty &&>(__value);
  }

  template <class _Ty>
    requires tag_invocable<as_awaitable_t, _Ty, __promise &>
  auto await_transform(_Ty &&__value) noexcept(
      nothrow_tag_invocable<as_awaitable_t, _Ty, __promise &>)
      -> tag_invoke_result_t<as_awaitable_t, _Ty, __promise &> {
    return tag_invoke(as_awaitable, static_cast<_Ty &&>(__value), *this);
  }

  auto get_env() const noexcept -> const _Env &;
};

template <class _Env, class _Query, class... _Args>
concept __queryable = tag_invocable<_Query, const _Env &, _Args...>;

template <class _Env, class _Query, class... _Args>
concept __nothrow_queryable =
    nothrow_tag_invocable<_Query, const _Env &, _Args...>;

template <class _Env, class _Query, class... _Args>
using __query_result_t = tag_invoke_result_t<_Query, const _Env &, _Args...>;

template <class _Query, class _Value> struct prop {
  using __t = prop;
  using __id = prop;

  [[no_unique_address]] _Query __query;

  [[no_unique_address]] _Value __value;

  [[nodiscard]] constexpr auto query(_Query) const noexcept -> const _Value & {
    return __value;
  }
};

template <class _Query, class _Value>

prop(_Query, _Value) -> prop<_Query, std::unwrap_reference_t<_Value>>;

template <class... _Envs> struct env {
  using __t = env;
  using __id = env;

  __tuple_for<_Envs...> __tup_;

  template <class _Query, class... _Args>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static constexpr auto
  __get_1st(const env &__self) noexcept -> decltype(auto) {

    constexpr bool __flags[] = {__queryable<_Envs, _Query, _Args...>...};
    constexpr std::size_t __idx = __pos_of(__flags, __flags + sizeof...(_Envs));
    return __self.__tup_.template __get<__idx>(__self.__tup_);
  }

  template <class _Query, class... _Args>
  using __1st_env_t =
      decltype(env::__get_1st<_Query, _Args...>(__declval<const env &>()));

  template <class _Query, class... _Args>
    requires(__queryable<_Envs, _Query, _Args...> || ...)
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr auto
  query(_Query __q, _Args &&...__args) const noexcept(
      __nothrow_queryable<__1st_env_t<_Query, _Args...>, _Query, _Args...>)
      -> decltype(auto) {
    return tag_invoke(__q, env::__get_1st<_Query, _Args...>(*this),
                      static_cast<_Args &&>(__args)...);
  }
};

template <class _Env0, class _Env1> struct env<_Env0, _Env1> {
  using __t = env;
  using __id = env;

  [[no_unique_address]] _Env0 __env0_;
  [[no_unique_address]] _Env1 __env1_;

  template <class _Query, class... _Args>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static constexpr auto
  __get_1st(const env &__self) noexcept -> decltype(auto) {
    if constexpr (__queryable<_Env0, _Query, _Args...>) {
      return (__self.__env0_);
    } else {
      return (__self.__env1_);
    }
  }

  template <class _Query, class... _Args>
  using __1st_env_t =
      decltype(env::__get_1st<_Query, _Args...>(__declval<const env &>()));

  template <class _Query, class... _Args>
    requires __queryable<_Env0, _Query, _Args...> ||
                 __queryable<_Env1, _Query, _Args...>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr auto
  query(_Query __q, _Args &&...__args) const noexcept(
      __nothrow_queryable<__1st_env_t<_Query, _Args...>, _Query, _Args...>)
      -> decltype(auto) {
    return tag_invoke(__q, env::__get_1st<_Query, _Args...>(*this),
                      static_cast<_Args &&>(__args)...);
  }
};

template <class... _Envs>
env(_Envs...) -> env<std::unwrap_reference_t<_Envs>...>;

template <class _Value, class _Tag, class... _Tags> struct __with {
  using __t = __with;
  using __id = __with;
  [[no_unique_address]] _Value __value_;

  __with() = default;

  constexpr explicit __with(_Value __value) noexcept(
      __nothrow_decay_copyable<_Value>)
      : __value_(static_cast<_Value &&>(__value)) {}

  constexpr explicit __with(_Value __value, _Tag,
                            _Tags...) noexcept(__nothrow_decay_copyable<_Value>)
      : __value_(static_cast<_Value &&>(__value)) {}

  template <__one_of<_Tag, _Tags...> _Key>
  auto query(_Key) const noexcept -> const _Value & {
    return __value_;
  }
};

template <class _Value, class _Tag, class... _Tags>
__with(_Value, _Tag, _Tags...) -> __with<_Value, _Tag, _Tags...>;

template <class _Env> struct __fwd_base {
  using __fwd_env_t = _Env;
};

template <class _EnvId> struct __fwd {
  using _Env = __cvref_t<_EnvId>;
  static_assert(__nothrow_move_constructible<_Env>);

  struct __t : __fwd_base<_Env> {
    using __id = __fwd;
    [[no_unique_address]] _Env __env_;

    using __cvref_env_t = const _Env &;

    template <__forwarding_query _Tag>
      requires tag_invocable<_Tag, __cvref_env_t>
    auto query(_Tag) const noexcept(nothrow_tag_invocable<_Tag, __cvref_env_t>)
        -> tag_invoke_result_t<_Tag, __cvref_env_t> {
      return tag_invoke(_Tag(), __env_);
    }
  };
};

template <class _Env>
concept __is_fwd_env = same_as<_Env, typename _Env::__fwd_env_t>;

struct __fwd_fn {
  template <class _Env> auto operator()(_Env &&__env) const -> decltype(auto) {
    if constexpr (__is_fwd_env<__decay_t<_Env>>) {
      return static_cast<_Env>(static_cast<_Env &&>(__env));
    } else {
      return __t<__fwd<__cvref_id<_Env>>>{{}, static_cast<_Env &&>(__env)};
    }
  }

  auto operator()(env<>) const -> env<> { return {}; }
};

template <class _Env> using __fwd_env_t = __call_result_t<__fwd_fn, _Env>;

template <class _EnvId, class _Tag> struct __without_ {
  using _Env = __cvref_t<_EnvId>;
  static_assert(__nothrow_move_constructible<_Env>);

  struct __t {
    using __id = __without_;
    _Env __env_;

    using __cvref_env_t = const _Env &;

    auto query(_Tag) const noexcept = delete;

    template <tag_invocable<__cvref_env_t> _Key>
    __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
    query(_Key) const
        noexcept(nothrow_tag_invocable<_Key, __cvref_env_t>) -> decltype(auto) {
      return tag_invoke(_Key(), __env_);
    }
  };
};

struct __without_fn {
  template <class _Env, class _Tag>
  constexpr auto operator()(_Env &&__env,
                            _Tag) const noexcept -> decltype(auto) {
    if constexpr (tag_invocable<_Tag, _Env>) {
      using _Without = __t<__without_<__cvref_id<_Env>, _Tag>>;
      return _Without{static_cast<_Env &&>(__env)};
    } else {
      return static_cast<_Env>(static_cast<_Env &&>(__env));
    }
  }
};

inline constexpr __without_fn __without{};

template <class _Env, class _Tag, class... _Tags>
using __without_t = __result_of<__without, _Env, _Tag, _Tags...>;

template <__nothrow_move_constructible _Fun> struct __from {
  using __t = __from;
  using __id = __from;
  [[no_unique_address]] _Fun __fun_;

  template <class _Tag>
    requires __callable<const _Fun &, _Tag>
  auto query(_Tag) const noexcept(__nothrow_callable<const _Fun &, _Tag>)
      -> __call_result_t<const _Fun &, _Tag> {
    return __fun_(_Tag());
  }
};

template <class _Fun> __from(_Fun) -> __from<_Fun>;

struct __join_fn {
  auto operator()(env<>, env<>) const noexcept -> env<> { return {}; }

  template <class _Env>
  auto operator()(_Env &&__env, env<> = {}) const noexcept -> _Env {
    return static_cast<_Env &&>(__env);
  }

  template <class _Env>
  auto operator()(env<>, _Env &&__env) const noexcept -> decltype(auto) {
    return __fwd_fn()(static_cast<_Env &&>(__env));
  }

  template <class _First, class _Second>
  auto operator()(_First &&__first, _Second &&__second) const noexcept
      -> env<_First, __fwd_env_t<_Second>> {
    return {static_cast<_First &&>(__first),
            __fwd_fn()(static_cast<_Second &&>(__second))};
  }
};

inline constexpr __join_fn __join{};

template <class _First, class... _Second>
using __join_env_t = __result_of<__join, _First, _Second...>;

struct __as_root_env_fn {
  template <class _Env>
  constexpr auto operator()(_Env __env) const noexcept
      -> __join_env_t<__root_env, std::unwrap_reference_t<_Env>> {
    return __join(__root_env{},
                  static_cast<std::unwrap_reference_t<_Env> &&>(__env));
  }
};

inline constexpr __as_root_env_fn __as_root_env{};

template <class _Env> using __as_root_env_t = __result_of<__as_root_env, _Env>;
} // namespace __env

using __env::__fwd_env_t;
using __env::__join_env_t;

namespace __get_env {

struct get_env_t {
  template <__same_as<get_env_t> _Self, class _EnvProvider>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline friend auto
  tag_invoke(_Self, const _EnvProvider &__env_provider) noexcept
      -> decltype(__env_provider.get_env()) {
    static_assert(noexcept(__env_provider.get_env()),
                  "get_env() members must be noexcept");
    return __env_provider.get_env();
  }

  template <class _EnvProvider>
    requires tag_invocable<get_env_t, const _EnvProvider &>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr auto
  operator()(const _EnvProvider &__env_provider) const noexcept
      -> tag_invoke_result_t<get_env_t, const _EnvProvider &> {
    static_assert(
        queryable<tag_invoke_result_t<get_env_t, const _EnvProvider &>>);
    static_assert(nothrow_tag_invocable<get_env_t, const _EnvProvider &>);
    return tag_invoke(*this, __env_provider);
  }

  template <class _EnvProvider>
  constexpr auto operator()(const _EnvProvider &) const noexcept -> env<> {
    return {};
  }
};
} // namespace __get_env

using __get_env::get_env_t;
inline constexpr get_env_t get_env{};

template <class _EnvProvider>
concept environment_provider = requires(_EnvProvider &__ep) {
  { get_env(std::as_const(__ep)) } -> queryable;
};

template <class _Scheduler, class _LateDomain = __none_such>
struct __sched_attrs {
  using __t = __sched_attrs;
  using __id = __sched_attrs;

  using __scheduler_t = __decay_t<_Scheduler>;
  using __sched_domain_t =
      __query_result_or_t<get_domain_t, __scheduler_t, default_domain>;
  _Scheduler __sched_;
  [[no_unique_address]] _LateDomain __late_domain_;

  auto query(get_completion_scheduler_t<set_value_t>) const noexcept
      -> __scheduler_t {
    return __sched_;
  }

  constexpr auto query(get_domain_t) const noexcept -> __sched_domain_t {
    return {};
  }

  constexpr auto query(get_domain_late_t) const noexcept -> _LateDomain
    requires(!same_as<_LateDomain, __none_such>)
  {
    return {};
  }
};

template <class _Scheduler, class _LateDomain = __none_such>
__sched_attrs(_Scheduler, _LateDomain = {})
    -> __sched_attrs<std::unwrap_reference_t<_Scheduler>, _LateDomain>;

template <class _Scheduler> struct __sched_env {
  using __t = __sched_env;
  using __id = __sched_env;

  using __scheduler_t = __decay_t<_Scheduler>;
  _Scheduler __sched_;

  auto query(get_scheduler_t) const noexcept -> __scheduler_t {
    return __sched_;
  }

  template <class _Sched = _Scheduler>
  auto query(get_domain_t) const noexcept -> __domain_of_t<_Sched> {
    return get_domain(__sched_);
  }
};

template <class _Scheduler>
__sched_env(_Scheduler) -> __sched_env<std::unwrap_reference_t<_Scheduler>>;

using __env::__as_root_env;
using __env::__as_root_env_t;

template <class _Env>
concept __is_root_env = requires(_Env &&__env) {
  { __root_t{}(__env) } -> same_as<bool>;
};

template <class _Sender>
concept __is_scheduler_affine = requires {
  requires __v<__call_result_t<__is_scheduler_affine_t, env_of_t<_Sender>>>;
};
} // namespace stdexec

#pragma GCC diagnostic pop
# 23 "./../stdexec/include/stdexec/__detail/__receivers.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/../functional.hpp" 1
# 21 "./../stdexec/include/stdexec/__detail/../functional.hpp"
# 1 "./../stdexec/include/stdexec/__detail/../concepts.hpp" 1
# 22 "./../stdexec/include/stdexec/__detail/../functional.hpp" 2

namespace stdexec {
template <class _Fun0, class _Fun1> struct __composed {
  [[no_unique_address]] _Fun0 __t0_;
  [[no_unique_address]] _Fun1 __t1_;

  template <class... _Ts>
    requires __callable<_Fun1, _Ts...> &&
                 __callable<_Fun0, __call_result_t<_Fun1, _Ts...>>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Ts &&...__ts)
      && -> __call_result_t<_Fun0, __call_result_t<_Fun1, _Ts...>> {
    return static_cast<_Fun0 &&>(__t0_)(
        static_cast<_Fun1 &&>(__t1_)(static_cast<_Ts &&>(__ts)...));
  }

  template <class... _Ts>
    requires __callable<const _Fun1 &, _Ts...> &&
                 __callable<const _Fun0 &,
                            __call_result_t<const _Fun1 &, _Ts...>>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Ts &&...__ts)
      const & -> __call_result_t<_Fun0, __call_result_t<_Fun1, _Ts...>> {
    return __t0_(__t1_(static_cast<_Ts &&>(__ts)...));
  }
};

inline constexpr struct __compose_t {
  template <class _Fun0, class _Fun1>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Fun0 __fun0, _Fun1 __fun1) const -> __composed<_Fun0, _Fun1> {
    return {static_cast<_Fun0 &&>(__fun0), static_cast<_Fun1 &&>(__fun1)};
  }
} __compose{};

namespace __invoke_ {
template <class> inline constexpr bool __is_refwrap = false;
template <class _Up>
inline constexpr bool __is_refwrap<std::reference_wrapper<_Up>> = true;

struct __funobj {
  template <class _Fun, class... _Args>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr auto
  operator()(_Fun &&__fun, _Args &&...__args) const noexcept(
      noexcept((static_cast<_Fun &&>(__fun))(static_cast<_Args &&>(__args)...)))
      -> decltype((static_cast<_Fun &&>(__fun))(
          static_cast<_Args &&>(__args)...)) {
    return static_cast<_Fun &&>(__fun)(static_cast<_Args &&>(__args)...);
  }
};

struct __memfn {
  template <class _Memptr, class _Ty, class... _Args>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr auto
  operator()(_Memptr __mem_ptr, _Ty &&__ty, _Args &&...__args) const
      noexcept(noexcept(((static_cast<_Ty &&>(__ty)).*
                         __mem_ptr)(static_cast<_Args &&>(__args)...)))
          -> decltype(((static_cast<_Ty &&>(__ty)).*
                       __mem_ptr)(static_cast<_Args &&>(__args)...)) {
    return ((static_cast<_Ty &&>(__ty)).*
            __mem_ptr)(static_cast<_Args &&>(__args)...);
  }
};

struct __memfn_refwrap {
  template <class _Memptr, class _Ty, class... _Args>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr auto
  operator()(_Memptr __mem_ptr, _Ty __ty, _Args &&...__args) const noexcept(
      noexcept((__ty.get().*__mem_ptr)(static_cast<_Args &&>(__args)...)))
      -> decltype((__ty.get().*__mem_ptr)(static_cast<_Args &&>(__args)...)) {
    return (__ty.get().*__mem_ptr)(static_cast<_Args &&>(__args)...);
  }
};

struct __memfn_smartptr {
  template <class _Memptr, class _Ty, class... _Args>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr auto
  operator()(_Memptr __mem_ptr, _Ty &&__ty, _Args &&...__args) const
      noexcept(noexcept(((*static_cast<_Ty &&>(__ty)).*
                         __mem_ptr)(static_cast<_Args &&>(__args)...)))
          -> decltype(((*static_cast<_Ty &&>(__ty)).*
                       __mem_ptr)(static_cast<_Args &&>(__args)...)) {
    return ((*static_cast<_Ty &&>(__ty)).*
            __mem_ptr)(static_cast<_Args &&>(__args)...);
  }
};

struct __memobj {
  template <class _Mbr, class _Class, class _Ty>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr auto
  operator()(_Mbr _Class::*__mem_ptr, _Ty &&__ty) const noexcept
      -> decltype(((static_cast<_Ty &&>(__ty)).*__mem_ptr)) {
    return ((static_cast<_Ty &&>(__ty)).*__mem_ptr);
  }
};

struct __memobj_refwrap {
  template <class _Mbr, class _Class, class _Ty>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr auto
  operator()(_Mbr _Class::*__mem_ptr,
             _Ty __ty) const noexcept -> decltype((__ty.get().*__mem_ptr)) {
    return (__ty.get().*__mem_ptr);
  }
};

struct __memobj_smartptr {
  template <class _Mbr, class _Class, class _Ty>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr auto
  operator()(_Mbr _Class::*__mem_ptr, _Ty &&__ty) const noexcept
      -> decltype(((*static_cast<_Ty &&>(__ty)).*__mem_ptr)) {
    return ((*static_cast<_Ty &&>(__ty)).*__mem_ptr);
  }
};

auto __invoke_selector(__ignore, __ignore) noexcept -> __funobj;

template <class _Mbr, class _Class, class _Ty>

auto __invoke_selector(_Mbr _Class::*, const _Ty &) noexcept {
  if constexpr (__is_function(_Mbr)) {

    if constexpr (__is_base_of(_Class, _Ty)) {
      return __memfn{};
    } else if constexpr (__is_refwrap<_Ty>) {
      return __memfn_refwrap{};
    } else {
      return __memfn_smartptr{};
    }
  } else {

    if constexpr (__is_base_of(_Class, _Ty)) {
      return __memobj{};
    } else if constexpr (__is_refwrap<_Ty>) {
      return __memobj_refwrap{};
    } else {
      return __memobj_smartptr{};
    }
  }
}

struct __invoke_t {
  template <class _Fun>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr auto
  operator()(_Fun &&__fun) const
      noexcept(noexcept(static_cast<_Fun &&>(__fun)()))
          -> decltype(static_cast<_Fun &&>(__fun)()) {
    return static_cast<_Fun &&>(__fun)();
  }

  template <class _Fun, class _Ty, class... _Args>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr auto
  operator()(_Fun &&__fun, _Ty &&__ty, _Args &&...__args) const
      noexcept(noexcept(__invoke_::__invoke_selector(__fun, __ty)(
          static_cast<_Fun &&>(__fun), static_cast<_Ty &&>(__ty),
          static_cast<_Args &&>(__args)...)))
          -> decltype(__invoke_::__invoke_selector(__fun, __ty)(
              static_cast<_Fun &&>(__fun), static_cast<_Ty &&>(__ty),
              static_cast<_Args &&>(__args)...)) {
    return decltype(__invoke_::__invoke_selector(__fun, __ty))()(
        static_cast<_Fun &&>(__fun), static_cast<_Ty &&>(__ty),
        static_cast<_Args &&>(__args)...);
  }
};
} // namespace __invoke_

inline constexpr __invoke_::__invoke_t __invoke{};

template <class _Fun, class... _As>
concept __invocable = requires(_Fun &&__f, _As &&...__as) {
  __invoke(static_cast<_Fun &&>(__f), static_cast<_As &&>(__as)...);
};

template <class _Fun, class... _As>
concept __nothrow_invocable =
    __invocable<_Fun, _As...> && requires(_Fun &&__f, _As &&...__as) {
      {
        __invoke(static_cast<_Fun &&>(__f), static_cast<_As &&>(__as)...)
      } noexcept;
    };

template <class _Fun, class... _As>
using __invoke_result_t =
    decltype(__invoke(__declval<_Fun>(), __declval<_As>()...));

namespace __apply_ {
using std::get;

template <std::size_t... _Is, class _Fn, class _Tup>
__attribute__((__always_inline__, __artificial__,
               __nodebug__)) inline constexpr auto
__impl(__indices<_Is...>, _Fn &&__fn, _Tup &&__tup) noexcept(noexcept(__invoke(
    static_cast<_Fn &&>(__fn), get<_Is>(static_cast<_Tup &&>(__tup))...)))
    -> decltype(__invoke(static_cast<_Fn &&>(__fn),
                         get<_Is>(static_cast<_Tup &&>(__tup))...)) {
  return __invoke(static_cast<_Fn &&>(__fn),
                  get<_Is>(static_cast<_Tup &&>(__tup))...);
}

template <class _Tup>
using __tuple_indices =
    __make_indices<std::tuple_size<std::remove_cvref_t<_Tup>>::value>;

template <class _Fn, class _Tup>
using __result_t = decltype(__apply_::__impl(
    __tuple_indices<_Tup>(), __declval<_Fn>(), __declval<_Tup>()));
} // namespace __apply_

template <class _Fn, class _Tup>
concept __applicable = __mvalid<__apply_::__result_t, _Fn, _Tup>;

template <class _Fn, class _Tup>
concept __nothrow_applicable =
    __applicable<_Fn, _Tup> &&
    noexcept(__apply_::__impl(__apply_::__tuple_indices<_Tup>(),
                              __declval<_Fn>(), __declval<_Tup>()));

template <class _Fn, class _Tup>
  requires __applicable<_Fn, _Tup>
using __apply_result_t = __apply_::__result_t<_Fn, _Tup>;

struct __apply_t {
  template <class _Fn, class _Tup>
    requires __applicable<_Fn, _Tup>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline constexpr auto
  operator()(_Fn &&__fn, _Tup &&__tup) const
      noexcept(__nothrow_applicable<_Fn, _Tup>) -> __apply_result_t<_Fn, _Tup> {
    return __apply_::__impl(__apply_::__tuple_indices<_Tup>(),
                            static_cast<_Fn &&>(__fn),
                            static_cast<_Tup &&>(__tup));
  }
};

inline constexpr __apply_t __apply{};
} // namespace stdexec
# 26 "./../stdexec/include/stdexec/__detail/__receivers.hpp" 2

namespace stdexec {

namespace __rcvrs {
template <class _Receiver, class... _As>
concept __set_value_member = requires(_Receiver &&__rcvr, _As &&...__args) {
  static_cast<_Receiver &&>(__rcvr).set_value(static_cast<_As &&>(__args)...);
};

struct set_value_t {
  template <class _Fn, class... _As> using __f = __minvoke<_Fn, _As...>;

  template <class _Receiver, class... _As>
    requires __set_value_member<_Receiver, _As...>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline friend void
  tag_invoke(set_value_t, _Receiver &&__rcvr, _As &&...__as) noexcept {
    static_assert(noexcept(static_cast<_Receiver &&>(__rcvr).set_value(
                      static_cast<_As &&>(__as)...)),
                  "set_value member functions must be noexcept");
    static_assert(
        __same_as<decltype(static_cast<_Receiver &&>(__rcvr).set_value(
                      static_cast<_As &&>(__as)...)),
                  void>,
        "set_value member functions must return void");
    static_cast<_Receiver &&>(__rcvr).set_value(static_cast<_As &&>(__as)...);
  }

  template <class _Receiver, class... _As>
    requires tag_invocable<set_value_t, _Receiver, _As...>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline void
  operator()(_Receiver &&__rcvr, _As &&...__as) const noexcept {
    static_assert(nothrow_tag_invocable<set_value_t, _Receiver, _As...>);
    (void)tag_invoke(stdexec::set_value_t{}, static_cast<_Receiver &&>(__rcvr),
                     static_cast<_As &&>(__as)...);
  }
};

template <class _Receiver, class _Error>
concept __set_error_member = requires(_Receiver &&__rcvr, _Error &&__err) {
  static_cast<_Receiver &&>(__rcvr).set_error(static_cast<_Error &&>(__err));
};

struct set_error_t {
  template <class _Fn, class... _Args>
    requires(sizeof...(_Args) == 1)
  using __f = __minvoke<_Fn, _Args...>;

  template <class _Receiver, class _Error>
    requires __set_error_member<_Receiver, _Error>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline friend void
  tag_invoke(set_error_t, _Receiver &&__rcvr, _Error &&__err) noexcept {
    static_assert(noexcept(static_cast<_Receiver &&>(__rcvr).set_error(
                      static_cast<_Error &&>(__err))),
                  "set_error member functions must be noexcept");
    static_assert(
        __same_as<decltype(static_cast<_Receiver &&>(__rcvr).set_error(
                      static_cast<_Error &&>(__err))),
                  void>,
        "set_error member functions must return void");
    static_cast<_Receiver &&>(__rcvr).set_error(static_cast<_Error &&>(__err));
  }

  template <class _Receiver, class _Error>
    requires tag_invocable<set_error_t, _Receiver, _Error>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline void
  operator()(_Receiver &&__rcvr, _Error &&__err) const noexcept {
    static_assert(nothrow_tag_invocable<set_error_t, _Receiver, _Error>);
    (void)tag_invoke(stdexec::set_error_t{}, static_cast<_Receiver &&>(__rcvr),
                     static_cast<_Error &&>(__err));
  }
};

template <class _Receiver>
concept __set_stopped_member = requires(_Receiver &&__rcvr) {
  static_cast<_Receiver &&>(__rcvr).set_stopped();
};

struct set_stopped_t {
  template <class _Fn, class... _Args>
    requires(sizeof...(_Args) == 0)
  using __f = __minvoke<_Fn, _Args...>;

  template <class _Receiver>
    requires __set_stopped_member<_Receiver>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline friend void
  tag_invoke(set_stopped_t, _Receiver &&__rcvr) noexcept {
    static_assert(noexcept(static_cast<_Receiver &&>(__rcvr).set_stopped()),
                  "set_stopped member functions must be noexcept");
    static_assert(
        __same_as<decltype(static_cast<_Receiver &&>(__rcvr).set_stopped()),
                  void>,
        "set_stopped member functions must return void");
    static_cast<_Receiver &&>(__rcvr).set_stopped();
  }

  template <class _Receiver>
    requires tag_invocable<set_stopped_t, _Receiver>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline void
  operator()(_Receiver &&__rcvr) const noexcept {
    static_assert(nothrow_tag_invocable<set_stopped_t, _Receiver>);
    (void)tag_invoke(stdexec::set_stopped_t{},
                     static_cast<_Receiver &&>(__rcvr));
  }
};
} // namespace __rcvrs

using __rcvrs::set_error_t;
using __rcvrs::set_stopped_t;
using __rcvrs::set_value_t;
inline constexpr set_value_t set_value{};
inline constexpr set_error_t set_error{};
inline constexpr set_stopped_t set_stopped{};

struct receiver_t {
  using receiver_concept = receiver_t;
};

namespace __detail {
template <class _Receiver>
concept __enable_receiver =
    (derived_from<typename _Receiver::receiver_concept, receiver_t>) ||
    requires { typename _Receiver::is_receiver; } ||
    __is_base_of(receiver_t, _Receiver);
} // namespace __detail

template <class _Receiver>
inline constexpr bool enable_receiver = __detail::__enable_receiver<_Receiver>;

template <class _Receiver>
concept receiver = enable_receiver<__decay_t<_Receiver>> &&
                   environment_provider<__cref_t<_Receiver>> &&
                   move_constructible<__decay_t<_Receiver>> &&
                   constructible_from<__decay_t<_Receiver>, _Receiver>;

namespace __detail {
template <class _Receiver, class _Tag, class... _Args>
auto __try_completion(_Tag (*)(_Args...))
    -> __mexception<_MISSING_COMPLETION_SIGNAL_<_Tag(_Args...)>,
                    _WITH_RECEIVER_<_Receiver>>;

template <class _Receiver, class _Tag, class... _Args>
  requires __callable<_Tag, _Receiver, _Args...>
auto __try_completion(_Tag (*)(_Args...)) -> __msuccess;

template <class _Receiver, class... _Sigs>
auto __try_completions(completion_signatures<_Sigs...> *)
    -> decltype((
        __msuccess(), ...,
        __detail::__try_completion<_Receiver>(static_cast<_Sigs *>(nullptr))));
} // namespace __detail

template <class _Receiver, class _Completions>
concept receiver_of =
    receiver<_Receiver> && requires(_Completions *__completions) {
      {
        __detail::__try_completions<__decay_t<_Receiver>>(__completions)
      } -> __ok;
    };

template <class _Receiver, class _Sender>
concept __receiver_from =
    receiver_of<_Receiver,
                __completion_signatures_of_t<_Sender, env_of_t<_Receiver>>>;

template <class _Receiver, class _Fun, class... _As>

void __set_value_invoke(_Receiver &&__rcvr, _Fun &&__fun,
                        _As &&...__as) noexcept {
  try {
    if constexpr (same_as<void, __invoke_result_t<_Fun, _As...>>) {
      __invoke(static_cast<_Fun &&>(__fun), static_cast<_As &&>(__as)...);
      stdexec::set_value(static_cast<_Receiver &&>(__rcvr));
    } else {
      set_value(
          static_cast<_Receiver &&>(__rcvr),
          __invoke(static_cast<_Fun &&>(__fun), static_cast<_As &&>(__as)...));
    }
  } catch (...) {
    if constexpr (!__nothrow_invocable<_Fun, _As...>) {
      stdexec::set_error(static_cast<_Receiver &&>(__rcvr),
                         std::current_exception());
    }
  }
}

template <class _Tag, class _Receiver>
auto __mk_completion_fn(_Tag, _Receiver &__rcvr) noexcept {
  return [&]<class... _Args>(_Args &&...__args) noexcept {
    _Tag()(static_cast<_Receiver &&>(__rcvr), static_cast<_Args &&>(__args)...);
  };
}
} // namespace stdexec
# 25 "./../stdexec/include/stdexec/__detail/__as_awaitable.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__senders.hpp" 1
# 22 "./../stdexec/include/stdexec/__detail/__senders.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__completion_signatures.hpp" 1
# 25 "./../stdexec/include/stdexec/__detail/__completion_signatures.hpp"
namespace stdexec {

namespace __sigs {
template <class... _Args>
inline constexpr bool __is_compl_sig<set_value_t(_Args...)> = true;
template <class _Error>
inline constexpr bool __is_compl_sig<set_error_t(_Error)> = true;
template <> inline constexpr bool __is_compl_sig<set_stopped_t()> = true;

template <class> inline constexpr bool __is_completion_signatures = false;
template <class... _Sigs>
inline constexpr bool
    __is_completion_signatures<completion_signatures<_Sigs...>> = true;
} // namespace __sigs

template <class... _Sigs> struct completion_signatures {};

template <class _Completions>
concept __valid_completion_signatures =
    __same_as<__ok_t<_Completions>, __msuccess> &&
    __sigs::__is_completion_signatures<_Completions>;

template <class _Sender, class... _Env>
using __unrecognized_sender_error =
    __mexception<_UNRECOGNIZED_SENDER_TYPE_<>, _WITH_SENDER_<_Sender>,
                 _WITH_ENVIRONMENT_<_Env>...>;
} // namespace stdexec
# 23 "./../stdexec/include/stdexec/__detail/__senders.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__connect_awaitable.hpp" 1
# 31 "./../stdexec/include/stdexec/__detail/__connect_awaitable.hpp"
namespace stdexec {

namespace __connect_awaitable_ {
struct __promise_base {
  auto initial_suspend() noexcept -> __coro::suspend_always { return {}; }

  [[noreturn]]
  auto final_suspend() noexcept -> __coro::suspend_always {
    std::terminate();
  }

  [[noreturn]]
  void unhandled_exception() noexcept {
    std::terminate();
  }

  [[noreturn]]
  void return_void() noexcept {
    std::terminate();
  }
};

struct __operation_base {
  __coro::coroutine_handle<> __coro_;

  explicit __operation_base(__coro::coroutine_handle<> __hcoro) noexcept
      : __coro_(__hcoro) {}

  __operation_base(__operation_base &&__other) noexcept
      : __coro_(std::exchange(__other.__coro_, {})) {}

  ~__operation_base() {
    if (__coro_) {
# 79 "./../stdexec/include/stdexec/__detail/__connect_awaitable.hpp"
      __coro_.destroy();
    }
  }

  void start() & noexcept { __coro_.resume(); }
};

template <class _ReceiverId> struct __promise;

template <class _ReceiverId> struct __operation {
  struct __t : __operation_base {
    using promise_type = stdexec::__t<__promise<_ReceiverId>>;
    using __operation_base::__operation_base;
  };
};

template <class _ReceiverId> struct __promise {
  using _Receiver = stdexec::__t<_ReceiverId>;

  struct __t : __promise_base {
    using __id = __promise;

    explicit __t(auto &, _Receiver &__rcvr) noexcept : __rcvr_(__rcvr) {}

    auto unhandled_stopped() noexcept -> __coro::coroutine_handle<> {
      stdexec::set_stopped(static_cast<_Receiver &&>(__rcvr_));

      return __coro::noop_coroutine();
    }

    auto
    get_return_object() noexcept -> stdexec::__t<__operation<_ReceiverId>> {
      return stdexec::__t<__operation<_ReceiverId>>{
          __coro::coroutine_handle<__t>::from_promise(*this)};
    }

    template <class _Awaitable>
    auto await_transform(_Awaitable &&__awaitable) noexcept -> _Awaitable && {
      return static_cast<_Awaitable &&>(__awaitable);
    }

    template <class _Awaitable>
      requires tag_invocable<as_awaitable_t, _Awaitable, __t &>
    auto await_transform(_Awaitable &&__awaitable) noexcept(
        nothrow_tag_invocable<as_awaitable_t, _Awaitable, __t &>)
        -> tag_invoke_result_t<as_awaitable_t, _Awaitable, __t &> {
      return tag_invoke(as_awaitable, static_cast<_Awaitable &&>(__awaitable),
                        *this);
    }

    auto get_env() const noexcept -> env_of_t<_Receiver> {
      return stdexec::get_env(__rcvr_);
    }

    _Receiver &__rcvr_;
  };
};

template <receiver _Receiver>
using __promise_t = __t<__promise<__id<_Receiver>>>;

template <receiver _Receiver>
using __operation_t = __t<__operation<__id<_Receiver>>>;

struct __connect_awaitable_t {
private:
  template <class _Fun, class... _Ts>
  static auto __co_call(_Fun __fun, _Ts &&...__as) noexcept {
    auto __fn = [&, __fun]() noexcept { __fun(static_cast<_Ts &&>(__as)...); };

    struct __awaiter {
      decltype(__fn) __fn_;

      static constexpr auto await_ready() noexcept -> bool { return false; }

      void await_suspend(__coro::coroutine_handle<>) noexcept { __fn_(); }

      [[noreturn]]
      void await_resume() noexcept {
        std::terminate();
      }
    };

    return __awaiter{__fn};
  }

  template <class _Awaitable, class _Receiver>

  static auto __co_impl(_Awaitable __awaitable,
                        _Receiver __rcvr) -> __operation_t<_Receiver> {
    using __result_t = __await_result_t<_Awaitable, __promise_t<_Receiver>>;
    std::exception_ptr __eptr;
    try {
      if constexpr (same_as<__result_t, void>)
        co_await (co_await static_cast<_Awaitable &&>(__awaitable),
                  __co_call(set_value, static_cast<_Receiver &&>(__rcvr)));
      else
        co_await __co_call(set_value, static_cast<_Receiver &&>(__rcvr),
                           co_await static_cast<_Awaitable &&>(__awaitable));
    } catch (...) {
      __eptr = std::current_exception();
    }
    co_await __co_call(set_error, static_cast<_Receiver &&>(__rcvr),
                       static_cast<std::exception_ptr &&>(__eptr));
  }

  template <receiver _Receiver, class _Awaitable>
  using __completions_t = completion_signatures<
      __minvoke<__mremove<void, __qf<set_value_t>>,
                __await_result_t<_Awaitable, __promise_t<_Receiver>>>,
      set_error_t(std::exception_ptr), set_stopped_t()>;

public:
  template <class _Receiver, __awaitable<__promise_t<_Receiver>> _Awaitable>
    requires receiver_of<_Receiver, __completions_t<_Receiver, _Awaitable>>
  auto operator()(_Awaitable &&__awaitable,
                  _Receiver __rcvr) const -> __operation_t<_Receiver> {
    return __co_impl(static_cast<_Awaitable &&>(__awaitable),
                     static_cast<_Receiver &&>(__rcvr));
  }
};
} // namespace __connect_awaitable_

using __connect_awaitable_::__connect_awaitable_t;

inline constexpr __connect_awaitable_t __connect_awaitable{};
} // namespace stdexec
# 25 "./../stdexec/include/stdexec/__detail/__senders.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__debug.hpp" 1
# 24 "./../stdexec/include/stdexec/__detail/__debug.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__senders_core.hpp" 1
# 24 "./../stdexec/include/stdexec/__detail/__senders_core.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__domain.hpp" 1
# 23 "./../stdexec/include/stdexec/__detail/__domain.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__sender_introspection.hpp" 1
# 20 "./../stdexec/include/stdexec/__detail/__sender_introspection.hpp"
namespace stdexec {
namespace __detail {

struct __get_data {
  template <class _Data>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(__ignore, _Data &&__data, auto &&...) const noexcept -> _Data && {
    return static_cast<_Data &&>(__data);
  }
};

struct __sexpr_apply_t {
  template <class _Sender, class _ApplyFn>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Sender &&__sndr, _ApplyFn &&__fun) const
      noexcept(noexcept(__sndr.apply(static_cast<_Sender &&>(__sndr),
                                     static_cast<_ApplyFn &&>(__fun))))
          -> decltype(__sndr.apply(static_cast<_Sender &&>(__sndr),
                                   static_cast<_ApplyFn &&>(__fun))) {
    return __sndr.apply(static_cast<_Sender &&>(__sndr),
                        static_cast<_ApplyFn &&>(__fun));
  }
};

template <class _Tag, class _Data, class... _Child> struct __desc {
  using __tag = _Tag;
  using __data = _Data;
  using __children = __types<_Child...>;

  template <class _Fn> using __f = __minvoke<_Fn, _Tag, _Data, _Child...>;
};

template <class _Fn> struct __sexpr_uncurry_fn {
  template <class _Tag, class _Data, class... _Child>
  constexpr auto operator()(_Tag, _Data &&, _Child &&...) const noexcept
      -> __minvoke<_Fn, _Tag, _Data, _Child...>;
};

template <class _CvrefSender, class _Fn>
using __sexpr_uncurry =
    __call_result_t<__sexpr_apply_t, _CvrefSender, __sexpr_uncurry_fn<_Fn>>;

template <class _Sender>
using __desc_of = __sexpr_uncurry<_Sender, __q<__desc>>;

using __get_desc = __sexpr_uncurry_fn<__q<__desc>>;
} // namespace __detail

using __detail::__sexpr_apply_t;
inline constexpr __sexpr_apply_t __sexpr_apply{};

template <class _Sender, class _ApplyFn>
using __sexpr_apply_result_t =
    __call_result_t<__sexpr_apply_t, _Sender, _ApplyFn>;

template <class _Sender>
using tag_of_t = typename __detail::__desc_of<_Sender>::__tag;

template <class _Sender>
using __data_of = typename __detail::__desc_of<_Sender>::__data;

template <class _Sender, class _Continuation = __q<__types>>
using __children_of =
    __mapply<_Continuation, typename __detail::__desc_of<_Sender>::__children>;

template <class _Ny, class _Sender>
using __nth_child_of = __children_of<_Sender, __mbind_front_q<__m_at, _Ny>>;

template <std::size_t _Ny, class _Sender>
using __nth_child_of_c =
    __children_of<_Sender, __mbind_front_q<__m_at, __msize_t<_Ny>>>;

template <class _Sender>
using __child_of = __children_of<_Sender, __q<__mfront>>;

template <class _Sender>
inline constexpr std::size_t __nbr_children_of =
    __v<__children_of<_Sender, __msize>>;

template <class _Tp>
  requires __mvalid<tag_of_t, _Tp>
struct __muncurry_<_Tp> {
  template <class _Fn> using __f = __detail::__sexpr_uncurry<_Tp, _Fn>;
};

template <class _Sender>
concept sender_expr = __mvalid<tag_of_t, _Sender>;

template <class _Sender, class _Tag>
concept sender_expr_for =
    sender_expr<_Sender> && same_as<tag_of_t<_Sender>, _Tag>;
} // namespace stdexec
# 24 "./../stdexec/include/stdexec/__detail/__domain.hpp" 2

namespace stdexec {

struct default_domain;
struct dependent_domain;

namespace __detail {
template <class _DomainOrTag, class _Sender, class... _Env>
concept __has_transform_sender =
    requires(_DomainOrTag __tag, _Sender &&__sender, const _Env &...__env) {
      __tag.transform_sender(static_cast<_Sender &&>(__sender), __env...);
    };

template <class _DomainOrTag, class _Sender, class... _Env>
concept __has_nothrow_transform_sender =
    requires(_DomainOrTag __tag, _Sender &&__sender, const _Env &...__env) {
      {
        __tag.transform_sender(static_cast<_Sender &&>(__sender), __env...)
      } noexcept;
    };

template <class _Sender, class... _Env>
concept __has_default_transform_sender =
    sender_expr<_Sender> &&
    __has_transform_sender<tag_of_t<_Sender>, _Sender, _Env...>;

template <class _DomainOrTag, class _Sender, class... _Env>
using __transform_sender_result_t = decltype(_DomainOrTag{}.transform_sender(
    __declval<_Sender>(), __declval<const _Env &>()...));

template <class _DomainOrTag, class _Sender, class _Env>
concept __has_transform_env =
    requires(_DomainOrTag __tag, _Sender &&__sender, _Env &&__env) {
      __tag.transform_env(static_cast<_Sender &&>(__sender),
                          static_cast<_Env &&>(__env));
    };

template <class _Sender, class _Env>
concept __has_default_transform_env =
    sender_expr<_Sender> &&
    __has_transform_env<tag_of_t<_Sender>, _Sender, _Env>;

template <class _DomainOrTag, class _Sender, class _Env>
using __transform_env_result_t = decltype(_DomainOrTag{}.transform_env(
    __declval<_Sender>(), __declval<_Env>()));

template <class _DomainOrTag, class... _Args>
concept __has_apply_sender = requires(_DomainOrTag __tag, _Args &&...__args) {
  __tag.apply_sender(static_cast<_Args &&>(__args)...);
};

template <class _Tag, class... _Args>
using __apply_sender_result_t =
    decltype(_Tag{}.apply_sender(__declval<_Args>()...));

template <class _Env, class _Tag>
using __completion_scheduler_for =
    __meval_or<__call_result_t, __none_such, get_completion_scheduler_t<_Tag>,
               _Env>;

template <class _Env, class _Tag>
using __completion_domain_for =
    __meval_or<__call_result_t, __none_such, get_domain_t,
               __completion_scheduler_for<_Env, _Tag>>;

template <class _Env>
struct __completion_domain_or_none_
    : __mdefer_<__mtransform<__mbind_front_q<__completion_domain_for, _Env>,
                             __mremove<__none_such,
                                       __munique<__msingle_or<__none_such>>>>,
                set_value_t, set_error_t, set_stopped_t> {};

template <class _Sender>
using __completion_domain_or_none =
    __t<__completion_domain_or_none_<env_of_t<_Sender>>>;

template <class _Sender>
concept __consistent_completion_domains =
    __mvalid<__completion_domain_or_none, _Sender>;

template <class _Sender>
concept __has_completion_domain =
    (!same_as<__completion_domain_or_none<_Sender>, __none_such>);

template <__has_completion_domain _Sender>
using __completion_domain_of = __completion_domain_or_none<_Sender>;

struct __get_early_domain_t {
  template <class _Sender, class _Default = default_domain>
  auto operator()(const _Sender &, _Default = {}) const noexcept {
    if constexpr (__callable<get_domain_t, env_of_t<_Sender>>) {
      return __domain_of_t<env_of_t<_Sender>>();
    } else if constexpr (__has_completion_domain<_Sender>) {
      return __completion_domain_of<_Sender>();
    } else {
      return _Default();
    }
  }
};

template <class _Sender, class _Default = default_domain>
using __early_domain_of_t =
    __call_result_t<__get_early_domain_t, _Sender, _Default>;

struct __get_late_domain_t {

  template <class _Sender, class _Env, class _Default = default_domain>
  auto operator()(const _Sender &__sndr, const _Env &__env,
                  _Default = {}) const noexcept {

    if constexpr (__callable<get_domain_late_t, env_of_t<_Sender>>) {
      return get_domain_late(get_env(__sndr));
    } else if constexpr (__callable<get_domain_t, const _Env &>) {
      return get_domain(__env);
    } else if constexpr (__callable<__composed<get_domain_t, get_scheduler_t>,
                                    const _Env &>) {
      return get_domain(get_scheduler(__env));
    } else {
      return _Default();
    }
  }
};

template <class _Sender, class _Env, class _Default = default_domain>
using __late_domain_of_t =
    __call_result_t<__get_late_domain_t, _Sender, _Env, _Default>;

struct __common_domain_fn {
  template <class _Default = default_domain,
            class _Dependent = dependent_domain, class... _Domains>
  static auto __common_domain(_Domains...) noexcept {
    if constexpr (sizeof...(_Domains) == 0) {
      return _Default();
    } else if constexpr (__one_of<_Dependent, _Domains...>) {
      return _Dependent();
    } else if constexpr (stdexec::__mvalid<std::common_type_t, _Domains...>) {
      return std::common_type_t<_Domains...>();
    } else {
      return __none_such();
    }
  }

  auto operator()(__ignore, __ignore, const auto &...__sndrs) const noexcept {
    return __common_domain(__get_early_domain_t{}(__sndrs)...);
  }
};
} // namespace __detail

struct default_domain {
  template <class _Sender, class... _Env>
    requires __detail::__has_default_transform_sender<_Sender, _Env...>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  transform_sender(_Sender &&__sndr, _Env &&...__env) const
      noexcept(__detail::__has_nothrow_transform_sender<tag_of_t<_Sender>,
                                                        _Sender, _Env...>)
          -> __detail::__transform_sender_result_t<tag_of_t<_Sender>, _Sender,
                                                   _Env...> {
    return tag_of_t<_Sender>().transform_sender(static_cast<_Sender &&>(__sndr),
                                                __env...);
  }

  template <class _Sender, class... _Env>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  transform_sender(_Sender &&__sndr, _Env &&...) const
      noexcept(__nothrow_constructible_from<_Sender, _Sender>) -> _Sender {
    return static_cast<_Sender>(static_cast<_Sender &&>(__sndr));
  }

  template <class _Sender, class _Env>
    requires __detail::__has_default_transform_env<_Sender, _Env>
  auto transform_env(_Sender &&__sndr, _Env &&__env) const noexcept
      -> __detail::__transform_env_result_t<tag_of_t<_Sender>, _Sender, _Env> {
    return tag_of_t<_Sender>().transform_env(static_cast<_Sender &&>(__sndr),
                                             static_cast<_Env &&>(__env));
  }

  template <class _Env>
  auto transform_env(__ignore, _Env &&__env) const noexcept -> _Env {
    return static_cast<_Env>(static_cast<_Env &&>(__env));
  }

  template <class _Tag, class... _Args>
    requires __detail::__has_apply_sender<_Tag, _Args...>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  apply_sender(_Tag, _Args &&...__args) const
      -> __detail::__apply_sender_result_t<_Tag, _Args...> {
    return _Tag().apply_sender(static_cast<_Args &&>(__args)...);
  }
};

inline constexpr __detail::__get_early_domain_t __get_early_domain{};
inline constexpr __detail::__get_late_domain_t __get_late_domain{};
using __detail::__early_domain_of_t;
using __detail::__late_domain_of_t;

struct dependent_domain {

  template <class _Sender, class _Env>
  static constexpr auto __is_nothrow_transform_sender() noexcept -> bool;

  template <sender_expr _Sender, class _Env>
    requires same_as<__early_domain_of_t<_Sender>, dependent_domain>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  transform_sender(_Sender &&__sndr, const _Env &__env) const
      noexcept(__is_nothrow_transform_sender<_Sender, _Env>())
          -> decltype(auto);
};

template <class... _Senders>
using __common_domain_t =
    __call_result_t<__detail::__common_domain_fn, int, int, _Senders...>;

template <class... _Senders>
concept __has_common_domain =
    __none_of<__none_such, __common_domain_t<_Senders...>>;
} // namespace stdexec
# 25 "./../stdexec/include/stdexec/__detail/__senders_core.hpp" 2

namespace stdexec {

struct sender_t {
  using sender_concept = sender_t;
};

namespace __detail {
template <class _Sender>
concept __enable_sender =
    derived_from<typename _Sender::sender_concept, sender_t> || requires {
      typename _Sender::is_sender;
    } || __awaitable<_Sender, __env::__promise<env<>>>;
} // namespace __detail

template <class _Sender>
inline constexpr bool enable_sender = __detail::__enable_sender<_Sender>;

template <class _Sender>
concept sender = enable_sender<__decay_t<_Sender>> &&
                 environment_provider<__cref_t<_Sender>> &&
                 __detail::__consistent_completion_domains<_Sender> &&
                 move_constructible<__decay_t<_Sender>> &&
                 constructible_from<__decay_t<_Sender>, _Sender>;

template <class _Sender, class... _Env>
concept sender_in =
    (sizeof...(_Env) <= 1) && sender<_Sender> &&
    requires(_Sender &&__sndr, _Env &&...__env) {
      {
        get_completion_signatures(static_cast<_Sender &&>(__sndr),
                                  static_cast<_Env &&>(__env)...)
      } -> __valid_completion_signatures;
    };

template <class _Sender, class _Receiver>
concept sender_to =
    receiver<_Receiver> && sender_in<_Sender, env_of_t<_Receiver>> &&
    __receiver_from<_Receiver, _Sender> &&
    requires(_Sender &&__sndr, _Receiver &&__rcvr) {
      connect(static_cast<_Sender &&>(__sndr),
              static_cast<_Receiver &&>(__rcvr));
    };

template <class _Sender, class _Receiver>
using connect_result_t = __call_result_t<connect_t, _Sender, _Receiver>;
} // namespace stdexec
# 25 "./../stdexec/include/stdexec/__detail/__debug.hpp" 2

namespace stdexec {

namespace __debug {
struct __is_debug_env_t {
  static constexpr auto query(forwarding_query_t) noexcept -> bool {
    return true;
  }
  template <class _Env>
    requires tag_invocable<__is_debug_env_t, const _Env &>
  auto operator()(const _Env &) const noexcept
      -> tag_invoke_result_t<__is_debug_env_t, const _Env &>;
};

template <class _Env>
using __debug_env_t = env<prop<__is_debug_env_t, bool>, _Env>;

template <class _Env>
concept __is_debug_env = tag_invocable<__is_debug_env_t, _Env>;

struct __completion_signatures {};
# 66 "./../stdexec/include/stdexec/__detail/__debug.hpp"
template <class _Sig> extern int __normalize_sig;

template <class _Tag, class... _Args>
extern _Tag (*__normalize_sig<_Tag(_Args...)>)(_Args &&...);

template <class _Sig> using __normalize_sig_t = decltype(__normalize_sig<_Sig>);

template <class... _Sigs> struct __valid_completions {
  template <class... _Args>
    requires __one_of<set_value_t (*)(_Args &&...), _Sigs...>

  void set_value(_Args &&...) noexcept {
    std::terminate();
  }

  template <class _Error>
    requires __one_of<set_error_t (*)(_Error &&), _Sigs...>

  void set_error(_Error &&) noexcept {
    std::terminate();
  }

  void set_stopped() noexcept
    requires __one_of<set_stopped_t (*)(), _Sigs...>
  {
    std::terminate();
  }
};

template <class _CvrefSenderId, class _Env, class _Completions>
struct __debug_receiver {
  using __t = __debug_receiver;
  using __id = __debug_receiver;
  using receiver_concept = receiver_t;
};

template <class _CvrefSenderId, class _Env, class... _Sigs>
struct __debug_receiver<_CvrefSenderId, _Env, completion_signatures<_Sigs...>>
    : __valid_completions<__normalize_sig_t<_Sigs>...> {
  using __t = __debug_receiver;
  using __id = __debug_receiver;
  using receiver_concept = receiver_t;

  auto get_env() const noexcept -> __debug_env_t<_Env> { std::terminate(); }
};

struct _COMPLETION_SIGNATURES_MISMATCH_ {};

template <class _Sig> struct _COMPLETION_SIGNATURE_ {};

template <class... _Sigs> struct _IS_NOT_ONE_OF_ {};

template <class _Sender> struct _SIGNAL_SENT_BY_SENDER_ {};

template <class _Warning>
[[deprecated("The sender claims to send a particular set of completions,"
             " but in actual fact it completes with a result that is not"
             " one of the declared completion signatures.")]] void
_ATTENTION_() noexcept {}

template <class _Sig> struct __invalid_completion {
  struct __t {
    template <class _CvrefSenderId, class _Env, class... _Sigs>

      requires(!__one_of<_Sig, _Sigs...>)
    __t(__debug_receiver<_CvrefSenderId, _Env, completion_signatures<_Sigs...>>
            &&) noexcept {
      using _SenderId = __decay_t<_CvrefSenderId>;
      using _Sender = stdexec::__t<_SenderId>;
      using _What =
          _WARNING_<_COMPLETION_SIGNATURES_MISMATCH_,
                    _COMPLETION_SIGNATURE_<_Sig>, _IS_NOT_ONE_OF_<_Sigs...>,
                    _SIGNAL_SENT_BY_SENDER_<__name_of<_Sender>>>;
      __debug::_ATTENTION_<_What>();
    }
  };
};

template <__completion_tag _Tag, class... _Args>

void tag_invoke(_Tag, __t<__invalid_completion<_Tag(_Args...)>>,
                _Args &&...) noexcept {}

struct __debug_operation {
  void start() & noexcept {}
};
# 212 "./../stdexec/include/stdexec/__detail/__debug.hpp"
template <class _Sigs, class _Env = env<>, class _Sender>
void __debug_sender(_Sender &&__sndr, const _Env & = {}) {
  if constexpr (!__is_debug_env<_Env>) {
    if (sizeof(_Sender) == ~0u) {
      using _Receiver = __debug_receiver<__cvref_id<_Sender>, _Env, _Sigs>;
      using _Operation = connect_result_t<_Sender, _Receiver>;

      if constexpr (!same_as<_Operation, __debug_operation>) {
        auto __op = connect(static_cast<_Sender &&>(__sndr), _Receiver{});
        stdexec::start(__op);
      }
    }
  }
}

template <class _Env = env<>, class _Sender>
void __debug_sender(_Sender &&__sndr, const _Env & = {}) {
  if constexpr (!__is_debug_env<_Env>) {
    if (sizeof(_Sender) == ~0ul) {
      using _Sigs = __completion_signatures_of_t<_Sender, __debug_env_t<_Env>>;
      if constexpr (!same_as<_Sigs, __debug::__completion_signatures>) {
        using _Receiver = __debug_receiver<__cvref_id<_Sender>, _Env, _Sigs>;
        using _Operation = connect_result_t<_Sender, _Receiver>;

        if constexpr (!same_as<_Operation, __debug_operation>) {
          auto __op = connect(static_cast<_Sender &&>(__sndr), _Receiver{});
          stdexec::start(__op);
        }
      }
    }
  }
}
} // namespace __debug

using __debug::__debug_sender;
using __debug::__is_debug_env;
} // namespace stdexec
# 26 "./../stdexec/include/stdexec/__detail/__senders.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__operation_states.hpp" 1
# 26 "./../stdexec/include/stdexec/__detail/__operation_states.hpp"
namespace stdexec {

struct operation_state_t {};

namespace __start {
struct start_t {
  template <__same_as<start_t> _Self, class _OpState>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline friend auto
  tag_invoke(_Self, _OpState &__op) noexcept -> decltype(__op.start()) {
    static_assert(noexcept(__op.start()), "start() members must be noexcept");
    static_assert(__same_as<decltype(__op.start()), void>,
                  "start() members must return void");
    __op.start();
  }

  template <class _Op>
    requires tag_invocable<start_t, _Op &>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline void
  operator()(_Op &__op) const noexcept {
    static_assert(nothrow_tag_invocable<start_t, _Op &>);
    (void)tag_invoke(start_t{}, __op);
  }
};
} // namespace __start

using __start::start_t;
inline constexpr start_t start{};

template <class _Op>
concept operation_state = destructible<_Op> && std::is_object_v<_Op> &&
                          requires(_Op &__op) { stdexec::start(__op); };
} // namespace stdexec
# 28 "./../stdexec/include/stdexec/__detail/__senders.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__transform_completion_signatures.hpp" 1
# 29 "./../stdexec/include/stdexec/__detail/__transform_completion_signatures.hpp"
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/variant" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/variant" 3
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/variant" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/parse_numbers.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/parse_numbers.h" 3

namespace std __attribute__((__visibility__("default"))) {

  namespace __parse_int {
  template <unsigned _Base, char _Dig> struct _Digit;

  template <unsigned _Base>
  struct _Digit<_Base, '0'> : integral_constant<unsigned, 0> {
    using __valid = true_type;
  };

  template <unsigned _Base>
  struct _Digit<_Base, '1'> : integral_constant<unsigned, 1> {
    using __valid = true_type;
  };

  template <unsigned _Base, unsigned _Val>
  struct _Digit_impl : integral_constant<unsigned, _Val> {
    static_assert(_Base > _Val, "invalid digit");
    using __valid = true_type;
  };

  template <unsigned _Base>
  struct _Digit<_Base, '2'> : _Digit_impl<_Base, 2> {};

  template <unsigned _Base>
  struct _Digit<_Base, '3'> : _Digit_impl<_Base, 3> {};

  template <unsigned _Base>
  struct _Digit<_Base, '4'> : _Digit_impl<_Base, 4> {};

  template <unsigned _Base>
  struct _Digit<_Base, '5'> : _Digit_impl<_Base, 5> {};

  template <unsigned _Base>
  struct _Digit<_Base, '6'> : _Digit_impl<_Base, 6> {};

  template <unsigned _Base>
  struct _Digit<_Base, '7'> : _Digit_impl<_Base, 7> {};

  template <unsigned _Base>
  struct _Digit<_Base, '8'> : _Digit_impl<_Base, 8> {};

  template <unsigned _Base>
  struct _Digit<_Base, '9'> : _Digit_impl<_Base, 9> {};

  template <unsigned _Base>
  struct _Digit<_Base, 'a'> : _Digit_impl<_Base, 0xa> {};

  template <unsigned _Base>
  struct _Digit<_Base, 'A'> : _Digit_impl<_Base, 0xa> {};

  template <unsigned _Base>
  struct _Digit<_Base, 'b'> : _Digit_impl<_Base, 0xb> {};

  template <unsigned _Base>
  struct _Digit<_Base, 'B'> : _Digit_impl<_Base, 0xb> {};

  template <unsigned _Base>
  struct _Digit<_Base, 'c'> : _Digit_impl<_Base, 0xc> {};

  template <unsigned _Base>
  struct _Digit<_Base, 'C'> : _Digit_impl<_Base, 0xc> {};

  template <unsigned _Base>
  struct _Digit<_Base, 'd'> : _Digit_impl<_Base, 0xd> {};

  template <unsigned _Base>
  struct _Digit<_Base, 'D'> : _Digit_impl<_Base, 0xd> {};

  template <unsigned _Base>
  struct _Digit<_Base, 'e'> : _Digit_impl<_Base, 0xe> {};

  template <unsigned _Base>
  struct _Digit<_Base, 'E'> : _Digit_impl<_Base, 0xe> {};

  template <unsigned _Base>
  struct _Digit<_Base, 'f'> : _Digit_impl<_Base, 0xf> {};

  template <unsigned _Base>
  struct _Digit<_Base, 'F'> : _Digit_impl<_Base, 0xf> {};

  template <unsigned _Base>
  struct _Digit<_Base, '\''> : integral_constant<unsigned, 0> {
    using __valid = false_type;
  };

  template <unsigned long long _Val>
  using __ull_constant = integral_constant<unsigned long long, _Val>;

  template <unsigned _Base, char _Dig, char... _Digs> struct _Power_help {
    using __next = typename _Power_help<_Base, _Digs...>::type;
    using __valid_digit = typename _Digit<_Base, _Dig>::__valid;
    using type =
        __ull_constant<__next::value *(__valid_digit{} ? _Base : 1ULL)>;
  };

  template <unsigned _Base, char _Dig> struct _Power_help<_Base, _Dig> {
    using __valid_digit = typename _Digit<_Base, _Dig>::__valid;
    using type = __ull_constant<__valid_digit::value>;
  };

  template <unsigned _Base, char... _Digs>
  struct _Power : _Power_help<_Base, _Digs...>::type {};

  template <unsigned _Base> struct _Power<_Base> : __ull_constant<0> {};

  template <unsigned _Base, unsigned long long _Pow, char _Dig, char... _Digs>
  struct _Number_help {
    using __digit = _Digit<_Base, _Dig>;
    using __valid_digit = typename __digit::__valid;
    using __next =
        _Number_help<_Base, __valid_digit::value ? _Pow / _Base : _Pow,
                     _Digs...>;
    using type = __ull_constant<_Pow * __digit::value + __next::type::value>;
    static_assert((type::value / _Pow) == __digit::value,
                  "integer literal does not fit in unsigned long long");
  };

  template <unsigned _Base, unsigned long long _Pow, char _Dig, char... _Digs>
  struct _Number_help<_Base, _Pow, '\'', _Dig, _Digs...>
      : _Number_help<_Base, _Pow, _Dig, _Digs...> {};

  template <unsigned _Base, char _Dig> struct _Number_help<_Base, 1ULL, _Dig> {
    using type = __ull_constant<_Digit<_Base, _Dig>::value>;
  };

  template <unsigned _Base, char... _Digs>
  struct _Number
      : _Number_help<_Base, _Power<_Base, _Digs...>::value, _Digs...>::type {};

  template <unsigned _Base> struct _Number<_Base> : __ull_constant<0> {};

  template <char... _Digs> struct _Parse_int;

  template <char... _Digs>
  struct _Parse_int<'0', 'b', _Digs...> : _Number<2U, _Digs...>::type {};

  template <char... _Digs>
  struct _Parse_int<'0', 'B', _Digs...> : _Number<2U, _Digs...>::type {};

  template <char... _Digs>
  struct _Parse_int<'0', 'x', _Digs...> : _Number<16U, _Digs...>::type {};

  template <char... _Digs>
  struct _Parse_int<'0', 'X', _Digs...> : _Number<16U, _Digs...>::type {};

  template <char... _Digs>
  struct _Parse_int<'0', _Digs...> : _Number<8U, _Digs...>::type {};

  template <char... _Digs> struct _Parse_int : _Number<10U, _Digs...>::type {};

  } // namespace __parse_int

  namespace __select_int {
  template <unsigned long long _Val, typename... _Ints> struct _Select_int_base;

  template <unsigned long long _Val, typename _IntType, typename... _Ints>
  struct _Select_int_base<_Val, _IntType, _Ints...>
      : __conditional_t<(_Val <= __gnu_cxx::__int_traits<_IntType>::__max),
                        integral_constant<_IntType, (_IntType)_Val>,
                        _Select_int_base<_Val, _Ints...>> {};

  template <unsigned long long _Val> struct _Select_int_base<_Val> {};

  template <char... _Digs>
  using _Select_int =
      typename _Select_int_base<__parse_int::_Parse_int<_Digs...>::value,
                                unsigned char, unsigned short, unsigned int,
                                unsigned long, unsigned long long>::type;

  } // namespace __select_int

} // namespace std
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/variant" 2 3
# 58 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/variant" 3
namespace std __attribute__((__visibility__("default"))) {

  template <typename... _Types> class tuple;
  template <typename... _Types> class variant;
  template <typename> struct hash;

  template <typename _Variant> struct variant_size;

  template <typename _Variant>
  struct variant_size<const _Variant> : variant_size<_Variant> {};

  template <typename _Variant>
  struct variant_size<volatile _Variant> : variant_size<_Variant> {};

  template <typename _Variant>
  struct variant_size<const volatile _Variant> : variant_size<_Variant> {};

  template <typename... _Types>
  struct variant_size<variant<_Types...>>
      : std::integral_constant<size_t, sizeof...(_Types)> {};

  template <typename _Variant>
  inline constexpr size_t variant_size_v = variant_size<_Variant>::value;

  template <typename... _Types>
  inline constexpr size_t variant_size_v<variant<_Types...>> =
      sizeof...(_Types);

  template <typename... _Types>
  inline constexpr size_t variant_size_v<const variant<_Types...>> =
      sizeof...(_Types);

  template <size_t _Np, typename _Variant> struct variant_alternative;

  template <size_t _Np, typename... _Types>
  struct variant_alternative<_Np, variant<_Types...>> {
    static_assert(_Np < sizeof...(_Types));

    using type = typename _Nth_type<_Np, _Types...>::type;
  };

  template <size_t _Np, typename _Variant>
  using variant_alternative_t =
      typename variant_alternative<_Np, _Variant>::type;

  template <size_t _Np, typename _Variant>
  struct variant_alternative<_Np, const _Variant> {
    using type = const variant_alternative_t<_Np, _Variant>;
  };

  template <size_t _Np, typename _Variant>
  struct variant_alternative<_Np, volatile _Variant> {
    using type = volatile variant_alternative_t<_Np, _Variant>;
  };

  template <size_t _Np, typename _Variant>
  struct variant_alternative<_Np, const volatile _Variant> {
    using type = const volatile variant_alternative_t<_Np, _Variant>;
  };

  inline constexpr size_t variant_npos = -1;

  template <size_t _Np, typename... _Types>
  constexpr variant_alternative_t<_Np, variant<_Types...>> &get(
      variant<_Types...> &);

  template <size_t _Np, typename... _Types>
  constexpr variant_alternative_t<_Np, variant<_Types...>> &&get(
      variant<_Types...> &&);

  template <size_t _Np, typename... _Types>
  constexpr variant_alternative_t<_Np, variant<_Types...>> const &get(
      const variant<_Types...> &);

  template <size_t _Np, typename... _Types>
  constexpr variant_alternative_t<_Np, variant<_Types...>> const &&get(
      const variant<_Types...> &&);

  template <typename _Result_type, typename _Visitor, typename... _Variants>
  constexpr decltype(auto) __do_visit(_Visitor && __visitor,
                                      _Variants && ...__variants);

  template <typename... _Types, typename _Tp>
  constexpr decltype(auto) __variant_cast(_Tp && __rhs) {
    if constexpr (is_lvalue_reference_v<_Tp>) {
      if constexpr (is_const_v<remove_reference_t<_Tp>>)
        return static_cast<const variant<_Types...> &>(__rhs);
      else
        return static_cast<variant<_Types...> &>(__rhs);
    } else
      return static_cast<variant<_Types...> &&>(__rhs);
  }

  namespace __detail {
  namespace __variant {

  struct __variant_cookie {};

  struct __variant_idx_cookie {
    using type = __variant_idx_cookie;
  };

  template <typename _Tp> struct __deduce_visit_result {
    using type = _Tp;
  };

  template <typename _Visitor, typename... _Variants>
  constexpr void __raw_visit(_Visitor &&__visitor, _Variants &&...__variants) {
    std::__do_visit<__variant_cookie>(std::forward<_Visitor>(__visitor),
                                      std::forward<_Variants>(__variants)...);
  }

  template <typename _Visitor, typename... _Variants>
  constexpr void __raw_idx_visit(_Visitor &&__visitor,
                                 _Variants &&...__variants) {
    std::__do_visit<__variant_idx_cookie>(
        std::forward<_Visitor>(__visitor),
        std::forward<_Variants>(__variants)...);
  }

  template <typename... _Types>
  constexpr std::variant<_Types...> &
  __as(std::variant<_Types...> &__v) noexcept {
    return __v;
  }

  template <typename... _Types>
  constexpr const std::variant<_Types...> &
  __as(const std::variant<_Types...> &__v) noexcept {
    return __v;
  }

  template <typename... _Types>
  constexpr std::variant<_Types...> &&
  __as(std::variant<_Types...> &&__v) noexcept {
    return std::move(__v);
  }

  template <typename... _Types>
  constexpr const std::variant<_Types...> &&
  __as(const std::variant<_Types...> &&__v) noexcept {
    return std::move(__v);
  }

  template <typename _Type, bool = std::is_trivially_destructible_v<_Type>>
  struct _Uninitialized;

  template <typename _Type> struct _Uninitialized<_Type, true> {
    template <typename... _Args>
    constexpr _Uninitialized(in_place_index_t<0>, _Args &&...__args)
        : _M_storage(std::forward<_Args>(__args)...) {}

    constexpr const _Type &_M_get() const & noexcept { return _M_storage; }

    constexpr _Type &_M_get() & noexcept { return _M_storage; }

    constexpr const _Type &&_M_get() const && noexcept {
      return std::move(_M_storage);
    }

    constexpr _Type &&_M_get() && noexcept { return std::move(_M_storage); }

    _Type _M_storage;
  };

  template <typename _Type> struct _Uninitialized<_Type, false> {
# 278 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/variant" 3
    template <typename... _Args>
    constexpr _Uninitialized(in_place_index_t<0>, _Args &&...__args) {
      ::new ((void *)std::addressof(_M_storage))
          _Type(std::forward<_Args>(__args)...);
    }

    const _Type &_M_get() const & noexcept { return *_M_storage._M_ptr(); }

    _Type &_M_get() & noexcept { return *_M_storage._M_ptr(); }

    const _Type &&_M_get() const && noexcept {
      return std::move(*_M_storage._M_ptr());
    }

    _Type &&_M_get() && noexcept { return std::move(*_M_storage._M_ptr()); }

    __gnu_cxx::__aligned_membuf<_Type> _M_storage;
  };

  template <size_t _Np, typename _Union>
  constexpr decltype(auto) __get_n(_Union &&__u) noexcept {
    if constexpr (_Np == 0)
      return std::forward<_Union>(__u)._M_first._M_get();
    else if constexpr (_Np == 1)
      return std::forward<_Union>(__u)._M_rest._M_first._M_get();
    else if constexpr (_Np == 2)
      return std::forward<_Union>(__u)._M_rest._M_rest._M_first._M_get();
    else
      return __variant::__get_n<_Np - 3>(
          std::forward<_Union>(__u)._M_rest._M_rest._M_rest);
  }

  template <size_t _Np, typename _Variant>
  constexpr decltype(auto) __get(_Variant &&__v) noexcept {
    return __variant::__get_n<_Np>(std::forward<_Variant>(__v)._M_u);
  }

  template <size_t _Np, typename _Union>
  constexpr decltype(auto) __construct_n(_Union &__u) noexcept {
    if constexpr (_Np == 0)
      return &__u._M_first;
    else if constexpr (_Np == 1) {
      std::_Construct(&__u._M_rest);
      return &__u._M_rest._M_first;
    } else if constexpr (_Np == 2) {
      std::_Construct(&__u._M_rest);
      std::_Construct(&__u._M_rest._M_rest);
      return &__u._M_rest._M_rest._M_first;
    } else {
      std::_Construct(&__u._M_rest);
      std::_Construct(&__u._M_rest._M_rest);
      std::_Construct(&__u._M_rest._M_rest._M_rest);
      return __variant::__construct_n<_Np - 3>(__u._M_rest._M_rest._M_rest);
    }
  }

  template <typename... _Types> struct _Traits {
    static constexpr bool _S_default_ctor =
        is_default_constructible_v<typename _Nth_type<0, _Types...>::type>;
    static constexpr bool _S_copy_ctor =
        (is_copy_constructible_v<_Types> && ...);
    static constexpr bool _S_move_ctor =
        (is_move_constructible_v<_Types> && ...);
    static constexpr bool _S_copy_assign =
        _S_copy_ctor && (is_copy_assignable_v<_Types> && ...);
    static constexpr bool _S_move_assign =
        _S_move_ctor && (is_move_assignable_v<_Types> && ...);

    static constexpr bool _S_trivial_dtor =
        (is_trivially_destructible_v<_Types> && ...);
    static constexpr bool _S_trivial_copy_ctor =
        (is_trivially_copy_constructible_v<_Types> && ...);
    static constexpr bool _S_trivial_move_ctor =
        (is_trivially_move_constructible_v<_Types> && ...);
    static constexpr bool _S_trivial_copy_assign =
        _S_trivial_dtor && _S_trivial_copy_ctor &&
        (is_trivially_copy_assignable_v<_Types> && ...);
    static constexpr bool _S_trivial_move_assign =
        _S_trivial_dtor && _S_trivial_move_ctor &&
        (is_trivially_move_assignable_v<_Types> && ...);

    static constexpr bool _S_nothrow_default_ctor =
        is_nothrow_default_constructible_v<
            typename _Nth_type<0, _Types...>::type>;
    static constexpr bool _S_nothrow_copy_ctor = false;
    static constexpr bool _S_nothrow_move_ctor =
        (is_nothrow_move_constructible_v<_Types> && ...);
    static constexpr bool _S_nothrow_copy_assign = false;
    static constexpr bool _S_nothrow_move_assign =
        _S_nothrow_move_ctor && (is_nothrow_move_assignable_v<_Types> && ...);
  };

  template <typename... _Types> union _Variadic_union {
    _Variadic_union() = default;

    template <size_t _Np, typename... _Args>
    _Variadic_union(in_place_index_t<_Np>, _Args &&...) = delete;
  };

  template <typename _First, typename... _Rest>
  union _Variadic_union<_First, _Rest...> {
    constexpr _Variadic_union() : _M_rest() {}

    template <typename... _Args>
    constexpr _Variadic_union(in_place_index_t<0>, _Args &&...__args)
        : _M_first(in_place_index<0>, std::forward<_Args>(__args)...) {}

    template <size_t _Np, typename... _Args>
    constexpr _Variadic_union(in_place_index_t<_Np>, _Args &&...__args)
        : _M_rest(in_place_index<_Np - 1>, std::forward<_Args>(__args)...) {}
# 434 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/variant" 3
    _Uninitialized<_First> _M_first;
    _Variadic_union<_Rest...> _M_rest;
  };

  template <typename _Tp>
  struct _Never_valueless_alt
      : __and_<bool_constant<sizeof(_Tp) <= 256>, is_trivially_copyable<_Tp>> {
  };
# 458 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/variant" 3
  template <typename... _Types> constexpr bool __never_valueless() {
    return _Traits<_Types...>::_S_move_assign &&
           (_Never_valueless_alt<_Types>::value && ...);
  }

  template <bool __trivially_destructible, typename... _Types>
  struct _Variant_storage;

  template <typename... _Types>
  using __select_index =
      typename __select_int::_Select_int_base<sizeof...(_Types), unsigned char,
                                              unsigned short>::type::value_type;

  template <typename... _Types> struct _Variant_storage<false, _Types...> {
    constexpr _Variant_storage()
        : _M_index(static_cast<__index_type>(variant_npos)) {}

    template <size_t _Np, typename... _Args>
    constexpr _Variant_storage(in_place_index_t<_Np>, _Args &&...__args)
        : _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
          _M_index{_Np} {}

    constexpr void _M_reset() {
      if (!_M_valid()) [[unlikely]]
        return;

      std::__do_visit<void>(
          [](auto &&__this_mem) mutable {
            std::_Destroy(std::__addressof(__this_mem));
          },
          __variant_cast<_Types...>(*this));

      _M_index = static_cast<__index_type>(variant_npos);
    }

    constexpr ~_Variant_storage() { _M_reset(); }

    constexpr bool _M_valid() const noexcept {
      if constexpr (__variant::__never_valueless<_Types...>())
        return true;
      return this->_M_index != __index_type(variant_npos);
    }

    _Variadic_union<_Types...> _M_u;
    using __index_type = __select_index<_Types...>;
    __index_type _M_index;
  };

  template <typename... _Types> struct _Variant_storage<true, _Types...> {
    constexpr _Variant_storage()
        : _M_index(static_cast<__index_type>(variant_npos)) {}

    template <size_t _Np, typename... _Args>
    constexpr _Variant_storage(in_place_index_t<_Np>, _Args &&...__args)
        : _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
          _M_index{_Np} {}

    constexpr void _M_reset() noexcept {
      _M_index = static_cast<__index_type>(variant_npos);
    }

    constexpr bool _M_valid() const noexcept {
      if constexpr (__variant::__never_valueless<_Types...>())
        return true;

      return this->_M_index != static_cast<__index_type>(variant_npos);
    }

    _Variadic_union<_Types...> _M_u;
    using __index_type = __select_index<_Types...>;
    __index_type _M_index;
  };

  template <size_t _Np, bool _Triv, typename... _Types, typename... _Args>
  constexpr inline void __emplace(_Variant_storage<_Triv, _Types...> &__v,
                                  _Args &&...__args) {
    __v._M_reset();
    auto *__addr = __variant::__construct_n<_Np>(__v._M_u);
    std::_Construct(__addr, in_place_index<0>, std::forward<_Args>(__args)...);

    __v._M_index = _Np;
  }

  template <typename... _Types>
  using _Variant_storage_alias =
      _Variant_storage<_Traits<_Types...>::_S_trivial_dtor, _Types...>;

  template <bool, typename... _Types>
  struct _Copy_ctor_base : _Variant_storage_alias<_Types...> {
    using _Base = _Variant_storage_alias<_Types...>;
    using _Base::_Base;

    constexpr _Copy_ctor_base(const _Copy_ctor_base &__rhs) noexcept(
        _Traits<_Types...>::_S_nothrow_copy_ctor) {
      __variant::__raw_idx_visit(
          [this](auto &&__rhs_mem, auto __rhs_index) mutable {
            constexpr size_t __j = __rhs_index;
            if constexpr (__j != variant_npos)
              std::_Construct(std::__addressof(this->_M_u), in_place_index<__j>,
                              __rhs_mem);
          },
          __variant_cast<_Types...>(__rhs));
      this->_M_index = __rhs._M_index;
    }

    _Copy_ctor_base(_Copy_ctor_base &&) = default;
    _Copy_ctor_base &operator=(const _Copy_ctor_base &) = default;
    _Copy_ctor_base &operator=(_Copy_ctor_base &&) = default;
  };

  template <typename... _Types>
  struct _Copy_ctor_base<true, _Types...> : _Variant_storage_alias<_Types...> {
    using _Base = _Variant_storage_alias<_Types...>;
    using _Base::_Base;
  };

  template <typename... _Types>
  using _Copy_ctor_alias =
      _Copy_ctor_base<_Traits<_Types...>::_S_trivial_copy_ctor, _Types...>;

  template <bool, typename... _Types>
  struct _Move_ctor_base : _Copy_ctor_alias<_Types...> {
    using _Base = _Copy_ctor_alias<_Types...>;
    using _Base::_Base;

    constexpr _Move_ctor_base(_Move_ctor_base &&__rhs) noexcept(
        _Traits<_Types...>::_S_nothrow_move_ctor) {
      __variant::__raw_idx_visit(
          [this](auto &&__rhs_mem, auto __rhs_index) mutable {
            constexpr size_t __j = __rhs_index;
            if constexpr (__j != variant_npos)
              std::_Construct(std::__addressof(this->_M_u), in_place_index<__j>,
                              std::forward<decltype(__rhs_mem)>(__rhs_mem));
          },
          __variant_cast<_Types...>(std::move(__rhs)));
      this->_M_index = __rhs._M_index;
    }

    _Move_ctor_base(const _Move_ctor_base &) = default;
    _Move_ctor_base &operator=(const _Move_ctor_base &) = default;
    _Move_ctor_base &operator=(_Move_ctor_base &&) = default;
  };

  template <typename... _Types>
  struct _Move_ctor_base<true, _Types...> : _Copy_ctor_alias<_Types...> {
    using _Base = _Copy_ctor_alias<_Types...>;
    using _Base::_Base;
  };

  template <typename... _Types>
  using _Move_ctor_alias =
      _Move_ctor_base<_Traits<_Types...>::_S_trivial_move_ctor, _Types...>;

  template <bool, typename... _Types>
  struct _Copy_assign_base : _Move_ctor_alias<_Types...> {
    using _Base = _Move_ctor_alias<_Types...>;
    using _Base::_Base;

    constexpr _Copy_assign_base &
    operator=(const _Copy_assign_base &__rhs) noexcept(
        _Traits<_Types...>::_S_nothrow_copy_assign) {
      __variant::__raw_idx_visit(
          [this](auto &&__rhs_mem, auto __rhs_index) mutable {
            constexpr size_t __j = __rhs_index;
            if constexpr (__j == variant_npos)
              this->_M_reset();
            else if (this->_M_index == __j)
              __variant::__get<__j>(*this) = __rhs_mem;
            else {
              using _Tj = typename _Nth_type<__j, _Types...>::type;
              if constexpr (is_nothrow_copy_constructible_v<_Tj> ||
                            !is_nothrow_move_constructible_v<_Tj>)
                __variant::__emplace<__j>(*this, __rhs_mem);
              else {
                using _Variant = variant<_Types...>;
                _Variant &__self = __variant_cast<_Types...>(*this);
                __self = _Variant(in_place_index<__j>, __rhs_mem);
              }
            }
          },
          __variant_cast<_Types...>(__rhs));
      return *this;
    }

    _Copy_assign_base(const _Copy_assign_base &) = default;
    _Copy_assign_base(_Copy_assign_base &&) = default;
    _Copy_assign_base &operator=(_Copy_assign_base &&) = default;
  };

  template <typename... _Types>
  struct _Copy_assign_base<true, _Types...> : _Move_ctor_alias<_Types...> {
    using _Base = _Move_ctor_alias<_Types...>;
    using _Base::_Base;
  };

  template <typename... _Types>
  using _Copy_assign_alias =
      _Copy_assign_base<_Traits<_Types...>::_S_trivial_copy_assign, _Types...>;

  template <bool, typename... _Types>
  struct _Move_assign_base : _Copy_assign_alias<_Types...> {
    using _Base = _Copy_assign_alias<_Types...>;
    using _Base::_Base;

    constexpr _Move_assign_base &operator=(_Move_assign_base &&__rhs) noexcept(
        _Traits<_Types...>::_S_nothrow_move_assign) {
      __variant::__raw_idx_visit(
          [this](auto &&__rhs_mem, auto __rhs_index) mutable {
            constexpr size_t __j = __rhs_index;
            if constexpr (__j != variant_npos) {
              if (this->_M_index == __j)
                __variant::__get<__j>(*this) = std::move(__rhs_mem);
              else {
                using _Tj = typename _Nth_type<__j, _Types...>::type;
                if constexpr (is_nothrow_move_constructible_v<_Tj>)
                  __variant::__emplace<__j>(*this, std::move(__rhs_mem));
                else {
                  using _Variant = variant<_Types...>;
                  _Variant &__self = __variant_cast<_Types...>(*this);
                  __self.template emplace<__j>(std::move(__rhs_mem));
                }
              }
            } else
              this->_M_reset();
          },
          __variant_cast<_Types...>(__rhs));
      return *this;
    }

    _Move_assign_base(const _Move_assign_base &) = default;
    _Move_assign_base(_Move_assign_base &&) = default;
    _Move_assign_base &operator=(const _Move_assign_base &) = default;
  };

  template <typename... _Types>
  struct _Move_assign_base<true, _Types...> : _Copy_assign_alias<_Types...> {
    using _Base = _Copy_assign_alias<_Types...>;
    using _Base::_Base;
  };

  template <typename... _Types>
  using _Move_assign_alias =
      _Move_assign_base<_Traits<_Types...>::_S_trivial_move_assign, _Types...>;

  template <typename... _Types>
  struct _Variant_base : _Move_assign_alias<_Types...> {
    using _Base = _Move_assign_alias<_Types...>;

    constexpr _Variant_base() noexcept(
        _Traits<_Types...>::_S_nothrow_default_ctor)
        : _Variant_base(in_place_index<0>) {}

    template <size_t _Np, typename... _Args>
    constexpr explicit _Variant_base(in_place_index_t<_Np> __i,
                                     _Args &&...__args)
        : _Base(__i, std::forward<_Args>(__args)...) {}

    _Variant_base(const _Variant_base &) = default;
    _Variant_base(_Variant_base &&) = default;
    _Variant_base &operator=(const _Variant_base &) = default;
    _Variant_base &operator=(_Variant_base &&) = default;
  };

  template <typename _Tp, typename... _Types>
  inline constexpr bool __exactly_once =
      std::__find_uniq_type_in_pack<_Tp, _Types...>() < sizeof...(_Types);

  template <typename _Ti> struct _Arr {
    _Ti _M_x[1];
  };

  template <size_t _Ind, typename _Tp, typename _Ti, typename = void>
  struct _Build_FUN {

    void _S_fun() = delete;
  };

  template <size_t _Ind, typename _Tp, typename _Ti>
  struct _Build_FUN<_Ind, _Tp, _Ti,
                    void_t<decltype(_Arr<_Ti>{{std::declval<_Tp>()}})>> {

    static integral_constant<size_t, _Ind> _S_fun(_Ti);
  };

  template <typename _Tp, typename _Variant,
            typename = make_index_sequence<variant_size_v<_Variant>>>
  struct _Build_FUNs;

  template <typename _Tp, typename... _Ti, size_t... _Ind>
  struct _Build_FUNs<_Tp, variant<_Ti...>, index_sequence<_Ind...>>
      : _Build_FUN<_Ind, _Tp, _Ti>... {
    using _Build_FUN<_Ind, _Tp, _Ti>::_S_fun...;
  };

  template <typename _Tp, typename _Variant>
  using _FUN_type =
      decltype(_Build_FUNs<_Tp, _Variant>::_S_fun(std::declval<_Tp>()));

  template <typename _Tp, typename _Variant, typename = void>
  inline constexpr size_t __accepted_index = variant_npos;

  template <typename _Tp, typename _Variant>
  inline constexpr size_t
      __accepted_index<_Tp, _Variant, void_t<_FUN_type<_Tp, _Variant>>> =
          _FUN_type<_Tp, _Variant>::value;

  template <typename _Maybe_variant_cookie, typename _Variant,
            typename = __remove_cvref_t<_Variant>>
  inline constexpr bool __extra_visit_slot_needed = false;

  template <typename _Var, typename... _Types>
  inline constexpr bool
      __extra_visit_slot_needed<__variant_cookie, _Var, variant<_Types...>> =
          !__variant::__never_valueless<_Types...>();

  template <typename _Var, typename... _Types>
  inline constexpr bool __extra_visit_slot_needed<__variant_idx_cookie, _Var,
                                                  variant<_Types...>> =
      !__variant::__never_valueless<_Types...>();

  template <typename _Tp, size_t... _Dimensions> struct _Multi_array;

  template <typename _Tp> struct _Multi_array<_Tp> {
    template <typename> struct __untag_result : false_type {
      using element_type = _Tp;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wignored-qualifiers"
    template <typename... _Args>
    struct __untag_result<const void (*)(_Args...)> : false_type {
      using element_type = void (*)(_Args...);
    };
#pragma GCC diagnostic pop

    template <typename... _Args>
    struct __untag_result<__variant_cookie (*)(_Args...)> : false_type {
      using element_type = void (*)(_Args...);
    };

    template <typename... _Args>
    struct __untag_result<__variant_idx_cookie (*)(_Args...)> : false_type {
      using element_type = void (*)(_Args...);
    };

    template <typename _Res, typename... _Args>
    struct __untag_result<__deduce_visit_result<_Res> (*)(_Args...)>
        : true_type {
      using element_type = _Res (*)(_Args...);
    };

    using __result_is_deduced = __untag_result<_Tp>;

    constexpr const typename __untag_result<_Tp>::element_type &
    _M_access() const {
      return _M_data;
    }

    typename __untag_result<_Tp>::element_type _M_data;
  };

  template <typename _Ret, typename _Visitor, typename... _Variants,
            size_t __first, size_t... __rest>
  struct _Multi_array<_Ret (*)(_Visitor, _Variants...), __first, __rest...> {
    static constexpr size_t __index =
        sizeof...(_Variants) - sizeof...(__rest) - 1;

    using _Variant = typename _Nth_type<__index, _Variants...>::type;

    static constexpr int __do_cookie =
        __extra_visit_slot_needed<_Ret, _Variant> ? 1 : 0;

    using _Tp = _Ret (*)(_Visitor, _Variants...);

    template <typename... _Args>
    constexpr decltype(auto) _M_access(size_t __first_index,
                                       _Args... __rest_indices) const {
      return _M_arr[__first_index + __do_cookie]._M_access(__rest_indices...);
    }

    _Multi_array<_Tp, __rest...> _M_arr[__first + __do_cookie];
  };
# 949 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/variant" 3
  template <typename _Array_type, typename _Index_seq> struct __gen_vtable_impl;
# 959 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/variant" 3
  template <typename _Result_type, typename _Visitor, size_t... __dimensions,
            typename... _Variants, size_t... __indices>
  struct __gen_vtable_impl<
      _Multi_array<_Result_type (*)(_Visitor, _Variants...), __dimensions...>,
      std::index_sequence<__indices...>> {
    using _Next = remove_reference_t<
        typename _Nth_type<sizeof...(__indices), _Variants...>::type>;
    using _Array_type =
        _Multi_array<_Result_type (*)(_Visitor, _Variants...), __dimensions...>;

    static constexpr _Array_type _S_apply() {
      _Array_type __vtable{};
      _S_apply_all_alts(__vtable, make_index_sequence<variant_size_v<_Next>>());
      return __vtable;
    }

    template <size_t... __var_indices>
    static constexpr void
    _S_apply_all_alts(_Array_type &__vtable,
                      std::index_sequence<__var_indices...>) {
      if constexpr (__extra_visit_slot_needed<_Result_type, _Next>)
        (_S_apply_single_alt<true, __var_indices>(
             __vtable._M_arr[__var_indices + 1], &(__vtable._M_arr[0])),
         ...);
      else
        (_S_apply_single_alt<false, __var_indices>(
             __vtable._M_arr[__var_indices]),
         ...);
    }

    template <bool __do_cookie, size_t __index, typename _Tp>
    static constexpr void _S_apply_single_alt(_Tp &__element,
                                              _Tp *__cookie_element = nullptr) {
      if constexpr (__do_cookie) {
        __element = __gen_vtable_impl<
            _Tp, std::index_sequence<__indices..., __index>>::_S_apply();
        *__cookie_element = __gen_vtable_impl<
            _Tp, std::index_sequence<__indices..., variant_npos>>::_S_apply();
      } else {
        auto __tmp_element = __gen_vtable_impl<
            remove_reference_t<decltype(__element)>,
            std::index_sequence<__indices..., __index>>::_S_apply();
        static_assert(is_same_v<_Tp, decltype(__tmp_element)>,
                      "std::visit requires the visitor to have the same "
                      "return type for all alternatives of a variant");
        __element = __tmp_element;
      }
    }
  };

  template <typename _Result_type, typename _Visitor, typename... _Variants,
            size_t... __indices>
  struct __gen_vtable_impl<
      _Multi_array<_Result_type (*)(_Visitor, _Variants...)>,
      std::index_sequence<__indices...>> {
    using _Array_type = _Multi_array<_Result_type (*)(_Visitor, _Variants...)>;

    template <size_t __index, typename _Variant>
    static constexpr decltype(auto)
    __element_by_index_or_cookie(_Variant &&__var) noexcept {
      if constexpr (__index != variant_npos)
        return __variant::__get<__index>(std::forward<_Variant>(__var));
      else
        return __variant_cookie{};
    }

    static constexpr decltype(auto) __visit_invoke(_Visitor &&__visitor,
                                                   _Variants... __vars) {
      if constexpr (is_same_v<_Result_type, __variant_idx_cookie>)

        std::__invoke(std::forward<_Visitor>(__visitor),
                      __element_by_index_or_cookie<__indices>(
                          std::forward<_Variants>(__vars))...,
                      integral_constant<size_t, __indices>()...);
      else if constexpr (is_same_v<_Result_type, __variant_cookie>)

        std::__invoke(std::forward<_Visitor>(__visitor),
                      __element_by_index_or_cookie<__indices>(
                          std::forward<_Variants>(__vars))...);
      else if constexpr (_Array_type::__result_is_deduced::value)

        return std::__invoke(std::forward<_Visitor>(__visitor),
                             __element_by_index_or_cookie<__indices>(
                                 std::forward<_Variants>(__vars))...);
      else
        return std::__invoke_r<_Result_type>(
            std::forward<_Visitor>(__visitor),
            __variant::__get<__indices>(std::forward<_Variants>(__vars))...);
    }

    static constexpr auto _S_apply() {
      if constexpr (_Array_type::__result_is_deduced::value) {
        constexpr bool __visit_ret_type_mismatch =
            !is_same_v<typename _Result_type::type,
                       decltype(__visit_invoke(std::declval<_Visitor>(),
                                               std::declval<_Variants>()...))>;
        if constexpr (__visit_ret_type_mismatch) {
          struct __cannot_match {};
          return __cannot_match{};
        } else
          return _Array_type{&__visit_invoke};
      } else
        return _Array_type{&__visit_invoke};
    }
  };

  template <typename _Result_type, typename _Visitor, typename... _Variants>
  struct __gen_vtable {
    using _Array_type =
        _Multi_array<_Result_type (*)(_Visitor, _Variants...),
                     variant_size_v<remove_reference_t<_Variants>>...>;

    static constexpr _Array_type _S_vtable =
        __gen_vtable_impl<_Array_type, std::index_sequence<>>::_S_apply();
  };

  template <size_t _Np, typename _Tp> struct _Base_dedup : public _Tp {};

  template <typename _Variant, typename __indices> struct _Variant_hash_base;

  template <typename... _Types, size_t... __indices>
  struct _Variant_hash_base<variant<_Types...>,
                            std::index_sequence<__indices...>>
      : _Base_dedup<__indices, __poison_hash<remove_const_t<_Types>>>... {};

  template <size_t _Np, typename _Variant,
            typename _AsV = decltype(__variant::__as(std::declval<_Variant>())),
            typename _Tp = variant_alternative_t<_Np, remove_reference_t<_AsV>>>
  using __get_t =
      __conditional_t<is_lvalue_reference_v<_Variant>, _Tp &, _Tp &&>;

  template <typename _Visitor, typename... _Variants>
  using __visit_result_t = invoke_result_t<_Visitor, __get_t<0, _Variants>...>;

  template <typename _Tp, typename... _Types>
  constexpr inline bool __same_types = (is_same_v<_Tp, _Types> && ...);

  template <typename _Visitor, typename _Variant, size_t... _Idxs>
  constexpr bool __check_visitor_results(std::index_sequence<_Idxs...>) {
    return __same_types<invoke_result_t<_Visitor, __get_t<_Idxs, _Variant>>...>;
  }

  } // namespace __variant
  } // namespace __detail

  template <typename _Tp, typename... _Types>
  constexpr bool holds_alternative(const variant<_Types...> &__v) noexcept {
    static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
                  "T must occur exactly once in alternatives");
    return __v.index() == std::__find_uniq_type_in_pack<_Tp, _Types...>();
  }

  template <typename _Tp, typename... _Types>
  constexpr _Tp &get(variant<_Types...> & __v) {
    static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
                  "T must occur exactly once in alternatives");
    constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();
    return std::get<__n>(__v);
  }

  template <typename _Tp, typename... _Types>
  constexpr _Tp &&get(variant<_Types...> && __v) {
    static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
                  "T must occur exactly once in alternatives");
    constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();
    return std::get<__n>(std::move(__v));
  }

  template <typename _Tp, typename... _Types>
  constexpr const _Tp &get(const variant<_Types...> &__v) {
    static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
                  "T must occur exactly once in alternatives");
    constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();
    return std::get<__n>(__v);
  }

  template <typename _Tp, typename... _Types>
  constexpr const _Tp &&get(const variant<_Types...> &&__v) {
    static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
                  "T must occur exactly once in alternatives");
    constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();
    return std::get<__n>(std::move(__v));
  }

  template <size_t _Np, typename... _Types>
  constexpr add_pointer_t<variant_alternative_t<_Np, variant<_Types...>>>
  get_if(variant<_Types...> * __ptr) noexcept {
    using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;
    static_assert(_Np < sizeof...(_Types),
                  "The index must be in [0, number of alternatives)");
    static_assert(!is_void_v<_Alternative_type>, "_Tp must not be void");
    if (__ptr && __ptr->index() == _Np)
      return std::addressof(__detail::__variant::__get<_Np>(*__ptr));
    return nullptr;
  }

  template <size_t _Np, typename... _Types>
  constexpr add_pointer_t<const variant_alternative_t<_Np, variant<_Types...>>>
  get_if(const variant<_Types...> *__ptr) noexcept {
    using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;
    static_assert(_Np < sizeof...(_Types),
                  "The index must be in [0, number of alternatives)");
    static_assert(!is_void_v<_Alternative_type>, "_Tp must not be void");
    if (__ptr && __ptr->index() == _Np)
      return std::addressof(__detail::__variant::__get<_Np>(*__ptr));
    return nullptr;
  }

  template <typename _Tp, typename... _Types>
  constexpr add_pointer_t<_Tp> get_if(variant<_Types...> * __ptr) noexcept {
    static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
                  "T must occur exactly once in alternatives");
    static_assert(!is_void_v<_Tp>, "_Tp must not be void");
    constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();
    return std::get_if<__n>(__ptr);
  }

  template <typename _Tp, typename... _Types>
  constexpr add_pointer_t<const _Tp> get_if(
      const variant<_Types...> *__ptr) noexcept {
    static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
                  "T must occur exactly once in alternatives");
    static_assert(!is_void_v<_Tp>, "_Tp must not be void");
    constexpr size_t __n = std::__find_uniq_type_in_pack<_Tp, _Types...>();
    return std::get_if<__n>(__ptr);
  }

  struct monostate {};
# 1264 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/variant" 3
  template <typename... _Types>
  constexpr bool operator<(const variant<_Types...> &__lhs,
                           const variant<_Types...> &__rhs) {
    bool __ret = true;
    __detail::__variant::__raw_idx_visit(
        [&__ret, &__lhs](auto &&__rhs_mem, auto __rhs_index) mutable {
          if constexpr (__rhs_index != variant_npos) {
            if (__lhs.index() == __rhs_index) {
              auto &__this_mem = std::get<__rhs_index>(__lhs);
              __ret = __this_mem < __rhs_mem;
            } else
              __ret = (__lhs.index() + 1) < (__rhs_index + 1);
          } else
            __ret = (__lhs.index() + 1) < (__rhs_index + 1);
        },
        __rhs);
    return __ret;
  }
  template <typename... _Types>
  constexpr bool operator<=(const variant<_Types...> &__lhs,
                            const variant<_Types...> &__rhs) {
    bool __ret = true;
    __detail::__variant::__raw_idx_visit(
        [&__ret, &__lhs](auto &&__rhs_mem, auto __rhs_index) mutable {
          if constexpr (__rhs_index != variant_npos) {
            if (__lhs.index() == __rhs_index) {
              auto &__this_mem = std::get<__rhs_index>(__lhs);
              __ret = __this_mem <= __rhs_mem;
            } else
              __ret = (__lhs.index() + 1) <= (__rhs_index + 1);
          } else
            __ret = (__lhs.index() + 1) <= (__rhs_index + 1);
        },
        __rhs);
    return __ret;
  }
  template <typename... _Types>
  constexpr bool operator==(const variant<_Types...> &__lhs,
                            const variant<_Types...> &__rhs) {
    bool __ret = true;
    __detail::__variant::__raw_idx_visit(
        [&__ret, &__lhs](auto &&__rhs_mem, auto __rhs_index) mutable {
          if constexpr (__rhs_index != variant_npos) {
            if (__lhs.index() == __rhs_index) {
              auto &__this_mem = std::get<__rhs_index>(__lhs);
              __ret = __this_mem == __rhs_mem;
            } else
              __ret = (__lhs.index() + 1) == (__rhs_index + 1);
          } else
            __ret = (__lhs.index() + 1) == (__rhs_index + 1);
        },
        __rhs);
    return __ret;
  }
  template <typename... _Types>
  constexpr bool operator!=(const variant<_Types...> &__lhs,
                            const variant<_Types...> &__rhs) {
    bool __ret = true;
    __detail::__variant::__raw_idx_visit(
        [&__ret, &__lhs](auto &&__rhs_mem, auto __rhs_index) mutable {
          if constexpr (__rhs_index != variant_npos) {
            if (__lhs.index() == __rhs_index) {
              auto &__this_mem = std::get<__rhs_index>(__lhs);
              __ret = __this_mem != __rhs_mem;
            } else
              __ret = (__lhs.index() + 1) != (__rhs_index + 1);
          } else
            __ret = (__lhs.index() + 1) != (__rhs_index + 1);
        },
        __rhs);
    return __ret;
  }
  template <typename... _Types>
  constexpr bool operator>=(const variant<_Types...> &__lhs,
                            const variant<_Types...> &__rhs) {
    bool __ret = true;
    __detail::__variant::__raw_idx_visit(
        [&__ret, &__lhs](auto &&__rhs_mem, auto __rhs_index) mutable {
          if constexpr (__rhs_index != variant_npos) {
            if (__lhs.index() == __rhs_index) {
              auto &__this_mem = std::get<__rhs_index>(__lhs);
              __ret = __this_mem >= __rhs_mem;
            } else
              __ret = (__lhs.index() + 1) >= (__rhs_index + 1);
          } else
            __ret = (__lhs.index() + 1) >= (__rhs_index + 1);
        },
        __rhs);
    return __ret;
  }
  template <typename... _Types>
  constexpr bool operator>(const variant<_Types...> &__lhs,
                           const variant<_Types...> &__rhs) {
    bool __ret = true;
    __detail::__variant::__raw_idx_visit(
        [&__ret, &__lhs](auto &&__rhs_mem, auto __rhs_index) mutable {
          if constexpr (__rhs_index != variant_npos) {
            if (__lhs.index() == __rhs_index) {
              auto &__this_mem = std::get<__rhs_index>(__lhs);
              __ret = __this_mem > __rhs_mem;
            } else
              __ret = (__lhs.index() + 1) > (__rhs_index + 1);
          } else
            __ret = (__lhs.index() + 1) > (__rhs_index + 1);
        },
        __rhs);
    return __ret;
  }

  constexpr bool operator==(monostate, monostate) noexcept { return true; }

  template <typename... _Types>
    requires(three_way_comparable<_Types> && ...)
  constexpr common_comparison_category_t<compare_three_way_result_t<_Types>...>
  operator<=>(const variant<_Types...> &__v, const variant<_Types...> &__w) {
    common_comparison_category_t<compare_three_way_result_t<_Types>...> __ret =
        strong_ordering::equal;

    __detail::__variant::__raw_idx_visit(
        [&__ret, &__v](auto &&__w_mem, auto __w_index) mutable {
          if constexpr (__w_index != variant_npos) {
            if (__v.index() == __w_index) {
              auto &__this_mem = std::get<__w_index>(__v);
              __ret = __this_mem <=> __w_mem;
              return;
            }
          }
          __ret = (__v.index() + 1) <=> (__w_index + 1);
        },
        __w);
    return __ret;
  }

  constexpr strong_ordering operator<=>(monostate, monostate) noexcept {
    return strong_ordering::equal;
  }
# 1312 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/variant" 3
  template <typename _Visitor, typename... _Variants>
  constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...> visit(
      _Visitor &&, _Variants && ...);

  template <typename... _Types>
  constexpr inline enable_if_t<(is_move_constructible_v<_Types> && ...) &&
                               (is_swappable_v<_Types> && ...)>
  swap(variant<_Types...> & __lhs,
       variant<_Types...> & __rhs) noexcept(noexcept(__lhs.swap(__rhs))) {
    __lhs.swap(__rhs);
  }

  template <typename... _Types>
  enable_if_t<!((is_move_constructible_v<_Types> && ...) &&
                (is_swappable_v<_Types> && ...))>
  swap(variant<_Types...> &, variant<_Types...> &) = delete;

  class bad_variant_access : public exception {
  public:
    bad_variant_access() noexcept {}

    const char *what() const noexcept override { return _M_reason; }

  private:
    bad_variant_access(const char *__reason) noexcept : _M_reason(__reason) {}

    const char *_M_reason = "bad variant access";

    friend void __throw_bad_variant_access(const char *__what);
  };

  inline void __throw_bad_variant_access(const char *__what) {
    (throw(bad_variant_access(__what)));
  }

  inline void __throw_bad_variant_access(bool __valueless) {
    if (__valueless) [[__unlikely__]]
      __throw_bad_variant_access("std::get: variant is valueless");
    else
      __throw_bad_variant_access("std::get: wrong index for variant");
  }

  template <typename... _Types>
  class variant : private __detail::__variant::_Variant_base<_Types...>,
                  private _Enable_default_constructor<
                      __detail::__variant::_Traits<_Types...>::_S_default_ctor,
                      variant<_Types...>>,
                  private _Enable_copy_move<
                      __detail::__variant::_Traits<_Types...>::_S_copy_ctor,
                      __detail::__variant::_Traits<_Types...>::_S_copy_assign,
                      __detail::__variant::_Traits<_Types...>::_S_move_ctor,
                      __detail::__variant::_Traits<_Types...>::_S_move_assign,
                      variant<_Types...>> {
  private:
    template <typename... _UTypes, typename _Tp>
    friend constexpr decltype(auto) __variant_cast(_Tp &&);

    static_assert(sizeof...(_Types) > 0,
                  "variant must have at least one alternative");
    static_assert(!(std::is_reference_v<_Types> || ...),
                  "variant must have no reference alternative");
    static_assert(!(std::is_void_v<_Types> || ...),
                  "variant must have no void alternative");

    using _Base = __detail::__variant::_Variant_base<_Types...>;
    using _Default_ctor_enabler = _Enable_default_constructor<
        __detail::__variant::_Traits<_Types...>::_S_default_ctor,
        variant<_Types...>>;

    template <typename _Tp>
    static constexpr bool __not_self =
        !is_same_v<__remove_cvref_t<_Tp>, variant>;

    template <typename _Tp>
    static constexpr bool __exactly_once =
        __detail::__variant::__exactly_once<_Tp, _Types...>;

    template <typename _Tp>
    static constexpr size_t __accepted_index =
        __detail::__variant::__accepted_index<_Tp, variant>;

    template <size_t _Np, typename = enable_if_t<(_Np < sizeof...(_Types))>>
    using __to_type = typename _Nth_type<_Np, _Types...>::type;

    template <typename _Tp, typename = enable_if_t<__not_self<_Tp>>>
    using __accepted_type = __to_type<__accepted_index<_Tp>>;

    template <typename _Tp>
    static constexpr size_t __index_of =
        std::__find_uniq_type_in_pack<_Tp, _Types...>();

    using _Traits = __detail::__variant::_Traits<_Types...>;

    template <typename _Tp> struct __is_in_place_tag : false_type {};
    template <typename _Tp>
    struct __is_in_place_tag<in_place_type_t<_Tp>> : true_type {};
    template <size_t _Np>
    struct __is_in_place_tag<in_place_index_t<_Np>> : true_type {};

    template <typename _Tp>
    static constexpr bool __not_in_place_tag =
        !__is_in_place_tag<__remove_cvref_t<_Tp>>::value;

  public:
    variant() = default;
    variant(const variant &__rhs) = default;
    variant(variant &&) = default;
    variant &operator=(const variant &) = default;
    variant &operator=(variant &&) = default;
    constexpr ~variant() = default;

    template <typename _Tp, typename = enable_if_t<sizeof...(_Types) != 0>,
              typename = enable_if_t<__not_in_place_tag<_Tp>>,
              typename _Tj = __accepted_type<_Tp &&>,
              typename = enable_if_t<__exactly_once<_Tj> &&
                                     is_constructible_v<_Tj, _Tp>>>
    constexpr variant(_Tp &&__t) noexcept(is_nothrow_constructible_v<_Tj, _Tp>)
        : variant(in_place_index<__accepted_index<_Tp>>,
                  std::forward<_Tp>(__t)) {}

    template <typename _Tp, typename... _Args,
              typename = enable_if_t<__exactly_once<_Tp> &&
                                     is_constructible_v<_Tp, _Args...>>>
    constexpr explicit variant(in_place_type_t<_Tp>, _Args &&...__args)
        : variant(in_place_index<__index_of<_Tp>>,
                  std::forward<_Args>(__args)...) {}

    template <typename _Tp, typename _Up, typename... _Args,
              typename = enable_if_t<
                  __exactly_once<_Tp> &&
                  is_constructible_v<_Tp, initializer_list<_Up> &, _Args...>>>
    constexpr explicit variant(in_place_type_t<_Tp>, initializer_list<_Up> __il,
                               _Args &&...__args)
        : variant(in_place_index<__index_of<_Tp>>, __il,
                  std::forward<_Args>(__args)...) {}

    template <size_t _Np, typename... _Args, typename _Tp = __to_type<_Np>,
              typename = enable_if_t<is_constructible_v<_Tp, _Args...>>>
    constexpr explicit variant(in_place_index_t<_Np>, _Args &&...__args)
        : _Base(in_place_index<_Np>, std::forward<_Args>(__args)...),
          _Default_ctor_enabler(_Enable_default_constructor_tag{}) {}

    template <size_t _Np, typename _Up, typename... _Args,
              typename _Tp = __to_type<_Np>,
              typename = enable_if_t<
                  is_constructible_v<_Tp, initializer_list<_Up> &, _Args...>>>
    constexpr explicit variant(in_place_index_t<_Np>,
                               initializer_list<_Up> __il, _Args &&...__args)
        : _Base(in_place_index<_Np>, __il, std::forward<_Args>(__args)...),
          _Default_ctor_enabler(_Enable_default_constructor_tag{}) {}

    template <typename _Tp>
    constexpr enable_if_t<
        __exactly_once<__accepted_type<_Tp &&>> &&
            is_constructible_v<__accepted_type<_Tp &&>, _Tp> &&
            is_assignable_v<__accepted_type<_Tp &&> &, _Tp>,
        variant &>
    operator=(_Tp &&__rhs) noexcept(
        is_nothrow_assignable_v<__accepted_type<_Tp &&> &, _Tp> &&
        is_nothrow_constructible_v<__accepted_type<_Tp &&>, _Tp>) {
      constexpr auto __index = __accepted_index<_Tp>;
      if (index() == __index)
        std::get<__index>(*this) = std::forward<_Tp>(__rhs);
      else {
        using _Tj = __accepted_type<_Tp &&>;
        if constexpr (is_nothrow_constructible_v<_Tj, _Tp> ||
                      !is_nothrow_move_constructible_v<_Tj>)
          this->emplace<__index>(std::forward<_Tp>(__rhs));
        else

          this->emplace<__index>(_Tj(std::forward<_Tp>(__rhs)));
      }
      return *this;
    }

    template <typename _Tp, typename... _Args>
    constexpr enable_if_t<
        is_constructible_v<_Tp, _Args...> && __exactly_once<_Tp>, _Tp &>
    emplace(_Args &&...__args) {
      constexpr size_t __index = __index_of<_Tp>;
      return this->emplace<__index>(std::forward<_Args>(__args)...);
    }

    template <typename _Tp, typename _Up, typename... _Args>
    constexpr enable_if_t<
        is_constructible_v<_Tp, initializer_list<_Up> &, _Args...> &&
            __exactly_once<_Tp>,
        _Tp &>
    emplace(initializer_list<_Up> __il, _Args &&...__args) {
      constexpr size_t __index = __index_of<_Tp>;
      return this->emplace<__index>(__il, std::forward<_Args>(__args)...);
    }

    template <size_t _Np, typename... _Args>
    constexpr enable_if_t<is_constructible_v<__to_type<_Np>, _Args...>,
                          __to_type<_Np> &>
    emplace(_Args &&...__args) {
      namespace __variant = std::__detail::__variant;
      using type = typename _Nth_type<_Np, _Types...>::type;

      if constexpr (is_nothrow_constructible_v<type, _Args...>) {
        __variant::__emplace<_Np>(*this, std::forward<_Args>(__args)...);
      } else if constexpr (is_scalar_v<type>) {

        const type __tmp(std::forward<_Args>(__args)...);

        __variant::__emplace<_Np>(*this, __tmp);
      } else if constexpr (__variant::_Never_valueless_alt<type>() &&
                           _Traits::_S_move_assign) {

        variant __tmp(in_place_index<_Np>, std::forward<_Args>(__args)...);

        *this = std::move(__tmp);
      } else {

        __variant::__emplace<_Np>(*this, std::forward<_Args>(__args)...);
      }
      return std::get<_Np>(*this);
    }

    template <size_t _Np, typename _Up, typename... _Args>
    constexpr enable_if_t<
        is_constructible_v<__to_type<_Np>, initializer_list<_Up> &, _Args...>,
        __to_type<_Np> &>
    emplace(initializer_list<_Up> __il, _Args &&...__args) {
      namespace __variant = std::__detail::__variant;
      using type = typename _Nth_type<_Np, _Types...>::type;

      if constexpr (is_nothrow_constructible_v<type, initializer_list<_Up> &,
                                               _Args...>) {
        __variant::__emplace<_Np>(*this, __il, std::forward<_Args>(__args)...);
      } else if constexpr (__variant::_Never_valueless_alt<type>() &&
                           _Traits::_S_move_assign) {

        variant __tmp(in_place_index<_Np>, __il,
                      std::forward<_Args>(__args)...);

        *this = std::move(__tmp);
      } else {

        __variant::__emplace<_Np>(*this, __il, std::forward<_Args>(__args)...);
      }
      return std::get<_Np>(*this);
    }

    template <size_t _Np, typename... _Args>
    enable_if_t<!(_Np < sizeof...(_Types))> emplace(_Args &&...) = delete;

    template <typename _Tp, typename... _Args>
    enable_if_t<!__exactly_once<_Tp>> emplace(_Args &&...) = delete;

    constexpr bool valueless_by_exception() const noexcept {
      return !this->_M_valid();
    }

    constexpr size_t index() const noexcept {
      using __index_type = typename _Base::__index_type;
      if constexpr (__detail::__variant::__never_valueless<_Types...>())
        return this->_M_index;
      else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
        return make_signed_t<__index_type>(this->_M_index);
      else
        return size_t(__index_type(this->_M_index + 1)) - 1;
    }

    constexpr void swap(variant &__rhs) noexcept(
        (__is_nothrow_swappable<_Types>::value && ...) &&
        is_nothrow_move_constructible_v<variant>) {
      static_assert((is_move_constructible_v<_Types> && ...));

      if (__rhs.valueless_by_exception()) [[__unlikely__]] {
        if (!this->valueless_by_exception()) [[__likely__]]
          __rhs.swap(*this);
        return;
      }

      namespace __variant = __detail::__variant;

      __variant::__raw_idx_visit(
          [this, &__rhs](auto &&__rhs_mem, auto __rhs_index) mutable {
            constexpr size_t __j = __rhs_index;
            if constexpr (__j != variant_npos) {
              if (this->index() == __j) {
                using std::swap;
                swap(std::get<__j>(*this), __rhs_mem);
              } else {
                auto __tmp(std::move(__rhs_mem));

                if constexpr (_Traits::_S_trivial_move_assign)
                  __rhs = std::move(*this);
                else
                  __variant::__raw_idx_visit(
                      [&__rhs](auto &&__this_mem, auto __this_index) mutable {
                        constexpr size_t __k = __this_index;
                        if constexpr (__k != variant_npos)
                          __variant::__emplace<__k>(__rhs,
                                                    std::move(__this_mem));
                      },
                      *this);

                __variant::__emplace<__j>(*this, std::move(__tmp));
              }
            }
          },
          __rhs);
    }

  private:
    template <size_t _Np, typename _Vp>
    friend constexpr decltype(auto)
    __detail::__variant::__get(_Vp &&__v) noexcept;

    template <typename... _Tp>
    friend constexpr bool operator<(const variant<_Tp...> &__lhs,
                                    const variant<_Tp...> &__rhs);
    template <typename... _Tp>
    friend constexpr bool operator<=(const variant<_Tp...> &__lhs,
                                     const variant<_Tp...> &__rhs);
    template <typename... _Tp>
    friend constexpr bool operator==(const variant<_Tp...> &__lhs,
                                     const variant<_Tp...> &__rhs);
    template <typename... _Tp>
    friend constexpr bool operator!=(const variant<_Tp...> &__lhs,
                                     const variant<_Tp...> &__rhs);
    template <typename... _Tp>
    friend constexpr bool operator>=(const variant<_Tp...> &__lhs,
                                     const variant<_Tp...> &__rhs);
    template <typename... _Tp>
    friend constexpr bool operator>(const variant<_Tp...> &__lhs,
                                    const variant<_Tp...> &__rhs);
  };

  template <size_t _Np, typename... _Types>
  constexpr variant_alternative_t<_Np, variant<_Types...>> &get(
      variant<_Types...> & __v) {
    static_assert(_Np < sizeof...(_Types),
                  "The index must be in [0, number of alternatives)");
    if (__v.index() != _Np)
      __throw_bad_variant_access(__v.valueless_by_exception());
    return __detail::__variant::__get<_Np>(__v);
  }

  template <size_t _Np, typename... _Types>
  constexpr variant_alternative_t<_Np, variant<_Types...>> &&get(
      variant<_Types...> && __v) {
    static_assert(_Np < sizeof...(_Types),
                  "The index must be in [0, number of alternatives)");
    if (__v.index() != _Np)
      __throw_bad_variant_access(__v.valueless_by_exception());
    return __detail::__variant::__get<_Np>(std::move(__v));
  }

  template <size_t _Np, typename... _Types>
  constexpr const variant_alternative_t<_Np, variant<_Types...>> &get(
      const variant<_Types...> &__v) {
    static_assert(_Np < sizeof...(_Types),
                  "The index must be in [0, number of alternatives)");
    if (__v.index() != _Np)
      __throw_bad_variant_access(__v.valueless_by_exception());
    return __detail::__variant::__get<_Np>(__v);
  }

  template <size_t _Np, typename... _Types>
  constexpr const variant_alternative_t<_Np, variant<_Types...>> &&get(
      const variant<_Types...> &&__v) {
    static_assert(_Np < sizeof...(_Types),
                  "The index must be in [0, number of alternatives)");
    if (__v.index() != _Np)
      __throw_bad_variant_access(__v.valueless_by_exception());
    return __detail::__variant::__get<_Np>(std::move(__v));
  }

  template <typename _Result_type, typename _Visitor, typename... _Variants>
  constexpr decltype(auto) __do_visit(_Visitor && __visitor,
                                      _Variants && ...__variants) {

    if constexpr (sizeof...(_Variants) == 0) {
      if constexpr (is_void_v<_Result_type>)
        return (void)std::forward<_Visitor>(__visitor)();
      else
        return std::forward<_Visitor>(__visitor)();
    } else {
      constexpr size_t __max = 11;

      using _V0 = typename _Nth_type<0, _Variants...>::type;

      constexpr auto __n = variant_size_v<remove_reference_t<_V0>>;

      if constexpr (sizeof...(_Variants) > 1 || __n > __max) {

        constexpr auto &__vtable =
            __detail::__variant::__gen_vtable<_Result_type, _Visitor &&,
                                              _Variants &&...>::_S_vtable;

        auto __func_ptr = __vtable._M_access(__variants.index()...);
        return (*__func_ptr)(std::forward<_Visitor>(__visitor),
                             std::forward<_Variants>(__variants)...);
      } else {

        _V0 &__v0 = [](_V0 &__v, ...) -> _V0 & { return __v; }(__variants...);

        using __detail::__variant::__gen_vtable_impl;
        using __detail::__variant::_Multi_array;
        using _Ma = _Multi_array<_Result_type (*)(_Visitor &&, _V0 &&)>;
# 1813 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/variant" 3
        switch (__v0.index()) {
        case 0: {
          if constexpr (0 < __n) {
            return __gen_vtable_impl<_Ma, index_sequence<0>>::__visit_invoke(
                std::forward<_Visitor>(__visitor), std::forward<_V0>(__v0));
          } else
            __builtin_unreachable();
        }
        case 1: {
          if constexpr (1 < __n) {
            return __gen_vtable_impl<_Ma, index_sequence<1>>::__visit_invoke(
                std::forward<_Visitor>(__visitor), std::forward<_V0>(__v0));
          } else
            __builtin_unreachable();
        }
        case 2: {
          if constexpr (2 < __n) {
            return __gen_vtable_impl<_Ma, index_sequence<2>>::__visit_invoke(
                std::forward<_Visitor>(__visitor), std::forward<_V0>(__v0));
          } else
            __builtin_unreachable();
        }
        case 3: {
          if constexpr (3 < __n) {
            return __gen_vtable_impl<_Ma, index_sequence<3>>::__visit_invoke(
                std::forward<_Visitor>(__visitor), std::forward<_V0>(__v0));
          } else
            __builtin_unreachable();
        }
        case 4: {
          if constexpr (4 < __n) {
            return __gen_vtable_impl<_Ma, index_sequence<4>>::__visit_invoke(
                std::forward<_Visitor>(__visitor), std::forward<_V0>(__v0));
          } else
            __builtin_unreachable();
        }
        case 5: {
          if constexpr (5 < __n) {
            return __gen_vtable_impl<_Ma, index_sequence<5>>::__visit_invoke(
                std::forward<_Visitor>(__visitor), std::forward<_V0>(__v0));
          } else
            __builtin_unreachable();
        }
        case 6: {
          if constexpr (6 < __n) {
            return __gen_vtable_impl<_Ma, index_sequence<6>>::__visit_invoke(
                std::forward<_Visitor>(__visitor), std::forward<_V0>(__v0));
          } else
            __builtin_unreachable();
        }
        case 7: {
          if constexpr (7 < __n) {
            return __gen_vtable_impl<_Ma, index_sequence<7>>::__visit_invoke(
                std::forward<_Visitor>(__visitor), std::forward<_V0>(__v0));
          } else
            __builtin_unreachable();
        }
        case 8: {
          if constexpr (8 < __n) {
            return __gen_vtable_impl<_Ma, index_sequence<8>>::__visit_invoke(
                std::forward<_Visitor>(__visitor), std::forward<_V0>(__v0));
          } else
            __builtin_unreachable();
        }
        case 9: {
          if constexpr (9 < __n) {
            return __gen_vtable_impl<_Ma, index_sequence<9>>::__visit_invoke(
                std::forward<_Visitor>(__visitor), std::forward<_V0>(__v0));
          } else
            __builtin_unreachable();
        }
        case 10: {
          if constexpr (10 < __n) {
            return __gen_vtable_impl<_Ma, index_sequence<10>>::__visit_invoke(
                std::forward<_Visitor>(__visitor), std::forward<_V0>(__v0));
          } else
            __builtin_unreachable();
        }
        case variant_npos:
          using __detail::__variant::__variant_cookie;
          using __detail::__variant::__variant_idx_cookie;
          if constexpr (is_same_v<_Result_type, __variant_idx_cookie> ||
                        is_same_v<_Result_type, __variant_cookie>) {
            using _Npos = index_sequence<variant_npos>;
            return __gen_vtable_impl<_Ma, _Npos>::__visit_invoke(
                std::forward<_Visitor>(__visitor), std::forward<_V0>(__v0));
          } else
            __builtin_unreachable();
        default:
          __builtin_unreachable();
        }
      }
    }
  }

  template <typename _Visitor, typename... _Variants>
  constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...> visit(
      _Visitor && __visitor, _Variants && ...__variants) {
    namespace __variant = std::__detail::__variant;

    if ((__variant::__as(__variants).valueless_by_exception() || ...))
      __throw_bad_variant_access("std::visit: variant is valueless");

    using _Result_type =
        __detail::__variant::__visit_result_t<_Visitor, _Variants...>;

    using _Tag = __detail::__variant::__deduce_visit_result<_Result_type>;

    if constexpr (sizeof...(_Variants) == 1) {
      using _Vp = decltype(__variant::__as(std::declval<_Variants>()...));

      constexpr bool __visit_rettypes_match =
          __detail::__variant::__check_visitor_results<_Visitor, _Vp>(
              make_index_sequence<variant_size_v<remove_reference_t<_Vp>>>());
      if constexpr (!__visit_rettypes_match) {
        static_assert(__visit_rettypes_match,
                      "std::visit requires the visitor to have the same "
                      "return type for all alternatives of a variant");
        return;
      } else
        return std::__do_visit<_Tag>(std::forward<_Visitor>(__visitor),
                                     static_cast<_Vp>(__variants)...);
    } else
      return std::__do_visit<_Tag>(
          std::forward<_Visitor>(__visitor),
          __variant::__as(std::forward<_Variants>(__variants))...);
  }

  template <typename _Res, typename _Visitor, typename... _Variants>
  constexpr _Res visit(_Visitor && __visitor, _Variants && ...__variants) {
    namespace __variant = std::__detail::__variant;

    if ((__variant::__as(__variants).valueless_by_exception() || ...))
      __throw_bad_variant_access("std::visit<R>: variant is valueless");

    return std::__do_visit<_Res>(
        std::forward<_Visitor>(__visitor),
        __variant::__as(std::forward<_Variants>(__variants))...);
  }

  template <bool, typename... _Types> struct __variant_hash_call_base_impl {
    size_t operator()(const variant<_Types...> &__t) const
        noexcept((is_nothrow_invocable_v<hash<decay_t<_Types>>, _Types> &&
                  ...)) {
      size_t __ret;
      __detail::__variant::__raw_visit(
          [&__t, &__ret](auto &&__t_mem) mutable {
            using _Type = __remove_cvref_t<decltype(__t_mem)>;
            if constexpr (!is_same_v<_Type,
                                     __detail::__variant::__variant_cookie>)
              __ret = std::hash<size_t>{}(__t.index()) +
                      std::hash<_Type>{}(__t_mem);
            else
              __ret = std::hash<size_t>{}(__t.index());
          },
          __t);
      return __ret;
    }
  };

  template <typename... _Types>
  struct __variant_hash_call_base_impl<false, _Types...> {};

  template <typename... _Types>
  using __variant_hash_call_base = __variant_hash_call_base_impl<
      (__poison_hash<remove_const_t<_Types>>::__enable_hash_call && ...),
      _Types...>;

  template <typename... _Types>
  struct hash<variant<_Types...>>
      : private __detail::__variant::_Variant_hash_base<
            variant<_Types...>, std::index_sequence_for<_Types...>>,
        public __variant_hash_call_base<_Types...> {
    using result_type [[__deprecated__]] = size_t;
    using argument_type [[__deprecated__]] = variant<_Types...>;
  };

  template <> struct hash<monostate> {
    using result_type [[__deprecated__]] = size_t;
    using argument_type [[__deprecated__]] = monostate;

    size_t operator()(const monostate &) const noexcept {
      constexpr size_t __magic_monostate_hash = -7777;
      return __magic_monostate_hash;
    }
  };

  template <typename... _Types>
  struct __is_fast_hash<hash<variant<_Types...>>>
      : bool_constant<(__is_fast_hash<_Types>::value && ...)> {};

} // namespace std
# 30 "./../stdexec/include/stdexec/__detail/__transform_completion_signatures.hpp" 2

namespace stdexec {
# 48 "./../stdexec/include/stdexec/__detail/__transform_completion_signatures.hpp"
template <class _Sender, class... _Env>
  requires sender_in<_Sender, _Env...>
using completion_signatures_of_t =
    __completion_signatures_of_t<_Sender, _Env...>;

struct __not_a_variant {
  __not_a_variant() = delete;
};

template <class... _Ts>
using __std_variant =
    __minvoke_if_c<sizeof...(_Ts) != 0,
                   __mtransform<__q1<__decay_t>, __munique<__qq<std::variant>>>,
                   __mconst<__not_a_variant>, _Ts...>;

template <class... _Ts>
using __nullable_std_variant =
    __mcall<__munique<__mbind_front<__qq<std::variant>, std::monostate>>,
            __decay_t<_Ts>...>;

template <class... _Ts>
using __decayed_std_tuple = __meval<std::tuple, __decay_t<_Ts>...>;

namespace __sigs {

template <class _Tag, class... _Args>
auto __normalize_sig_impl(_Args &&...) -> _Tag (*)(_Args...);

template <class _Tag, class... _Args>
auto __normalize_sig(_Tag (*)(_Args...))
    -> decltype(__sigs::__normalize_sig_impl<_Tag>(__declval<_Args>()...));

template <class... _Sigs>
auto __repack_completions(_Sigs *...) -> completion_signatures<_Sigs...>;

template <class... _Sigs>
auto __normalize_completions(completion_signatures<_Sigs...> *)
    -> decltype(__sigs::__repack_completions(
        __sigs::__normalize_sig(static_cast<_Sigs *>(nullptr))...));

template <class _Completions>
using __normalize_completions_t = decltype(__sigs::__normalize_completions(
    static_cast<_Completions *>(nullptr)));
} // namespace __sigs

template <class... _SigPtrs>
using __completion_signature_ptrs =
    decltype(__sigs::__repack_completions(static_cast<_SigPtrs>(nullptr)...));

template <class... _Sigs>
using __concat_completion_signatures =
    __mconcat<__qq<completion_signatures>>::__f<
        __mconcat<__qq<__mmake_set>>::__f<_Sigs...>>;

namespace __sigs {

template <template <class...> class _Tuple, class _Tag, class... _Args>
auto __for_each_sig(_Tag (*)(_Args...)) -> _Tuple<_Tag, _Args...>;

template <class _Sig, template <class...> class _Tuple>
using __for_each_sig_t =
    decltype(__sigs::__for_each_sig<_Tuple>(static_cast<_Sig *>(nullptr)));

template <template <class...> class _Tuple, template <class...> class _Variant,
          class... _More, class _What, class... _With>
auto __for_each_completion_signature_fn(_ERROR_<_What, _With...> **)
    -> _ERROR_<_What, _With...>;

template <template <class...> class _Tuple, template <class...> class _Variant,
          class... _More, class... _Sigs>
auto __for_each_completion_signature_fn(completion_signatures<_Sigs...> **)
    -> _Variant<__for_each_sig_t<_Sigs, _Tuple>..., _More...>;
} // namespace __sigs

template <class _Sigs, template <class...> class _Tuple,
          template <class...> class _Variant, class... _More>
using __for_each_completion_signature =
    decltype(__sigs::__for_each_completion_signature_fn<_Tuple, _Variant,
                                                        _More...>(
        static_cast<_Sigs **>(nullptr)));

namespace __sigs {

template <template <class...> class _SetVal, template <class...> class _SetErr,
          class _SetStp, class... _Values>
auto __transform_sig(set_value_t (*)(_Values...)) -> _SetVal<_Values...>;

template <template <class...> class _SetVal, template <class...> class _SetErr,
          class _SetStp, class _Error>
auto __transform_sig(set_error_t (*)(_Error)) -> _SetErr<_Error>;

template <template <class...> class _SetVal, template <class...> class _SetErr,
          class _SetStp>
auto __transform_sig(set_stopped_t (*)()) -> _SetStp;

template <class _Sig, template <class...> class _SetVal,
          template <class...> class _SetErr, class _SetStp>
using __transform_sig_t =
    decltype(__sigs::__transform_sig<_SetVal, _SetErr, _SetStp>(
        static_cast<_Sig *>(nullptr)));

template <template <class...> class _SetVal, template <class...> class _SetErr,
          class _SetStp, template <class...> class _Variant, class... _More,
          class _What, class... _With>
auto __transform_sigs_fn(_ERROR_<_What, _With...> **)
    -> _ERROR_<_What, _With...>;

template <template <class...> class _SetVal, template <class...> class _SetErr,
          class _SetStp, template <class...> class _Variant, class... _More,
          class... _Sigs>
auto __transform_sigs_fn(completion_signatures<_Sigs...> **)
    -> _Variant<__transform_sig_t<_Sigs, _SetVal, _SetErr, _SetStp>...,
                _More...>;
} // namespace __sigs

template <class _Sigs, template <class...> class _SetVal,
          template <class...> class _SetErr, class _SetStp,
          template <class...> class _Variant, class... _More>
using __transform_completion_signatures =
    decltype(__sigs::__transform_sigs_fn<_SetVal, _SetErr, _SetStp, _Variant,
                                         _More...>(
        static_cast<_Sigs **>(nullptr)));

namespace __sigs {

template <class _WantedTag> struct __gather_sigs_fn;

template <> struct __gather_sigs_fn<set_value_t> {
  template <class _Sigs, template <class...> class _Then,
            template <class...> class _Else, template <class...> class _Variant,
            class... _More>
  using __f = __transform_completion_signatures<
      _Sigs, _Then, __mbind_front_q<_Else, set_error_t>::template __f,
      _Else<set_stopped_t>, _Variant, _More...>;
};

template <> struct __gather_sigs_fn<set_error_t> {
  template <class _Sigs, template <class...> class _Then,
            template <class...> class _Else, template <class...> class _Variant,
            class... _More>
  using __f = __transform_completion_signatures<
      _Sigs, __mbind_front_q<_Else, set_value_t>::template __f, _Then,
      _Else<set_stopped_t>, _Variant, _More...>;
};

template <> struct __gather_sigs_fn<set_stopped_t> {
  template <class _Sigs, template <class...> class _Then,
            template <class...> class _Else, template <class...> class _Variant,
            class... _More>
  using __f = __transform_completion_signatures<
      _Sigs, __mbind_front_q<_Else, set_value_t>::template __f,
      __mbind_front_q<_Else, set_error_t>::template __f, _Then<>, _Variant,
      _More...>;
};

template <class... _Values>
using __default_set_value = completion_signatures<set_value_t(_Values...)>;

template <class... _Error>
using __default_set_error = completion_signatures<set_error_t(_Error...)>;

template <class _Tag, class... _Args>
using __default_completion = completion_signatures<_Tag(_Args...)>;
} // namespace __sigs

template <class _Sigs, class _WantedTag, template <class...> class _Then,
          template <class...> class _Else, template <class...> class _Variant,
          class... _More>
using __gather_completion_signatures = typename __sigs::__gather_sigs_fn<
    _WantedTag>::template __f<_Sigs, _Then, _Else, _Variant, _More...>;
# 354 "./../stdexec/include/stdexec/__detail/__transform_completion_signatures.hpp"
template <
    class _Sigs, class _MoreSigs = completion_signatures<>,
    template <class...> class _ValueTransform = __sigs::__default_set_value,
    template <class...> class _ErrorTransform = __sigs::__default_set_error,
    class _StoppedSigs = completion_signatures<set_stopped_t()>>
using transform_completion_signatures = __transform_completion_signatures<
    _Sigs, _ValueTransform, _ErrorTransform, _StoppedSigs,
    __mtry_q<__concat_completion_signatures>::__f, _MoreSigs>;

template <
    class _Sndr, class _Env = env<>, class _MoreSigs = completion_signatures<>,
    template <class...> class _ValueTransform = __sigs::__default_set_value,
    template <class...> class _ErrorTransform = __sigs::__default_set_error,
    class _StoppedSigs = completion_signatures<set_stopped_t()>>
using transform_completion_signatures_of =
    transform_completion_signatures<completion_signatures_of_t<_Sndr, _Env>,
                                    _MoreSigs, _ValueTransform, _ErrorTransform,
                                    _StoppedSigs>;

using __eptr_completion =
    completion_signatures<set_error_t(std::exception_ptr)>;

template <class _NoExcept>
using __eptr_completion_if_t =
    __if<_NoExcept, completion_signatures<>, __eptr_completion>;

template <bool _NoExcept>
using __eptr_completion_if = __eptr_completion_if_t<__mbool<_NoExcept>>;

template <class _Sender, class _Env = env<>,
          class _More = completion_signatures<>,
          class _SetValue = __qq<__sigs::__default_set_value>,
          class _SetError = __qq<__sigs::__default_set_error>,
          class _SetStopped = completion_signatures<set_stopped_t()>>
using __try_make_completion_signatures = __transform_completion_signatures<
    __completion_signatures_of_t<_Sender, _Env>, _SetValue::template __f,
    _SetError::template __f, _SetStopped,
    __mtry_q<__concat_completion_signatures>::__f, _More>;

template <class _SetTag, class _Completions, class _Tuple, class _Variant>
using __gather_completions = __gather_completion_signatures<
    _Completions, _SetTag,
    __mcompose_q<__types, _Tuple::template __f>::template __f,
    __mconst<__types<>>::__f, __mconcat<_Variant>::template __f>;

template <class _SetTag, class _Sender, class _Env, class _Tuple,
          class _Variant>
using __gather_completions_of =
    __gather_completions<_SetTag, __completion_signatures_of_t<_Sender, _Env>,
                         _Tuple, _Variant>;

template <class _Sender, class _Env = env<>,
          class _Sigs = completion_signatures<>,
          template <class...> class _SetValue = __sigs::__default_set_value,
          template <class...> class _SetError = __sigs::__default_set_error,
          class _SetStopped = completion_signatures<set_stopped_t()>>
using make_completion_signatures =
    transform_completion_signatures_of<_Sender, _Env, _Sigs, _SetValue,
                                       _SetError, _SetStopped>;

template <class _Sigs, class _Tuple = __q<__decayed_std_tuple>,
          class _Variant = __q<__std_variant>>
using __value_types_t =
    __gather_completions<set_value_t, _Sigs, _Tuple, _Variant>;

template <class _Sender, class _Env = env<>,
          class _Tuple = __q<__decayed_std_tuple>,
          class _Variant = __q<__std_variant>>
using __value_types_of_t =
    __value_types_t<__completion_signatures_of_t<_Sender, _Env>, _Tuple,
                    _Variant>;

template <class _Sigs, class _Variant = __q<__std_variant>>
using __error_types_t =
    __gather_completions<set_error_t, _Sigs, __q<__midentity>, _Variant>;

template <class _Sender, class _Env = env<>,
          class _Variant = __q<__std_variant>>
using __error_types_of_t =
    __error_types_t<__completion_signatures_of_t<_Sender, _Env>, _Variant>;

template <class _Sender, class _Env = env<>,
          template <class...> class _Tuple = __decayed_std_tuple,
          template <class...> class _Variant = __std_variant>
using value_types_of_t =
    __value_types_of_t<_Sender, _Env, __q<_Tuple>, __q<_Variant>>;

template <class _Sender, class _Env = env<>,
          template <class...> class _Variant = __std_variant>
using error_types_of_t = __error_types_of_t<_Sender, _Env, __q<_Variant>>;

template <class _Tag, class _Sender, class... _Env>
using __count_of = __gather_completion_signatures<
    __completion_signatures_of_t<_Sender, _Env...>, _Tag,
    __mconst<__msize_t<1>>::__f, __mconst<__msize_t<0>>::__f, __mplus_t>;

template <class _Tag, class _Sender, class... _Env>
  requires sender_in<_Sender, _Env...>
inline constexpr bool __sends = __v<__gather_completion_signatures<
    __completion_signatures_of_t<_Sender, _Env...>, _Tag,
    __mconst<__mtrue>::__f, __mconst<__mfalse>::__f, __mor_t>>;

template <class _Sender, class... _Env>
concept sends_stopped =
    sender_in<_Sender, _Env...> && __sends<set_stopped_t, _Sender, _Env...>;

template <class _Sender, class... _Env>
using __single_sender_value_t =
    __value_types_t<__completion_signatures_of_t<_Sender, _Env...>,
                    __q<__msingle>, __q<__msingle>>;

template <class _Sender, class... _Env>
concept __single_value_sender = sender_in<_Sender, _Env...> && requires {
  typename __single_sender_value_t<_Sender, _Env...>;
};

template <class _Sender, class... _Env>
using __single_value_variant_sender_t =
    __value_types_t<__completion_signatures_of_t<_Sender, _Env...>,
                    __qq<__types>, __q<__msingle>>;

template <class _Sender, class... _Env>
concept __single_value_variant_sender =
    sender_in<_Sender, _Env...> &&
    requires { typename __single_value_variant_sender_t<_Sender, _Env...>; };

template <class _Fun, class... _Args>
  requires __invocable<_Fun, _Args...>
using __nothrow_invocable_t = __mbool<__nothrow_invocable<_Fun, _Args...>>;

template <class _Catch, class _Tag, class _Fun, class _Sender, class... _Env>
using __with_error_invoke_t =
    __if<__gather_completion_signatures<
             __completion_signatures_of_t<_Sender, _Env...>, _Tag,
             __mbind_front<__mtry_catch_q<__nothrow_invocable_t, _Catch>,
                           _Fun>::template __f,
             __mconst<__mbool<true>>::__f, __mand>,
         completion_signatures<>, __eptr_completion>;

template <class _Fun, class... _Args>
  requires __invocable<_Fun, _Args...>
using __set_value_invoke_t =
    completion_signatures<__minvoke<__mremove<void, __qf<set_value_t>>,
                                    __invoke_result_t<_Fun, _Args...>>>;

template <class _Completions>
using __decay_copyable_results_t =
    __for_each_completion_signature<_Completions, __decay_copyable_t, __mand_t>;

template <class _Completions>
using __nothrow_decay_copyable_results_t =
    __for_each_completion_signature<_Completions, __nothrow_decay_copyable_t,
                                    __mand_t>;
} // namespace stdexec
# 31 "./../stdexec/include/stdexec/__detail/__senders.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__transform_sender.hpp" 1
# 21 "./../stdexec/include/stdexec/__detail/__transform_sender.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__basic_sender.hpp" 1
# 34 "./../stdexec/include/stdexec/__detail/__basic_sender.hpp"
namespace stdexec {

namespace __detail {
template <class _Sender>
using __impl_of = decltype((__declval<_Sender>().__impl_));
}

template <class _Descriptor, auto _DescriptorFn = [] { return _Descriptor(); }>
inline constexpr auto __descriptor_fn_v = _DescriptorFn;

template <class _Tag, class _Data, class... _Child>
inline constexpr auto __descriptor_fn() {
  return __descriptor_fn_v<__detail::__desc<_Tag, _Data, _Child...>>;
}
# 64 "./../stdexec/include/stdexec/__detail/__basic_sender.hpp"
template <class _Tag> struct __sexpr_impl;

template <class _Sexpr, class _Receiver> struct __op_state;

template <class _ReceiverId, class _Sexpr, std::size_t _Idx> struct __rcvr;

namespace __detail {
template <class _Sexpr, class _Receiver> struct __connect_fn;

template <class _Tag, class _Sexpr, class _Receiver>
using __state_type_t =
    __decay_t<__result_of<__sexpr_impl<_Tag>::get_state, _Sexpr, _Receiver &>>;

template <class _Self, class _Tag, class _Index, class _Sexpr, class _Receiver>
using __env_type_t = __result_of<
    __sexpr_impl<__meval<__msecond, _Self, _Tag>>::get_env, _Index,
    __state_type_t<__meval<__msecond, _Self, _Tag>, _Sexpr, _Receiver> &,
    _Receiver &>;

template <class _Sexpr, class _Receiver>
concept __connectable =
    __callable<__impl_of<_Sexpr>, __copy_cvref_fn<_Sexpr>,
               __connect_fn<_Sexpr, _Receiver>> &&
    __mvalid<__state_type_t, tag_of_t<_Sexpr>, _Sexpr, _Receiver>;

struct __defaults {
  static constexpr auto get_attrs =
      [](__ignore, const auto &...__child) noexcept -> decltype(auto) {
    if constexpr (sizeof...(__child) == 1) {
      return __env::__fwd_fn()(stdexec::get_env(__child...));
    } else {
      return env<>();
    }
  };

  static constexpr auto get_env =
      []<class _Receiver>(__ignore, __ignore, const _Receiver &__rcvr) noexcept
      -> env_of_t<const _Receiver &> { return stdexec::get_env(__rcvr); };

  static constexpr auto get_state =
      []<class _Sender>(_Sender &&__sndr, __ignore) noexcept -> decltype(auto) {
    return __sndr.apply(static_cast<_Sender &&>(__sndr), __get_data());
  };

  static constexpr auto connect =
      []<class _Sender, class _Receiver>(
          _Sender &&__sndr,
          _Receiver
              __rcvr) noexcept(__nothrow_constructible_from<__op_state<_Sender,
                                                                       _Receiver>,
                                                            _Sender, _Receiver>)
      -> __op_state<_Sender, _Receiver>
    requires __connectable<_Sender, _Receiver>
  {
    return __op_state<_Sender, _Receiver>{static_cast<_Sender &&>(__sndr),
                                          static_cast<_Receiver &&>(__rcvr)};
  };

  static constexpr auto start =
      []<class _StartTag = start_t, class... _ChildOps>(
          __ignore, __ignore, _ChildOps &...__ops) noexcept {
        (_StartTag()(__ops), ...);
      };

  static constexpr auto complete =
      []<class _Index, class _Receiver, class _SetTag, class... _Args>(
          _Index, __ignore, _Receiver &__rcvr, _SetTag,
          _Args &&...__args) noexcept {
        static_assert(__v<_Index> == 0,
                      "I don't know how to complete this operation.");
        _SetTag()(std::move(__rcvr), static_cast<_Args &&>(__args)...);
      };

  static constexpr auto get_completion_signatures =
      []<class _Sender>(_Sender &&, auto &&...) noexcept {
        static_assert(__mnever<tag_of_t<_Sender>>,
                      "No customization of get_completion_signatures for this "
                      "sender tag type.");
      };
};

template <class _Sexpr, class _Receiver>
using __state_t =
    __state_type_t<typename __decay_t<_Sexpr>::__tag_t, _Sexpr, _Receiver>;

template <class _Sexpr, class _Receiver> struct __op_base;

template <class _Receiver> struct __receiver_box {
  _Receiver __rcvr_;

  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  __rcvr() & noexcept -> _Receiver & {
    return this->__rcvr_;
  }

  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  __rcvr() const & noexcept -> const _Receiver & {
    return this->__rcvr_;
  }
};

template <class _Sexpr, class _Receiver> struct __state_box : __immovable {
  using __tag_t = typename __decay_t<_Sexpr>::__tag_t;
  using __state_t = __state_type_t<__tag_t, _Sexpr, _Receiver>;

  __state_box(_Sexpr &&__sndr, _Receiver &__rcvr) noexcept(
      __noexcept_of<__sexpr_impl<__tag_t>::get_state, _Sexpr, _Receiver &>) {
    ::new (static_cast<void *>(__buf_)) auto(__sexpr_impl<__tag_t>::get_state(
        static_cast<_Sexpr &&>(__sndr), __rcvr));
  }

  ~__state_box() { reinterpret_cast<__state_t *>(__buf_)->~__state_t(); }

  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  __state() & noexcept -> __state_t & {
    return *reinterpret_cast<__state_t *>(__buf_);
  }

  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  __state() const & noexcept -> const __state_t & {
    return *reinterpret_cast<const __state_t *>(__buf_);
  }

  alignas(__state_t) std::byte __buf_[sizeof(__state_t)];
};

template <class _Sexpr, class _Receiver, class _State>
struct __enable_receiver_from_this {

  auto __receiver() noexcept -> decltype(auto) {
    void *__state = static_cast<_State *>(this);

    auto *__sbox = static_cast<__state_box<_Sexpr, _Receiver> *>(__state);
    return (static_cast<__op_base<_Sexpr, _Receiver> *>(__sbox)->__rcvr_);
  }
};

template <class _Sexpr, class _Receiver>
concept __state_uses_receiver =
    derived_from<__state_t<_Sexpr, _Receiver>,
                 __enable_receiver_from_this<_Sexpr, _Receiver,
                                             __state_t<_Sexpr, _Receiver>>>;

template <class _Sexpr, class _Receiver> struct __op_base : __immovable {
  using __tag_t = typename __decay_t<_Sexpr>::__tag_t;
  using __state_t = __state_type_t<__tag_t, _Sexpr, _Receiver>;

  [[no_unique_address]]
  _Receiver __rcvr_;
  [[no_unique_address]]
  __state_t __state_;

  __op_base(_Sexpr &&__sndr, _Receiver &&__rcvr) noexcept(
      __nothrow_decay_copyable<_Receiver> &&
      __noexcept_of<__sexpr_impl<__tag_t>::get_state, _Sexpr, _Receiver &>)
      : __rcvr_(static_cast<_Receiver &&>(__rcvr)),
        __state_(__sexpr_impl<__tag_t>::get_state(
            static_cast<_Sexpr &&>(__sndr), __rcvr_)) {}

  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  __state() & noexcept -> __state_t & {
    return __state_;
  }

  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  __state() const & noexcept -> const __state_t & {
    return __state_;
  }

  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  __rcvr() & noexcept -> _Receiver & {
    return __rcvr_;
  }

  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  __rcvr() const & noexcept -> const _Receiver & {
    return __rcvr_;
  }
};

template <class _Sexpr, class _Receiver>
  requires __state_uses_receiver<_Sexpr, _Receiver>
struct __op_base<_Sexpr, _Receiver> : __receiver_box<_Receiver>,
                                      __state_box<_Sexpr, _Receiver> {
  using __tag_t = typename __decay_t<_Sexpr>::__tag_t;
  using __state_t = __state_type_t<__tag_t, _Sexpr, _Receiver>;

  __op_base(__op_base &&) = delete;

  __op_base(_Sexpr &&__sndr, _Receiver &&__rcvr) noexcept(
      __nothrow_decay_copyable<_Receiver> &&
      __nothrow_move_constructible<__state_t>)
      : __receiver_box<_Receiver>{static_cast<_Receiver &&>(__rcvr)},
        __state_box<_Sexpr, _Receiver>{static_cast<_Sexpr &&>(__sndr),
                                       this->__rcvr_} {

    static_assert(std::is_standard_layout_v<__state_box<_Sexpr, _Receiver>>);
  }
};

#pragma GCC diagnostic push
# 273 "./../stdexec/include/stdexec/__detail/__basic_sender.hpp"
#pragma GCC diagnostic ignored "-Wpragmas"
# 273 "./../stdexec/include/stdexec/__detail/__basic_sender.hpp"
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
# 273 "./../stdexec/include/stdexec/__detail/__basic_sender.hpp"
#pragma GCC diagnostic ignored "-Wunknown-warning-option"
# 273 "./../stdexec/include/stdexec/__detail/__basic_sender.hpp"
#pragma GCC diagnostic ignored "-Wunknown-attributes"
# 273 "./../stdexec/include/stdexec/__detail/__basic_sender.hpp"
#pragma GCC diagnostic ignored "-Wattributes"
#pragma GCC diagnostic ignored "-Wmissing-braces"

template <class _Sexpr, class _Receiver> struct __connect_fn {
  template <std::size_t _Idx>
  using __receiver_t = __t<__rcvr<__id<_Receiver>, _Sexpr, _Idx>>;

  __op_state<_Sexpr, _Receiver> *__op_;

  struct __impl {
    __op_state<_Sexpr, _Receiver> *__op_;

    template <std::size_t... _Is, class... _Child>
    auto operator()(__indices<_Is...>, _Child &&...__child) const
        noexcept((__nothrow_connectable<_Child, __receiver_t<_Is>> && ...))
            -> __tuple_for<connect_result_t<_Child, __receiver_t<_Is>>...> {
      return __tuple{connect(static_cast<_Child &&>(__child),
                             __receiver_t<_Is>{__op_})...};
    }
  };

  template <class... _Child>
  auto operator()(__ignore, __ignore, _Child &&...__child) const
      noexcept(__nothrow_callable<__impl, __indices_for<_Child...>, _Child...>)
          -> __call_result_t<__impl, __indices_for<_Child...>, _Child...> {
    return __impl{__op_}(__indices_for<_Child...>(),
                         static_cast<_Child &&>(__child)...);
  }

  auto operator()(__ignore, __ignore) const noexcept -> __tuple_for<> {
    return {};
  }
};

#pragma GCC diagnostic pop

inline constexpr auto __drop_front = []<class _Fn>(_Fn __fn) noexcept {
  return
      [__fn = std::move(__fn)]<class... _Rest>(
          auto &&,
          _Rest &&...__rest) noexcept(__nothrow_callable<const _Fn &, _Rest...>)
          -> __call_result_t<const _Fn &, _Rest...> {
        return __fn(static_cast<_Rest &&>(__rest)...);
      };
};

template <class _Tag, class... _Captures>
__attribute__((__always_inline__, __artificial__,
               __nodebug__)) inline constexpr auto
__captures(_Tag, _Captures &&...__captures2) {
  return
      [... __captures3 =
           static_cast<_Captures &&>(__captures2)]<class _Cvref, class _Fun>(
          _Cvref,
          _Fun &&__fun) mutable noexcept(__nothrow_callable<_Fun, _Tag,
                                                            __minvoke<
                                                                _Cvref,
                                                                _Captures>...>)
          -> __call_result_t<_Fun, _Tag, __minvoke<_Cvref, _Captures>...>
        requires __callable<_Fun, _Tag, __minvoke<_Cvref, _Captures>...>
  {
    return static_cast<_Fun &&>(__fun)(
        _Tag(), const_cast<__minvoke<_Cvref, decltype(__captures3)> &&>(
                    __captures3)...);
  };
}

template <class _Tag, class _Data, class... _Child>
using __captures_t = decltype(__detail::__captures(_Tag(), __declval<_Data>(),
                                                   __declval<_Child>()...));

template <class, class, class... _Child>
using __tuple_size_t = char[sizeof...(_Child) + 2];

template <std::size_t _Idx, class _Descriptor>
concept __in_range =
    (_Idx < sizeof(__minvoke<_Descriptor, __q<__tuple_size_t>>));

} // namespace __detail

using __sexpr_defaults = __detail::__defaults;

template <class _ReceiverId, class _Sexpr, std::size_t _Idx> struct __rcvr {
  using _Receiver = stdexec::__t<_ReceiverId>;

  struct __t {
    using receiver_concept = receiver_t;
    using __id = __rcvr;

    using __index = __msize_t<_Idx>;
    using __parent_op_t = __op_state<_Sexpr, _Receiver>;
    using __tag_t = tag_of_t<_Sexpr>;

    __parent_op_t *__op_;

    template <class... _Args>
    __attribute__((__always_inline__, __artificial__, __nodebug__)) inline void
    set_value(_Args &&...__args) noexcept {
      __op_->__complete(__index(), stdexec::set_value,
                        static_cast<_Args &&>(__args)...);
    }

    template <class _Error>
    __attribute__((__always_inline__, __artificial__, __nodebug__)) inline void
    set_error(_Error &&__err) noexcept {
      __op_->__complete(__index(), stdexec::set_error,
                        static_cast<_Error &&>(__err));
    }

    __attribute__((__always_inline__, __artificial__, __nodebug__)) inline void
    set_stopped() noexcept {
      __op_->__complete(__index(), stdexec::set_stopped);
    }

    template <__same_as<__t> _Self = __t>
    __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
    get_env() const noexcept
        -> __detail::__env_type_t<_Self, __tag_t, __index, _Sexpr, _Receiver> {
      return __op_->__get_env(__index());
    }
  };
};

template <class _Sexpr, class _Receiver>
struct __op_state : __detail::__op_base<_Sexpr, _Receiver> {
  using __desc_t = typename __decay_t<_Sexpr>::__desc_t;
  using __tag_t = typename __desc_t::__tag;
  using __data_t = typename __desc_t::__data;
  using __state_t = typename __op_state::__state_t;
  using __inner_ops_t = __result_of<__sexpr_apply, _Sexpr,
                                    __detail::__connect_fn<_Sexpr, _Receiver>>;

  __inner_ops_t __inner_ops_;

  __op_state(_Sexpr &&__sexpr, _Receiver __rcvr) noexcept(
      __nothrow_constructible_from<__detail::__op_base<_Sexpr, _Receiver>,
                                   _Sexpr, _Receiver> &&
      __noexcept_of<__sexpr_apply, _Sexpr,
                    __detail::__connect_fn<_Sexpr, _Receiver>>)
      : __op_state::__op_base{static_cast<_Sexpr &&>(__sexpr),
                              static_cast<_Receiver &&>(__rcvr)},
        __inner_ops_(
            __sexpr_apply(static_cast<_Sexpr &&>(__sexpr),
                          __detail::__connect_fn<_Sexpr, _Receiver>{this})) {}

  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline void
  start() & noexcept {
    using __tag_t = typename __op_state::__tag_t;
    auto &&__rcvr = this->__rcvr();
    __inner_ops_.apply(
        [&](auto &...__ops) noexcept {
          __sexpr_impl<__tag_t>::start(this->__state(), __rcvr, __ops...);
        },
        __inner_ops_);
  }

  template <class _Index, class _Tag2, class... _Args>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline void
  __complete(_Index, _Tag2, _Args &&...__args) noexcept {
    using __tag_t = typename __op_state::__tag_t;
    auto &&__rcvr = this->__rcvr();
    using _CompleteFn = __mtypeof<__sexpr_impl<__tag_t>::complete>;
    if constexpr (__callable<_CompleteFn, _Index, __op_state &, _Tag2,
                             _Args...>) {
      __sexpr_impl<__tag_t>::complete(_Index(), *this, _Tag2(),
                                      static_cast<_Args &&>(__args)...);
    } else {
      __sexpr_impl<__tag_t>::complete(_Index(), this->__state(), __rcvr,
                                      _Tag2(),
                                      static_cast<_Args &&>(__args)...);
    }
  }

  template <class _Index>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  __get_env(_Index) const noexcept
      -> __detail::__env_type_t<_Index, __tag_t, _Index, _Sexpr, _Receiver> {
    const auto &__rcvr = this->__rcvr();
    return __sexpr_impl<__tag_t>::get_env(_Index(), this->__state(), __rcvr);
  }
};

template <class _Tag> struct __sexpr_impl : __detail::__defaults {
  using not_specialized = void;
};

using __detail::__enable_receiver_from_this;

template <class _Tag>
using __get_attrs_fn = __result_of<__detail::__drop_front,
                                   __mtypeof<__sexpr_impl<_Tag>::get_attrs>>;

template <class...> struct __basic_sender {

  using __id = __basic_sender;
  using __t = __basic_sender;
};

namespace {

template <auto _DescriptorFn> struct __sexpr {
  using sender_concept = sender_t;

  using __id = __sexpr;
  using __t = __sexpr;
  using __desc_t = decltype(_DescriptorFn());
  using __tag_t = typename __desc_t::__tag;
  using __captures_t = __minvoke<__desc_t, __q<__detail::__captures_t>>;

  mutable __captures_t __impl_;

  template <class _Tag, class _Data, class... _Child>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline explicit __sexpr(_Tag, _Data &&__data,
                                                       _Child &&...__child)
      : __impl_(__detail::__captures(_Tag(), static_cast<_Data &&>(__data),
                                     static_cast<_Child &&>(__child)...)) {}

  template <class _Self>
  using __impl = __sexpr_impl<__meval<__msecond, _Self, __tag_t>>;

  template <class _Self = __sexpr>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  get_env() const noexcept
      -> __result_of<__sexpr_apply, const _Self &, __get_attrs_fn<__tag_t>> {
    return __sexpr_apply(*this,
                         __detail::__drop_front(__impl<_Self>::get_attrs));
  }

  template <__decays_to<__sexpr> _Self, class... _Env>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  get_completion_signatures(_Self &&, _Env &&...) noexcept
      -> __msecond<__if_c<__decays_to<_Self, __sexpr>>,
                   __result_of<__impl<_Self>::get_completion_signatures, _Self,
                               _Env...>> {
    return {};
  }

  template <__decays_to<__sexpr> _Self, class _Receiver>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  connect(_Self &&__self, _Receiver &&__rcvr) noexcept(
      __noexcept_of<__impl<_Self>::connect, _Self, _Receiver>)
      -> __msecond<__if_c<__decays_to<_Self, __sexpr>>,
                   __result_of<__impl<_Self>::connect, _Self, _Receiver>> {
    return __impl<_Self>::connect(static_cast<_Self &&>(__self),
                                  static_cast<_Receiver &&>(__rcvr));
  }

  template <__decays_to<__sexpr> _Self, class _Receiver>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  submit(_Self &&__self, _Receiver &&__rcvr) noexcept(
      __noexcept_of<__impl<_Self>::submit, _Self, _Receiver>)
      -> __msecond<__if_c<__decays_to<_Self, __sexpr>>,
                   __result_of<__impl<_Self>::submit, _Self, _Receiver>> {
    return __impl<_Self>::submit(static_cast<_Self &&>(__self),
                                 static_cast<_Receiver &&>(__rcvr));
  }

  template <class _Sender, class _ApplyFn>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  apply(_Sender &&__sndr, _ApplyFn &&__fun) noexcept(
      __nothrow_callable<__detail::__impl_of<_Sender>, __copy_cvref_fn<_Sender>,
                         _ApplyFn>)
      -> __call_result_t<__detail::__impl_of<_Sender>, __copy_cvref_fn<_Sender>,
                         _ApplyFn> {
    return static_cast<_Sender &&>(__sndr).__impl_(
        __copy_cvref_fn<_Sender>(), static_cast<_ApplyFn &&>(__fun));
  }

  template <std::size_t _Idx, __decays_to_derived_from<__sexpr> _Self>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline friend auto
  get(_Self &&__self) noexcept -> decltype(auto)
    requires __detail::__in_range<_Idx, __desc_t>
  {
    if constexpr (_Idx == 0) {
      return __tag_t();
    } else {
      return __self.__impl_(__copy_cvref_fn<_Self>(), __nth_pack_element<_Idx>);
    }
  }
};

template <class _Tag, class _Data, class... _Child>

__sexpr(_Tag, _Data, _Child...)
    -> __sexpr<stdexec::__descriptor_fn_v<
        stdexec::__detail::__desc<_Tag, _Data, _Child...>>>;
} // namespace

template <class _Tag, class _Data, class... _Child>
using __sexpr_t = __sexpr<stdexec::__descriptor_fn_v<
    stdexec::__detail::__desc<_Tag, _Data, _Child...>>>;

namespace __detail {
template <class _Tag> struct __make_sexpr_t {
  template <class _Data = __, class... _Child>
  constexpr auto operator()(_Data __data = {}, _Child... __child) const {
    return __sexpr_t<_Tag, _Data, _Child...>{
        _Tag(), static_cast<_Data &&>(__data),
        static_cast<_Child &&>(__child)...};
  }
};
} // namespace __detail

template <class _Tag>
inline constexpr __detail::__make_sexpr_t<_Tag> __make_sexpr{};

namespace __detail {
struct __basic_sender_name {
  template <class _Tag, class _Data, class... _Child>
  using __result = __basic_sender<_Tag, _Data, __name_of<_Child>...>;

  template <class _Sender>
  using __f = __minvoke<typename __decay_t<_Sender>::__desc_t, __q<__result>>;
};

struct __id_name {
  template <class _Sender> using __f = __name_of<__id<_Sender>>;
};

template <class _Sender>
extern __mcompose<__cplr, __name_of_fn<_Sender>> __name_of_v<_Sender &>;

template <class _Sender>
extern __mcompose<__cprr, __name_of_fn<_Sender>> __name_of_v<_Sender &&>;

template <class _Sender>
extern __mcompose<__cpclr, __name_of_fn<_Sender>> __name_of_v<const _Sender &>;

template <auto _Descriptor>
extern __basic_sender_name __name_of_v<__sexpr<_Descriptor>>;

template <__has_id _Sender>
  requires(!same_as<__id<_Sender>, _Sender>)
extern __id_name __name_of_v<_Sender>;
} // namespace __detail
} // namespace stdexec

namespace std {
template <auto _Descriptor>
struct tuple_size<stdexec::__sexpr<_Descriptor>>
    : integral_constant<
          size_t, stdexec::__v<stdexec::__minvoke<
                      stdexec::__result_of<_Descriptor>, stdexec::__msize>>> {};

template <size_t _Idx, auto _Descriptor>
struct tuple_element<_Idx, stdexec::__sexpr<_Descriptor>> {
  using type = stdexec::__remove_rvalue_reference_t<stdexec::__call_result_t<
      stdexec::__detail::__impl_of<stdexec::__sexpr<_Descriptor>>,
      stdexec::__cp, stdexec::__nth_pack_element_t<_Idx>>>;
};
} // namespace std
# 22 "./../stdexec/include/stdexec/__detail/__transform_sender.hpp" 2

#pragma GCC diagnostic push
# 30 "./../stdexec/include/stdexec/__detail/__transform_sender.hpp"
#pragma GCC diagnostic ignored "-Wpragmas"
# 30 "./../stdexec/include/stdexec/__detail/__transform_sender.hpp"
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
# 30 "./../stdexec/include/stdexec/__detail/__transform_sender.hpp"
#pragma GCC diagnostic ignored "-Wunknown-warning-option"
# 30 "./../stdexec/include/stdexec/__detail/__transform_sender.hpp"
#pragma GCC diagnostic ignored "-Wunknown-attributes"
# 30 "./../stdexec/include/stdexec/__detail/__transform_sender.hpp"
#pragma GCC diagnostic ignored "-Wattributes"

namespace stdexec {

namespace __detail {
struct __transform_env {
  template <class _Domain, class _Sender, class _Env>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Domain __dom, _Sender &&__sndr,
             _Env &&__env) const noexcept -> decltype(auto) {
    if constexpr (__detail::__has_transform_env<_Domain, _Sender, _Env>) {
      return __dom.transform_env(static_cast<_Sender &&>(__sndr),
                                 static_cast<_Env &&>(__env));
    } else {
      return default_domain().transform_env(static_cast<_Sender &&>(__sndr),
                                            static_cast<_Env &&>(__env));
    }
  }
};

struct __transform_sender_1 {
  template <class _Domain, class _Sender, class... _Env>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static constexpr auto
  __is_nothrow() noexcept -> bool {
    if constexpr (__detail::__has_transform_sender<_Domain, _Sender, _Env...>) {
      return noexcept(__declval<_Domain &>().transform_sender(
          __declval<_Sender>(), __declval<const _Env &>()...));
    } else {
      return noexcept(default_domain().transform_sender(
          __declval<_Sender>(), __declval<const _Env &>()...));
    }
  }

  template <class _Domain, class _Sender, class... _Env>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Domain __dom, _Sender &&__sndr, const _Env &...__env) const
      noexcept(__is_nothrow<_Domain, _Sender, const _Env &...>())
          -> decltype(auto) {
    if constexpr (__detail::__has_transform_sender<_Domain, _Sender, _Env...>) {
      return __dom.transform_sender(static_cast<_Sender &&>(__sndr), __env...);
    } else {
      return default_domain().transform_sender(static_cast<_Sender &&>(__sndr),
                                               __env...);
    }
  }
};

template <class _Ty, class _Uy>
concept __decay_same_as = same_as<__decay_t<_Ty>, __decay_t<_Uy>>;

struct __transform_sender {
  template <class _Self = __transform_sender, class _Domain, class _Sender,
            class... _Env>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Domain __dom, _Sender &&__sndr, const _Env &...__env) const
      noexcept(__nothrow_callable<__transform_sender_1, _Domain, _Sender,
                                  const _Env &...>) -> decltype(auto) {
    using _Sender2 = __call_result_t<__transform_sender_1, _Domain, _Sender,
                                     const _Env &...>;

    if constexpr (__decay_same_as<_Sender, _Sender2>) {
      return __transform_sender_1()(__dom, static_cast<_Sender &&>(__sndr),
                                    __env...);
    } else {

      return _Self()(__dom,
                     __transform_sender_1()(
                         __dom, static_cast<_Sender &&>(__sndr), __env...),
                     __env...);
    }
  }
};

struct __transform_dependent_sender {

  template <class _Domain, sender_expr _Sender, class _Env>
    requires same_as<__early_domain_of_t<_Sender>, dependent_domain>
  auto operator()(_Domain __dom, _Sender &&__sndr, const _Env &__env) const
      noexcept(noexcept(__transform_sender()(
          __dom,
          dependent_domain().transform_sender(static_cast<_Sender &&>(__sndr),
                                              __env),
          __env))) -> decltype(auto) {
    static_assert(__none_of<_Domain, dependent_domain>);
    return __transform_sender()(__dom,
                                dependent_domain().transform_sender(
                                    static_cast<_Sender &&>(__sndr), __env),
                                __env);
  }
};
} // namespace __detail

inline constexpr struct transform_sender_t
    : __detail::__transform_sender,
      __detail::__transform_dependent_sender {
  using __detail::__transform_sender::operator();
  using __detail::__transform_dependent_sender::operator();
} transform_sender{};

template <class _Domain, class _Sender, class... _Env>
using transform_sender_result_t =
    __call_result_t<transform_sender_t, _Domain, _Sender, _Env...>;

inline constexpr __detail::__transform_env transform_env{};

struct _CHILD_SENDERS_WITH_DIFFERENT_DOMAINS_ {};

template <class _Sender, class _Env>
constexpr auto
dependent_domain::__is_nothrow_transform_sender() noexcept -> bool {
  using _Env2 = __call_result_t<__detail::__transform_env, dependent_domain &,
                                _Sender, _Env>;
  return __v<decltype(__sexpr_apply(
      __declval<_Sender>(), []<class _Tag, class _Data, class... _Childs>(
                                _Tag, _Data &&, _Childs &&...) {
        constexpr bool __first_transform_is_nothrow =
            noexcept(__make_sexpr<_Tag>(
                __declval<_Data>(),
                __detail::__transform_sender()(__declval<dependent_domain &>(),
                                               __declval<_Childs>(),
                                               __declval<const _Env2 &>())...));
        using _Sender2 = decltype(__make_sexpr<_Tag>(
            __declval<_Data>(),
            __detail::__transform_sender()(__declval<dependent_domain &>(),
                                           __declval<_Childs>(),
                                           __declval<const _Env2 &>())...));
        using _Domain2 = decltype(__sexpr_apply(
            __declval<_Sender2 &>(), __detail::__common_domain_fn()));
        constexpr bool __second_transform_is_nothrow =
            noexcept(__detail::__transform_sender()(__declval<_Domain2 &>(),
                                                    __declval<_Sender2>(),
                                                    __declval<const _Env &>()));
        return __mbool < __first_transform_is_nothrow &&
               __second_transform_is_nothrow > ();
      }))>;
}

template <sender_expr _Sender, class _Env>
  requires same_as<__early_domain_of_t<_Sender>, dependent_domain>
auto dependent_domain::transform_sender(_Sender &&__sndr,
                                        const _Env &__env) const
    noexcept(__is_nothrow_transform_sender<_Sender, _Env>()) -> decltype(auto) {

  const auto &__env2 =
      transform_env(*this, static_cast<_Sender &&>(__sndr), __env);

  return __sexpr_apply(
      static_cast<_Sender &&>(__sndr),
      [&]<class _Tag, class _Data, class... _Childs>(_Tag, _Data &&__data,
                                                     _Childs &&...__childs) {
        auto __sndr2 = __make_sexpr<_Tag>(
            static_cast<_Data &&>(__data),
            __detail::__transform_sender()(
                *this, static_cast<_Childs &&>(__childs), __env2)...);
        using _Sender2 = decltype(__sndr2);

        auto __domain2 = __sexpr_apply(__sndr2, __detail::__common_domain_fn());
        using _Domain2 = decltype(__domain2);

        if constexpr (same_as<_Domain2, __none_such>) {
          return __mexception<_CHILD_SENDERS_WITH_DIFFERENT_DOMAINS_,
                              _WITH_SENDER_<_Sender2>>();
        } else {
          return __detail::__transform_sender()(__domain2, std::move(__sndr2),
                                                __env);
        }
      });
}

template <class _Tag, class _Domain, class _Sender, class... _Args>
concept __has_implementation_for =
    __detail::__has_apply_sender<_Domain, _Tag, _Sender, _Args...> ||
    __detail::__has_apply_sender<default_domain, _Tag, _Sender, _Args...>;

inline constexpr struct apply_sender_t {
  template <class _Domain, class _Tag, class _Sender, class... _Args>
    requires __has_implementation_for<_Tag, _Domain, _Sender, _Args...>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Domain __dom, _Tag, _Sender &&__sndr,
             _Args &&...__args) const -> decltype(auto) {
    if constexpr (__detail::__has_apply_sender<_Domain, _Tag, _Sender,
                                               _Args...>) {
      return __dom.apply_sender(_Tag(), static_cast<_Sender &&>(__sndr),
                                static_cast<_Args &&>(__args)...);
    } else {
      return default_domain().apply_sender(_Tag(),
                                           static_cast<_Sender &&>(__sndr),
                                           static_cast<_Args &&>(__args)...);
    }
  }
} apply_sender{};

template <class _Domain, class _Tag, class _Sender, class... _Args>
using apply_sender_result_t =
    __call_result_t<apply_sender_t, _Domain, _Tag, _Sender, _Args...>;

template <class _Sender, class _Scheduler, class _Tag = set_value_t>
concept __completes_on = __decays_to<
    __call_result_t<get_completion_scheduler_t<_Tag>, env_of_t<_Sender>>,
    _Scheduler>;

template <class _Sender, class _Scheduler, class _Env>
concept __starts_on =
    __decays_to<__call_result_t<get_scheduler_t, _Env>, _Scheduler>;
} // namespace stdexec

#pragma GCC diagnostic pop
# 32 "./../stdexec/include/stdexec/__detail/__senders.hpp" 2

namespace stdexec {

namespace __detail {
struct __dependent_completions {};

using dependent_completions = _ERROR_<__detail::__dependent_completions>;

template <class _Completions>
concept __well_formed_completions_helper =
    __valid_completion_signatures<_Completions> ||
    __same_as<_Completions, dependent_completions>;

template <class _Completions>
inline constexpr bool __well_formed_completions_v =
    __well_formed_completions_helper<_Completions>;

template <class _Completions>
concept __well_formed_completions = __well_formed_completions_v<_Completions>;
} // namespace __detail

using __detail::dependent_completions;

namespace __sigs {
template <class _Sender, class _Env>
using __tfx_sender =
    transform_sender_result_t<__late_domain_of_t<_Sender, _Env>, _Sender, _Env>;

template <class _Sender, class... _Env>
using __member_result_t =
    decltype(__declval<_Sender>().get_completion_signatures(
        __declval<_Env>()...));

template <class _Sender, class... _Env>
using __static_member_result_t =
    decltype(stdexec::_remove_reference_t<_Sender>::get_completion_signatures(
        __declval<_Sender>(), __declval<_Env>()...));

template <class _Sender, class... _Env>
concept __with_member = __mvalid<__member_result_t, _Sender, _Env...>;

template <class _Sender, class... _Env>
concept __with_static_member =
    __mvalid<__static_member_result_t, _Sender, _Env...>;

template <class _Sender, class... _Env>
concept __with_tag_invoke =
    tag_invocable<get_completion_signatures_t, _Sender, _Env...>;

template <class _Sender, class... _Env>
concept __with_legacy_tag_invoke =
    (sizeof...(_Env) == 0) &&
    tag_invocable<get_completion_signatures_t, _Sender, env<>>;

template <class _Sender>
using __member_alias_t = typename __decay_t<_Sender>::completion_signatures;

template <class _Sender>
concept __with_member_alias = __mvalid<__member_alias_t, _Sender>;

struct get_completion_signatures_t {
  template <class _Sender, class... _Env>
    requires(sizeof...(_Env) <= 1)
  static auto __impl() {

    using __tfx_fn =
        __if_c<sizeof...(_Env) == 0, __mconst<_Sender>, __q<__tfx_sender>>;
    using _TfxSender = __minvoke<__tfx_fn, _Sender, _Env...>;

    if constexpr (__merror<_TfxSender>) {

      return static_cast<_TfxSender (*)()>(nullptr);
    } else if constexpr (__with_member_alias<_TfxSender>) {
      using _Result = __member_alias_t<_TfxSender>;
      return static_cast<_Result (*)()>(nullptr);
    } else if constexpr (__with_static_member<_TfxSender, _Env...>) {
      using _Result = __static_member_result_t<_TfxSender, _Env...>;
      return static_cast<_Result (*)()>(nullptr);
    } else if constexpr (__with_member<_TfxSender, _Env...>) {
      using _Result = __member_result_t<_TfxSender, _Env...>;
      return static_cast<_Result (*)()>(nullptr);
    } else if constexpr (__with_tag_invoke<_TfxSender, _Env...>) {
      using _Result =
          tag_invoke_result_t<get_completion_signatures_t, _TfxSender, _Env...>;
      return static_cast<_Result (*)()>(nullptr);
    } else if constexpr (__with_legacy_tag_invoke<_TfxSender, _Env...>) {

      using _Result =
          tag_invoke_result_t<get_completion_signatures_t, _Sender, env<>>;
      return static_cast<_Result (*)()>(nullptr);

    } else if constexpr (bool(__awaitable<_TfxSender,
                                          __env::__promise<_Env>...>)) {
      using _AwaitResult =
          __await_result_t<_TfxSender, __env::__promise<_Env>...>;
      using _Result = completion_signatures<

          __minvoke<__mremove<void, __qf<set_value_t>>, _AwaitResult>,
          set_error_t(std::exception_ptr), set_stopped_t()>;
      return static_cast<_Result (*)()>(nullptr);
    } else if constexpr (sizeof...(_Env) == 0) {

      return static_cast<dependent_completions (*)()>(nullptr);
    } else if constexpr ((__is_debug_env<_Env> || ...)) {
      using __tag_invoke::tag_invoke;

      using _Completions [[maybe_unused]] =
          tag_invoke_result_t<get_completion_signatures_t, _Sender, _Env...>;
      return static_cast<__debug::__completion_signatures (*)()>(nullptr);
    } else {
      using _Result =
          __mexception<_UNRECOGNIZED_SENDER_TYPE_<>, _WITH_SENDER_<_Sender>,
                       _WITH_ENVIRONMENT_<_Env>...>;
      return static_cast<_Result (*)()>(nullptr);
    }
  }

  template <class _Sender, class... _Env>
    requires(sizeof...(_Env) <= 1)
  constexpr auto operator()(_Sender &&, _Env &&...) const noexcept
      -> decltype(__impl<_Sender, _Env...>()()) {
    return {};
  }
};
} // namespace __sigs

using __sigs::get_completion_signatures_t;
inline constexpr get_completion_signatures_t get_completion_signatures{};

namespace __connect {
template <class _Sender, class _Receiver>
using __tfx_sender =
    transform_sender_result_t<__late_domain_of_t<_Sender, env_of_t<_Receiver>>,
                              _Sender, env_of_t<_Receiver>>;

template <class _Sender, class _Receiver>
using __member_result_t =
    decltype(__declval<_Sender>().connect(__declval<_Receiver>()));

template <class _Sender, class _Receiver>
using __static_member_result_t =
    decltype(stdexec::_remove_reference_t<_Sender>::connect(
        __declval<_Sender>(), __declval<_Receiver>()));

template <class _Sender, class _Receiver>
concept __with_member = __mvalid<__member_result_t, _Sender, _Receiver>;

template <class _Sender, class _Receiver>
concept __with_static_member =
    __mvalid<__static_member_result_t, _Sender, _Receiver>;

template <class _Sender, class _Receiver>
concept __with_tag_invoke = tag_invocable<connect_t, _Sender, _Receiver>;

template <class _Sender, class _Receiver>
concept __with_co_await = __callable<__connect_awaitable_t, _Sender, _Receiver>;

struct _NO_USABLE_CONNECT_CUSTOMIZATION_FOUND_ {
  void operator()() const noexcept = delete;
};

struct connect_t {
  template <class _Sender, class _Env>
  static constexpr auto __check_signatures() -> bool {
    if constexpr (sender_in<_Sender, _Env>) {

      using __checked_signatures [[maybe_unused]] =
          completion_signatures_of_t<_Sender, _Env>;
    }
    return true;
  }

  template <class _Sender, class _Receiver>
  static constexpr auto __select_impl() noexcept {
    using _Domain = __late_domain_of_t<_Sender, env_of_t<_Receiver>>;
    using _TfxSender = __tfx_sender<_Sender, _Receiver>;
    constexpr bool _NothrowTfxSender =
        __nothrow_callable<transform_sender_t, _Domain, _Sender,
                           env_of_t<_Receiver>>;

    static_assert(sender<_Sender>,
                  "The first argument to stdexec::connect must be a sender");
    static_assert(receiver<_Receiver>,
                  "The second argument to stdexec::connect must be a receiver");

    if constexpr (__with_static_member<_TfxSender, _Receiver>) {
      using _Result = __static_member_result_t<_TfxSender, _Receiver>;
      static_assert(operation_state<_Result>,
                    "Sender::connect(sender, receiver) must return a type that "
                    "satisfies the operation_state concept");
      constexpr bool _Nothrow =
          _NothrowTfxSender &&
          noexcept(__declval<_TfxSender>().connect(__declval<_TfxSender>(),
                                                   __declval<_Receiver>()));
      return static_cast<_Result (*)() noexcept(_Nothrow)>(nullptr);
    } else if constexpr (__with_member<_TfxSender, _Receiver>) {
      using _Result = __member_result_t<_TfxSender, _Receiver>;
      static_assert(operation_state<_Result>,
                    "sender.connect(receiver) must return a type that "
                    "satisfies the operation_state concept");
      constexpr bool _Nothrow =
          _NothrowTfxSender &&
          noexcept(__declval<_TfxSender>().connect(__declval<_Receiver>()));
      return static_cast<_Result (*)() noexcept(_Nothrow)>(nullptr);
    } else if constexpr (__with_tag_invoke<_TfxSender, _Receiver>) {
      using _Result = tag_invoke_result_t<connect_t, _TfxSender, _Receiver>;
      static_assert(
          operation_state<_Result>,
          "stdexec::connect(sender, receiver) must return a type that "
          "satisfies the operation_state concept");
      constexpr bool _Nothrow =
          _NothrowTfxSender &&
          nothrow_tag_invocable<connect_t, _TfxSender, _Receiver>;
      return static_cast<_Result (*)() noexcept(_Nothrow)>(nullptr);
    } else if constexpr (__with_co_await<_TfxSender, _Receiver>) {
      using _Result =
          __call_result_t<__connect_awaitable_t, _TfxSender, _Receiver>;
      return static_cast<_Result (*)()>(nullptr);
    } else if constexpr (__is_debug_env<env_of_t<_Receiver>>) {
      using _Result = __debug::__debug_operation;
      return static_cast<_Result (*)() noexcept(_NothrowTfxSender)>(nullptr);
    } else {
      return _NO_USABLE_CONNECT_CUSTOMIZATION_FOUND_();
    }
  }

  template <class _Sender, class _Receiver>
  using __select_impl_t = decltype(__select_impl<_Sender, _Receiver>());

  template <class _Sender, class _Receiver>
  auto operator()(_Sender &&__sndr, _Receiver &&__rcvr) const
      noexcept(__nothrow_callable<__select_impl_t<_Sender, _Receiver>>)
          -> __call_result_t<__select_impl_t<_Sender, _Receiver>> {
    using _TfxSender = __tfx_sender<_Sender, _Receiver>;
    auto &&__env = get_env(__rcvr);
    auto __domain = __get_late_domain(__sndr, __env);

    if constexpr (__with_static_member<_TfxSender, _Receiver>) {
      auto &&__tfx_sndr =
          transform_sender(__domain, static_cast<_Sender &&>(__sndr), __env);
      return __tfx_sndr.connect(static_cast<_TfxSender &&>(__tfx_sndr),
                                static_cast<_Receiver &&>(__rcvr));
    } else if constexpr (__with_member<_TfxSender, _Receiver>) {
      return transform_sender(__domain, static_cast<_Sender &&>(__sndr), __env)
          .connect(static_cast<_Receiver &&>(__rcvr));
    } else if constexpr (__with_tag_invoke<_TfxSender, _Receiver>) {
      return tag_invoke(
          connect_t(),
          transform_sender(__domain, static_cast<_Sender &&>(__sndr), __env),
          static_cast<_Receiver &&>(__rcvr));
    } else if constexpr (__with_co_await<_TfxSender, _Receiver>) {
      return __connect_awaitable(
          transform_sender(__domain, static_cast<_Sender &&>(__sndr), __env),
          static_cast<_Receiver &&>(__rcvr));
    } else {

      using __tag_invoke::tag_invoke;
      tag_invoke(
          *this,
          transform_sender(__domain, static_cast<_Sender &&>(__sndr), __env),
          static_cast<_Receiver &&>(__rcvr));
    }
  }

  static constexpr auto query(forwarding_query_t) noexcept -> bool {
    return false;
  }
};
} // namespace __connect

using __connect::connect_t;
inline constexpr __connect::connect_t connect{};

template <class _Tag, class... _Args>
auto __tag_of_sig_(_Tag (*)(_Args...)) -> _Tag;
template <class _Sig>
using __tag_of_sig_t =
    decltype(stdexec::__tag_of_sig_(static_cast<_Sig *>(nullptr)));

template <class _Sender, class _SetSig, class _Env = env<>>
concept sender_of =
    sender_in<_Sender, _Env> &&
    same_as<
        __types<_SetSig>,
        __gather_completions_of<
            __tag_of_sig_t<_SetSig>, _Sender, _Env,
            __mcompose_q<__types, __qf<__tag_of_sig_t<_SetSig>>::template __f>,
            __mconcat<__qq<__types>>>>;

template <class _Error>
  requires false
using __nofail_t = _Error;

template <class _Sender, class _Env = env<>>
concept __nofail_sender = sender_in<_Sender, _Env> && requires {
  typename __gather_completion_signatures<
      __completion_signatures_of_t<_Sender, _Env>, set_error_t, __nofail_t,
      __sigs::__default_completion, __types>;
};

template <class _Sender>
concept __well_formed_sender = __detail::__well_formed_completions<__minvoke<
    __with_default_q<__completion_signatures_of_t, dependent_completions>,
    _Sender>>;

template <class _Sender, class... _Env>
auto __diagnose_sender_concept_failure() {
  if constexpr (!enable_sender<_Sender>) {
    static_assert(enable_sender<_Sender>,
                  "The given type is not a sender because "
                  "stdexec::enable_sender<Sender> is false. Either "
                  "give the type a nested ::sender_concept typedef that is an "
                  "alias for stdexec::sender_t, "
                  "or else specialize the stdexec::enable_sender boolean trait "
                  "for this type to true.");
  } else if constexpr (!__detail::__consistent_completion_domains<_Sender>) {
    static_assert(__detail::__consistent_completion_domains<_Sender>,
                  "The completion schedulers of the sender do not have "
                  "consistent domains. This is likely a "
                  "bug in the sender implementation.");
  } else if constexpr (!move_constructible<__decay_t<_Sender>>) {
    static_assert(move_constructible<__decay_t<_Sender>>,
                  "The sender type is not move-constructible.");
  } else if constexpr (!constructible_from<__decay_t<_Sender>, _Sender>) {
    static_assert(
        constructible_from<__decay_t<_Sender>, _Sender>,
        "The sender cannot be decay-copied. Did you forget a std::move?");
  } else {
    using _Completions = __completion_signatures_of_t<_Sender, _Env...>;
    if constexpr (__same_as<_Completions,
                            __unrecognized_sender_error<_Sender, _Env...>>) {
      static_assert(
          __mnever<_Completions>,
          "The sender type was not able to report its completion signatures "
          "when asked. This is "
          "either because it lacks the necessary member functions, or because "
          "the member functions "
          "were ill-formed.\n\nA sender can declare its completion signatures "
          "in one of two ways:\n"
          "  1. By defining a nested type alias named `completion_signatures` "
          "that is a\n"
          "     specialization of stdexec::completion_signatures<...>.\n"
          "  2. By defining a member function named "
          "`get_completion_signatures` that returns a\n"
          "     specialization of stdexec::completion_signatures<...>.");
    } else if constexpr (__merror<_Completions>) {
      static_assert(!__merror<_Completions>,
                    "Trying to compute the sender's completion signatures "
                    "resulted in an error. See the rest "
                    "of the compiler diagnostic for clues. Look for the string "
                    "\"_ERROR_\".");
    } else {
      static_assert(__valid_completion_signatures<_Completions>,
                    "The stdexec::sender_in<Sender, Environment> concept check "
                    "has failed. This is likely a "
                    "bug in the sender implementation.");
    }
  }
}
} // namespace stdexec
# 26 "./../stdexec/include/stdexec/__detail/__as_awaitable.hpp" 2

namespace stdexec {

namespace __as_awaitable {
struct __void {};

template <class _Value>
using __value_or_void_t = __if_c<__same_as<_Value, void>, __void, _Value>;

template <class _Value>
using __expected_t =
    std::variant<std::monostate, __value_or_void_t<_Value>, std::exception_ptr>;

template <class _Value> struct __receiver_base {
  using receiver_concept = receiver_t;

  template <class... _Us>
    requires constructible_from<__value_or_void_t<_Value>, _Us...>
  void set_value(_Us &&...__us) noexcept {
    try {
      __result_->template emplace<1>(static_cast<_Us &&>(__us)...);
      __continuation_.resume();
    } catch (...) {
      stdexec::set_error(static_cast<__receiver_base &&>(*this),
                         std::current_exception());
    }
  }

  template <class _Error> void set_error(_Error &&__err) noexcept {
    if constexpr (__decays_to<_Error, std::exception_ptr>)
      __result_->template emplace<2>(static_cast<_Error &&>(__err));
    else if constexpr (__decays_to<_Error, std::error_code>)
      __result_->template emplace<2>(
          std::make_exception_ptr(std::system_error(__err)));
    else
      __result_->template emplace<2>(
          std::make_exception_ptr(static_cast<_Error &&>(__err)));
    __continuation_.resume();
  }

  __expected_t<_Value> *__result_;
  __coro::coroutine_handle<> __continuation_;
};

template <class _PromiseId, class _Value> struct __receiver {
  using _Promise = stdexec::__t<_PromiseId>;

  struct __t : __receiver_base<_Value> {
    using __id = __receiver;

    void set_stopped() noexcept {
      auto __continuation = __coro::coroutine_handle<_Promise>::from_address(
          this->__continuation_.address());
      __coro::coroutine_handle<> __stopped_continuation =
          __continuation.promise().unhandled_stopped();
      __stopped_continuation.resume();
    }

    auto get_env() const noexcept -> env_of_t<_Promise &> {
      auto __continuation = __coro::coroutine_handle<_Promise>::from_address(
          this->__continuation_.address());
      return stdexec::get_env(__continuation.promise());
    }
  };
};

template <std::size_t _Count> extern const __q<__decayed_std_tuple> __as_single;

template <> inline const __q<__midentity> __as_single<1>;

template <> inline const __mconst<void> __as_single<0>;

template <class... _Values>
using __single_value =
    __minvoke<decltype(__as_single<sizeof...(_Values)>), _Values...>;

template <class _Sender, class _Promise>
using __value_t =
    __decay_t<__value_types_of_t<_Sender, env_of_t<_Promise &>,
                                 __q<__single_value>, __msingle_or<void>>>;

template <class _Sender, class _Promise>
using __receiver_t =
    __t<__receiver<__id<_Promise>, __value_t<_Sender, _Promise>>>;

template <class _Value> struct __sender_awaitable_base {
  [[nodiscard]]
  auto await_ready() const noexcept -> bool {
    return false;
  }

  auto await_resume() -> _Value {
    switch (__result_.index()) {
    case 0:
      do {
        static_assert(noexcept(false && +"_Should never get here" == nullptr));
        (static_cast<bool>(false && +"_Should never get here" == nullptr)
             ? void(0)
             : __assert_fail("false && +\"_Should never get here\" == nullptr",
                             __builtin_FILE(), __builtin_LINE(),
                             __extension__ __PRETTY_FUNCTION__));
      } while (false);
      break;
    case 1:
      if constexpr (!__same_as<_Value, void>)
        return static_cast<_Value &&>(std::get<1>(__result_));
      else
        return;
    case 2:
      std::rethrow_exception(std::get<2>(__result_));
    }
    std::terminate();
  }

protected:
  __expected_t<_Value> __result_;
};

template <class _PromiseId, class _SenderId> struct __sender_awaitable {
  using _Promise = stdexec::__t<_PromiseId>;
  using _Sender = stdexec::__t<_SenderId>;
  using __value = __value_t<_Sender, _Promise>;

  struct __t : __sender_awaitable_base<__value> {
    __t(_Sender &&sndr, __coro::coroutine_handle<_Promise> __hcoro) noexcept(
        __nothrow_connectable<_Sender, __receiver>)
        : __op_state_(connect(static_cast<_Sender &&>(sndr),
                              __receiver{{&this->__result_, __hcoro}})) {}

    void await_suspend(__coro::coroutine_handle<_Promise>) noexcept {
      stdexec::start(__op_state_);
    }

  private:
    using __receiver = __receiver_t<_Sender, _Promise>;
    connect_result_t<_Sender, __receiver> __op_state_;
  };
};

template <class _Promise, class _Sender>
using __sender_awaitable_t =
    __t<__sender_awaitable<__id<_Promise>, __id<_Sender>>>;

template <class _Sender, class _Promise>
concept __awaitable_sender =
    sender_in<_Sender, env_of_t<_Promise &>> &&
    __mvalid<__value_t, _Sender, _Promise> &&
    sender_to<_Sender, __receiver_t<_Sender, _Promise>> &&
    requires(_Promise &__promise) {
      {
        __promise.unhandled_stopped()
      } -> convertible_to<__coro::coroutine_handle<>>;
    };

struct __unspecified {
  auto get_return_object() noexcept -> __unspecified;
  auto initial_suspend() noexcept -> __unspecified;
  auto final_suspend() noexcept -> __unspecified;
  void unhandled_exception() noexcept;
  void return_void() noexcept;
  auto unhandled_stopped() noexcept -> __coro::coroutine_handle<>;
};

struct as_awaitable_t {
  template <class _Tp, class _Promise>
  static constexpr auto __select_impl_() noexcept {
    if constexpr (tag_invocable<as_awaitable_t, _Tp, _Promise &>) {
      using _Result = tag_invoke_result_t<as_awaitable_t, _Tp, _Promise &>;
      constexpr bool _Nothrow =
          nothrow_tag_invocable<as_awaitable_t, _Tp, _Promise &>;
      return static_cast<_Result (*)() noexcept(_Nothrow)>(nullptr);

    } else if constexpr (__awaitable<_Tp, __unspecified>) {
      using _Result = _Tp &&;
      return static_cast<_Result (*)() noexcept>(nullptr);
    } else if constexpr (__awaitable_sender<_Tp, _Promise>) {
      using _Result = __sender_awaitable_t<_Promise, _Tp>;
      constexpr bool _Nothrow =
          __nothrow_constructible_from<_Result, _Tp,
                                       __coro::coroutine_handle<_Promise>>;
      return static_cast<_Result (*)() noexcept(_Nothrow)>(nullptr);
    } else {
      using _Result = _Tp &&;
      return static_cast<_Result (*)() noexcept>(nullptr);
    }
  }

  template <class _Tp, class _Promise>
  using __select_impl_t = decltype(__select_impl_<_Tp, _Promise>());

  template <class _Tp, class _Promise>
  auto operator()(_Tp &&__t, _Promise &__promise) const
      noexcept(__nothrow_callable<__select_impl_t<_Tp, _Promise>>)
          -> __call_result_t<__select_impl_t<_Tp, _Promise>> {
    if constexpr (tag_invocable<as_awaitable_t, _Tp, _Promise &>) {
      using _Result = tag_invoke_result_t<as_awaitable_t, _Tp, _Promise &>;
      static_assert(__awaitable<_Result, _Promise>);
      return tag_invoke(*this, static_cast<_Tp &&>(__t), __promise);

    } else if constexpr (__awaitable<_Tp, __unspecified>) {
      return static_cast<_Tp &&>(__t);
    } else if constexpr (__awaitable_sender<_Tp, _Promise>) {
      auto __hcoro =
          __coro::coroutine_handle<_Promise>::from_promise(__promise);
      return __sender_awaitable_t<_Promise, _Tp>{static_cast<_Tp &&>(__t),
                                                 __hcoro};
    } else {
      return static_cast<_Tp &&>(__t);
    }
  }
};
} // namespace __as_awaitable

using __as_awaitable::as_awaitable_t;
inline constexpr as_awaitable_t as_awaitable{};

} // namespace stdexec
# 22 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__bulk.hpp" 1
# 18 "./../stdexec/include/stdexec/__detail/__bulk.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__execution_legacy.hpp" 1
# 20 "./../stdexec/include/stdexec/__detail/__execution_legacy.hpp"
namespace stdexec {
# 39 "./../stdexec/include/stdexec/__detail/__execution_legacy.hpp"
struct __hidden_construction {};

struct sequenced_policy {
  constexpr explicit sequenced_policy(__hidden_construction){};
  sequenced_policy(const sequenced_policy &) = delete;
  sequenced_policy &operator=(const sequenced_policy &) = delete;
};

struct parallel_policy {
  constexpr explicit parallel_policy(__hidden_construction){};
  parallel_policy(const parallel_policy &) = delete;
  parallel_policy &operator=(const parallel_policy &) = delete;
};

struct parallel_unsequenced_policy {
  constexpr explicit parallel_unsequenced_policy(__hidden_construction){};
  parallel_unsequenced_policy(const parallel_unsequenced_policy &) = delete;
  parallel_unsequenced_policy &
  operator=(const parallel_unsequenced_policy &) = delete;
};

struct unsequenced_policy {
  constexpr explicit unsequenced_policy(__hidden_construction){};
  unsequenced_policy(const unsequenced_policy &) = delete;
  unsequenced_policy &operator=(const unsequenced_policy &) = delete;
};

inline constexpr sequenced_policy seq{__hidden_construction{}};
inline constexpr parallel_policy par{__hidden_construction{}};
inline constexpr parallel_unsequenced_policy par_unseq{__hidden_construction{}};
inline constexpr unsequenced_policy unseq{__hidden_construction{}};

template <typename> inline constexpr bool is_execution_policy_v = false;

template <>
inline constexpr bool is_execution_policy_v<sequenced_policy> = true;

template <> inline constexpr bool is_execution_policy_v<parallel_policy> = true;

template <>
inline constexpr bool is_execution_policy_v<parallel_unsequenced_policy> = true;

template <>
inline constexpr bool is_execution_policy_v<unsequenced_policy> = true;

template <class _T>
struct is_execution_policy : std::bool_constant<is_execution_policy_v<_T>> {};

} // namespace stdexec
# 19 "./../stdexec/include/stdexec/__detail/__bulk.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__sender_adaptor_closure.hpp" 1
# 25 "./../stdexec/include/stdexec/__detail/__sender_adaptor_closure.hpp"
namespace stdexec {

namespace __closure {
template <__class _Dp> struct sender_adaptor_closure;
}

using __closure::sender_adaptor_closure;

template <class _Tp>
concept __sender_adaptor_closure =
    derived_from<__decay_t<_Tp>, sender_adaptor_closure<__decay_t<_Tp>>> &&
    move_constructible<__decay_t<_Tp>> &&
    constructible_from<__decay_t<_Tp>, _Tp>;

template <class _Tp, class _Sender>
concept __sender_adaptor_closure_for =
    __sender_adaptor_closure<_Tp> && sender<__decay_t<_Sender>> &&
    __callable<_Tp, __decay_t<_Sender>> &&
    sender<__call_result_t<_Tp, __decay_t<_Sender>>>;

namespace __closure {
template <class _T0, class _T1>
struct __compose : sender_adaptor_closure<__compose<_T0, _T1>> {
  [[no_unique_address]] _T0 __t0_;
  [[no_unique_address]] _T1 __t1_;

  template <sender _Sender>
    requires __callable<_T0, _Sender> &&
                 __callable<_T1, __call_result_t<_T0, _Sender>>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Sender &&__sndr)
      && -> __call_result_t<_T1, __call_result_t<_T0, _Sender>> {
    return static_cast<_T1 &&>(__t1_)(
        static_cast<_T0 &&>(__t0_)(static_cast<_Sender &&>(__sndr)));
  }

  template <sender _Sender>
    requires __callable<const _T0 &, _Sender> &&
                 __callable<const _T1 &, __call_result_t<const _T0 &, _Sender>>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Sender &&__sndr) const
      & -> __call_result_t<const _T1 &, __call_result_t<const _T0 &, _Sender>> {
    return __t1_(__t0_(static_cast<_Sender &&>(__sndr)));
  }
};

template <__class _Dp> struct sender_adaptor_closure {};

template <sender _Sender, __sender_adaptor_closure_for<_Sender> _Closure>
__attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
operator|(_Sender &&__sndr,
          _Closure &&__clsur) -> __call_result_t<_Closure, _Sender> {
  return static_cast<_Closure &&>(__clsur)(static_cast<_Sender &&>(__sndr));
}

template <__sender_adaptor_closure _T0, __sender_adaptor_closure _T1>
__attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
operator|(_T0 &&__t0, _T1 &&__t1) -> __compose<__decay_t<_T0>, __decay_t<_T1>> {
  return {{}, static_cast<_T0 &&>(__t0), static_cast<_T1 &&>(__t1)};
}

template <class _Fun, class... _As>
struct __binder_back : __tuple_for<_As...>,
                       sender_adaptor_closure<__binder_back<_Fun, _As...>> {
  [[no_unique_address]] _Fun __fun_{};
# 120 "./../stdexec/include/stdexec/__detail/__sender_adaptor_closure.hpp"
  template <sender _Sender>
    requires __callable<_Fun, _Sender, _As...>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Sender &&__sndr) && noexcept(
      __nothrow_callable<_Fun, _Sender, _As...>)
      -> __call_result_t<_Fun, _Sender, _As...> {

    return this->apply(
        [&__sndr,
         this](_As &...__as) noexcept(__nothrow_callable<_Fun, _Sender, _As...>)
            -> __call_result_t<_Fun, _Sender, _As...> {
          return static_cast<_Fun &&>(__fun_)(static_cast<_Sender &&>(__sndr),
                                              static_cast<_As &&>(__as)...);
        },
        *this);
  }

  template <sender _Sender>
    requires __callable<const _Fun &, _Sender, const _As &...>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Sender &&__sndr) const & noexcept(
      __nothrow_callable<const _Fun &, _Sender, const _As &...>)
      -> __call_result_t<const _Fun &, _Sender, const _As &...> {

    return this->apply(
        [&__sndr, this](const _As &...__as) noexcept(
            __nothrow_callable<const _Fun &, _Sender, const _As &...>)
            -> __call_result_t<const _Fun &, _Sender, const _As &...> {
          return __fun_(static_cast<_Sender &&>(__sndr), __as...);
        },
        *this);
  }
};
} // namespace __closure

using __closure::__binder_back;
} // namespace stdexec
# 28 "./../stdexec/include/stdexec/__detail/__bulk.hpp" 2

#pragma GCC diagnostic push
# 32 "./../stdexec/include/stdexec/__detail/__bulk.hpp"
#pragma GCC diagnostic ignored "-Wpragmas"
# 32 "./../stdexec/include/stdexec/__detail/__bulk.hpp"
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
# 32 "./../stdexec/include/stdexec/__detail/__bulk.hpp"
#pragma GCC diagnostic ignored "-Wunknown-warning-option"
# 32 "./../stdexec/include/stdexec/__detail/__bulk.hpp"
#pragma GCC diagnostic ignored "-Wunknown-attributes"
# 32 "./../stdexec/include/stdexec/__detail/__bulk.hpp"
#pragma GCC diagnostic ignored "-Wattributes"
#pragma GCC diagnostic ignored "-Wmissing-braces"

namespace stdexec {

namespace __bulk {
struct bulk_t;
struct bulk_chunked_t;
struct bulk_unchunked_t;

template <class _Pol> struct __policy_wrapper {
  _Pol __pol_;

  __policy_wrapper(_Pol __pol) : __pol_{__pol} {}

  const _Pol &__get() const noexcept { return __pol_; }
};

template <> struct __policy_wrapper<sequenced_policy> {
  __policy_wrapper(const sequenced_policy &) {}

  const sequenced_policy &__get() const noexcept { return seq; }
};

template <> struct __policy_wrapper<parallel_policy> {
  __policy_wrapper(const parallel_policy &) {}

  const parallel_policy &__get() const noexcept { return par; }
};

template <> struct __policy_wrapper<parallel_unsequenced_policy> {
  __policy_wrapper(const parallel_unsequenced_policy &) {}

  const parallel_unsequenced_policy &__get() const noexcept {
    return par_unseq;
  }
};

template <> struct __policy_wrapper<unsequenced_policy> {
  __policy_wrapper(const unsequenced_policy &) {}

  const unsequenced_policy &__get() const noexcept { return unseq; }
};

template <class _Pol, class _Shape, class _Fun> struct __data {
  [[no_unique_address]] __policy_wrapper<_Pol> __pol_;
  _Shape __shape_;
  [[no_unique_address]] _Fun __fun_;
  static constexpr auto __mbrs_ =
      __mliterals<&__data::__pol_, &__data::__shape_, &__data::__fun_>();
};
template <class _Pol, class _Shape, class _Fun>
__data(const _Pol &, _Shape, _Fun) -> __data<_Pol, _Shape, _Fun>;

template <class _AlgoTag> struct __bulk_traits;

template <> struct __bulk_traits<bulk_t> {
  using __on_not_callable = __callable_error<
      "In stdexec::bulk(Sender, Policy, Shape, Function)..."_mstr>;

  template <class _Fun, class _Shape>
  using __fun_curried =
      __mbind_front<__mtry_catch_q<__nothrow_invocable_t, __on_not_callable>,
                    _Fun, _Shape>;
};

template <> struct __bulk_traits<bulk_chunked_t> {
  using __on_not_callable = __callable_error<
      "In stdexec::bulk_chunked(Sender, Policy, Shape, Function)..."_mstr>;

  template <class _Fun, class _Shape>
  using __fun_curried =
      __mbind_front<__mtry_catch_q<__nothrow_invocable_t, __on_not_callable>,
                    _Fun, _Shape, _Shape>;
};

template <> struct __bulk_traits<bulk_unchunked_t> {
  using __on_not_callable = __callable_error<
      "In stdexec::bulk_unchunked(Sender, Shape, Function)..."_mstr>;

  template <class _Fun, class _Shape>
  using __fun_curried =
      __mbind_front<__mtry_catch_q<__nothrow_invocable_t, __on_not_callable>,
                    _Fun, _Shape>;
};

template <class _Ty> using __decay_ref = __decay_t<_Ty> &;

template <class _AlgoTag, class _Fun, class _Shape, class _CvrefSender,
          class... _Env>
using __with_error_invoke_t =
    __if<__value_types_t<__completion_signatures_of_t<_CvrefSender, _Env...>,
                         __mtransform<__q<__decay_ref>,
                                      typename __bulk_traits<_AlgoTag>::
                                          template __fun_curried<_Fun, _Shape>>,
                         __q<__mand>>,
         completion_signatures<>, __eptr_completion>;

template <class _AlgoTag, class _Fun, class _Shape, class _CvrefSender,
          class... _Env>
using __completion_signatures = transform_completion_signatures<
    __completion_signatures_of_t<_CvrefSender, _Env...>,
    __with_error_invoke_t<_AlgoTag, _Fun, _Shape, _CvrefSender, _Env...>>;

template <class _AlgoTag> struct __generic_bulk_t {
  template <sender _Sender, typename _Policy, integral _Shape,
            copy_constructible _Fun>
    requires is_execution_policy_v<std::remove_cvref_t<_Policy>>

  auto operator()(_Sender &&__sndr, _Policy &&__pol, _Shape __shape,
                  _Fun __fun) const -> __well_formed_sender auto {
    auto __domain = __get_early_domain(__sndr);
    return stdexec::transform_sender(
        __domain, __make_sexpr<_AlgoTag>(
                      __data{__pol, __shape, static_cast<_Fun &&>(__fun)},
                      static_cast<_Sender &&>(__sndr)));
  }

  template <typename _Policy, integral _Shape, copy_constructible _Fun>
    requires is_execution_policy_v<std::remove_cvref_t<_Policy>>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Policy &&__pol, _Shape __shape, _Fun __fun) const
      -> __binder_back<_AlgoTag, _Policy, _Shape, _Fun> {
    return {{static_cast<_Policy &&>(__pol), static_cast<_Shape &&>(__shape),
             static_cast<_Fun &&>(__fun)},
            {},
            {}};
  }

  template <sender _Sender, integral _Shape, copy_constructible _Fun>
  [[deprecated("The bulk algorithm now requires an execution policy such as "
               "stdexec::par as an "
               "argument.")]]
  auto operator()(_Sender &&__sndr, _Shape __shape, _Fun __fun) const {
    return (*this)(static_cast<_Sender &&>(__sndr), par,
                   static_cast<_Shape &&>(__shape),
                   static_cast<_Fun &&>(__fun));
  }

  template <integral _Shape, copy_constructible _Fun>
  [[deprecated("The bulk algorithm now requires an execution policy such as "
               "stdexec::par as an "
               "argument.")]]
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Shape __shape, _Fun __fun) const {
    return (*this)(par, static_cast<_Shape &&>(__shape),
                   static_cast<_Fun &&>(__fun));
  }
};

struct bulk_t : __generic_bulk_t<bulk_t> {
  template <class _Env> static auto __transform_sender_fn(const _Env &) {
    return [&]<class _Data, class _Child>(__ignore, _Data &&__data,
                                          _Child &&__child) {
      using __shape_t = std::remove_cvref_t<decltype(__data.__shape_)>;
      auto __new_f = [__func = std::move(__data.__fun_)](__shape_t __begin,
                                                         __shape_t __end,
                                                         auto &&...__vs) mutable

          noexcept(noexcept(__data.__fun_(__begin++, __vs...)))

      {
        while (__begin != __end)
          __func(__begin++, __vs...);
      };

      return bulk_chunked(static_cast<_Child &&>(__child),
                          __data.__pol_.__get(), __data.__shape_,
                          std::move(__new_f));
    };
  }

  template <class _Sender, class _Env>
  static auto transform_sender(_Sender &&__sndr, const _Env &__env) {
    return __sexpr_apply(static_cast<_Sender &&>(__sndr),
                         __transform_sender_fn(__env));
  }
};

struct bulk_chunked_t : __generic_bulk_t<bulk_chunked_t> {};

struct bulk_unchunked_t {
  template <sender _Sender, integral _Shape, copy_constructible _Fun>

  auto operator()(_Sender &&__sndr, _Shape __shape,
                  _Fun __fun) const -> __well_formed_sender auto {
    auto __domain = __get_early_domain(__sndr);
    return stdexec::transform_sender(
        __domain, __make_sexpr<bulk_unchunked_t>(
                      __data{par, __shape, static_cast<_Fun &&>(__fun)},
                      static_cast<_Sender &&>(__sndr)));
  }

  template <integral _Shape, copy_constructible _Fun>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Shape __shape, _Fun __fun) const
      -> __binder_back<bulk_unchunked_t, _Shape, _Fun> {
    return {
        {static_cast<_Shape &&>(__shape), static_cast<_Fun &&>(__fun)}, {}, {}};
  }
};

template <class _AlgoTag> struct __bulk_impl_base : __sexpr_defaults {
  template <class _Sender>
  using __fun_t = decltype(__decay_t<__data_of<_Sender>>::__fun_);

  template <class _Sender>
  using __shape_t = decltype(__decay_t<__data_of<_Sender>>::__shape_);

  static constexpr auto get_completion_signatures =
      []<class _Sender, class... _Env>(_Sender &&, _Env &&...) noexcept
      -> __completion_signatures<_AlgoTag, __fun_t<_Sender>, __shape_t<_Sender>,
                                 __child_of<_Sender>, _Env...> {
    static_assert(sender_expr_for<_Sender, bulk_t>);
    return {};
  };
};

struct __bulk_chunked_impl : __bulk_impl_base<bulk_chunked_t> {

  static constexpr auto complete =
      []<class _Tag, class _State, class _Receiver, class... _Args>(
          __ignore, _State &__state, _Receiver &__rcvr, _Tag,
          _Args &&...__args) noexcept -> void {
    if constexpr (same_as<_Tag, set_value_t>) {

      using __shape_t = decltype(__state.__shape_);
      if constexpr (noexcept(
                        __state.__fun_(__shape_t{}, __shape_t{}, __args...))) {

        __state.__fun_(static_cast<__shape_t>(0), __state.__shape_, __args...);
        _Tag()(static_cast<_Receiver &&>(__rcvr),
               static_cast<_Args &&>(__args)...);
      } else {
        try {
          __state.__fun_(static_cast<__shape_t>(0), __state.__shape_,
                         __args...);
          _Tag()(static_cast<_Receiver &&>(__rcvr),
                 static_cast<_Args &&>(__args)...);
        } catch (...) {
          stdexec::set_error(static_cast<_Receiver &&>(__rcvr),
                             std::current_exception());
        }
      }
    } else {
      _Tag()(static_cast<_Receiver &&>(__rcvr),
             static_cast<_Args &&>(__args)...);
    }
  };
};

struct __bulk_unchunked_impl : __bulk_impl_base<bulk_unchunked_t> {

  static constexpr auto complete =
      []<class _Tag, class _State, class _Receiver, class... _Args>(
          __ignore, _State &__state, _Receiver &__rcvr, _Tag,
          _Args &&...__args) noexcept -> void {
    if constexpr (std::same_as<_Tag, set_value_t>) {

      using __shape_t = decltype(__state.__shape_);
      constexpr bool __scheduler_available =
          requires { get_completion_scheduler<set_value_t>(get_env(__rcvr)); };
      if constexpr (__scheduler_available) {

        constexpr auto __guarantee = get_forward_progress_guarantee(
            get_completion_scheduler<set_value_t>(get_env(__rcvr)));
        static_assert(__guarantee != forward_progress_guarantee::concurrent);
      }
      if constexpr (noexcept(__state.__fun_(__shape_t{}, __args...))) {

        for (__shape_t __i{}; __i != __state.__shape_; ++__i) {
          __state.__fun_(__i, __args...);
        }
        _Tag()(static_cast<_Receiver &&>(__rcvr),
               static_cast<_Args &&>(__args)...);
      } else {
        try {
          for (__shape_t __i{}; __i != __state.__shape_; ++__i) {
            __state.__fun_(__i, __args...);
          }
          _Tag()(static_cast<_Receiver &&>(__rcvr),
                 static_cast<_Args &&>(__args)...);
        } catch (...) {
          stdexec::set_error(static_cast<_Receiver &&>(__rcvr),
                             std::current_exception());
        }
      }
    } else {
      _Tag()(static_cast<_Receiver &&>(__rcvr),
             static_cast<_Args &&>(__args)...);
    }
  };
};

struct __bulk_impl : __bulk_impl_base<bulk_t> {};
} // namespace __bulk

using __bulk::bulk_chunked_t;
using __bulk::bulk_t;
using __bulk::bulk_unchunked_t;
inline constexpr bulk_t bulk{};
inline constexpr bulk_chunked_t bulk_chunked{};
inline constexpr bulk_unchunked_t bulk_unchunked{};

template <> struct __sexpr_impl<bulk_t> : __bulk::__bulk_impl {};

template <>
struct __sexpr_impl<bulk_chunked_t> : __bulk::__bulk_chunked_impl {};

template <>
struct __sexpr_impl<bulk_unchunked_t> : __bulk::__bulk_unchunked_impl {};
} // namespace stdexec

#pragma GCC diagnostic pop
# 24 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__continues_on.hpp" 1
# 24 "./../stdexec/include/stdexec/__detail/__continues_on.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__schedule_from.hpp" 1
# 28 "./../stdexec/include/stdexec/__detail/__schedule_from.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__schedulers.hpp" 1
# 26 "./../stdexec/include/stdexec/__detail/__schedulers.hpp"
namespace stdexec {

namespace __sched {
struct schedule_t {
  template <__same_as<schedule_t> _Self, class _Scheduler>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline friend auto
  tag_invoke(_Self, _Scheduler &&__sched) noexcept(
      noexcept(static_cast<_Scheduler &&>(__sched).schedule()))
      -> decltype(static_cast<_Scheduler &&>(__sched).schedule()) {
    static_assert(
        sender<decltype(static_cast<_Scheduler &&>(__sched).schedule())>,
        "schedule() member functions must return a sender");
    return static_cast<_Scheduler &&>(__sched).schedule();
  }

  template <class _Scheduler>
    requires tag_invocable<schedule_t, _Scheduler>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Scheduler &&__sched) const
      noexcept(nothrow_tag_invocable<schedule_t, _Scheduler>) {
    static_assert(sender<tag_invoke_result_t<schedule_t, _Scheduler>>);
    return tag_invoke(schedule_t{}, static_cast<_Scheduler &&>(__sched));
  }

  static constexpr auto query(forwarding_query_t) noexcept -> bool {
    return false;
  }
};
} // namespace __sched

using __sched::schedule_t;
inline constexpr schedule_t schedule{};

template <class _Scheduler>
concept __has_schedule = requires(_Scheduler &&__sched) {
  { schedule(static_cast<_Scheduler &&>(__sched)) } -> sender;
};

template <class _Scheduler>
concept __sender_has_completion_scheduler = requires(_Scheduler &&__sched) {
  {
    stdexec::__decay_copy(get_completion_scheduler<set_value_t>(
        get_env(schedule(static_cast<_Scheduler &&>(__sched)))))
  } -> same_as<__decay_t<_Scheduler>>;
};

template <class _Scheduler>
concept scheduler = __has_schedule<_Scheduler> &&
                    __sender_has_completion_scheduler<_Scheduler> &&
                    equality_comparable<__decay_t<_Scheduler>> &&
                    copy_constructible<__decay_t<_Scheduler>>;

template <scheduler _Scheduler>
using schedule_result_t = __call_result_t<schedule_t, _Scheduler>;

template <class _SchedulerProvider>
concept __scheduler_provider = requires(const _SchedulerProvider &__sp) {
  { get_scheduler(__sp) } -> scheduler;
};

namespace __queries {
template <class _Env>
  requires tag_invocable<get_scheduler_t, const _Env &>
inline auto get_scheduler_t::operator()(const _Env &__env) const noexcept
    -> tag_invoke_result_t<get_scheduler_t, const _Env &> {
  static_assert(nothrow_tag_invocable<get_scheduler_t, const _Env &>);
  static_assert(scheduler<tag_invoke_result_t<get_scheduler_t, const _Env &>>);
  return tag_invoke(get_scheduler_t{}, __env);
}

template <class _Env>
  requires tag_invocable<get_delegation_scheduler_t, const _Env &>
inline auto get_delegation_scheduler_t::operator()(const _Env &__env) const
    noexcept -> tag_invoke_result_t<get_delegation_scheduler_t, const _Env &> {
  static_assert(
      nothrow_tag_invocable<get_delegation_scheduler_t, const _Env &>);
  static_assert(
      scheduler<tag_invoke_result_t<get_delegation_scheduler_t, const _Env &>>);
  return tag_invoke(get_delegation_scheduler_t{}, __env);
}

template <__completion_tag _Tag>
template <__has_completion_scheduler_for<_Tag> _Env>
auto get_completion_scheduler_t<_Tag>::operator()(
    const _Env &__env) const noexcept
    -> tag_invoke_result_t<get_completion_scheduler_t<_Tag>, const _Env &> {
  static_assert(
      nothrow_tag_invocable<get_completion_scheduler_t<_Tag>, const _Env &>,
      "get_completion_scheduler<_Tag> should be noexcept");
  static_assert(
      scheduler<
          tag_invoke_result_t<get_completion_scheduler_t<_Tag>, const _Env &>>);
  return tag_invoke(*this, __env);
}
} // namespace __queries
} // namespace stdexec
# 29 "./../stdexec/include/stdexec/__detail/__schedule_from.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__variant.hpp" 1
# 21 "./../stdexec/include/stdexec/__detail/__variant.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__scope.hpp" 1
# 22 "./../stdexec/include/stdexec/__detail/__scope.hpp"
namespace stdexec {
template <class _Fn, class... _Ts>
  requires __nothrow_callable<_Fn, _Ts...>
struct __scope_guard;

template <class _Fn> struct __scope_guard<_Fn> {
  [[no_unique_address]] _Fn __fn_;
  [[no_unique_address]] __immovable __hidden_{};
  bool __dismissed_{false};

  ~__scope_guard() {
    if (!__dismissed_)
      static_cast<_Fn &&>(__fn_)();
  }

  void __dismiss() noexcept { __dismissed_ = true; }
};

template <class _Fn, class _T0> struct __scope_guard<_Fn, _T0> {
  [[no_unique_address]] _Fn __fn_;
  [[no_unique_address]] _T0 __t0_;
  [[no_unique_address]] __immovable __hidden_{};

  bool __dismissed_{false};

  void __dismiss() noexcept { __dismissed_ = true; }

  ~__scope_guard() {
    if (!__dismissed_)
      static_cast<_Fn &&>(__fn_)(static_cast<_T0 &&>(__t0_));
  }
};

template <class _Fn, class _T0, class _T1> struct __scope_guard<_Fn, _T0, _T1> {
  [[no_unique_address]] _Fn __fn_;
  [[no_unique_address]] _T0 __t0_;
  [[no_unique_address]] _T1 __t1_;
  [[no_unique_address]] __immovable __hidden_{};

  bool __dismissed_{false};

  void __dismiss() noexcept { __dismissed_ = true; }

  ~__scope_guard() {
    if (!__dismissed_)
      static_cast<_Fn &&>(__fn_)(static_cast<_T0 &&>(__t0_),
                                 static_cast<_T1 &&>(__t1_));
  }
};

template <class _Fn, class _T0, class _T1, class _T2>
struct __scope_guard<_Fn, _T0, _T1, _T2> {
  [[no_unique_address]] _Fn __fn_;
  [[no_unique_address]] _T0 __t0_;
  [[no_unique_address]] _T1 __t1_;
  [[no_unique_address]] _T2 __t2_;
  [[no_unique_address]] __immovable __hidden_{};

  bool __dismissed_{false};

  void __dismiss() noexcept { __dismissed_ = true; }

  ~__scope_guard() {
    if (!__dismissed_)
      static_cast<_Fn &&>(__fn_)(static_cast<_T0 &&>(__t0_),
                                 static_cast<_T1 &&>(__t1_),
                                 static_cast<_T2 &&>(__t2_));
  }
};

template <class _Fn, class... _Ts>
__scope_guard(_Fn, _Ts...) -> __scope_guard<_Fn, _Ts...>;
} // namespace stdexec
# 22 "./../stdexec/include/stdexec/__detail/__variant.hpp" 2

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/memory" 1 3
# 48 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/memory" 3
# 70 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/memory" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_raw_storage_iter.h" 1 3
# 59 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_raw_storage_iter.h" 3
namespace std __attribute__((__visibility__("default"))) {

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

  template <class _OutputIterator, class _Tp>
  class [[__deprecated__]] raw_storage_iterator
      : public iterator<output_iterator_tag, void, void, void, void> {
  protected:
    _OutputIterator _M_iter;

  public:
    explicit raw_storage_iterator(_OutputIterator __x) : _M_iter(__x) {}

    raw_storage_iterator &operator*() { return *this; }

    raw_storage_iterator &operator=(const _Tp &__element) {
      std::_Construct(std::__addressof(*_M_iter), __element);
      return *this;
    }

    raw_storage_iterator &operator=(_Tp &&__element) {
      std::_Construct(std::__addressof(*_M_iter), std::move(__element));
      return *this;
    }

    raw_storage_iterator &operator++() {
      ++_M_iter;
      return *this;
    }

    raw_storage_iterator operator++(int) {
      raw_storage_iterator __tmp = *this;
      ++_M_iter;
      return __tmp;
    }

    _OutputIterator base() const { return _M_iter; }
  };
#pragma GCC diagnostic pop

} // namespace std
# 71 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/memory" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/align.h" 1 3
# 36 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/align.h" 3
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stdint.h" 1 3
# 52 "/usr/lib/llvm-18/lib/clang/18/include/stdint.h" 3
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h" 3 4
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;

typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
# 42 "/usr/include/stdint.h" 2 3 4

typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 60 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 76 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;

typedef unsigned long int uintptr_t;
# 90 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 53 "/usr/lib/llvm-18/lib/clang/18/include/stdint.h" 2 3
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/align.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 61 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/align.h" 3
  inline void *align(size_t __align, size_t __size, void *&__ptr,
                     size_t &__space) noexcept {
    if (__space < __size)
      return nullptr;
    const auto __intptr = reinterpret_cast<uintptr_t>(__ptr);
    const auto __aligned = (__intptr - 1u + __align) & -__align;
    const auto __diff = __aligned - __intptr;
    if (__diff > (__space - __size))
      return nullptr;
    else {
      __space -= __diff;
      return __ptr = reinterpret_cast<void *>(__aligned);
    }
  }
# 90 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/align.h" 3
  template <size_t _Align, class _Tp>
  [[nodiscard, __gnu__::__always_inline__]]
  constexpr _Tp *assume_aligned(_Tp * __ptr) noexcept {
    static_assert(std::has_single_bit(_Align));
    if (std::is_constant_evaluated())
      return __ptr;
    else {

      ;
      return static_cast<_Tp *>(__builtin_assume_aligned(__ptr, _Align));
    }
  }

} // namespace std
# 75 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/memory" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 1 3
# 53 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
namespace std __attribute__((__visibility__("default"))) {

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template <typename> class auto_ptr;
#pragma GCC diagnostic pop

  template <typename _Tp> struct default_delete {

    constexpr default_delete() noexcept = default;

    template <typename _Up, typename = _Require<is_convertible<_Up *, _Tp *>>>

    default_delete(const default_delete<_Up> &) noexcept {}

    void operator()(_Tp *__ptr) const {
      static_assert(!is_void<_Tp>::value,
                    "can't delete pointer to incomplete type");
      static_assert(sizeof(_Tp) > 0, "can't delete pointer to incomplete type");
      delete __ptr;
    }
  };
# 111 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
  template <typename _Tp> struct default_delete<_Tp[]> {
  public:
    constexpr default_delete() noexcept = default;
# 127 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
    template <typename _Up,
              typename = _Require<is_convertible<_Up (*)[], _Tp (*)[]>>>

    default_delete(const default_delete<_Up[]> &) noexcept {}

    template <typename _Up>

    typename enable_if<is_convertible<_Up (*)[], _Tp (*)[]>::value>::type
    operator()(_Up *__ptr) const {
      static_assert(sizeof(_Tp) > 0, "can't delete pointer to incomplete type");
      delete[] __ptr;
    }
  };

  template <typename _Tp, typename _Dp> class __uniq_ptr_impl {
    template <typename _Up, typename _Ep, typename = void> struct _Ptr {
      using type = _Up *;
    };

    template <typename _Up, typename _Ep>
    struct _Ptr<_Up, _Ep,
                __void_t<typename remove_reference<_Ep>::type::pointer>> {
      using type = typename remove_reference<_Ep>::type::pointer;
    };

  public:
    using _DeleterConstraint = enable_if<
        __and_<__not_<is_pointer<_Dp>>, is_default_constructible<_Dp>>::value>;

    using pointer = typename _Ptr<_Tp, _Dp>::type;

    static_assert(!is_rvalue_reference<_Dp>::value,
                  "unique_ptr's deleter type must be a function object type"
                  " or an lvalue reference type");

    __uniq_ptr_impl() = default;

    __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }

    template <typename _Del>

    __uniq_ptr_impl(pointer __p, _Del &&__d)
        : _M_t(__p, std::forward<_Del>(__d)) {}

    __uniq_ptr_impl(__uniq_ptr_impl &&__u) noexcept
        : _M_t(std::move(__u._M_t)) {
      __u._M_ptr() = nullptr;
    }

    __uniq_ptr_impl &operator=(__uniq_ptr_impl &&__u) noexcept {
      reset(__u.release());
      _M_deleter() = std::forward<_Dp>(__u._M_deleter());
      return *this;
    }

    pointer &_M_ptr() noexcept { return std::get<0>(_M_t); }

    pointer _M_ptr() const noexcept { return std::get<0>(_M_t); }

    _Dp &_M_deleter() noexcept { return std::get<1>(_M_t); }

    const _Dp &_M_deleter() const noexcept { return std::get<1>(_M_t); }

    void reset(pointer __p) noexcept {
      const pointer __old_p = _M_ptr();
      _M_ptr() = __p;
      if (__old_p)
        _M_deleter()(__old_p);
    }

    pointer release() noexcept {
      pointer __p = _M_ptr();
      _M_ptr() = nullptr;
      return __p;
    }

    void swap(__uniq_ptr_impl &__rhs) noexcept {
      using std::swap;
      swap(this->_M_ptr(), __rhs._M_ptr());
      swap(this->_M_deleter(), __rhs._M_deleter());
    }

  private:
    tuple<pointer, _Dp> _M_t;
  };

  template <typename _Tp, typename _Dp,
            bool = is_move_constructible<_Dp>::value,
            bool = is_move_assignable<_Dp>::value>
  struct __uniq_ptr_data : __uniq_ptr_impl<_Tp, _Dp> {
    using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
    __uniq_ptr_data(__uniq_ptr_data &&) = default;
    __uniq_ptr_data &operator=(__uniq_ptr_data &&) = default;
  };

  template <typename _Tp, typename _Dp>
  struct __uniq_ptr_data<_Tp, _Dp, true, false> : __uniq_ptr_impl<_Tp, _Dp> {
    using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
    __uniq_ptr_data(__uniq_ptr_data &&) = default;
    __uniq_ptr_data &operator=(__uniq_ptr_data &&) = delete;
  };

  template <typename _Tp, typename _Dp>
  struct __uniq_ptr_data<_Tp, _Dp, false, true> : __uniq_ptr_impl<_Tp, _Dp> {
    using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
    __uniq_ptr_data(__uniq_ptr_data &&) = delete;
    __uniq_ptr_data &operator=(__uniq_ptr_data &&) = default;
  };

  template <typename _Tp, typename _Dp>
  struct __uniq_ptr_data<_Tp, _Dp, false, false> : __uniq_ptr_impl<_Tp, _Dp> {
    using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
    __uniq_ptr_data(__uniq_ptr_data &&) = delete;
    __uniq_ptr_data &operator=(__uniq_ptr_data &&) = delete;
  };

  template <typename _Tp, typename _Dp = default_delete<_Tp>> class unique_ptr {
    template <typename _Up>
    using _DeleterConstraint =
        typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

    __uniq_ptr_data<_Tp, _Dp> _M_t;

  public:
    using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
    using element_type = _Tp;
    using deleter_type = _Dp;

  private:
    template <typename _Up, typename _Ep>
    using __safe_conversion_up =
        __and_<is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
               __not_<is_array<_Up>>>;

  public:
    template <typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
    constexpr unique_ptr() noexcept : _M_t() {}

    template <typename _Del = _Dp, typename = _DeleterConstraint<_Del>>

    explicit unique_ptr(pointer __p) noexcept : _M_t(__p) {}
# 328 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
    template <typename _Del = deleter_type,
              typename = _Require<is_copy_constructible<_Del>>>

    unique_ptr(pointer __p, const deleter_type &__d) noexcept
        : _M_t(__p, __d) {}
# 341 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
    template <typename _Del = deleter_type,
              typename = _Require<is_move_constructible<_Del>>>

    unique_ptr(
        pointer __p,
        __enable_if_t<!is_lvalue_reference<_Del>::value, _Del &&> __d) noexcept
        : _M_t(__p, std::move(__d)) {}

    template <typename _Del = deleter_type,
              typename _DelUnref = typename remove_reference<_Del>::type>

    unique_ptr(pointer,
               __enable_if_t<is_lvalue_reference<_Del>::value, _DelUnref &&>) =
        delete;

    template <typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
    constexpr unique_ptr(nullptr_t) noexcept : _M_t() {}

    unique_ptr(unique_ptr &&) = default;

    template <typename _Up, typename _Ep,
              typename = _Require<
                  __safe_conversion_up<_Up, _Ep>,
                  __conditional_t<is_reference<_Dp>::value, is_same<_Ep, _Dp>,
                                  is_convertible<_Ep, _Dp>>>>

    unique_ptr(unique_ptr<_Up, _Ep> &&__u) noexcept
        : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter())) {}

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

    template <typename _Up,
              typename = _Require<is_convertible<_Up *, _Tp *>,
                                  is_same<_Dp, default_delete<_Tp>>>>
    unique_ptr(auto_ptr<_Up> &&__u) noexcept;
#pragma GCC diagnostic pop

    ~unique_ptr() noexcept {
      static_assert(__is_invocable<deleter_type &, pointer>::value,
                    "unique_ptr's deleter must be invocable with a pointer");
      auto &__ptr = _M_t._M_ptr();
      if (__ptr != nullptr)
        get_deleter()(std::move(__ptr));
      __ptr = pointer();
    }

    unique_ptr &operator=(unique_ptr &&) = default;
# 423 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
    template <typename _Up, typename _Ep>

    typename enable_if<__and_<__safe_conversion_up<_Up, _Ep>,
                              is_assignable<deleter_type &, _Ep &&>>::value,
                       unique_ptr &>::type
    operator=(unique_ptr<_Up, _Ep> &&__u) noexcept {
      reset(__u.release());
      get_deleter() = std::forward<_Ep>(__u.get_deleter());
      return *this;
    }

    unique_ptr &operator=(nullptr_t) noexcept {
      reset();
      return *this;
    }

    typename add_lvalue_reference<element_type>::type operator*() const
        noexcept(noexcept(*std::declval<pointer>())) {
      do {
        if (std::__is_constant_evaluated() && !bool(get() != pointer()))
          __builtin_unreachable();
      } while (false);
      return *get();
    }

    pointer operator->() const noexcept {
      ;
      return get();
    }

    pointer get() const noexcept { return _M_t._M_ptr(); }

    deleter_type &get_deleter() noexcept { return _M_t._M_deleter(); }

    const deleter_type &get_deleter() const noexcept {
      return _M_t._M_deleter();
    }

    explicit operator bool() const noexcept {
      return get() == pointer() ? false : true;
    }

    pointer release() noexcept { return _M_t.release(); }
# 504 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
    void reset(pointer __p = pointer()) noexcept {
      static_assert(__is_invocable<deleter_type &, pointer>::value,
                    "unique_ptr's deleter must be invocable with a pointer");
      _M_t.reset(std::move(__p));
    }

    void swap(unique_ptr &__u) noexcept {
      static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
      _M_t.swap(__u._M_t);
    }

    unique_ptr(const unique_ptr &) = delete;
    unique_ptr &operator=(const unique_ptr &) = delete;
  };
# 534 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
  template <typename _Tp, typename _Dp> class unique_ptr<_Tp[], _Dp> {
    template <typename _Up>
    using _DeleterConstraint =
        typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

    __uniq_ptr_data<_Tp, _Dp> _M_t;

    template <typename _Up>
    using __is_derived_Tp =
        __and_<is_base_of<_Tp, _Up>,
               __not_<is_same<__remove_cv_t<_Tp>, __remove_cv_t<_Up>>>>;

  public:
    using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
    using element_type = _Tp;
    using deleter_type = _Dp;

    template <typename _Up, typename _Ep, typename _UPtr = unique_ptr<_Up, _Ep>,
              typename _UP_pointer = typename _UPtr::pointer,
              typename _UP_element_type = typename _UPtr::element_type>
    using __safe_conversion_up =
        __and_<is_array<_Up>, is_same<pointer, element_type *>,
               is_same<_UP_pointer, _UP_element_type *>,
               is_convertible<_UP_element_type (*)[], element_type (*)[]>>;

    template <typename _Up>
    using __safe_conversion_raw = __and_<
        __or_<__or_<is_same<_Up, pointer>, is_same<_Up, nullptr_t>>,
              __and_<is_pointer<_Up>, is_same<pointer, element_type *>,
                     is_convertible<typename remove_pointer<_Up>::type (*)[],
                                    element_type (*)[]>>>>;

    template <typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
    constexpr unique_ptr() noexcept : _M_t() {}
# 596 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
    template <
        typename _Up, typename _Vp = _Dp, typename = _DeleterConstraint<_Vp>,
        typename =
            typename enable_if<__safe_conversion_raw<_Up>::value, bool>::type>

    explicit unique_ptr(_Up __p) noexcept : _M_t(__p) {}
# 615 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
    template <typename _Up, typename _Del = deleter_type,
              typename = _Require<__safe_conversion_raw<_Up>,
                                  is_copy_constructible<_Del>>>

    unique_ptr(_Up __p, const deleter_type &__d) noexcept : _M_t(__p, __d) {}
# 630 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
    template <typename _Up, typename _Del = deleter_type,
              typename = _Require<__safe_conversion_raw<_Up>,
                                  is_move_constructible<_Del>>>

    unique_ptr(
        _Up __p,
        __enable_if_t<!is_lvalue_reference<_Del>::value, _Del &&> __d) noexcept
        : _M_t(std::move(__p), std::move(__d)) {}

    template <typename _Up, typename _Del = deleter_type,
              typename _DelUnref = typename remove_reference<_Del>::type,
              typename = _Require<__safe_conversion_raw<_Up>>>
    unique_ptr(_Up,
               __enable_if_t<is_lvalue_reference<_Del>::value, _DelUnref &&>) =
        delete;

    unique_ptr(unique_ptr &&) = default;

    template <typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
    constexpr unique_ptr(nullptr_t) noexcept : _M_t() {}

    template <typename _Up, typename _Ep,
              typename = _Require<
                  __safe_conversion_up<_Up, _Ep>,
                  __conditional_t<is_reference<_Dp>::value, is_same<_Ep, _Dp>,
                                  is_convertible<_Ep, _Dp>>>>

    unique_ptr(unique_ptr<_Up, _Ep> &&__u) noexcept
        : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter())) {}

    ~unique_ptr() {
      auto &__ptr = _M_t._M_ptr();
      if (__ptr != nullptr)
        get_deleter()(__ptr);
      __ptr = pointer();
    }

    unique_ptr &operator=(unique_ptr &&) = default;
# 694 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
    template <typename _Up, typename _Ep>

    typename enable_if<__and_<__safe_conversion_up<_Up, _Ep>,
                              is_assignable<deleter_type &, _Ep &&>>::value,
                       unique_ptr &>::type
    operator=(unique_ptr<_Up, _Ep> &&__u) noexcept {
      reset(__u.release());
      get_deleter() = std::forward<_Ep>(__u.get_deleter());
      return *this;
    }

    unique_ptr &operator=(nullptr_t) noexcept {
      reset();
      return *this;
    }

    typename std::add_lvalue_reference<element_type>::type
    operator[](size_t __i) const {
      do {
        if (std::__is_constant_evaluated() && !bool(get() != pointer()))
          __builtin_unreachable();
      } while (false);
      return get()[__i];
    }

    pointer get() const noexcept { return _M_t._M_ptr(); }

    deleter_type &get_deleter() noexcept { return _M_t._M_deleter(); }

    const deleter_type &get_deleter() const noexcept {
      return _M_t._M_deleter();
    }

    explicit operator bool() const noexcept {
      return get() == pointer() ? false : true;
    }

    pointer release() noexcept { return _M_t.release(); }

    template <
        typename _Up,
        typename = _Require<__or_<
            is_same<_Up, pointer>,
            __and_<is_same<pointer, element_type *>, is_pointer<_Up>,
                   is_convertible<typename remove_pointer<_Up>::type (*)[],
                                  element_type (*)[]>>>>>

    void reset(_Up __p) noexcept {
      _M_t.reset(std::move(__p));
    }

    void reset(nullptr_t = nullptr) noexcept { reset(pointer()); }

    void swap(unique_ptr &__u) noexcept {
      static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
      _M_t.swap(__u._M_t);
    }

    unique_ptr(const unique_ptr &) = delete;
    unique_ptr &operator=(const unique_ptr &) = delete;
  };

  template <typename _Tp, typename _Dp>
  inline

      typename enable_if<__is_swappable<_Dp>::value>::type

      swap(unique_ptr<_Tp, _Dp> & __x, unique_ptr<_Tp, _Dp> & __y) noexcept {
    __x.swap(__y);
  }

  template <typename _Tp, typename _Dp>
  typename enable_if<!__is_swappable<_Dp>::value>::type swap(
      unique_ptr<_Tp, _Dp> &, unique_ptr<_Tp, _Dp> &) = delete;

  template <typename _Tp, typename _Dp, typename _Up, typename _Ep>
  [[__nodiscard__]]
  inline bool operator==(const unique_ptr<_Tp, _Dp> &__x,
                         const unique_ptr<_Up, _Ep> &__y) {
    return __x.get() == __y.get();
  }

  template <typename _Tp, typename _Dp>
  [[__nodiscard__]]
  inline bool operator==(const unique_ptr<_Tp, _Dp> &__x, nullptr_t) noexcept {
    return !__x;
  }
# 873 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
  template <typename _Tp, typename _Dp, typename _Up, typename _Ep>
  [[__nodiscard__]]
  inline bool operator<(const unique_ptr<_Tp, _Dp> &__x,
                        const unique_ptr<_Up, _Ep> &__y) {
    typedef
        typename std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                                  typename unique_ptr<_Up, _Ep>::pointer>::type
            _CT;
    return std::less<_CT>()(__x.get(), __y.get());
  }

  template <typename _Tp, typename _Dp>
  [[__nodiscard__]]
  inline bool operator<(const unique_ptr<_Tp, _Dp> &__x, nullptr_t) {
    return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
                                                               nullptr);
  }

  template <typename _Tp, typename _Dp>
  [[__nodiscard__]]
  inline bool operator<(nullptr_t, const unique_ptr<_Tp, _Dp> &__x) {
    return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
                                                               __x.get());
  }

  template <typename _Tp, typename _Dp, typename _Up, typename _Ep>
  [[__nodiscard__]]
  inline bool operator<=(const unique_ptr<_Tp, _Dp> &__x,
                         const unique_ptr<_Up, _Ep> &__y) {
    return !(__y < __x);
  }

  template <typename _Tp, typename _Dp>
  [[__nodiscard__]]
  inline bool operator<=(const unique_ptr<_Tp, _Dp> &__x, nullptr_t) {
    return !(nullptr < __x);
  }

  template <typename _Tp, typename _Dp>
  [[__nodiscard__]]
  inline bool operator<=(nullptr_t, const unique_ptr<_Tp, _Dp> &__x) {
    return !(__x < nullptr);
  }

  template <typename _Tp, typename _Dp, typename _Up, typename _Ep>
  [[__nodiscard__]]
  inline bool operator>(const unique_ptr<_Tp, _Dp> &__x,
                        const unique_ptr<_Up, _Ep> &__y) {
    return (__y < __x);
  }

  template <typename _Tp, typename _Dp>
  [[__nodiscard__]]
  inline bool operator>(const unique_ptr<_Tp, _Dp> &__x, nullptr_t) {
    return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
                                                               __x.get());
  }

  template <typename _Tp, typename _Dp>
  [[__nodiscard__]]
  inline bool operator>(nullptr_t, const unique_ptr<_Tp, _Dp> &__x) {
    return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
                                                               nullptr);
  }

  template <typename _Tp, typename _Dp, typename _Up, typename _Ep>
  [[__nodiscard__]]
  inline bool operator>=(const unique_ptr<_Tp, _Dp> &__x,
                         const unique_ptr<_Up, _Ep> &__y) {
    return !(__x < __y);
  }

  template <typename _Tp, typename _Dp>
  [[__nodiscard__]]
  inline bool operator>=(const unique_ptr<_Tp, _Dp> &__x, nullptr_t) {
    return !(__x < nullptr);
  }

  template <typename _Tp, typename _Dp>
  [[__nodiscard__]] inline bool operator>=(nullptr_t,
                                           const unique_ptr<_Tp, _Dp> &__x) {
    return !(nullptr < __x);
  }

  template <typename _Tp, typename _Dp, typename _Up, typename _Ep>
    requires three_way_comparable_with<typename unique_ptr<_Tp, _Dp>::pointer,
                                       typename unique_ptr<_Up, _Ep>::pointer>

  inline compare_three_way_result_t<typename unique_ptr<_Tp, _Dp>::pointer,
                                    typename unique_ptr<_Up, _Ep>::pointer>
  operator<=>(const unique_ptr<_Tp, _Dp> &__x,
              const unique_ptr<_Up, _Ep> &__y) {
    return compare_three_way()(__x.get(), __y.get());
  }

  template <typename _Tp, typename _Dp>
    requires three_way_comparable<typename unique_ptr<_Tp, _Dp>::pointer>

  inline compare_three_way_result_t<typename unique_ptr<_Tp, _Dp>::pointer>
  operator<=>(const unique_ptr<_Tp, _Dp> &__x, nullptr_t) {
    using pointer = typename unique_ptr<_Tp, _Dp>::pointer;
    return compare_three_way()(__x.get(), static_cast<pointer>(nullptr));
  }

  template <typename _Up, typename _Ptr = typename _Up::pointer,
            bool = __poison_hash<_Ptr>::__enable_hash_call>
  struct __uniq_ptr_hash

      : private __poison_hash<_Ptr>

  {
    size_t operator()(const _Up &__u) const
        noexcept(noexcept(std::declval<hash<_Ptr>>()(std::declval<_Ptr>()))) {
      return hash<_Ptr>()(__u.get());
    }
  };

  template <typename _Up, typename _Ptr>
  struct __uniq_ptr_hash<_Up, _Ptr, false> : private __poison_hash<_Ptr> {};

  template <typename _Tp, typename _Dp>
  struct hash<unique_ptr<_Tp, _Dp>>
      : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>,
        public __uniq_ptr_hash<unique_ptr<_Tp, _Dp>> {};

  namespace __detail {
  template <typename _Tp> struct _MakeUniq {
    typedef unique_ptr<_Tp> __single_object;
  };

  template <typename _Tp> struct _MakeUniq<_Tp[]> {
    typedef unique_ptr<_Tp[]> __array;
  };

  template <typename _Tp, size_t _Bound> struct _MakeUniq<_Tp[_Bound]> {
    struct __invalid_type {};
  };

  template <typename _Tp>
  using __unique_ptr_t = typename _MakeUniq<_Tp>::__single_object;
  template <typename _Tp>
  using __unique_ptr_array_t = typename _MakeUniq<_Tp>::__array;
  template <typename _Tp>
  using __invalid_make_unique_t = typename _MakeUniq<_Tp>::__invalid_type;
  } // namespace __detail
# 1066 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
  template <typename _Tp, typename... _Args>

  inline __detail::__unique_ptr_t<_Tp> make_unique(_Args && ...__args) {
    return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...));
  }
# 1081 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
  template <typename _Tp>

  inline __detail::__unique_ptr_array_t<_Tp> make_unique(size_t __num) {
    return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]());
  }

  template <typename _Tp, typename... _Args>
  __detail::__invalid_make_unique_t<_Tp> make_unique(_Args && ...) = delete;
# 1103 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
  template <typename _Tp>

  inline __detail::__unique_ptr_t<_Tp> make_unique_for_overwrite() {
    return unique_ptr<_Tp>(new _Tp);
  }
# 1116 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
  template <typename _Tp>

  inline __detail::__unique_ptr_array_t<_Tp> make_unique_for_overwrite(
      size_t __num) {
    return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]);
  }

  template <typename _Tp, typename... _Args>
  __detail::__invalid_make_unique_t<_Tp> make_unique_for_overwrite(
      _Args && ...) = delete;
# 1140 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_ptr.h" 3
  template <typename _CharT, typename _Traits, typename _Tp, typename _Dp>
  inline basic_ostream<_CharT, _Traits> &operator<<(
      basic_ostream<_CharT, _Traits> &__os, const unique_ptr<_Tp, _Dp> &__p)
    requires requires { __os << __p.get(); }
  {
    __os << __p.get();
    return __os;
  }

  namespace __detail::__variant {
  template <typename> struct _Never_valueless_alt;

  template <typename _Tp, typename _Del>
  struct _Never_valueless_alt<std::unique_ptr<_Tp, _Del>> : std::true_type {};
  } // namespace __detail::__variant

} // namespace std
# 79 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/memory" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 1 3
# 53 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_base.h" 1 3
# 53 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_base.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/allocated_ptr.h" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/allocated_ptr.h" 3
namespace std __attribute__((__visibility__("default"))) {

  template <typename _Alloc> struct __allocated_ptr {
    using pointer = typename allocator_traits<_Alloc>::pointer;
    using value_type = typename allocator_traits<_Alloc>::value_type;

    __allocated_ptr(_Alloc &__a, pointer __ptr) noexcept
        : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr) {}

    template <typename _Ptr,
              typename _Req = _Require<is_same<_Ptr, value_type *>>>
    __allocated_ptr(_Alloc &__a, _Ptr __ptr)
        : _M_alloc(std::__addressof(__a)),
          _M_ptr(pointer_traits<pointer>::pointer_to(*__ptr)) {}

    __allocated_ptr(__allocated_ptr &&__gd) noexcept
        : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr) {
      __gd._M_ptr = nullptr;
    }

    ~__allocated_ptr() {
      if (_M_ptr != nullptr)
        std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
    }

    __allocated_ptr &operator=(std::nullptr_t) noexcept {
      _M_ptr = nullptr;
      return *this;
    }

    value_type *get() { return std::__to_address(_M_ptr); }

  private:
    _Alloc *_M_alloc;
    pointer _M_ptr;
  };

  template <typename _Alloc>
  __allocated_ptr<_Alloc> __allocate_guarded(_Alloc & __a) {
    return {__a, std::allocator_traits<_Alloc>::allocate(__a, 1)};
  }

} // namespace std
# 54 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_base.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/concurrence.h" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/concurrence.h" 3

namespace __gnu_cxx __attribute__((__visibility__("default"))) {

  enum _Lock_policy { _S_single, _S_mutex, _S_atomic };

  inline const _Lock_policy __default_lock_policy =

      _S_atomic;

  class __concurrence_lock_error : public std::exception {
  public:
    virtual char const *what() const throw() {
      return "__gnu_cxx::__concurrence_lock_error";
    }
  };

  class __concurrence_unlock_error : public std::exception {
  public:
    virtual char const *what() const throw() {
      return "__gnu_cxx::__concurrence_unlock_error";
    }
  };

  class __concurrence_broadcast_error : public std::exception {
  public:
    virtual char const *what() const throw() {
      return "__gnu_cxx::__concurrence_broadcast_error";
    }
  };

  class __concurrence_wait_error : public std::exception {
  public:
    virtual char const *what() const throw() {
      return "__gnu_cxx::__concurrence_wait_error";
    }
  };

  inline void __throw_concurrence_lock_error() {
    (throw(__concurrence_lock_error()));
  }

  inline void __throw_concurrence_unlock_error() {
    (throw(__concurrence_unlock_error()));
  }

  inline void __throw_concurrence_broadcast_error() {
    (throw(__concurrence_broadcast_error()));
  }

  inline void __throw_concurrence_wait_error() {
    (throw(__concurrence_wait_error()));
  }

  class __mutex {
  private:
    __gthread_mutex_t _M_mutex = {
        {0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, 0, {0, 0}}};

    __mutex(const __mutex &);
    __mutex &operator=(const __mutex &);

  public:
    __mutex() {}
# 144 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/concurrence.h" 3
    void lock() {

      if (__gthread_active_p()) {
        if (__gthread_mutex_lock(&_M_mutex) != 0)
          __throw_concurrence_lock_error();
      }
    }

    void unlock() {

      if (__gthread_active_p()) {
        if (__gthread_mutex_unlock(&_M_mutex) != 0)
          __throw_concurrence_unlock_error();
      }
    }

    __gthread_mutex_t *gthread_mutex(void) { return &_M_mutex; }
  };

  class __recursive_mutex {
  private:
    __gthread_recursive_mutex_t _M_mutex = {
        {0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, 0, {0, 0}}};

    __recursive_mutex(const __recursive_mutex &);
    __recursive_mutex &operator=(const __recursive_mutex &);

  public:
    __recursive_mutex() {}
# 199 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/concurrence.h" 3
    void lock() {

      if (__gthread_active_p()) {
        if (__gthread_recursive_mutex_lock(&_M_mutex) != 0)
          __throw_concurrence_lock_error();
      }
    }

    void unlock() {

      if (__gthread_active_p()) {
        if (__gthread_recursive_mutex_unlock(&_M_mutex) != 0)
          __throw_concurrence_unlock_error();
      }
    }

    __gthread_recursive_mutex_t *gthread_recursive_mutex(void) {
      return &_M_mutex;
    }
  };

  class __scoped_lock {
  public:
    typedef __mutex __mutex_type;

  private:
    __mutex_type &_M_device;

    __scoped_lock(const __scoped_lock &);
    __scoped_lock &operator=(const __scoped_lock &);

  public:
    explicit __scoped_lock(__mutex_type &__name) : _M_device(__name) {
      _M_device.lock();
    }

    ~__scoped_lock() throw() { _M_device.unlock(); }
  };

  class __cond {
  private:
    __gthread_cond_t _M_cond = {{{0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0}}};

    __cond(const __cond &);
    __cond &operator=(const __cond &);

  public:
    __cond() {}
# 277 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ext/concurrence.h" 3
    void broadcast() {

      if (__gthread_active_p()) {
        if (__gthread_cond_broadcast(&_M_cond) != 0)
          __throw_concurrence_broadcast_error();
      }
    }

    void wait(__mutex *mutex) {

      {
        if (__gthread_cond_wait(&_M_cond, mutex->gthread_mutex()) != 0)
          __throw_concurrence_wait_error();
      }
    }

    void wait_recursive(__recursive_mutex *mutex) {

      {
        if (__gthread_cond_wait_recursive(
                &_M_cond, mutex->gthread_recursive_mutex()) != 0)
          __throw_concurrence_wait_error();
      }
    }
  };

} // namespace __gnu_cxx
# 63 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_base.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template <typename> class auto_ptr;
#pragma GCC diagnostic pop

  class bad_weak_ptr : public std::exception {
  public:
    virtual char const *what() const noexcept;

    virtual ~bad_weak_ptr() noexcept;
  };

  inline void __throw_bad_weak_ptr() { (throw(bad_weak_ptr())); }

  using __gnu_cxx::__default_lock_policy;
  using __gnu_cxx::_Lock_policy;
  using __gnu_cxx::_S_atomic;
  using __gnu_cxx::_S_mutex;
  using __gnu_cxx::_S_single;

  template <_Lock_policy _Lp> class _Mutex_base {
  protected:
    enum { _S_need_barriers = 0 };
  };

  template <> class _Mutex_base<_S_mutex> : public __gnu_cxx::__mutex {
  protected:
    enum { _S_need_barriers = 1 };
  };

  template <_Lock_policy _Lp = __default_lock_policy>
  class _Sp_counted_base : public _Mutex_base<_Lp> {
  public:
    _Sp_counted_base() noexcept : _M_use_count(1), _M_weak_count(1) {}

    virtual ~_Sp_counted_base() noexcept {}

    virtual void _M_dispose() noexcept = 0;

    virtual void _M_destroy() noexcept { delete this; }

    virtual void *_M_get_deleter(const std::type_info &) noexcept = 0;

    void _M_add_ref_copy() {
      __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1);
    }

    void _M_add_ref_lock() {
      if (!_M_add_ref_lock_nothrow())
        __throw_bad_weak_ptr();
    }

    bool _M_add_ref_lock_nothrow() noexcept;

    void _M_release() noexcept;

    void _M_release_last_use() noexcept {
      ;
      _M_dispose();

      if (_Mutex_base<_Lp>::_S_need_barriers) {
        __atomic_thread_fence(4);
      }

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1) {
        ;
        _M_destroy();
      }
    }

    __attribute__((__noinline__)) void _M_release_last_use_cold() noexcept {
      _M_release_last_use();
    }

    void _M_weak_add_ref() noexcept {
      __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1);
    }

    void _M_weak_release() noexcept {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1) {
        ;
        if (_Mutex_base<_Lp>::_S_need_barriers) {

          __atomic_thread_fence(4);
        }
        _M_destroy();
      }
    }

    long _M_get_use_count() const noexcept {

      return __atomic_load_n(&_M_use_count, 0);
    }

  private:
    _Sp_counted_base(_Sp_counted_base const &) = delete;
    _Sp_counted_base &operator=(_Sp_counted_base const &) = delete;

    _Atomic_word _M_use_count;
    _Atomic_word _M_weak_count;
  };

  template <>
  inline bool _Sp_counted_base<_S_single>::_M_add_ref_lock_nothrow() noexcept {
    if (_M_use_count == 0)
      return false;
    ++_M_use_count;
    return true;
  }

  template <>
  inline bool _Sp_counted_base<_S_mutex>::_M_add_ref_lock_nothrow() noexcept {
    __gnu_cxx::__scoped_lock sentry(*this);
    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0) {
      _M_use_count = 0;
      return false;
    }
    return true;
  }

  template <>
  inline bool _Sp_counted_base<_S_atomic>::_M_add_ref_lock_nothrow() noexcept {

    _Atomic_word __count = _M_get_use_count();
    do {
      if (__count == 0)
        return false;

    } while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
                                          true, 4, 0));
    return true;
  }

  template <> inline void _Sp_counted_base<_S_single>::_M_add_ref_copy() {
    ++_M_use_count;
  }

  template <> inline void _Sp_counted_base<_S_single>::_M_release() noexcept {
    if (--_M_use_count == 0) {
      _M_dispose();
      if (--_M_weak_count == 0)
        _M_destroy();
    }
  }

  template <> inline void _Sp_counted_base<_S_mutex>::_M_release() noexcept {

    ;
    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1) {
      _M_release_last_use();
    }
  }

  template <> inline void _Sp_counted_base<_S_atomic>::_M_release() noexcept {
    ;

    constexpr bool __lock_free =
        __atomic_always_lock_free(sizeof(long long), 0) &&
        __atomic_always_lock_free(sizeof(_Atomic_word), 0);
    constexpr bool __double_word =
        sizeof(long long) == 2 * sizeof(_Atomic_word);

    constexpr bool __aligned = __alignof(long long) <= alignof(void *);
    if constexpr (__lock_free && __double_word && __aligned) {
      constexpr int __wordbits = 8 * sizeof(_Atomic_word);
      constexpr int __shiftbits = __double_word ? __wordbits : 0;
      constexpr long long __unique_ref = 1LL + (1LL << __shiftbits);
      auto __both_counts = reinterpret_cast<long long *>(&_M_use_count);

      ;
      if (__atomic_load_n(__both_counts, 2) == __unique_ref) {

        _M_weak_count = _M_use_count = 0;
        ;
        ;
        _M_dispose();
        _M_destroy();
        return;
      }
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
          [[__unlikely__]] {
        _M_release_last_use_cold();
        return;
      }
    } else

        if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1) {
      _M_release_last_use();
    }
  }

  template <>
  inline void _Sp_counted_base<_S_single>::_M_weak_add_ref() noexcept {
    ++_M_weak_count;
  }

  template <>
  inline void _Sp_counted_base<_S_single>::_M_weak_release() noexcept {
    if (--_M_weak_count == 0)
      _M_destroy();
  }

  template <>
  inline long _Sp_counted_base<_S_single>::_M_get_use_count() const noexcept {
    return _M_use_count;
  }

  template <typename _Tp, _Lock_policy _Lp = __default_lock_policy>
  class __shared_ptr;

  template <typename _Tp, _Lock_policy _Lp = __default_lock_policy>
  class __weak_ptr;

  template <typename _Tp, _Lock_policy _Lp = __default_lock_policy>
  class __enable_shared_from_this;

  template <typename _Tp> class shared_ptr;

  template <typename _Tp> class weak_ptr;

  template <typename _Tp> struct owner_less;

  template <typename _Tp> class enable_shared_from_this;

  template <_Lock_policy _Lp = __default_lock_policy> class __weak_count;

  template <_Lock_policy _Lp = __default_lock_policy> class __shared_count;

  template <typename> class _Sp_atomic;

  template <typename _Ptr, _Lock_policy _Lp>
  class _Sp_counted_ptr final : public _Sp_counted_base<_Lp> {
  public:
    explicit _Sp_counted_ptr(_Ptr __p) noexcept : _M_ptr(__p) {}

    virtual void _M_dispose() noexcept { delete _M_ptr; }

    virtual void _M_destroy() noexcept { delete this; }

    virtual void *_M_get_deleter(const std::type_info &) noexcept {
      return nullptr;
    }

    _Sp_counted_ptr(const _Sp_counted_ptr &) = delete;
    _Sp_counted_ptr &operator=(const _Sp_counted_ptr &) = delete;

  private:
    _Ptr _M_ptr;
  };

  template <>
  inline void _Sp_counted_ptr<nullptr_t, _S_single>::_M_dispose() noexcept {}

  template <>
  inline void _Sp_counted_ptr<nullptr_t, _S_mutex>::_M_dispose() noexcept {}

  template <>
  inline void _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept {}

  template <int _Nm, typename _Tp,
            bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
  struct _Sp_ebo_helper;

  template <int _Nm, typename _Tp>
  struct _Sp_ebo_helper<_Nm, _Tp, true> : private _Tp {
    explicit _Sp_ebo_helper(const _Tp &__tp) : _Tp(__tp) {}
    explicit _Sp_ebo_helper(_Tp &&__tp) : _Tp(std::move(__tp)) {}

    static _Tp &_S_get(_Sp_ebo_helper &__eboh) {
      return static_cast<_Tp &>(__eboh);
    }
  };

  template <int _Nm, typename _Tp> struct _Sp_ebo_helper<_Nm, _Tp, false> {
    explicit _Sp_ebo_helper(const _Tp &__tp) : _M_tp(__tp) {}
    explicit _Sp_ebo_helper(_Tp &&__tp) : _M_tp(std::move(__tp)) {}

    static _Tp &_S_get(_Sp_ebo_helper &__eboh) { return __eboh._M_tp; }

  private:
    _Tp _M_tp;
  };

  template <typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>
  class _Sp_counted_deleter final : public _Sp_counted_base<_Lp> {
    class _Impl : _Sp_ebo_helper<0, _Deleter>, _Sp_ebo_helper<1, _Alloc> {
      typedef _Sp_ebo_helper<0, _Deleter> _Del_base;
      typedef _Sp_ebo_helper<1, _Alloc> _Alloc_base;

    public:
      _Impl(_Ptr __p, _Deleter __d, const _Alloc &__a) noexcept
          : _Del_base(std::move(__d)), _Alloc_base(__a), _M_ptr(__p) {}

      _Deleter &_M_del() noexcept { return _Del_base::_S_get(*this); }
      _Alloc &_M_alloc() noexcept { return _Alloc_base::_S_get(*this); }

      _Ptr _M_ptr;
    };

  public:
    using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_deleter>;

    _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
        : _M_impl(__p, std::move(__d), _Alloc()) {}

    _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc &__a) noexcept
        : _M_impl(__p, std::move(__d), __a) {}

    ~_Sp_counted_deleter() noexcept {}

    virtual void _M_dispose() noexcept { _M_impl._M_del()(_M_impl._M_ptr); }

    virtual void _M_destroy() noexcept {
      __allocator_type __a(_M_impl._M_alloc());
      __allocated_ptr<__allocator_type> __guard_ptr{__a, this};
      this->~_Sp_counted_deleter();
    }

    virtual void *_M_get_deleter(const type_info &__ti
                                 [[__gnu__::__unused__]]) noexcept {

      return __ti == typeid(_Deleter) ? std::__addressof(_M_impl._M_del())
                                      : nullptr;
    }

  private:
    _Impl _M_impl;
  };

  struct _Sp_make_shared_tag {
  private:
    template <typename _Tp, typename _Alloc, _Lock_policy _Lp>
    friend class _Sp_counted_ptr_inplace;

    static const type_info &_S_ti() noexcept
        __attribute__((__visibility__("default"))) {
      alignas(type_info) static constexpr char __tag[sizeof(type_info)] = {};
      return reinterpret_cast<const type_info &>(__tag);
    }

    static bool _S_eq(const type_info &) noexcept;
  };

  template <typename _Alloc> struct _Sp_alloc_shared_tag {
    const _Alloc &_M_a;
  };

  template <typename _Tp, typename _Alloc, _Lock_policy _Lp>
  class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp> {
    class _Impl : _Sp_ebo_helper<0, _Alloc> {
      typedef _Sp_ebo_helper<0, _Alloc> _A_base;

    public:
      explicit _Impl(_Alloc __a) noexcept : _A_base(__a) {}

      _Alloc &_M_alloc() noexcept { return _A_base::_S_get(*this); }

      __gnu_cxx::__aligned_buffer<_Tp> _M_storage;
    };

  public:
    using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;

    template <typename... _Args>
    _Sp_counted_ptr_inplace(_Alloc __a, _Args &&...__args) : _M_impl(__a) {

      allocator_traits<_Alloc>::construct(__a, _M_ptr(),
                                          std::forward<_Args>(__args)...);
    }

    ~_Sp_counted_ptr_inplace() noexcept {}

    virtual void _M_dispose() noexcept {
      allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
    }

    virtual void _M_destroy() noexcept {
      __allocator_type __a(_M_impl._M_alloc());
      __allocated_ptr<__allocator_type> __guard_ptr{__a, this};
      this->~_Sp_counted_ptr_inplace();
    }

  private:
    friend class __shared_count<_Lp>;

    virtual void *_M_get_deleter(const std::type_info &__ti) noexcept override {
      auto __ptr = const_cast<typename remove_cv<_Tp>::type *>(_M_ptr());

      if (&__ti == &_Sp_make_shared_tag::_S_ti() ||

          __ti == typeid(_Sp_make_shared_tag)

      )
        return __ptr;
      return nullptr;
    }

    _Tp *_M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }

    _Impl _M_impl;
  };

  struct _Sp_overwrite_tag {};

  template <typename _Tp, typename _Alloc, _Lock_policy _Lp>
    requires is_same_v<typename _Alloc::value_type, _Sp_overwrite_tag>
  class _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> final

      : public _Sp_counted_base<_Lp> {
    [[no_unique_address]] _Alloc _M_alloc;

    union {
      _Tp _M_obj;
      char _M_unused;
    };

    friend class __shared_count<_Lp>;

    _Tp *_M_ptr() noexcept { return std::__addressof(_M_obj); }

  public:
    using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;

    _Sp_counted_ptr_inplace(const _Alloc &__a) : _M_alloc(__a) {
      ::new ((void *)_M_ptr()) _Tp;
    }

    ~_Sp_counted_ptr_inplace() noexcept {}

    virtual void _M_dispose() noexcept { _M_obj.~_Tp(); }

    virtual void _M_destroy() noexcept {
      using pointer = typename allocator_traits<__allocator_type>::pointer;
      __allocator_type __a(_M_alloc);
      auto __p = pointer_traits<pointer>::pointer_to(*this);
      __allocated_ptr<__allocator_type> __guard_ptr{__a, __p};
      this->~_Sp_counted_ptr_inplace();
    }

    void *_M_get_deleter(const std::type_info &) noexcept override {
      return nullptr;
    }
  };

  struct _Sp_overwrite_tag;

  template <typename _Alloc> struct _Sp_counted_array_base {
    [[no_unique_address]] _Alloc _M_alloc{};
    size_t _M_n = 0;
    bool _M_overwrite = false;

    typename allocator_traits<_Alloc>::pointer _M_alloc_array(size_t __tail) {
      return allocator_traits<_Alloc>::allocate(_M_alloc, _M_n + __tail);
    }

    void _M_dealloc_array(typename allocator_traits<_Alloc>::pointer __p,
                          size_t __tail) {
      allocator_traits<_Alloc>::deallocate(_M_alloc, __p, _M_n + __tail);
    }

    template <typename _Init>
    void _M_init(typename allocator_traits<_Alloc>::value_type *__p,
                 _Init __init) {
      using _Tp = remove_pointer_t<_Init>;
      using _Up = typename allocator_traits<_Alloc>::value_type;

      if constexpr (is_same_v<_Init, _Sp_overwrite_tag>) {
        std::uninitialized_default_construct_n(__p, _M_n);
        _M_overwrite = true;
      } else if (__init == nullptr)
        std::__uninitialized_default_n_a(__p, _M_n, _M_alloc);
      else if constexpr (!is_array_v<_Tp>)
        std::__uninitialized_fill_n_a(__p, _M_n, *__init, _M_alloc);
      else {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
        struct _Iter {
          using value_type = _Up;
          using difference_type = ptrdiff_t;
          using pointer = const _Up *;
          using reference = const _Up &;
          using iterator_category = forward_iterator_tag;

          const _Up *_M_p;
          size_t _M_len;
          size_t _M_pos;

          _Iter &operator++() {
            ++_M_pos;
            return *this;
          }
          _Iter operator++(int) {
            auto __i(*this);
            ++_M_pos;
            return __i;
          }

          reference operator*() const { return _M_p[_M_pos % _M_len]; }
          pointer operator->() const { return _M_p + (_M_pos % _M_len); }

          bool operator==(const _Iter &__i) const {
            return _M_pos == __i._M_pos;
          }
        };
#pragma GCC diagnostic pop

        _Iter __first{_S_first_elem(__init), sizeof(_Tp) / sizeof(_Up)};
        _Iter __last = __first;
        __last._M_pos = _M_n;
        std::__uninitialized_copy_a(__first, __last, __p, _M_alloc);
      }
    }

  protected:
    void _M_dispose_array(typename allocator_traits<_Alloc>::value_type *__p) {
      if (_M_overwrite)
        std::destroy_n(__p, _M_n);
      else {
        size_t __n = _M_n;
        while (__n--)
          allocator_traits<_Alloc>::destroy(_M_alloc, __p + __n);
      }
    }

  private:
    template <typename _Tp> static _Tp *_S_first_elem(_Tp *__p) { return __p; }

    template <typename _Tp, size_t _Nm>
    static auto _S_first_elem(_Tp (*__p)[_Nm]) {
      return _S_first_elem(*__p);
    }
  };

  template <typename _Alloc, _Lock_policy _Lp>
  class _Sp_counted_array final : public _Sp_counted_base<_Lp>,
                                  _Sp_counted_array_base<_Alloc> {
    using pointer = typename allocator_traits<_Alloc>::pointer;

    pointer _M_alloc_ptr;

    auto _M_ptr() const noexcept { return std::to_address(_M_alloc_ptr); }

    friend class __shared_count<_Lp>;

  public:
    _Sp_counted_array(const _Sp_counted_array_base<_Alloc> &__a,
                      pointer __p) noexcept
        : _Sp_counted_array_base<_Alloc>(__a), _M_alloc_ptr(__p) {}

    ~_Sp_counted_array() = default;

    virtual void _M_dispose() noexcept {
      if (this->_M_n)
        this->_M_dispose_array(_M_ptr());
    }

    virtual void _M_destroy() noexcept {
      _Sp_counted_array_base<_Alloc> __a = *this;
      pointer __p = _M_alloc_ptr;
      this->~_Sp_counted_array();
      __a._M_dealloc_array(__p, _S_tail());
    }

    static constexpr size_t _S_tail() {

      using _Tp = typename allocator_traits<_Alloc>::value_type;

      size_t __bytes = sizeof(_Sp_counted_array);

      if constexpr (alignof(_Tp) < alignof(_Sp_counted_array))
        __bytes += alignof(_Sp_counted_array) - alignof(_Tp);

      return (__bytes + sizeof(_Tp) - 1) / sizeof(_Tp);
    }

    void *_M_get_deleter(const std::type_info &) noexcept override {
      return nullptr;
    }
  };

  struct __sp_array_delete {
    template <typename _Yp> void operator()(_Yp *__p) const { delete[] __p; }
  };

  template <_Lock_policy _Lp> class __shared_count {

    template <typename _Tp> struct __not_alloc_shared_tag {
      using type = void;
    };

    template <typename _Tp>
    struct __not_alloc_shared_tag<_Sp_alloc_shared_tag<_Tp>> {};

    template <typename _Alloc>
    struct __not_alloc_shared_tag<_Sp_counted_array_base<_Alloc>> {};

  public:
    constexpr __shared_count() noexcept : _M_pi(0) {}

    template <typename _Ptr> explicit __shared_count(_Ptr __p) : _M_pi(0) {
      try {
        _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
      } catch (...) {
        delete __p;
        throw;
      }
    }

    template <typename _Ptr>
    __shared_count(_Ptr __p, false_type) : __shared_count(__p) {}

    template <typename _Ptr>
    __shared_count(_Ptr __p, true_type)
        : __shared_count(__p, __sp_array_delete{}, allocator<void>()) {}

    template <typename _Ptr, typename _Deleter,
              typename = typename __not_alloc_shared_tag<_Deleter>::type>
    __shared_count(_Ptr __p, _Deleter __d)
        : __shared_count(__p, std::move(__d), allocator<void>()) {}

    template <typename _Ptr, typename _Deleter, typename _Alloc,
              typename = typename __not_alloc_shared_tag<_Deleter>::type>
    __shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0) {
      typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
      try {
        typename _Sp_cd_type::__allocator_type __a2(__a);
        auto __guard = std::__allocate_guarded(__a2);
        _Sp_cd_type *__mem = __guard.get();
        ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
        _M_pi = __mem;
        __guard = nullptr;
      } catch (...) {
        __d(__p);
        throw;
      }
    }

    template <typename _Tp, typename _Alloc, typename... _Args>
    __shared_count(_Tp *&__p, _Sp_alloc_shared_tag<_Alloc> __a,
                   _Args &&...__args) {
      typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
      typename _Sp_cp_type::__allocator_type __a2(__a._M_a);
      auto __guard = std::__allocate_guarded(__a2);
      _Sp_cp_type *__mem = __guard.get();
      auto __pi =
          ::new (__mem) _Sp_cp_type(__a._M_a, std::forward<_Args>(__args)...);
      __guard = nullptr;
      _M_pi = __pi;
      __p = __pi->_M_ptr();
    }

    template <typename _Tp, typename _Alloc, typename _Init>
    __shared_count(_Tp *&__p, const _Sp_counted_array_base<_Alloc> &__a,
                   _Init __init) {
      using _Up = remove_all_extents_t<_Tp>;
      static_assert(is_same_v<_Up, typename _Alloc::value_type>);

      using _Sp_ca_type = _Sp_counted_array<_Alloc, _Lp>;
      const size_t __tail = _Sp_ca_type::_S_tail();

      struct _Guarded_ptr : _Sp_counted_array_base<_Alloc> {
        typename allocator_traits<_Alloc>::pointer _M_ptr;

        _Guarded_ptr(_Sp_counted_array_base<_Alloc> __a)
            : _Sp_counted_array_base<_Alloc>(__a),
              _M_ptr(this->_M_alloc_array(_Sp_ca_type::_S_tail())) {}

        ~_Guarded_ptr() {
          if (_M_ptr)
            this->_M_dealloc_array(_M_ptr, _Sp_ca_type::_S_tail());
        }
      };

      _Guarded_ptr __guard{__a};
      _Up *const __raw = std::to_address(__guard._M_ptr);
      __guard._M_init(__raw, __init);

      void *__c = __raw + __a._M_n;
      if constexpr (alignof(_Up) < alignof(_Sp_ca_type)) {
        size_t __space = sizeof(_Up) * __tail;
        __c =
            std::align(alignof(_Sp_ca_type), sizeof(_Sp_ca_type), __c, __space);
      }
      auto __pi = ::new (__c) _Sp_ca_type(__guard, __guard._M_ptr);
      __guard._M_ptr = nullptr;
      _M_pi = __pi;
      __p = reinterpret_cast<_Tp *>(__raw);
    }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

    template <typename _Tp> explicit __shared_count(std::auto_ptr<_Tp> &&__r);
#pragma GCC diagnostic pop

    template <typename _Tp, typename _Del>
    explicit __shared_count(std::unique_ptr<_Tp, _Del> &&__r) : _M_pi(0) {

      if (__r.get() == nullptr)
        return;

      using _Ptr = typename unique_ptr<_Tp, _Del>::pointer;
      using _Del2 = __conditional_t<
          is_reference<_Del>::value,
          reference_wrapper<typename remove_reference<_Del>::type>, _Del>;
      using _Sp_cd_type =
          _Sp_counted_deleter<_Ptr, _Del2, allocator<void>, _Lp>;
      using _Alloc = allocator<_Sp_cd_type>;
      using _Alloc_traits = allocator_traits<_Alloc>;
      _Alloc __a;
      _Sp_cd_type *__mem = _Alloc_traits::allocate(__a, 1);

      _Alloc_traits::construct(__a, __mem, __r.release(),
                               std::forward<_Del>(__r.get_deleter()));
      _M_pi = __mem;
    }

    explicit __shared_count(const __weak_count<_Lp> &__r);

    explicit __shared_count(const __weak_count<_Lp> &__r,
                            std::nothrow_t) noexcept;

    ~__shared_count() noexcept {
      if (_M_pi != nullptr)
        _M_pi->_M_release();
    }

    __shared_count(const __shared_count &__r) noexcept : _M_pi(__r._M_pi) {
      if (_M_pi != nullptr)
        _M_pi->_M_add_ref_copy();
    }

    __shared_count &operator=(const __shared_count &__r) noexcept {
      _Sp_counted_base<_Lp> *__tmp = __r._M_pi;
      if (__tmp != _M_pi) {
        if (__tmp != nullptr)
          __tmp->_M_add_ref_copy();
        if (_M_pi != nullptr)
          _M_pi->_M_release();
        _M_pi = __tmp;
      }
      return *this;
    }

    void _M_swap(__shared_count &__r) noexcept {
      _Sp_counted_base<_Lp> *__tmp = __r._M_pi;
      __r._M_pi = _M_pi;
      _M_pi = __tmp;
    }

    long _M_get_use_count() const noexcept {
      return _M_pi ? _M_pi->_M_get_use_count() : 0;
    }

    bool _M_unique() const noexcept { return this->_M_get_use_count() == 1; }

    void *_M_get_deleter(const std::type_info &__ti) const noexcept {
      return _M_pi ? _M_pi->_M_get_deleter(__ti) : nullptr;
    }

    bool _M_less(const __shared_count &__rhs) const noexcept {
      return std::less<_Sp_counted_base<_Lp> *>()(this->_M_pi, __rhs._M_pi);
    }

    bool _M_less(const __weak_count<_Lp> &__rhs) const noexcept {
      return std::less<_Sp_counted_base<_Lp> *>()(this->_M_pi, __rhs._M_pi);
    }

    friend inline bool operator==(const __shared_count &__a,
                                  const __shared_count &__b) noexcept {
      return __a._M_pi == __b._M_pi;
    }

  private:
    friend class __weak_count<_Lp>;

    template <typename> friend class _Sp_atomic;

    _Sp_counted_base<_Lp> *_M_pi;
  };

  template <_Lock_policy _Lp> class __weak_count {
  public:
    constexpr __weak_count() noexcept : _M_pi(nullptr) {}

    __weak_count(const __shared_count<_Lp> &__r) noexcept : _M_pi(__r._M_pi) {
      if (_M_pi != nullptr)
        _M_pi->_M_weak_add_ref();
    }

    __weak_count(const __weak_count &__r) noexcept : _M_pi(__r._M_pi) {
      if (_M_pi != nullptr)
        _M_pi->_M_weak_add_ref();
    }

    __weak_count(__weak_count &&__r) noexcept : _M_pi(__r._M_pi) {
      __r._M_pi = nullptr;
    }

    ~__weak_count() noexcept {
      if (_M_pi != nullptr)
        _M_pi->_M_weak_release();
    }

    __weak_count &operator=(const __shared_count<_Lp> &__r) noexcept {
      _Sp_counted_base<_Lp> *__tmp = __r._M_pi;
      if (__tmp != nullptr)
        __tmp->_M_weak_add_ref();
      if (_M_pi != nullptr)
        _M_pi->_M_weak_release();
      _M_pi = __tmp;
      return *this;
    }

    __weak_count &operator=(const __weak_count &__r) noexcept {
      _Sp_counted_base<_Lp> *__tmp = __r._M_pi;
      if (__tmp != nullptr)
        __tmp->_M_weak_add_ref();
      if (_M_pi != nullptr)
        _M_pi->_M_weak_release();
      _M_pi = __tmp;
      return *this;
    }

    __weak_count &operator=(__weak_count &&__r) noexcept {
      if (_M_pi != nullptr)
        _M_pi->_M_weak_release();
      _M_pi = __r._M_pi;
      __r._M_pi = nullptr;
      return *this;
    }

    void _M_swap(__weak_count &__r) noexcept {
      _Sp_counted_base<_Lp> *__tmp = __r._M_pi;
      __r._M_pi = _M_pi;
      _M_pi = __tmp;
    }

    long _M_get_use_count() const noexcept {
      return _M_pi != nullptr ? _M_pi->_M_get_use_count() : 0;
    }

    bool _M_less(const __weak_count &__rhs) const noexcept {
      return std::less<_Sp_counted_base<_Lp> *>()(this->_M_pi, __rhs._M_pi);
    }

    bool _M_less(const __shared_count<_Lp> &__rhs) const noexcept {
      return std::less<_Sp_counted_base<_Lp> *>()(this->_M_pi, __rhs._M_pi);
    }

    friend inline bool operator==(const __weak_count &__a,
                                  const __weak_count &__b) noexcept {
      return __a._M_pi == __b._M_pi;
    }

  private:
    friend class __shared_count<_Lp>;

    template <typename> friend class _Sp_atomic;

    _Sp_counted_base<_Lp> *_M_pi;
  };

  template <_Lock_policy _Lp>
  inline __shared_count<_Lp>::__shared_count(const __weak_count<_Lp> &__r)
      : _M_pi(__r._M_pi) {
    if (_M_pi == nullptr || !_M_pi->_M_add_ref_lock_nothrow())
      __throw_bad_weak_ptr();
  }

  template <_Lock_policy _Lp>
  inline __shared_count<_Lp>::__shared_count(const __weak_count<_Lp> &__r,
                                             std::nothrow_t) noexcept
      : _M_pi(__r._M_pi) {
    if (_M_pi && !_M_pi->_M_add_ref_lock_nothrow())
      _M_pi = nullptr;
  }

  template <typename _Yp_ptr, typename _Tp_ptr>
  struct __sp_compatible_with : false_type {};

  template <typename _Yp, typename _Tp>
  struct __sp_compatible_with<_Yp *, _Tp *>
      : is_convertible<_Yp *, _Tp *>::type {};

  template <typename _Up, size_t _Nm>
  struct __sp_compatible_with<_Up(*)[_Nm], _Up(*)[]> : true_type {};

  template <typename _Up, size_t _Nm>
  struct __sp_compatible_with<_Up(*)[_Nm], const _Up(*)[]> : true_type {};

  template <typename _Up, size_t _Nm>
  struct __sp_compatible_with<_Up(*)[_Nm], volatile _Up(*)[]> : true_type {};

  template <typename _Up, size_t _Nm>
  struct __sp_compatible_with<_Up(*)[_Nm], const volatile _Up(*)[]>
      : true_type {};

  template <typename _Up, size_t _Nm, typename _Yp, typename = void>
  struct __sp_is_constructible_arrN : false_type {};

  template <typename _Up, size_t _Nm, typename _Yp>
  struct __sp_is_constructible_arrN<_Up, _Nm, _Yp, __void_t<_Yp[_Nm]>>
      : is_convertible<_Yp(*)[_Nm], _Up(*)[_Nm]>::type {};

  template <typename _Up, typename _Yp, typename = void>
  struct __sp_is_constructible_arr : false_type {};

  template <typename _Up, typename _Yp>
  struct __sp_is_constructible_arr<_Up, _Yp, __void_t<_Yp[]>>
      : is_convertible<_Yp(*)[], _Up(*)[]>::type {};

  template <typename _Tp, typename _Yp> struct __sp_is_constructible;

  template <typename _Up, size_t _Nm, typename _Yp>
  struct __sp_is_constructible<_Up[_Nm], _Yp>
      : __sp_is_constructible_arrN<_Up, _Nm, _Yp>::type {};

  template <typename _Up, typename _Yp>
  struct __sp_is_constructible<_Up[], _Yp>
      : __sp_is_constructible_arr<_Up, _Yp>::type {};

  template <typename _Tp, typename _Yp>
  struct __sp_is_constructible : is_convertible<_Yp *, _Tp *>::type {};

  template <typename _Tp, _Lock_policy _Lp, bool = is_array<_Tp>::value,
            bool = is_void<_Tp>::value>
  class __shared_ptr_access {
  public:
    using element_type = _Tp;

    element_type &operator*() const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(_M_get() != nullptr))
          __builtin_unreachable();
      } while (false);
      return *_M_get();
    }

    element_type *operator->() const noexcept {
      ;
      return _M_get();
    }

  private:
    element_type *_M_get() const noexcept {
      return static_cast<const __shared_ptr<_Tp, _Lp> *>(this)->get();
    }
  };

  template <typename _Tp, _Lock_policy _Lp>
  class __shared_ptr_access<_Tp, _Lp, false, true> {
  public:
    using element_type = _Tp;

    element_type *operator->() const noexcept {
      auto __ptr = static_cast<const __shared_ptr<_Tp, _Lp> *>(this)->get();
      ;
      return __ptr;
    }
  };

  template <typename _Tp, _Lock_policy _Lp>
  class __shared_ptr_access<_Tp, _Lp, true, false> {
  public:
    using element_type = typename remove_extent<_Tp>::type;
# 1407 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_base.h" 3
    element_type &operator[](ptrdiff_t __i) const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(_M_get() != nullptr))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(!extent<_Tp>::value || __i < extent<_Tp>::value))
          __builtin_unreachable();
      } while (false);
      return _M_get()[__i];
    }

  private:
    element_type *_M_get() const noexcept {
      return static_cast<const __shared_ptr<_Tp, _Lp> *>(this)->get();
    }
  };

  template <typename _Tp, _Lock_policy _Lp>
  class __shared_ptr : public __shared_ptr_access<_Tp, _Lp> {
  public:
    using element_type = typename remove_extent<_Tp>::type;

  private:
    template <typename _Yp>
    using _SafeConv =
        typename enable_if<__sp_is_constructible<_Tp, _Yp>::value>::type;

    template <typename _Yp, typename _Res = void>
    using _Compatible =
        typename enable_if<__sp_compatible_with<_Yp *, _Tp *>::value,
                           _Res>::type;

    template <typename _Yp>
    using _Assignable = _Compatible<_Yp, __shared_ptr &>;

    template <typename _Yp, typename _Del, typename _Res = void,
              typename _Ptr = typename unique_ptr<_Yp, _Del>::pointer>
    using _UniqCompatible =
        __enable_if_t<__and_<__sp_compatible_with<_Yp *, _Tp *>,
                             is_convertible<_Ptr, element_type *>,
                             is_move_constructible<_Del>>::value,
                      _Res>;

    template <typename _Yp, typename _Del>
    using _UniqAssignable = _UniqCompatible<_Yp, _Del, __shared_ptr &>;

  public:
    using weak_type = __weak_ptr<_Tp, _Lp>;

    constexpr __shared_ptr() noexcept : _M_ptr(0), _M_refcount() {}

    template <typename _Yp, typename = _SafeConv<_Yp>>
    explicit __shared_ptr(_Yp *__p)
        : _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type()) {
      static_assert(!is_void<_Yp>::value, "incomplete type");
      static_assert(sizeof(_Yp) > 0, "incomplete type");
      _M_enable_shared_from_this_with(__p);
    }

    template <typename _Yp, typename _Deleter, typename = _SafeConv<_Yp>>
    __shared_ptr(_Yp *__p, _Deleter __d)
        : _M_ptr(__p), _M_refcount(__p, std::move(__d)) {
      static_assert(__is_invocable<_Deleter &, _Yp *&>::value,
                    "deleter expression d(p) is well-formed");
      _M_enable_shared_from_this_with(__p);
    }

    template <typename _Yp, typename _Deleter, typename _Alloc,
              typename = _SafeConv<_Yp>>
    __shared_ptr(_Yp *__p, _Deleter __d, _Alloc __a)
        : _M_ptr(__p), _M_refcount(__p, std::move(__d), std::move(__a)) {
      static_assert(__is_invocable<_Deleter &, _Yp *&>::value,
                    "deleter expression d(p) is well-formed");
      _M_enable_shared_from_this_with(__p);
    }

    template <typename _Deleter>
    __shared_ptr(nullptr_t __p, _Deleter __d)
        : _M_ptr(0), _M_refcount(__p, std::move(__d)) {}

    template <typename _Deleter, typename _Alloc>
    __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
        : _M_ptr(0), _M_refcount(__p, std::move(__d), std::move(__a)) {}

    template <typename _Yp>
    __shared_ptr(const __shared_ptr<_Yp, _Lp> &__r, element_type *__p) noexcept
        : _M_ptr(__p), _M_refcount(__r._M_refcount) {}

    template <typename _Yp>
    __shared_ptr(__shared_ptr<_Yp, _Lp> &&__r, element_type *__p) noexcept
        : _M_ptr(__p), _M_refcount() {
      _M_refcount._M_swap(__r._M_refcount);
      __r._M_ptr = nullptr;
    }

    __shared_ptr(const __shared_ptr &) noexcept = default;
    __shared_ptr &operator=(const __shared_ptr &) noexcept = default;
    ~__shared_ptr() = default;

    template <typename _Yp, typename = _Compatible<_Yp>>
    __shared_ptr(const __shared_ptr<_Yp, _Lp> &__r) noexcept
        : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) {}

    __shared_ptr(__shared_ptr &&__r) noexcept
        : _M_ptr(__r._M_ptr), _M_refcount() {
      _M_refcount._M_swap(__r._M_refcount);
      __r._M_ptr = nullptr;
    }

    template <typename _Yp, typename = _Compatible<_Yp>>
    __shared_ptr(__shared_ptr<_Yp, _Lp> &&__r) noexcept
        : _M_ptr(__r._M_ptr), _M_refcount() {
      _M_refcount._M_swap(__r._M_refcount);
      __r._M_ptr = nullptr;
    }

    template <typename _Yp, typename = _Compatible<_Yp>>
    explicit __shared_ptr(const __weak_ptr<_Yp, _Lp> &__r)
        : _M_refcount(__r._M_refcount) {

      _M_ptr = __r._M_ptr;
    }

    template <typename _Yp, typename _Del,
              typename = _UniqCompatible<_Yp, _Del>>
    __shared_ptr(unique_ptr<_Yp, _Del> &&__r)
        : _M_ptr(__r.get()), _M_refcount() {
      auto __raw = __to_address(__r.get());
      _M_refcount = __shared_count<_Lp>(std::move(__r));
      _M_enable_shared_from_this_with(__raw);
    }
# 1585 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_base.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

    template <typename _Yp, typename = _Compatible<_Yp>>
    __shared_ptr(auto_ptr<_Yp> &&__r);
#pragma GCC diagnostic pop

    constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() {}

    template <typename _Yp>
    _Assignable<_Yp> operator=(const __shared_ptr<_Yp, _Lp> &__r) noexcept {
      _M_ptr = __r._M_ptr;
      _M_refcount = __r._M_refcount;
      return *this;
    }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    template <typename _Yp> _Assignable<_Yp> operator=(auto_ptr<_Yp> &&__r) {
      __shared_ptr(std::move(__r)).swap(*this);
      return *this;
    }
#pragma GCC diagnostic pop

    __shared_ptr &operator=(__shared_ptr &&__r) noexcept {
      __shared_ptr(std::move(__r)).swap(*this);
      return *this;
    }

    template <class _Yp>
    _Assignable<_Yp> operator=(__shared_ptr<_Yp, _Lp> &&__r) noexcept {
      __shared_ptr(std::move(__r)).swap(*this);
      return *this;
    }

    template <typename _Yp, typename _Del>
    _UniqAssignable<_Yp, _Del> operator=(unique_ptr<_Yp, _Del> &&__r) {
      __shared_ptr(std::move(__r)).swap(*this);
      return *this;
    }

    void reset() noexcept { __shared_ptr().swap(*this); }

    template <typename _Yp> _SafeConv<_Yp> reset(_Yp *__p) {

      do {
        if (std::__is_constant_evaluated() &&
            !bool(__p == nullptr || __p != _M_ptr))
          __builtin_unreachable();
      } while (false);
      __shared_ptr(__p).swap(*this);
    }

    template <typename _Yp, typename _Deleter>
    _SafeConv<_Yp> reset(_Yp *__p, _Deleter __d) {
      __shared_ptr(__p, std::move(__d)).swap(*this);
    }

    template <typename _Yp, typename _Deleter, typename _Alloc>
    _SafeConv<_Yp> reset(_Yp *__p, _Deleter __d, _Alloc __a) {
      __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this);
    }

    element_type *get() const noexcept { return _M_ptr; }

    explicit operator bool() const noexcept { return _M_ptr != nullptr; }

    bool unique() const noexcept { return _M_refcount._M_unique(); }

    long use_count() const noexcept { return _M_refcount._M_get_use_count(); }

    void swap(__shared_ptr<_Tp, _Lp> &__other) noexcept {
      std::swap(_M_ptr, __other._M_ptr);
      _M_refcount._M_swap(__other._M_refcount);
    }
# 1697 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_base.h" 3
    template <typename _Tp1>
    bool owner_before(__shared_ptr<_Tp1, _Lp> const &__rhs) const noexcept {
      return _M_refcount._M_less(__rhs._M_refcount);
    }

    template <typename _Tp1>
    bool owner_before(__weak_ptr<_Tp1, _Lp> const &__rhs) const noexcept {
      return _M_refcount._M_less(__rhs._M_refcount);
    }

  protected:
    template <typename _Alloc, typename... _Args>
    __shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args &&...__args)
        : _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward<_Args>(__args)...) {
      _M_enable_shared_from_this_with(_M_ptr);
    }

    template <typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
              typename... _Args>
    friend __shared_ptr<_Tp1, _Lp1> __allocate_shared(const _Alloc &__a,
                                                      _Args &&...__args);

    template <typename _Alloc, typename _Init = const remove_extent_t<_Tp> *>
    __shared_ptr(const _Sp_counted_array_base<_Alloc> &__a,
                 _Init __init = nullptr)
        : _M_ptr(), _M_refcount(_M_ptr, __a, __init) {}

    __shared_ptr(const __weak_ptr<_Tp, _Lp> &__r, std::nothrow_t) noexcept
        : _M_refcount(__r._M_refcount, std::nothrow) {
      _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;
    }

    friend class __weak_ptr<_Tp, _Lp>;

  private:
    template <typename _Yp>
    using __esft_base_t = decltype(__enable_shared_from_this_base(
        std::declval<const __shared_count<_Lp> &>(), std::declval<_Yp *>()));

    template <typename _Yp, typename = void>
    struct __has_esft_base : false_type {};

    template <typename _Yp>
    struct __has_esft_base<_Yp, __void_t<__esft_base_t<_Yp>>>
        : __not_<is_array<_Tp>> {};

    template <typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
    typename enable_if<__has_esft_base<_Yp2>::value>::type
    _M_enable_shared_from_this_with(_Yp *__p) noexcept {
      if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))
        __base->_M_weak_assign(const_cast<_Yp2 *>(__p), _M_refcount);
    }

    template <typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
    typename enable_if<!__has_esft_base<_Yp2>::value>::type
    _M_enable_shared_from_this_with(_Yp *) noexcept {}

    void *_M_get_deleter(const std::type_info &__ti) const noexcept {
      return _M_refcount._M_get_deleter(__ti);
    }

    template <typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
    template <typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;

    template <typename _Del, typename _Tp1, _Lock_policy _Lp1>
    friend _Del *get_deleter(const __shared_ptr<_Tp1, _Lp1> &) noexcept;

    template <typename _Del, typename _Tp1>
    friend _Del *get_deleter(const shared_ptr<_Tp1> &) noexcept;

    friend _Sp_atomic<shared_ptr<_Tp>>;

    element_type *_M_ptr;
    __shared_count<_Lp> _M_refcount;
  };

  template <typename _Tp1, typename _Tp2, _Lock_policy _Lp>
  inline bool operator==(const __shared_ptr<_Tp1, _Lp> &__a,
                         const __shared_ptr<_Tp2, _Lp> &__b) noexcept {
    return __a.get() == __b.get();
  }

  template <typename _Tp, _Lock_policy _Lp>
  inline bool operator==(const __shared_ptr<_Tp, _Lp> &__a,
                         nullptr_t) noexcept {
    return !__a;
  }

  template <typename _Tp, typename _Up, _Lock_policy _Lp>
  inline strong_ordering operator<=>(
      const __shared_ptr<_Tp, _Lp> &__a,
      const __shared_ptr<_Up, _Lp> &__b) noexcept {
    return compare_three_way()(__a.get(), __b.get());
  }

  template <typename _Tp, _Lock_policy _Lp>
  inline strong_ordering operator<=>(const __shared_ptr<_Tp, _Lp> &__a,
                                     nullptr_t) noexcept {
    using pointer = typename __shared_ptr<_Tp, _Lp>::element_type *;
    return compare_three_way()(__a.get(), static_cast<pointer>(nullptr));
  }
# 1915 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_base.h" 3
  template <typename _Tp, _Lock_policy _Lp>
  inline void swap(__shared_ptr<_Tp, _Lp> & __a,
                   __shared_ptr<_Tp, _Lp> & __b) noexcept {
    __a.swap(__b);
  }
# 1927 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_base.h" 3
  template <typename _Tp, typename _Tp1, _Lock_policy _Lp>
  inline __shared_ptr<_Tp, _Lp> static_pointer_cast(
      const __shared_ptr<_Tp1, _Lp> &__r) noexcept {
    using _Sp = __shared_ptr<_Tp, _Lp>;
    return _Sp(__r, static_cast<typename _Sp::element_type *>(__r.get()));
  }

  template <typename _Tp, typename _Tp1, _Lock_policy _Lp>
  inline __shared_ptr<_Tp, _Lp> const_pointer_cast(
      const __shared_ptr<_Tp1, _Lp> &__r) noexcept {
    using _Sp = __shared_ptr<_Tp, _Lp>;
    return _Sp(__r, const_cast<typename _Sp::element_type *>(__r.get()));
  }

  template <typename _Tp, typename _Tp1, _Lock_policy _Lp>
  inline __shared_ptr<_Tp, _Lp> dynamic_pointer_cast(
      const __shared_ptr<_Tp1, _Lp> &__r) noexcept {
    using _Sp = __shared_ptr<_Tp, _Lp>;
    if (auto *__p = dynamic_cast<typename _Sp::element_type *>(__r.get()))
      return _Sp(__r, __p);
    return _Sp();
  }

  template <typename _Tp, typename _Tp1, _Lock_policy _Lp>
  inline __shared_ptr<_Tp, _Lp> reinterpret_pointer_cast(
      const __shared_ptr<_Tp1, _Lp> &__r) noexcept {
    using _Sp = __shared_ptr<_Tp, _Lp>;
    return _Sp(__r, reinterpret_cast<typename _Sp::element_type *>(__r.get()));
  }

  template <typename _Tp, _Lock_policy _Lp> class __weak_ptr {
    template <typename _Yp, typename _Res = void>
    using _Compatible =
        typename enable_if<__sp_compatible_with<_Yp *, _Tp *>::value,
                           _Res>::type;

    template <typename _Yp> using _Assignable = _Compatible<_Yp, __weak_ptr &>;

  public:
    using element_type = typename remove_extent<_Tp>::type;

    constexpr __weak_ptr() noexcept : _M_ptr(nullptr), _M_refcount() {}

    __weak_ptr(const __weak_ptr &) noexcept = default;

    ~__weak_ptr() = default;
# 2009 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_base.h" 3
    template <typename _Yp, typename = _Compatible<_Yp>>
    __weak_ptr(const __weak_ptr<_Yp, _Lp> &__r) noexcept
        : _M_refcount(__r._M_refcount) {
      _M_ptr = __r.lock().get();
    }

    template <typename _Yp, typename = _Compatible<_Yp>>
    __weak_ptr(const __shared_ptr<_Yp, _Lp> &__r) noexcept
        : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) {}

    __weak_ptr(__weak_ptr &&__r) noexcept
        : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount)) {
      __r._M_ptr = nullptr;
    }

    template <typename _Yp, typename = _Compatible<_Yp>>
    __weak_ptr(__weak_ptr<_Yp, _Lp> &&__r) noexcept
        : _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount)) {
      __r._M_ptr = nullptr;
    }

    __weak_ptr &operator=(const __weak_ptr &__r) noexcept = default;

    template <typename _Yp>
    _Assignable<_Yp> operator=(const __weak_ptr<_Yp, _Lp> &__r) noexcept {
      _M_ptr = __r.lock().get();
      _M_refcount = __r._M_refcount;
      return *this;
    }

    template <typename _Yp>
    _Assignable<_Yp> operator=(const __shared_ptr<_Yp, _Lp> &__r) noexcept {
      _M_ptr = __r._M_ptr;
      _M_refcount = __r._M_refcount;
      return *this;
    }

    __weak_ptr &operator=(__weak_ptr &&__r) noexcept {
      __weak_ptr(std::move(__r)).swap(*this);
      return *this;
    }

    template <typename _Yp>
    _Assignable<_Yp> operator=(__weak_ptr<_Yp, _Lp> &&__r) noexcept {
      _M_ptr = __r.lock().get();
      _M_refcount = std::move(__r._M_refcount);
      __r._M_ptr = nullptr;
      return *this;
    }

    __shared_ptr<_Tp, _Lp> lock() const noexcept {
      return __shared_ptr<element_type, _Lp>(*this, std::nothrow);
    }

    long use_count() const noexcept { return _M_refcount._M_get_use_count(); }

    bool expired() const noexcept {
      return _M_refcount._M_get_use_count() == 0;
    }

    template <typename _Tp1>
    bool owner_before(const __shared_ptr<_Tp1, _Lp> &__rhs) const noexcept {
      return _M_refcount._M_less(__rhs._M_refcount);
    }

    template <typename _Tp1>
    bool owner_before(const __weak_ptr<_Tp1, _Lp> &__rhs) const noexcept {
      return _M_refcount._M_less(__rhs._M_refcount);
    }

    void reset() noexcept { __weak_ptr().swap(*this); }

    void swap(__weak_ptr &__s) noexcept {
      std::swap(_M_ptr, __s._M_ptr);
      _M_refcount._M_swap(__s._M_refcount);
    }

  private:
    void _M_assign(_Tp *__ptr, const __shared_count<_Lp> &__refcount) noexcept {
      if (use_count() == 0) {
        _M_ptr = __ptr;
        _M_refcount = __refcount;
      }
    }

    template <typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
    template <typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
    friend class __enable_shared_from_this<_Tp, _Lp>;
    friend class enable_shared_from_this<_Tp>;

    friend _Sp_atomic<weak_ptr<_Tp>>;

    element_type *_M_ptr;
    __weak_count<_Lp> _M_refcount;
  };

  template <typename _Tp, _Lock_policy _Lp>
  inline void swap(__weak_ptr<_Tp, _Lp> & __a,
                   __weak_ptr<_Tp, _Lp> & __b) noexcept {
    __a.swap(__b);
  }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template <typename _Tp, typename _Tp1>
  struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool> {
    bool operator()(const _Tp &__lhs, const _Tp &__rhs) const noexcept {
      return __lhs.owner_before(__rhs);
    }

    bool operator()(const _Tp &__lhs, const _Tp1 &__rhs) const noexcept {
      return __lhs.owner_before(__rhs);
    }

    bool operator()(const _Tp1 &__lhs, const _Tp &__rhs) const noexcept {
      return __lhs.owner_before(__rhs);
    }
  };
#pragma GCC diagnostic pop

  template <> struct _Sp_owner_less<void, void> {
    template <typename _Tp, typename _Up>
    auto operator()(const _Tp &__lhs, const _Up &__rhs) const noexcept
        -> decltype(__lhs.owner_before(__rhs)) {
      return __lhs.owner_before(__rhs);
    }

    using is_transparent = void;
  };

  template <typename _Tp, _Lock_policy _Lp>
  struct owner_less<__shared_ptr<_Tp, _Lp>>
      : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>> {};

  template <typename _Tp, _Lock_policy _Lp>
  struct owner_less<__weak_ptr<_Tp, _Lp>>
      : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>> {};

  template <typename _Tp, _Lock_policy _Lp> class __enable_shared_from_this {
  protected:
    constexpr __enable_shared_from_this() noexcept {}

    __enable_shared_from_this(const __enable_shared_from_this &) noexcept {}

    __enable_shared_from_this &
    operator=(const __enable_shared_from_this &) noexcept {
      return *this;
    }

    ~__enable_shared_from_this() {}

  public:
    __shared_ptr<_Tp, _Lp> shared_from_this() {
      return __shared_ptr<_Tp, _Lp>(this->_M_weak_this);
    }

    __shared_ptr<const _Tp, _Lp> shared_from_this() const {
      return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this);
    }

    __weak_ptr<_Tp, _Lp> weak_from_this() noexcept {
      return this->_M_weak_this;
    }

    __weak_ptr<const _Tp, _Lp> weak_from_this() const noexcept {
      return this->_M_weak_this;
    }

  private:
    template <typename _Tp1>
    void _M_weak_assign(_Tp1 *__p,
                        const __shared_count<_Lp> &__n) const noexcept {
      _M_weak_this._M_assign(__p, __n);
    }

    friend const __enable_shared_from_this *
    __enable_shared_from_this_base(const __shared_count<_Lp> &,
                                   const __enable_shared_from_this *__p) {
      return __p;
    }

    template <typename, _Lock_policy> friend class __shared_ptr;

    mutable __weak_ptr<_Tp, _Lp> _M_weak_this;
  };

  template <typename _Tp, _Lock_policy _Lp = __default_lock_policy,
            typename _Alloc, typename... _Args>
  inline __shared_ptr<_Tp, _Lp> __allocate_shared(const _Alloc &__a,
                                                  _Args &&...__args) {
    static_assert(!is_array<_Tp>::value, "make_shared<T[]> not supported");

    return __shared_ptr<_Tp, _Lp>(_Sp_alloc_shared_tag<_Alloc>{__a},
                                  std::forward<_Args>(__args)...);
  }

  template <typename _Tp, _Lock_policy _Lp = __default_lock_policy,
            typename... _Args>
  inline __shared_ptr<_Tp, _Lp> __make_shared(_Args && ...__args) {
    typedef typename std::remove_const<_Tp>::type _Tp_nc;
    return std::__allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),
                                            std::forward<_Args>(__args)...);
  }

  template <typename _Tp, _Lock_policy _Lp>
  struct hash<__shared_ptr<_Tp, _Lp>>
      : public __hash_base<size_t, __shared_ptr<_Tp, _Lp>> {
    size_t operator()(const __shared_ptr<_Tp, _Lp> &__s) const noexcept {
      return hash<typename __shared_ptr<_Tp, _Lp>::element_type *>()(__s.get());
    }
  };

} // namespace std
# 54 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 68 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
  template <typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>
  inline std::basic_ostream<_Ch, _Tr> &operator<<(
      std::basic_ostream<_Ch, _Tr> &__os, const __shared_ptr<_Tp, _Lp> &__p) {
    __os << __p.get();
    return __os;
  }

  template <typename _Del, typename _Tp, _Lock_policy _Lp>
  inline _Del *get_deleter(const __shared_ptr<_Tp, _Lp> &__p) noexcept {

    return static_cast<_Del *>(__p._M_get_deleter(typeid(_Del)));
  }

  template <typename _Del, typename _Tp>
  inline _Del *get_deleter(const shared_ptr<_Tp> &__p) noexcept {

    return static_cast<_Del *>(__p._M_get_deleter(typeid(_Del)));
  }

  template <typename _Tp>
    requires(!is_array_v<_Tp>)
  using _NonArray = _Tp;
# 118 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
  template <typename _Tp>
    requires is_array_v<_Tp> && (extent_v<_Tp> == 0)
  using _UnboundedArray = _Tp;
# 129 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
  template <typename _Tp>
    requires(extent_v<_Tp> != 0)
  using _BoundedArray = _Tp;
# 141 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
  template <typename _Tp>
    requires(!is_array_v<_Tp>) || (extent_v<_Tp> != 0)
  using _NotUnboundedArray = _Tp;
# 174 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
  template <typename _Tp> class shared_ptr : public __shared_ptr<_Tp> {
    template <typename... _Args>
    using _Constructible = typename enable_if<
        is_constructible<__shared_ptr<_Tp>, _Args...>::value>::type;

    template <typename _Arg>
    using _Assignable =
        typename enable_if<is_assignable<__shared_ptr<_Tp> &, _Arg>::value,
                           shared_ptr &>::type;

  public:
    using element_type = typename __shared_ptr<_Tp>::element_type;

    using weak_type = weak_ptr<_Tp>;

    constexpr shared_ptr() noexcept : __shared_ptr<_Tp>() {}

    shared_ptr(const shared_ptr &) noexcept = default;

    template <typename _Yp, typename = _Constructible<_Yp *>>
    explicit shared_ptr(_Yp *__p) : __shared_ptr<_Tp>(__p) {}
# 229 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
    template <typename _Yp, typename _Deleter,
              typename = _Constructible<_Yp *, _Deleter>>
    shared_ptr(_Yp *__p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, std::move(__d)) {}
# 247 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
    template <typename _Deleter>
    shared_ptr(nullptr_t __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, std::move(__d)) {}
# 266 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
    template <typename _Yp, typename _Deleter, typename _Alloc,
              typename = _Constructible<_Yp *, _Deleter, _Alloc>>
    shared_ptr(_Yp *__p, _Deleter __d, _Alloc __a)
        : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) {}
# 286 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
    template <typename _Deleter, typename _Alloc>
    shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
        : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) {}
# 310 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
    template <typename _Yp>
    shared_ptr(const shared_ptr<_Yp> &__r, element_type *__p) noexcept
        : __shared_ptr<_Tp>(__r, __p) {}
# 338 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
    template <typename _Yp>
    shared_ptr(shared_ptr<_Yp> &&__r, element_type *__p) noexcept
        : __shared_ptr<_Tp>(std::move(__r), __p) {}
# 349 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
    template <typename _Yp, typename = _Constructible<const shared_ptr<_Yp> &>>
    shared_ptr(const shared_ptr<_Yp> &__r) noexcept : __shared_ptr<_Tp>(__r) {}

    shared_ptr(shared_ptr &&__r) noexcept : __shared_ptr<_Tp>(std::move(__r)) {}

    template <typename _Yp, typename = _Constructible<shared_ptr<_Yp>>>
    shared_ptr(shared_ptr<_Yp> &&__r) noexcept
        : __shared_ptr<_Tp>(std::move(__r)) {}
# 379 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
    template <typename _Yp, typename = _Constructible<const weak_ptr<_Yp> &>>
    explicit shared_ptr(const weak_ptr<_Yp> &__r) : __shared_ptr<_Tp>(__r) {}

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    template <typename _Yp, typename = _Constructible<auto_ptr<_Yp>>>
    shared_ptr(auto_ptr<_Yp> &&__r);
#pragma GCC diagnostic pop

    template <typename _Yp, typename _Del,
              typename = _Constructible<unique_ptr<_Yp, _Del>>>
    shared_ptr(unique_ptr<_Yp, _Del> &&__r)
        : __shared_ptr<_Tp>(std::move(__r)) {}
# 412 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
    constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() {}

    shared_ptr &operator=(const shared_ptr &) noexcept = default;

    template <typename _Yp>
    _Assignable<const shared_ptr<_Yp> &>
    operator=(const shared_ptr<_Yp> &__r) noexcept {
      this->__shared_ptr<_Tp>::operator=(__r);
      return *this;
    }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    template <typename _Yp>
    _Assignable<auto_ptr<_Yp>> operator=(auto_ptr<_Yp> &&__r) {
      this->__shared_ptr<_Tp>::operator=(std::move(__r));
      return *this;
    }
#pragma GCC diagnostic pop

    shared_ptr &operator=(shared_ptr &&__r) noexcept {
      this->__shared_ptr<_Tp>::operator=(std::move(__r));
      return *this;
    }

    template <class _Yp>
    _Assignable<shared_ptr<_Yp>> operator=(shared_ptr<_Yp> &&__r) noexcept {
      this->__shared_ptr<_Tp>::operator=(std::move(__r));
      return *this;
    }

    template <typename _Yp, typename _Del>
    _Assignable<unique_ptr<_Yp, _Del>> operator=(unique_ptr<_Yp, _Del> &&__r) {
      this->__shared_ptr<_Tp>::operator=(std::move(__r));
      return *this;
    }

  private:
    template <typename _Alloc, typename... _Args>
    shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args &&...__args)
        : __shared_ptr<_Tp>(__tag, std::forward<_Args>(__args)...) {}

    template <typename _Yp, typename _Alloc, typename... _Args>
    friend shared_ptr<_NonArray<_Yp>> allocate_shared(const _Alloc &,
                                                      _Args &&...);

    template <typename _Yp, typename... _Args>
    friend shared_ptr<_NonArray<_Yp>> make_shared(_Args &&...);

    template <typename _Alloc, typename _Init = const remove_extent_t<_Tp> *>
    shared_ptr(const _Sp_counted_array_base<_Alloc> &__a,
               _Init __init = nullptr)
        : __shared_ptr<_Tp>(__a, __init) {}

    template <typename _Yp, typename _Alloc>
    friend shared_ptr<_UnboundedArray<_Yp>> allocate_shared(const _Alloc &,
                                                            size_t);

    template <typename _Yp>
    friend shared_ptr<_UnboundedArray<_Yp>> make_shared(size_t);

    template <typename _Yp, typename _Alloc>
    friend shared_ptr<_UnboundedArray<_Yp>>
    allocate_shared(const _Alloc &, size_t, const remove_extent_t<_Yp> &);

    template <typename _Yp>
    friend shared_ptr<_UnboundedArray<_Yp>>
    make_shared(size_t, const remove_extent_t<_Yp> &);

    template <typename _Yp, typename _Alloc>
    friend shared_ptr<_BoundedArray<_Yp>> allocate_shared(const _Alloc &);

    template <typename _Yp> friend shared_ptr<_BoundedArray<_Yp>> make_shared();

    template <typename _Yp, typename _Alloc>
    friend shared_ptr<_BoundedArray<_Yp>>
    allocate_shared(const _Alloc &, const remove_extent_t<_Yp> &);

    template <typename _Yp>
    friend shared_ptr<_BoundedArray<_Yp>>
    make_shared(const remove_extent_t<_Yp> &);

    template <typename _Yp, typename _Alloc>
    friend shared_ptr<_NotUnboundedArray<_Yp>>
    allocate_shared_for_overwrite(const _Alloc &);

    template <typename _Yp>
    friend shared_ptr<_NotUnboundedArray<_Yp>> make_shared_for_overwrite();

    template <typename _Yp, typename _Alloc>
    friend shared_ptr<_UnboundedArray<_Yp>>
    allocate_shared_for_overwrite(const _Alloc &, size_t);

    template <typename _Yp>
    friend shared_ptr<_UnboundedArray<_Yp>> make_shared_for_overwrite(size_t);

    shared_ptr(const weak_ptr<_Tp> &__r, std::nothrow_t) noexcept
        : __shared_ptr<_Tp>(__r, std::nothrow) {}

    friend class weak_ptr<_Tp>;
  };

  template <typename _Tp> shared_ptr(weak_ptr<_Tp>) -> shared_ptr<_Tp>;
  template <typename _Tp, typename _Del>
  shared_ptr(unique_ptr<_Tp, _Del>) -> shared_ptr<_Tp>;

  template <typename _Tp, typename _Up>
  [[__nodiscard__]] inline bool operator==(
      const shared_ptr<_Tp> &__a, const shared_ptr<_Up> &__b) noexcept {
    return __a.get() == __b.get();
  }

  template <typename _Tp>
  [[__nodiscard__]] inline bool operator==(const shared_ptr<_Tp> &__a,
                                           nullptr_t) noexcept {
    return !__a;
  }

  template <typename _Tp, typename _Up>
  inline strong_ordering operator<=>(const shared_ptr<_Tp> &__a,
                                     const shared_ptr<_Up> &__b) noexcept {
    return compare_three_way()(__a.get(), __b.get());
  }

  template <typename _Tp>
  inline strong_ordering operator<=>(const shared_ptr<_Tp> &__a,
                                     nullptr_t) noexcept {
    using pointer = typename shared_ptr<_Tp>::element_type *;
    return compare_three_way()(__a.get(), static_cast<pointer>(nullptr));
  }
# 690 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
  template <typename _Tp>
  inline void swap(shared_ptr<_Tp> & __a, shared_ptr<_Tp> & __b) noexcept {
    __a.swap(__b);
  }

  template <typename _Tp, typename _Up>
  inline shared_ptr<_Tp> static_pointer_cast(
      const shared_ptr<_Up> &__r) noexcept {
    using _Sp = shared_ptr<_Tp>;
    return _Sp(__r, static_cast<typename _Sp::element_type *>(__r.get()));
  }

  template <typename _Tp, typename _Up>
  inline shared_ptr<_Tp> const_pointer_cast(
      const shared_ptr<_Up> &__r) noexcept {
    using _Sp = shared_ptr<_Tp>;
    return _Sp(__r, const_cast<typename _Sp::element_type *>(__r.get()));
  }

  template <typename _Tp, typename _Up>
  inline shared_ptr<_Tp> dynamic_pointer_cast(
      const shared_ptr<_Up> &__r) noexcept {
    using _Sp = shared_ptr<_Tp>;
    if (auto *__p = dynamic_cast<typename _Sp::element_type *>(__r.get()))
      return _Sp(__r, __p);
    return _Sp();
  }

  template <typename _Tp, typename _Up>
  inline shared_ptr<_Tp> reinterpret_pointer_cast(
      const shared_ptr<_Up> &__r) noexcept {
    using _Sp = shared_ptr<_Tp>;
    return _Sp(__r, reinterpret_cast<typename _Sp::element_type *>(__r.get()));
  }

  template <typename _Tp, typename _Up>
  inline shared_ptr<_Tp> static_pointer_cast(shared_ptr<_Up> && __r) noexcept {
    using _Sp = shared_ptr<_Tp>;
    return _Sp(std::move(__r),
               static_cast<typename _Sp::element_type *>(__r.get()));
  }

  template <typename _Tp, typename _Up>
  inline shared_ptr<_Tp> const_pointer_cast(shared_ptr<_Up> && __r) noexcept {
    using _Sp = shared_ptr<_Tp>;
    return _Sp(std::move(__r),
               const_cast<typename _Sp::element_type *>(__r.get()));
  }

  template <typename _Tp, typename _Up>
  inline shared_ptr<_Tp> dynamic_pointer_cast(shared_ptr<_Up> && __r) noexcept {
    using _Sp = shared_ptr<_Tp>;
    if (auto *__p = dynamic_cast<typename _Sp::element_type *>(__r.get()))
      return _Sp(std::move(__r), __p);
    return _Sp();
  }

  template <typename _Tp, typename _Up>
  inline shared_ptr<_Tp> reinterpret_pointer_cast(shared_ptr<_Up> &&
                                                  __r) noexcept {
    using _Sp = shared_ptr<_Tp>;
    return _Sp(std::move(__r),
               reinterpret_cast<typename _Sp::element_type *>(__r.get()));
  }
# 810 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
  template <typename _Tp> class weak_ptr : public __weak_ptr<_Tp> {
    template <typename _Arg>
    using _Constructible = typename enable_if<
        is_constructible<__weak_ptr<_Tp>, _Arg>::value>::type;

    template <typename _Arg>
    using _Assignable =
        typename enable_if<is_assignable<__weak_ptr<_Tp> &, _Arg>::value,
                           weak_ptr &>::type;

  public:
    constexpr weak_ptr() noexcept = default;

    template <typename _Yp, typename = _Constructible<const shared_ptr<_Yp> &>>
    weak_ptr(const shared_ptr<_Yp> &__r) noexcept : __weak_ptr<_Tp>(__r) {}

    weak_ptr(const weak_ptr &) noexcept = default;

    template <typename _Yp, typename = _Constructible<const weak_ptr<_Yp> &>>
    weak_ptr(const weak_ptr<_Yp> &__r) noexcept : __weak_ptr<_Tp>(__r) {}

    weak_ptr(weak_ptr &&) noexcept = default;

    template <typename _Yp, typename = _Constructible<weak_ptr<_Yp>>>
    weak_ptr(weak_ptr<_Yp> &&__r) noexcept : __weak_ptr<_Tp>(std::move(__r)) {}

    weak_ptr &operator=(const weak_ptr &__r) noexcept = default;

    template <typename _Yp>
    _Assignable<const weak_ptr<_Yp> &>
    operator=(const weak_ptr<_Yp> &__r) noexcept {
      this->__weak_ptr<_Tp>::operator=(__r);
      return *this;
    }

    template <typename _Yp>
    _Assignable<const shared_ptr<_Yp> &>
    operator=(const shared_ptr<_Yp> &__r) noexcept {
      this->__weak_ptr<_Tp>::operator=(__r);
      return *this;
    }

    weak_ptr &operator=(weak_ptr &&__r) noexcept = default;

    template <typename _Yp>
    _Assignable<weak_ptr<_Yp>> operator=(weak_ptr<_Yp> &&__r) noexcept {
      this->__weak_ptr<_Tp>::operator=(std::move(__r));
      return *this;
    }

    shared_ptr<_Tp> lock() const noexcept {
      return shared_ptr<_Tp>(*this, std::nothrow);
    }
  };

  template <typename _Tp> weak_ptr(shared_ptr<_Tp>) -> weak_ptr<_Tp>;

  template <typename _Tp>
  inline void swap(weak_ptr<_Tp> & __a, weak_ptr<_Tp> & __b) noexcept {
    __a.swap(__b);
  }

  template <typename _Tp = void> struct owner_less;

  template <> struct owner_less<void> : _Sp_owner_less<void, void> {};

  template <typename _Tp>
  struct owner_less<shared_ptr<_Tp>>
      : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>> {};

  template <typename _Tp>
  struct owner_less<weak_ptr<_Tp>>
      : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>> {};

  template <typename _Tp> class enable_shared_from_this {
  protected:
    constexpr enable_shared_from_this() noexcept {}

    enable_shared_from_this(const enable_shared_from_this &) noexcept {}

    enable_shared_from_this &
    operator=(const enable_shared_from_this &) noexcept {
      return *this;
    }

    ~enable_shared_from_this() {}

  public:
    shared_ptr<_Tp> shared_from_this() {
      return shared_ptr<_Tp>(this->_M_weak_this);
    }

    shared_ptr<const _Tp> shared_from_this() const {
      return shared_ptr<const _Tp>(this->_M_weak_this);
    }

    weak_ptr<_Tp> weak_from_this() noexcept { return this->_M_weak_this; }

    weak_ptr<const _Tp> weak_from_this() const noexcept {
      return this->_M_weak_this;
    }

  private:
    template <typename _Tp1>
    void _M_weak_assign(_Tp1 *__p, const __shared_count<> &__n) const noexcept {
      _M_weak_this._M_assign(__p, __n);
    }

    friend const enable_shared_from_this *
    __enable_shared_from_this_base(const __shared_count<> &,
                                   const enable_shared_from_this *__p) {
      return __p;
    }

    template <typename, _Lock_policy> friend class __shared_ptr;

    mutable weak_ptr<_Tp> _M_weak_this;
  };
# 988 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
  template <typename _Tp, typename _Alloc, typename... _Args>
  inline shared_ptr<_NonArray<_Tp>> allocate_shared(const _Alloc &__a,
                                                    _Args &&...__args) {
    return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{__a},
                           std::forward<_Args>(__args)...);
  }
# 1003 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr.h" 3
  template <typename _Tp, typename... _Args>
  inline shared_ptr<_NonArray<_Tp>> make_shared(_Args && ...__args) {
    using _Alloc = allocator<void>;
    _Alloc __a;
    return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{__a},
                           std::forward<_Args>(__args)...);
  }

  template <typename _Tp, typename _Alloc = allocator<void>>
  auto __make_shared_arr_tag(size_t __n,
                             const _Alloc &__a = _Alloc()) noexcept {
    using _Up = remove_all_extents_t<_Tp>;
    using _UpAlloc = __alloc_rebind<_Alloc, _Up>;
    size_t __s = sizeof(remove_extent_t<_Tp>) / sizeof(_Up);
    if (__builtin_mul_overflow(__s, __n, &__n))
      std::__throw_bad_array_new_length();
    return _Sp_counted_array_base<_UpAlloc>{_UpAlloc(__a), __n};
  }

  template <typename _Tp, typename _Alloc>
  inline shared_ptr<_UnboundedArray<_Tp>> allocate_shared(const _Alloc &__a,
                                                          size_t __n) {
    return shared_ptr<_Tp>(std::__make_shared_arr_tag<_Tp>(__n, __a));
  }

  template <typename _Tp>
  inline shared_ptr<_UnboundedArray<_Tp>> make_shared(size_t __n) {
    return shared_ptr<_Tp>(std::__make_shared_arr_tag<_Tp>(__n));
  }

  template <typename _Tp, typename _Alloc>
  inline shared_ptr<_UnboundedArray<_Tp>> allocate_shared(
      const _Alloc &__a, size_t __n, const remove_extent_t<_Tp> &__u) {
    return shared_ptr<_Tp>(std::__make_shared_arr_tag<_Tp>(__n, __a),
                           std::__addressof(__u));
  }

  template <typename _Tp>
  inline shared_ptr<_UnboundedArray<_Tp>> make_shared(
      size_t __n, const remove_extent_t<_Tp> &__u) {
    return shared_ptr<_Tp>(std::__make_shared_arr_tag<_Tp>(__n),
                           std::__addressof(__u));
  }

  template <typename _Tp, typename _Alloc = allocator<void>>
  auto __make_shared_arrN_tag(const _Alloc &__a = _Alloc()) noexcept {
    using _Up = remove_all_extents_t<_Tp>;
    using _UpAlloc = __alloc_rebind<_Alloc, _Up>;
    size_t __n = sizeof(_Tp) / sizeof(_Up);
    return _Sp_counted_array_base<_UpAlloc>{_UpAlloc(__a), __n};
  }

  template <typename _Tp, typename _Alloc>
  inline shared_ptr<_BoundedArray<_Tp>> allocate_shared(const _Alloc &__a) {
    return shared_ptr<_Tp>(std::__make_shared_arrN_tag<_Tp>(__a));
  }

  template <typename _Tp> inline shared_ptr<_BoundedArray<_Tp>> make_shared() {
    return shared_ptr<_Tp>(std::__make_shared_arrN_tag<_Tp>());
  }

  template <typename _Tp, typename _Alloc>
  inline shared_ptr<_BoundedArray<_Tp>> allocate_shared(
      const _Alloc &__a, const remove_extent_t<_Tp> &__u) {
    return shared_ptr<_Tp>(std::__make_shared_arrN_tag<_Tp>(__a),
                           std::__addressof(__u));
  }

  template <typename _Tp>
  inline shared_ptr<_BoundedArray<_Tp>> make_shared(
      const remove_extent_t<_Tp> &__u) {
    return shared_ptr<_Tp>(std::__make_shared_arrN_tag<_Tp>(),
                           std::__addressof(__u));
  }

  template <typename _Tp, typename _Alloc>
  inline shared_ptr<_NotUnboundedArray<_Tp>> allocate_shared_for_overwrite(
      const _Alloc &__a) {
    if constexpr (is_array_v<_Tp>)
      return shared_ptr<_Tp>(std::__make_shared_arrN_tag<_Tp>(__a),
                             _Sp_overwrite_tag{});
    else {

      using _Alloc2 = __alloc_rebind<_Alloc, _Sp_overwrite_tag>;
      _Alloc2 __a2 = __a;
      return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc2>{__a2});
    }
  }

  template <typename _Tp>
  inline shared_ptr<_NotUnboundedArray<_Tp>> make_shared_for_overwrite() {
    if constexpr (is_array_v<_Tp>)
      return shared_ptr<_Tp>(std::__make_shared_arrN_tag<_Tp>(),
                             _Sp_overwrite_tag{});
    else {
      using _Alloc = allocator<_Sp_overwrite_tag>;
      return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{{}});
    }
  }

  template <typename _Tp, typename _Alloc>
  inline shared_ptr<_UnboundedArray<_Tp>> allocate_shared_for_overwrite(
      const _Alloc &__a, size_t __n) {
    return shared_ptr<_Tp>(std::__make_shared_arr_tag<_Tp>(__n, __a),
                           _Sp_overwrite_tag{});
  }

  template <typename _Tp>
  inline shared_ptr<_UnboundedArray<_Tp>> make_shared_for_overwrite(
      size_t __n) {
    return shared_ptr<_Tp>(std::__make_shared_arr_tag<_Tp>(__n),
                           _Sp_overwrite_tag{});
  }

  template <typename _Tp>
  struct hash<shared_ptr<_Tp>> : public __hash_base<size_t, shared_ptr<_Tp>> {
    size_t operator()(const shared_ptr<_Tp> &__s) const noexcept {
      return std::hash<typename shared_ptr<_Tp>::element_type *>()(__s.get());
    }
  };

  namespace __detail::__variant {
  template <typename> struct _Never_valueless_alt;

  template <typename _Tp>
  struct _Never_valueless_alt<std::shared_ptr<_Tp>> : std::true_type {};

  template <typename _Tp>
  struct _Never_valueless_alt<std::weak_ptr<_Tp>> : std::true_type {};
  } // namespace __detail::__variant

} // namespace std
# 81 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/memory" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_atomic.h" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_atomic.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_base.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_base.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_lockfree_defines.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_lockfree_defines.h" 3
# 39 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_base.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_wait.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_wait.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdint" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdint" 3
# 48 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdint" 3
namespace std {

using ::int16_t;
using ::int32_t;
using ::int64_t;
using ::int8_t;

using ::int_fast16_t;
using ::int_fast32_t;
using ::int_fast64_t;
using ::int_fast8_t;

using ::int_least16_t;
using ::int_least32_t;
using ::int_least64_t;
using ::int_least8_t;

using ::intmax_t;
using ::intptr_t;

using ::uint16_t;
using ::uint32_t;
using ::uint64_t;
using ::uint8_t;

using ::uint_fast16_t;
using ::uint_fast32_t;
using ::uint_fast64_t;
using ::uint_fast8_t;

using ::uint_least16_t;
using ::uint_least32_t;
using ::uint_least64_t;
using ::uint_least8_t;

using ::uintmax_t;
using ::uintptr_t;
# 142 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cstdint" 3
} // namespace std
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_wait.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cerrno" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cerrno" 3
# 44 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_wait.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/climits" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/climits" 3

# 1 "/usr/lib/llvm-18/lib/clang/18/include/limits.h" 1 3
# 21 "/usr/lib/llvm-18/lib/clang/18/include/limits.h" 3
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 195 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 196 "/usr/include/limits.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 200 "/usr/include/limits.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 204 "/usr/include/limits.h" 2 3 4
# 22 "/usr/lib/llvm-18/lib/clang/18/include/limits.h" 2 3
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/climits" 2 3
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_wait.h" 2 3
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4
extern "C" {
# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 1 3 4
# 77 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 1 3 4
# 18 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_size_t.h" 3 4
typedef long unsigned int size_t;
# 78 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 92 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-18/lib/clang/18/include/__stddef_null.h" 1 3 4
# 93 "/usr/lib/llvm-18/lib/clang/18/include/stddef.h" 2 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 274 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access(const char *__name, int __type) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int euidaccess(const char *__name, int __type) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int eaccess(const char *__name, int __type) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int execveat(int __fd, const char *__path, char *const __argv[],
                    char *const __envp[], int __flags) noexcept(true)
    __attribute__((__nonnull__(2, 3)));

extern int faccessat(int __fd, const char *__file, int __type,
                     int __flag) noexcept(true) __attribute__((__nonnull__(2)));
# 339 "/usr/include/unistd.h" 3 4
extern __off_t lseek(int __fd, __off_t __offset, int __whence) noexcept(true);
# 350 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64(int __fd, __off64_t __offset,
                         int __whence) noexcept(true);

extern int close(int __fd);

extern void closefrom(int __lowfd) noexcept(true);

extern ssize_t read(int __fd, void *__buf, size_t __nbytes);

extern ssize_t write(int __fd, const void *__buf, size_t __n);
# 389 "/usr/include/unistd.h" 3 4
extern ssize_t pread(int __fd, void *__buf, size_t __nbytes, __off_t __offset);

extern ssize_t pwrite(int __fd, const void *__buf, size_t __n,
                      __off_t __offset);
# 422 "/usr/include/unistd.h" 3 4
extern ssize_t pread64(int __fd, void *__buf, size_t __nbytes,
                       __off64_t __offset);

extern ssize_t pwrite64(int __fd, const void *__buf, size_t __n,
                        __off64_t __offset);

extern int pipe(int __pipedes[2]) noexcept(true);

extern int pipe2(int __pipedes[2], int __flags) noexcept(true);
# 452 "/usr/include/unistd.h" 3 4
extern unsigned int alarm(unsigned int __seconds) noexcept(true);
# 464 "/usr/include/unistd.h" 3 4
extern unsigned int sleep(unsigned int __seconds);

extern __useconds_t ualarm(__useconds_t __value,
                           __useconds_t __interval) noexcept(true);

extern int usleep(__useconds_t __useconds);
# 489 "/usr/include/unistd.h" 3 4
extern int pause(void);

extern int chown(const char *__file, __uid_t __owner,
                 __gid_t __group) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int fchown(int __fd, __uid_t __owner, __gid_t __group) noexcept(true);

extern int lchown(const char *__file, __uid_t __owner,
                  __gid_t __group) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int fchownat(int __fd, const char *__file, __uid_t __owner,
                    __gid_t __group, int __flag) noexcept(true)
    __attribute__((__nonnull__(2)));

extern int chdir(const char *__path) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int fchdir(int __fd) noexcept(true);
# 531 "/usr/include/unistd.h" 3 4
extern char *getcwd(char *__buf, size_t __size) noexcept(true);

extern char *get_current_dir_name(void) noexcept(true);

extern char *getwd(char *__buf) noexcept(true) __attribute__((__nonnull__(1)))
__attribute__((__deprecated__));

extern int dup(int __fd) noexcept(true);

extern int dup2(int __fd, int __fd2) noexcept(true);

extern int dup3(int __fd, int __fd2, int __flags) noexcept(true);

extern char **__environ;

extern char **environ;

extern int execve(const char *__path, char *const __argv[],
                  char *const __envp[]) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int fexecve(int __fd, char *const __argv[],
                   char *const __envp[]) noexcept(true)
    __attribute__((__nonnull__(2)));

extern int execv(const char *__path, char *const __argv[]) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int execle(const char *__path, const char *__arg, ...) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int execl(const char *__path, const char *__arg, ...) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int execvp(const char *__file, char *const __argv[]) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int execlp(const char *__file, const char *__arg, ...) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int execvpe(const char *__file, char *const __argv[],
                   char *const __envp[]) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int nice(int __inc) noexcept(true);

extern void _exit(int __status) __attribute__((__noreturn__));

# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum {
  _PC_LINK_MAX,

  _PC_MAX_CANON,

  _PC_MAX_INPUT,

  _PC_NAME_MAX,

  _PC_PATH_MAX,

  _PC_PIPE_BUF,

  _PC_CHOWN_RESTRICTED,

  _PC_NO_TRUNC,

  _PC_VDISABLE,

  _PC_SYNC_IO,

  _PC_ASYNC_IO,

  _PC_PRIO_IO,

  _PC_SOCK_MAXBUF,

  _PC_FILESIZEBITS,

  _PC_REC_INCR_XFER_SIZE,

  _PC_REC_MAX_XFER_SIZE,

  _PC_REC_MIN_XFER_SIZE,

  _PC_REC_XFER_ALIGN,

  _PC_ALLOC_SIZE_MIN,

  _PC_SYMLINK_MAX,

  _PC_2_SYMLINKS

};

enum {
  _SC_ARG_MAX,

  _SC_CHILD_MAX,

  _SC_CLK_TCK,

  _SC_NGROUPS_MAX,

  _SC_OPEN_MAX,

  _SC_STREAM_MAX,

  _SC_TZNAME_MAX,

  _SC_JOB_CONTROL,

  _SC_SAVED_IDS,

  _SC_REALTIME_SIGNALS,

  _SC_PRIORITY_SCHEDULING,

  _SC_TIMERS,

  _SC_ASYNCHRONOUS_IO,

  _SC_PRIORITIZED_IO,

  _SC_SYNCHRONIZED_IO,

  _SC_FSYNC,

  _SC_MAPPED_FILES,

  _SC_MEMLOCK,

  _SC_MEMLOCK_RANGE,

  _SC_MEMORY_PROTECTION,

  _SC_MESSAGE_PASSING,

  _SC_SEMAPHORES,

  _SC_SHARED_MEMORY_OBJECTS,

  _SC_AIO_LISTIO_MAX,

  _SC_AIO_MAX,

  _SC_AIO_PRIO_DELTA_MAX,

  _SC_DELAYTIMER_MAX,

  _SC_MQ_OPEN_MAX,

  _SC_MQ_PRIO_MAX,

  _SC_VERSION,

  _SC_PAGESIZE,

  _SC_RTSIG_MAX,

  _SC_SEM_NSEMS_MAX,

  _SC_SEM_VALUE_MAX,

  _SC_SIGQUEUE_MAX,

  _SC_TIMER_MAX,

  _SC_BC_BASE_MAX,

  _SC_BC_DIM_MAX,

  _SC_BC_SCALE_MAX,

  _SC_BC_STRING_MAX,

  _SC_COLL_WEIGHTS_MAX,

  _SC_EQUIV_CLASS_MAX,

  _SC_EXPR_NEST_MAX,

  _SC_LINE_MAX,

  _SC_RE_DUP_MAX,

  _SC_CHARCLASS_NAME_MAX,

  _SC_2_VERSION,

  _SC_2_C_BIND,

  _SC_2_C_DEV,

  _SC_2_FORT_DEV,

  _SC_2_FORT_RUN,

  _SC_2_SW_DEV,

  _SC_2_LOCALEDEF,

  _SC_PII,

  _SC_PII_XTI,

  _SC_PII_SOCKET,

  _SC_PII_INTERNET,

  _SC_PII_OSI,

  _SC_POLL,

  _SC_SELECT,

  _SC_UIO_MAXIOV,

  _SC_IOV_MAX = _SC_UIO_MAXIOV,

  _SC_PII_INTERNET_STREAM,

  _SC_PII_INTERNET_DGRAM,

  _SC_PII_OSI_COTS,

  _SC_PII_OSI_CLTS,

  _SC_PII_OSI_M,

  _SC_T_IOV_MAX,

  _SC_THREADS,

  _SC_THREAD_SAFE_FUNCTIONS,

  _SC_GETGR_R_SIZE_MAX,

  _SC_GETPW_R_SIZE_MAX,

  _SC_LOGIN_NAME_MAX,

  _SC_TTY_NAME_MAX,

  _SC_THREAD_DESTRUCTOR_ITERATIONS,

  _SC_THREAD_KEYS_MAX,

  _SC_THREAD_STACK_MIN,

  _SC_THREAD_THREADS_MAX,

  _SC_THREAD_ATTR_STACKADDR,

  _SC_THREAD_ATTR_STACKSIZE,

  _SC_THREAD_PRIORITY_SCHEDULING,

  _SC_THREAD_PRIO_INHERIT,

  _SC_THREAD_PRIO_PROTECT,

  _SC_THREAD_PROCESS_SHARED,

  _SC_NPROCESSORS_CONF,

  _SC_NPROCESSORS_ONLN,

  _SC_PHYS_PAGES,

  _SC_AVPHYS_PAGES,

  _SC_ATEXIT_MAX,

  _SC_PASS_MAX,

  _SC_XOPEN_VERSION,

  _SC_XOPEN_XCU_VERSION,

  _SC_XOPEN_UNIX,

  _SC_XOPEN_CRYPT,

  _SC_XOPEN_ENH_I18N,

  _SC_XOPEN_SHM,

  _SC_2_CHAR_TERM,

  _SC_2_C_VERSION,

  _SC_2_UPE,

  _SC_XOPEN_XPG2,

  _SC_XOPEN_XPG3,

  _SC_XOPEN_XPG4,

  _SC_CHAR_BIT,

  _SC_CHAR_MAX,

  _SC_CHAR_MIN,

  _SC_INT_MAX,

  _SC_INT_MIN,

  _SC_LONG_BIT,

  _SC_WORD_BIT,

  _SC_MB_LEN_MAX,

  _SC_NZERO,

  _SC_SSIZE_MAX,

  _SC_SCHAR_MAX,

  _SC_SCHAR_MIN,

  _SC_SHRT_MAX,

  _SC_SHRT_MIN,

  _SC_UCHAR_MAX,

  _SC_UINT_MAX,

  _SC_ULONG_MAX,

  _SC_USHRT_MAX,

  _SC_NL_ARGMAX,

  _SC_NL_LANGMAX,

  _SC_NL_MSGMAX,

  _SC_NL_NMAX,

  _SC_NL_SETMAX,

  _SC_NL_TEXTMAX,

  _SC_XBS5_ILP32_OFF32,

  _SC_XBS5_ILP32_OFFBIG,

  _SC_XBS5_LP64_OFF64,

  _SC_XBS5_LPBIG_OFFBIG,

  _SC_XOPEN_LEGACY,

  _SC_XOPEN_REALTIME,

  _SC_XOPEN_REALTIME_THREADS,

  _SC_ADVISORY_INFO,

  _SC_BARRIERS,

  _SC_BASE,

  _SC_C_LANG_SUPPORT,

  _SC_C_LANG_SUPPORT_R,

  _SC_CLOCK_SELECTION,

  _SC_CPUTIME,

  _SC_THREAD_CPUTIME,

  _SC_DEVICE_IO,

  _SC_DEVICE_SPECIFIC,

  _SC_DEVICE_SPECIFIC_R,

  _SC_FD_MGMT,

  _SC_FIFO,

  _SC_PIPE,

  _SC_FILE_ATTRIBUTES,

  _SC_FILE_LOCKING,

  _SC_FILE_SYSTEM,

  _SC_MONOTONIC_CLOCK,

  _SC_MULTI_PROCESS,

  _SC_SINGLE_PROCESS,

  _SC_NETWORKING,

  _SC_READER_WRITER_LOCKS,

  _SC_SPIN_LOCKS,

  _SC_REGEXP,

  _SC_REGEX_VERSION,

  _SC_SHELL,

  _SC_SIGNALS,

  _SC_SPAWN,

  _SC_SPORADIC_SERVER,

  _SC_THREAD_SPORADIC_SERVER,

  _SC_SYSTEM_DATABASE,

  _SC_SYSTEM_DATABASE_R,

  _SC_TIMEOUTS,

  _SC_TYPED_MEMORY_OBJECTS,

  _SC_USER_GROUPS,

  _SC_USER_GROUPS_R,

  _SC_2_PBS,

  _SC_2_PBS_ACCOUNTING,

  _SC_2_PBS_LOCATE,

  _SC_2_PBS_MESSAGE,

  _SC_2_PBS_TRACK,

  _SC_SYMLOOP_MAX,

  _SC_STREAMS,

  _SC_2_PBS_CHECKPOINT,

  _SC_V6_ILP32_OFF32,

  _SC_V6_ILP32_OFFBIG,

  _SC_V6_LP64_OFF64,

  _SC_V6_LPBIG_OFFBIG,

  _SC_HOST_NAME_MAX,

  _SC_TRACE,

  _SC_TRACE_EVENT_FILTER,

  _SC_TRACE_INHERIT,

  _SC_TRACE_LOG,

  _SC_LEVEL1_ICACHE_SIZE,

  _SC_LEVEL1_ICACHE_ASSOC,

  _SC_LEVEL1_ICACHE_LINESIZE,

  _SC_LEVEL1_DCACHE_SIZE,

  _SC_LEVEL1_DCACHE_ASSOC,

  _SC_LEVEL1_DCACHE_LINESIZE,

  _SC_LEVEL2_CACHE_SIZE,

  _SC_LEVEL2_CACHE_ASSOC,

  _SC_LEVEL2_CACHE_LINESIZE,

  _SC_LEVEL3_CACHE_SIZE,

  _SC_LEVEL3_CACHE_ASSOC,

  _SC_LEVEL3_CACHE_LINESIZE,

  _SC_LEVEL4_CACHE_SIZE,

  _SC_LEVEL4_CACHE_ASSOC,

  _SC_LEVEL4_CACHE_LINESIZE,

  _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

  _SC_RAW_SOCKETS,

  _SC_V7_ILP32_OFF32,

  _SC_V7_ILP32_OFFBIG,

  _SC_V7_LP64_OFF64,

  _SC_V7_LPBIG_OFFBIG,

  _SC_SS_REPL_MAX,

  _SC_TRACE_EVENT_NAME_MAX,

  _SC_TRACE_NAME_MAX,

  _SC_TRACE_SYS_MAX,

  _SC_TRACE_USER_EVENT_MAX,

  _SC_XOPEN_STREAMS,

  _SC_THREAD_ROBUST_PRIO_INHERIT,

  _SC_THREAD_ROBUST_PRIO_PROTECT,

  _SC_MINSIGSTKSZ,

  _SC_SIGSTKSZ

};

enum {
  _CS_PATH,

  _CS_V6_WIDTH_RESTRICTED_ENVS,

  _CS_GNU_LIBC_VERSION,

  _CS_GNU_LIBPTHREAD_VERSION,

  _CS_V5_WIDTH_RESTRICTED_ENVS,

  _CS_V7_WIDTH_RESTRICTED_ENVS,

  _CS_LFS_CFLAGS = 1000,

  _CS_LFS_LDFLAGS,

  _CS_LFS_LIBS,

  _CS_LFS_LINTFLAGS,

  _CS_LFS64_CFLAGS,

  _CS_LFS64_LDFLAGS,

  _CS_LFS64_LIBS,

  _CS_LFS64_LINTFLAGS,

  _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

  _CS_XBS5_ILP32_OFF32_LDFLAGS,

  _CS_XBS5_ILP32_OFF32_LIBS,

  _CS_XBS5_ILP32_OFF32_LINTFLAGS,

  _CS_XBS5_ILP32_OFFBIG_CFLAGS,

  _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

  _CS_XBS5_ILP32_OFFBIG_LIBS,

  _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

  _CS_XBS5_LP64_OFF64_CFLAGS,

  _CS_XBS5_LP64_OFF64_LDFLAGS,

  _CS_XBS5_LP64_OFF64_LIBS,

  _CS_XBS5_LP64_OFF64_LINTFLAGS,

  _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

  _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

  _CS_XBS5_LPBIG_OFFBIG_LIBS,

  _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,

  _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

  _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

  _CS_POSIX_V6_ILP32_OFF32_LIBS,

  _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

  _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

  _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

  _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

  _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

  _CS_POSIX_V6_LP64_OFF64_CFLAGS,

  _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

  _CS_POSIX_V6_LP64_OFF64_LIBS,

  _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

  _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

  _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

  _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

  _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,

  _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

  _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

  _CS_POSIX_V7_ILP32_OFF32_LIBS,

  _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

  _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

  _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

  _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

  _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

  _CS_POSIX_V7_LP64_OFF64_CFLAGS,

  _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

  _CS_POSIX_V7_LP64_OFF64_LIBS,

  _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

  _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

  _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

  _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

  _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,

  _CS_V6_ENV,

  _CS_V7_ENV

};
# 631 "/usr/include/unistd.h" 2 3 4

extern long int pathconf(const char *__path, int __name) noexcept(true)
    __attribute__((__nonnull__(1)));

extern long int fpathconf(int __fd, int __name) noexcept(true);

extern long int sysconf(int __name) noexcept(true);

extern size_t confstr(int __name, char *__buf, size_t __len) noexcept(true);

extern __pid_t getpid(void) noexcept(true);

extern __pid_t getppid(void) noexcept(true);

extern __pid_t getpgrp(void) noexcept(true);

extern __pid_t __getpgid(__pid_t __pid) noexcept(true);

extern __pid_t getpgid(__pid_t __pid) noexcept(true);

extern int setpgid(__pid_t __pid, __pid_t __pgid) noexcept(true);
# 682 "/usr/include/unistd.h" 3 4
extern int setpgrp(void) noexcept(true);

extern __pid_t setsid(void) noexcept(true);

extern __pid_t getsid(__pid_t __pid) noexcept(true);

extern __uid_t getuid(void) noexcept(true);

extern __uid_t geteuid(void) noexcept(true);

extern __gid_t getgid(void) noexcept(true);

extern __gid_t getegid(void) noexcept(true);

extern int getgroups(int __size, __gid_t __list[]) noexcept(true);

extern int group_member(__gid_t __gid) noexcept(true);

extern int setuid(__uid_t __uid) noexcept(true);

extern int setreuid(__uid_t __ruid, __uid_t __euid) noexcept(true);

extern int seteuid(__uid_t __uid) noexcept(true);

extern int setgid(__gid_t __gid) noexcept(true);

extern int setregid(__gid_t __rgid, __gid_t __egid) noexcept(true);

extern int setegid(__gid_t __gid) noexcept(true);

extern int getresuid(__uid_t *__ruid, __uid_t *__euid,
                     __uid_t *__suid) noexcept(true);

extern int getresgid(__gid_t *__rgid, __gid_t *__egid,
                     __gid_t *__sgid) noexcept(true);

extern int setresuid(__uid_t __ruid, __uid_t __euid,
                     __uid_t __suid) noexcept(true);

extern int setresgid(__gid_t __rgid, __gid_t __egid,
                     __gid_t __sgid) noexcept(true);

extern __pid_t fork(void) noexcept(true);

extern __pid_t vfork(void) noexcept(true);

extern __pid_t _Fork(void) noexcept(true);

extern char *ttyname(int __fd) noexcept(true);

extern int ttyname_r(int __fd, char *__buf, size_t __buflen) noexcept(true)
    __attribute__((__nonnull__(2)));

extern int isatty(int __fd) noexcept(true);

extern int ttyslot(void) noexcept(true);

extern int link(const char *__from, const char *__to) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int linkat(int __fromfd, const char *__from, int __tofd,
                  const char *__to, int __flags) noexcept(true)
    __attribute__((__nonnull__(2, 4)));

extern int symlink(const char *__from, const char *__to) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern ssize_t readlink(const char *__restrict __path, char *__restrict __buf,
                        size_t __len) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern int symlinkat(const char *__from, int __tofd,
                     const char *__to) noexcept(true)
    __attribute__((__nonnull__(1, 3)));

extern ssize_t readlinkat(int __fd, const char *__restrict __path,
                          char *__restrict __buf, size_t __len) noexcept(true)
    __attribute__((__nonnull__(2, 3)));

extern int unlink(const char *__name) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int unlinkat(int __fd, const char *__name, int __flag) noexcept(true)
    __attribute__((__nonnull__(2)));

extern int rmdir(const char *__path) noexcept(true)
    __attribute__((__nonnull__(1)));

extern __pid_t tcgetpgrp(int __fd) noexcept(true);

extern int tcsetpgrp(int __fd, __pid_t __pgrp_id) noexcept(true);

extern char *getlogin(void);

extern int getlogin_r(char *__name, size_t __name_len)
    __attribute__((__nonnull__(1)));

extern int setlogin(const char *__name) noexcept(true)
    __attribute__((__nonnull__(1)));

# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern "C" {

extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;

extern int opterr;

extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt(int ___argc, char *const *___argv,
                  const char *__shortopts) noexcept(true)
    __attribute__((__nonnull__(2, 3)));
}
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4

extern "C" {
# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
}
# 904 "/usr/include/unistd.h" 2 3 4

extern int gethostname(char *__name, size_t __len) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int sethostname(const char *__name, size_t __len) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int sethostid(long int __id) noexcept(true);

extern int getdomainname(char *__name, size_t __len) noexcept(true)
    __attribute__((__nonnull__(1)));
extern int setdomainname(const char *__name, size_t __len) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int vhangup(void) noexcept(true);

extern int revoke(const char *__file) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int profil(unsigned short int *__sample_buffer, size_t __size,
                  size_t __offset, unsigned int __scale) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int acct(const char *__name) noexcept(true);

extern char *getusershell(void) noexcept(true);
extern void endusershell(void) noexcept(true);
extern void setusershell(void) noexcept(true);

extern int daemon(int __nochdir, int __noclose) noexcept(true);

extern int chroot(const char *__path) noexcept(true)
    __attribute__((__nonnull__(1)));

extern char *getpass(const char *__prompt) __attribute__((__nonnull__(1)));

extern int fsync(int __fd);

extern int syncfs(int __fd) noexcept(true);

extern long int gethostid(void);

extern void sync(void) noexcept(true);

extern int getpagesize(void) noexcept(true) __attribute__((__const__));

extern int getdtablesize(void) noexcept(true);
# 1026 "/usr/include/unistd.h" 3 4
extern int truncate(const char *__file, __off_t __length) noexcept(true)
    __attribute__((__nonnull__(1)));
# 1038 "/usr/include/unistd.h" 3 4
extern int truncate64(const char *__file, __off64_t __length) noexcept(true)
    __attribute__((__nonnull__(1)));
# 1049 "/usr/include/unistd.h" 3 4
extern int ftruncate(int __fd, __off_t __length) noexcept(true);
# 1059 "/usr/include/unistd.h" 3 4
extern int ftruncate64(int __fd, __off64_t __length) noexcept(true);
# 1070 "/usr/include/unistd.h" 3 4
extern int brk(void *__addr) noexcept(true);

extern void *sbrk(intptr_t __delta) noexcept(true);
# 1091 "/usr/include/unistd.h" 3 4
extern long int syscall(long int __sysno, ...) noexcept(true);
# 1114 "/usr/include/unistd.h" 3 4
extern int lockf(int __fd, int __cmd, __off_t __len);
# 1124 "/usr/include/unistd.h" 3 4
extern int lockf64(int __fd, int __cmd, __off64_t __len);
# 1142 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range(int __infd, __off64_t *__pinoff, int __outfd,
                        __off64_t *__poutoff, size_t __length,
                        unsigned int __flags);

extern int fdatasync(int __fildes);
# 1162 "/usr/include/unistd.h" 3 4
extern char *crypt(const char *__key, const char *__salt) noexcept(true)
    __attribute__((__nonnull__(1, 2)));

extern void swab(const void *__restrict __from, void *__restrict __to,
                 ssize_t __n) noexcept(true) __attribute__((__nonnull__(1, 2)))

;
# 1201 "/usr/include/unistd.h" 3 4
int getentropy(void *__buffer, size_t __length);
# 1211 "/usr/include/unistd.h" 3 4
extern int close_range(unsigned int __fd, unsigned int __max_fd,
                       int __flags) noexcept(true);
# 1221 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid(void) noexcept(true);

# 1 "/usr/include/linux/close_range.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 2 3 4
# 1222 "/usr/include/unistd.h" 2 3 4
}
# 46 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_wait.h" 2 3
# 1 "/usr/include/syscall.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/syscall.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/syscall.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/unistd.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/asm/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/unistd_64.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/asm/unistd.h" 2 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/syscall.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/syscall.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/syscall.h" 2 3 4
# 2 "/usr/include/syscall.h" 2 3 4
# 47 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_wait.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_mutex.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_mutex.h" 3
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_mutex.h" 3
namespace std __attribute__((__visibility__("default"))) {
# 59 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_mutex.h" 3
  class __mutex_base {
  protected:
    typedef __gthread_mutex_t __native_type;

    __native_type _M_mutex = {
        {0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, 0, {0, 0}}};

    constexpr __mutex_base() noexcept = default;
# 80 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_mutex.h" 3
    __mutex_base(const __mutex_base &) = delete;
    __mutex_base &operator=(const __mutex_base &) = delete;
  };
# 96 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_mutex.h" 3
  class mutex : private __mutex_base {
  public:
    typedef __native_type *native_handle_type;

    constexpr

        mutex() noexcept = default;
    ~mutex() = default;

    mutex(const mutex &) = delete;
    mutex &operator=(const mutex &) = delete;

    void lock() {
      int __e = __gthread_mutex_lock(&_M_mutex);

      if (__e)
        __throw_system_error(__e);
    }

    [[__nodiscard__]]
    bool try_lock() noexcept {

      return !__gthread_mutex_trylock(&_M_mutex);
    }

    void unlock() { __gthread_mutex_unlock(&_M_mutex); }

    native_handle_type native_handle() noexcept { return &_M_mutex; }
  };

  class __condvar {
    using timespec = __gthread_time_t;

  public:
    __condvar() noexcept {}

    ~__condvar() {
      int __e __attribute__((__unused__)) = __gthread_cond_destroy(&_M_cond);
      do {
        if (std::__is_constant_evaluated() && !bool(__e != 16))
          __builtin_unreachable();
      } while (false);
    }

    __condvar(const __condvar &) = delete;
    __condvar &operator=(const __condvar &) = delete;

    __gthread_cond_t *native_handle() noexcept { return &_M_cond; }

    void wait(mutex &__m) {
      int __e __attribute__((__unused__)) =
          __gthread_cond_wait(&_M_cond, __m.native_handle());
      do {
        if (std::__is_constant_evaluated() && !bool(__e == 0))
          __builtin_unreachable();
      } while (false);
    }

    void wait_until(mutex &__m, timespec &__abs_time) {
      __gthread_cond_timedwait(&_M_cond, __m.native_handle(), &__abs_time);
    }

    void wait_until(mutex &__m, clockid_t __clock, timespec &__abs_time) {
      pthread_cond_clockwait(&_M_cond, __m.native_handle(), __clock,
                             &__abs_time);
    }

    void notify_one() noexcept {
      int __e __attribute__((__unused__)) = __gthread_cond_signal(&_M_cond);
      do {
        if (std::__is_constant_evaluated() && !bool(__e == 0))
          __builtin_unreachable();
      } while (false);
    }

    void notify_all() noexcept {
      int __e __attribute__((__unused__)) = __gthread_cond_broadcast(&_M_cond);
      do {
        if (std::__is_constant_evaluated() && !bool(__e == 0))
          __builtin_unreachable();
      } while (false);
    }

  protected:
    __gthread_cond_t _M_cond = {{{0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0}}};
  };

  struct defer_lock_t {
    explicit defer_lock_t() = default;
  };

  struct try_to_lock_t {
    explicit try_to_lock_t() = default;
  };

  struct adopt_lock_t {
    explicit adopt_lock_t() = default;
  };

  inline constexpr defer_lock_t defer_lock{};

  inline constexpr try_to_lock_t try_to_lock{};

  inline constexpr adopt_lock_t adopt_lock{};
# 242 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_mutex.h" 3
  template <typename _Mutex> class lock_guard {
  public:
    typedef _Mutex mutex_type;

    explicit lock_guard(mutex_type &__m) : _M_device(__m) { _M_device.lock(); }

    lock_guard(mutex_type &__m, adopt_lock_t) noexcept : _M_device(__m) {}

    ~lock_guard() { _M_device.unlock(); }

    lock_guard(const lock_guard &) = delete;
    lock_guard &operator=(const lock_guard &) = delete;

  private:
    mutex_type &_M_device;
  };

} // namespace std
# 51 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_wait.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  namespace __detail {

  using __platform_wait_t = int;
  inline constexpr size_t __platform_wait_alignment = 4;
# 76 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_wait.h" 3
  } // namespace __detail

  template <typename _Tp>
  inline constexpr bool __platform_wait_uses_type

      = is_scalar_v<_Tp> &&
        ((sizeof(_Tp) == sizeof(__detail::__platform_wait_t)) &&
         (alignof(_Tp *) >= __detail::__platform_wait_alignment));

  namespace __detail {

  enum class __futex_wait_flags : int {

    __private_flag = 0,

    __wait = 0,
    __wake = 1,
    __wait_bitset = 9,
    __wake_bitset = 10,
    __wait_private = __wait | __private_flag,
    __wake_private = __wake | __private_flag,
    __wait_bitset_private = __wait_bitset | __private_flag,
    __wake_bitset_private = __wake_bitset | __private_flag,
    __bitset_match_any = -1
  };

  template <typename _Tp>
  void __platform_wait(const _Tp *__addr, __platform_wait_t __val) noexcept {
    auto __e = syscall(202, static_cast<const void *>(__addr),
                       static_cast<int>(__futex_wait_flags::__wait_private),
                       __val, nullptr);
    if (!__e || (*__errno_location()) == 11)
      return;
    if ((*__errno_location()) != 4)
      __throw_system_error((*__errno_location()));
  }

  template <typename _Tp>
  void __platform_notify(const _Tp *__addr, bool __all) noexcept {
    syscall(202, static_cast<const void *>(__addr),
            static_cast<int>(__futex_wait_flags::__wake_private),
            __all ? 2147483647 : 1);
  }

  inline void __thread_yield() noexcept { __gthread_yield(); }

  inline void __thread_relax() noexcept { __builtin_ia32_pause(); }

  inline constexpr auto __atomic_spin_count_relax = 12;
  inline constexpr auto __atomic_spin_count = 16;

  struct __default_spin_policy {
    bool operator()() const noexcept { return false; }
  };

  template <typename _Pred, typename _Spin = __default_spin_policy>
  bool __atomic_spin(_Pred &__pred, _Spin __spin = _Spin{}) noexcept {
    for (auto __i = 0; __i < __atomic_spin_count; ++__i) {
      if (__pred())
        return true;

      if (__i < __atomic_spin_count_relax)
        __detail::__thread_relax();
      else
        __detail::__thread_yield();
    }

    while (__spin()) {
      if (__pred())
        return true;
    }

    return false;
  }

  template <typename _Tp>
  bool __atomic_compare(const _Tp &__a, const _Tp &__b) {

    return __builtin_memcmp(&__a, &__b, sizeof(_Tp)) == 0;
  }

  struct __waiter_pool_base {

    static constexpr auto _S_align = 64;

    alignas(_S_align) __platform_wait_t _M_wait = 0;

    alignas(_S_align) __platform_wait_t _M_ver = 0;

    __waiter_pool_base() = default;

    void _M_enter_wait() noexcept { __atomic_fetch_add(&_M_wait, 1, 5); }

    void _M_leave_wait() noexcept { __atomic_fetch_sub(&_M_wait, 1, 3); }

    bool _M_waiting() const noexcept {
      __platform_wait_t __res;
      __atomic_load(&_M_wait, &__res, 5);
      return __res != 0;
    }

    void _M_notify(__platform_wait_t *__addr, [[maybe_unused]] bool __all,
                   bool __bare) noexcept {

      if (__addr == &_M_ver) {
        __atomic_fetch_add(__addr, 1, 5);
        __all = true;
      }

      if (__bare || _M_waiting())
        __platform_notify(__addr, __all);
# 249 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_wait.h" 3
    }

    static __waiter_pool_base &_S_for(const void *__addr) noexcept {
      constexpr uintptr_t __ct = 16;
      static __waiter_pool_base __w[__ct];
      auto __key = (uintptr_t(__addr) >> 2) % __ct;
      return __w[__key];
    }
  };

  struct __waiter_pool : __waiter_pool_base {
    void _M_do_wait(const __platform_wait_t *__addr,
                    __platform_wait_t __old) noexcept {

      __platform_wait(__addr, __old);
# 279 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_wait.h" 3
    }
  };

  template <typename _Tp> struct __waiter_base {
    using __waiter_type = _Tp;

    __waiter_type &_M_w;
    __platform_wait_t *_M_addr;

    template <typename _Up>
    static __platform_wait_t *_S_wait_addr(const _Up *__a,
                                           __platform_wait_t *__b) {
      if constexpr (__platform_wait_uses_type<_Up>)
        return reinterpret_cast<__platform_wait_t *>(const_cast<_Up *>(__a));
      else
        return __b;
    }

    static __waiter_type &_S_for(const void *__addr) noexcept {
      static_assert(sizeof(__waiter_type) == sizeof(__waiter_pool_base));
      auto &res = __waiter_pool_base::_S_for(__addr);
      return reinterpret_cast<__waiter_type &>(res);
    }

    template <typename _Up>
    explicit __waiter_base(const _Up *__addr) noexcept
        : _M_w(_S_for(__addr)), _M_addr(_S_wait_addr(__addr, &_M_w._M_ver)) {}

    void _M_notify(bool __all, bool __bare = false) noexcept {
      _M_w._M_notify(_M_addr, __all, __bare);
    }

    template <typename _Up, typename _ValFn,
              typename _Spin = __default_spin_policy>
    static bool _S_do_spin_v(__platform_wait_t *__addr, const _Up &__old,
                             _ValFn __vfn, __platform_wait_t &__val,
                             _Spin __spin = _Spin{}) {
      auto const __pred = [=] {
        return !__detail::__atomic_compare(__old, __vfn());
      };

      if constexpr (__platform_wait_uses_type<_Up>) {
        __builtin_memcpy(&__val, &__old, sizeof(__val));
      } else {
        __atomic_load(__addr, &__val, 2);
      }
      return __atomic_spin(__pred, __spin);
    }

    template <typename _Up, typename _ValFn,
              typename _Spin = __default_spin_policy>
    bool _M_do_spin_v(const _Up &__old, _ValFn __vfn, __platform_wait_t &__val,
                      _Spin __spin = _Spin{}) {
      return _S_do_spin_v(_M_addr, __old, __vfn, __val, __spin);
    }

    template <typename _Pred, typename _Spin = __default_spin_policy>
    static bool _S_do_spin(const __platform_wait_t *__addr, _Pred __pred,
                           __platform_wait_t &__val, _Spin __spin = _Spin{}) {
      __atomic_load(__addr, &__val, 2);
      return __atomic_spin(__pred, __spin);
    }

    template <typename _Pred, typename _Spin = __default_spin_policy>
    bool _M_do_spin(_Pred __pred, __platform_wait_t &__val,
                    _Spin __spin = _Spin{}) {
      return _S_do_spin(_M_addr, __pred, __val, __spin);
    }
  };

  template <typename _EntersWait>
  struct __waiter : __waiter_base<__waiter_pool> {
    using __base_type = __waiter_base<__waiter_pool>;

    template <typename _Tp>
    explicit __waiter(const _Tp *__addr) noexcept : __base_type(__addr) {
      if constexpr (_EntersWait::value)
        _M_w._M_enter_wait();
    }

    ~__waiter() {
      if constexpr (_EntersWait::value)
        _M_w._M_leave_wait();
    }

    template <typename _Tp, typename _ValFn>
    void _M_do_wait_v(_Tp __old, _ValFn __vfn) {
      do {
        __platform_wait_t __val;
        if (__base_type::_M_do_spin_v(__old, __vfn, __val))
          return;
        __base_type::_M_w._M_do_wait(__base_type::_M_addr, __val);
      } while (__detail::__atomic_compare(__old, __vfn()));
    }

    template <typename _Pred> void _M_do_wait(_Pred __pred) noexcept {
      do {
        __platform_wait_t __val;
        if (__base_type::_M_do_spin(__pred, __val))
          return;
        __base_type::_M_w._M_do_wait(__base_type::_M_addr, __val);
      } while (!__pred());
    }
  };

  using __enters_wait = __waiter<std::true_type>;
  using __bare_wait = __waiter<std::false_type>;
  } // namespace __detail

  template <typename _Tp, typename _ValFn>
  void __atomic_wait_address_v(const _Tp *__addr, _Tp __old,
                               _ValFn __vfn) noexcept {
    __detail::__enters_wait __w(__addr);
    __w._M_do_wait_v(__old, __vfn);
  }

  template <typename _Tp, typename _Pred>
  void __atomic_wait_address(const _Tp *__addr, _Pred __pred) noexcept {
    __detail::__enters_wait __w(__addr);
    __w._M_do_wait(__pred);
  }

  template <typename _Pred>
  void __atomic_wait_address_bare(const __detail::__platform_wait_t *__addr,
                                  _Pred __pred) noexcept {

    do {
      __detail::__platform_wait_t __val;
      if (__detail::__bare_wait::_S_do_spin(__addr, __pred, __val))
        return;
      __detail::__platform_wait(__addr, __val);
    } while (!__pred());
  }

  template <typename _Tp>
  void __atomic_notify_address(const _Tp *__addr, bool __all) noexcept {
    __detail::__bare_wait __w(__addr);
    __w._M_notify(__all);
  }

  inline void __atomic_notify_address_bare(
      const __detail::__platform_wait_t *__addr, bool __all) noexcept {

    __detail::__platform_notify(__addr, __all);
  }

} // namespace std
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_base.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 62 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_base.h" 3
  enum class memory_order : int {
    relaxed,
    consume,
    acquire,
    release,
    acq_rel,
    seq_cst
  };

  inline constexpr memory_order memory_order_relaxed = memory_order::relaxed;
  inline constexpr memory_order memory_order_consume = memory_order::consume;
  inline constexpr memory_order memory_order_acquire = memory_order::acquire;
  inline constexpr memory_order memory_order_release = memory_order::release;
  inline constexpr memory_order memory_order_acq_rel = memory_order::acq_rel;
  inline constexpr memory_order memory_order_seq_cst = memory_order::seq_cst;
# 91 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_base.h" 3
  enum __memory_order_modifier {
    __memory_order_mask = 0x0ffff,
    __memory_order_modifier_mask = 0xffff0000,
    __memory_order_hle_acquire = 0x10000,
    __memory_order_hle_release = 0x20000
  };

  constexpr memory_order operator|(memory_order __m,
                                   __memory_order_modifier __mod) {
    return memory_order(int(__m) | int(__mod));
  }

  constexpr memory_order operator&(memory_order __m,
                                   __memory_order_modifier __mod) {
    return memory_order(int(__m) & int(__mod));
  }

  constexpr memory_order __cmpexch_failure_order2(memory_order __m) noexcept {
    return __m == memory_order_acq_rel   ? memory_order_acquire
           : __m == memory_order_release ? memory_order_relaxed
                                         : __m;
  }

  constexpr memory_order __cmpexch_failure_order(memory_order __m) noexcept {
    return memory_order(
        __cmpexch_failure_order2(__m & __memory_order_mask) |
        __memory_order_modifier(__m & __memory_order_modifier_mask));
  }

  constexpr bool __is_valid_cmpexch_failure_order(memory_order __m) noexcept {
    return (__m & __memory_order_mask) != memory_order_release &&
           (__m & __memory_order_mask) != memory_order_acq_rel;
  }

  template <typename _IntTp> struct __atomic_base;

  inline __attribute__((__always_inline__)) void atomic_thread_fence(
      memory_order __m) noexcept {
    __atomic_thread_fence(int(__m));
  }

  inline __attribute__((__always_inline__)) void atomic_signal_fence(
      memory_order __m) noexcept {
    __atomic_signal_fence(int(__m));
  }

  template <typename _Tp> inline _Tp kill_dependency(_Tp __y) noexcept {
    _Tp __ret(__y);
    return __ret;
  }
# 173 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_base.h" 3
  template <typename _Tp> struct atomic;

  template <typename _Tp> struct atomic<_Tp *>;

  typedef bool __atomic_flag_data_type;
# 198 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_base.h" 3
  extern "C" {

  struct __atomic_flag_base {
    __atomic_flag_data_type _M_i = {};
  };
  }

  struct atomic_flag : public __atomic_flag_base {
    atomic_flag() noexcept = default;
    ~atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag &) = delete;
    atomic_flag &operator=(const atomic_flag &) = delete;
    atomic_flag &operator=(const atomic_flag &) volatile = delete;

    constexpr atomic_flag(bool __i) noexcept
        : __atomic_flag_base{_S_init(__i)} {}

    inline __attribute__((__always_inline__)) bool
    test_and_set(memory_order __m = memory_order_seq_cst) noexcept {
      return __atomic_test_and_set(&_M_i, int(__m));
    }

    inline __attribute__((__always_inline__)) bool
    test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept {
      return __atomic_test_and_set(&_M_i, int(__m));
    }

    inline __attribute__((__always_inline__)) bool
    test(memory_order __m = memory_order_seq_cst) const noexcept {
      __atomic_flag_data_type __v;
      __atomic_load(&_M_i, &__v, int(__m));
      return __v == 1;
    }

    inline __attribute__((__always_inline__)) bool
    test(memory_order __m = memory_order_seq_cst) const volatile noexcept {
      __atomic_flag_data_type __v;
      __atomic_load(&_M_i, &__v, int(__m));
      return __v == 1;
    }

    inline __attribute__((__always_inline__)) void
    wait(bool __old, memory_order __m = memory_order_seq_cst) const noexcept {
      const __atomic_flag_data_type __v = __old ? 1 : 0;

      std::__atomic_wait_address_v(
          &_M_i, __v, [__m, this] { return __atomic_load_n(&_M_i, int(__m)); });
    }

    inline __attribute__((__always_inline__)) void notify_one() noexcept {
      std::__atomic_notify_address(&_M_i, false);
    }

    inline __attribute__((__always_inline__)) void notify_all() noexcept {
      std::__atomic_notify_address(&_M_i, true);
    }

    inline __attribute__((__always_inline__)) void
    clear(memory_order __m = memory_order_seq_cst) noexcept {
      memory_order __b __attribute__((__unused__)) = __m & __memory_order_mask;
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_consume))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_acquire))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_acq_rel))
          __builtin_unreachable();
      } while (false);

      __atomic_clear(&_M_i, int(__m));
    }

    inline __attribute__((__always_inline__)) void
    clear(memory_order __m = memory_order_seq_cst) volatile noexcept {
      memory_order __b __attribute__((__unused__)) = __m & __memory_order_mask;
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_consume))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_acquire))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_acq_rel))
          __builtin_unreachable();
      } while (false);

      __atomic_clear(&_M_i, int(__m));
    }

  private:
    static constexpr __atomic_flag_data_type _S_init(bool __i) {
      return __i ? 1 : 0;
    }
  };
# 340 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_base.h" 3
  template <typename _ITp> struct __atomic_base {
    using value_type = _ITp;
    using difference_type = value_type;

  private:
    typedef _ITp __int_type;

    static constexpr int _S_alignment = sizeof(_ITp) > alignof(_ITp)
                                            ? sizeof(_ITp)
                                            : alignof(_ITp);

    alignas(_S_alignment) __int_type _M_i = 0;

  public:
    __atomic_base() noexcept = default;
    ~__atomic_base() noexcept = default;
    __atomic_base(const __atomic_base &) = delete;
    __atomic_base &operator=(const __atomic_base &) = delete;
    __atomic_base &operator=(const __atomic_base &) volatile = delete;

    constexpr __atomic_base(__int_type __i) noexcept : _M_i(__i) {}

    operator __int_type() const noexcept { return load(); }

    operator __int_type() const volatile noexcept { return load(); }

    __int_type operator=(__int_type __i) noexcept {
      store(__i);
      return __i;
    }

    __int_type operator=(__int_type __i) volatile noexcept {
      store(__i);
      return __i;
    }

    __int_type operator++(int) noexcept { return fetch_add(1); }

    __int_type operator++(int) volatile noexcept { return fetch_add(1); }

    __int_type operator--(int) noexcept { return fetch_sub(1); }

    __int_type operator--(int) volatile noexcept { return fetch_sub(1); }

    __int_type operator++() noexcept {
      return __atomic_add_fetch(&_M_i, 1, int(memory_order_seq_cst));
    }

    __int_type operator++() volatile noexcept {
      return __atomic_add_fetch(&_M_i, 1, int(memory_order_seq_cst));
    }

    __int_type operator--() noexcept {
      return __atomic_sub_fetch(&_M_i, 1, int(memory_order_seq_cst));
    }

    __int_type operator--() volatile noexcept {
      return __atomic_sub_fetch(&_M_i, 1, int(memory_order_seq_cst));
    }

    __int_type operator+=(__int_type __i) noexcept {
      return __atomic_add_fetch(&_M_i, __i, int(memory_order_seq_cst));
    }

    __int_type operator+=(__int_type __i) volatile noexcept {
      return __atomic_add_fetch(&_M_i, __i, int(memory_order_seq_cst));
    }

    __int_type operator-=(__int_type __i) noexcept {
      return __atomic_sub_fetch(&_M_i, __i, int(memory_order_seq_cst));
    }

    __int_type operator-=(__int_type __i) volatile noexcept {
      return __atomic_sub_fetch(&_M_i, __i, int(memory_order_seq_cst));
    }

    __int_type operator&=(__int_type __i) noexcept {
      return __atomic_and_fetch(&_M_i, __i, int(memory_order_seq_cst));
    }

    __int_type operator&=(__int_type __i) volatile noexcept {
      return __atomic_and_fetch(&_M_i, __i, int(memory_order_seq_cst));
    }

    __int_type operator|=(__int_type __i) noexcept {
      return __atomic_or_fetch(&_M_i, __i, int(memory_order_seq_cst));
    }

    __int_type operator|=(__int_type __i) volatile noexcept {
      return __atomic_or_fetch(&_M_i, __i, int(memory_order_seq_cst));
    }

    __int_type operator^=(__int_type __i) noexcept {
      return __atomic_xor_fetch(&_M_i, __i, int(memory_order_seq_cst));
    }

    __int_type operator^=(__int_type __i) volatile noexcept {
      return __atomic_xor_fetch(&_M_i, __i, int(memory_order_seq_cst));
    }

    bool is_lock_free() const noexcept {

      return __atomic_is_lock_free(sizeof(_M_i),
                                   reinterpret_cast<void *>(-_S_alignment));
    }

    bool is_lock_free() const volatile noexcept {

      return __atomic_is_lock_free(sizeof(_M_i),
                                   reinterpret_cast<void *>(-_S_alignment));
    }

    inline __attribute__((__always_inline__)) void
    store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept {
      memory_order __b __attribute__((__unused__)) = __m & __memory_order_mask;
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_acquire))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_acq_rel))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_consume))
          __builtin_unreachable();
      } while (false);

      __atomic_store_n(&_M_i, __i, int(__m));
    }

    inline __attribute__((__always_inline__)) void
    store(__int_type __i,
          memory_order __m = memory_order_seq_cst) volatile noexcept {
      memory_order __b __attribute__((__unused__)) = __m & __memory_order_mask;
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_acquire))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_acq_rel))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_consume))
          __builtin_unreachable();
      } while (false);

      __atomic_store_n(&_M_i, __i, int(__m));
    }

    inline __attribute__((__always_inline__)) __int_type
    load(memory_order __m = memory_order_seq_cst) const noexcept {
      memory_order __b __attribute__((__unused__)) = __m & __memory_order_mask;
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_release))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_acq_rel))
          __builtin_unreachable();
      } while (false);

      return __atomic_load_n(&_M_i, int(__m));
    }

    inline __attribute__((__always_inline__)) __int_type
    load(memory_order __m = memory_order_seq_cst) const volatile noexcept {
      memory_order __b __attribute__((__unused__)) = __m & __memory_order_mask;
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_release))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_acq_rel))
          __builtin_unreachable();
      } while (false);

      return __atomic_load_n(&_M_i, int(__m));
    }

    inline __attribute__((__always_inline__)) __int_type
    exchange(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept {
      return __atomic_exchange_n(&_M_i, __i, int(__m));
    }

    inline __attribute__((__always_inline__)) __int_type
    exchange(__int_type __i,
             memory_order __m = memory_order_seq_cst) volatile noexcept {
      return __atomic_exchange_n(&_M_i, __i, int(__m));
    }

    inline __attribute__((__always_inline__)) bool
    compare_exchange_weak(__int_type &__i1, __int_type __i2, memory_order __m1,
                          memory_order __m2) noexcept {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__is_valid_cmpexch_failure_order(__m2)))
          __builtin_unreachable();
      } while (false);

      return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, int(__m1),
                                         int(__m2));
    }

    inline __attribute__((__always_inline__)) bool
    compare_exchange_weak(__int_type &__i1, __int_type __i2, memory_order __m1,
                          memory_order __m2) volatile noexcept {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__is_valid_cmpexch_failure_order(__m2)))
          __builtin_unreachable();
      } while (false);

      return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, int(__m1),
                                         int(__m2));
    }

    inline __attribute__((__always_inline__)) bool
    compare_exchange_weak(__int_type &__i1, __int_type __i2,
                          memory_order __m = memory_order_seq_cst) noexcept {
      return compare_exchange_weak(__i1, __i2, __m,
                                   __cmpexch_failure_order(__m));
    }

    inline __attribute__((__always_inline__)) bool compare_exchange_weak(
        __int_type &__i1, __int_type __i2,
        memory_order __m = memory_order_seq_cst) volatile noexcept {
      return compare_exchange_weak(__i1, __i2, __m,
                                   __cmpexch_failure_order(__m));
    }

    inline __attribute__((__always_inline__)) bool
    compare_exchange_strong(__int_type &__i1, __int_type __i2,
                            memory_order __m1, memory_order __m2) noexcept {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__is_valid_cmpexch_failure_order(__m2)))
          __builtin_unreachable();
      } while (false);

      return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, int(__m1),
                                         int(__m2));
    }

    inline __attribute__((__always_inline__)) bool
    compare_exchange_strong(__int_type &__i1, __int_type __i2,
                            memory_order __m1,
                            memory_order __m2) volatile noexcept {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__is_valid_cmpexch_failure_order(__m2)))
          __builtin_unreachable();
      } while (false);

      return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, int(__m1),
                                         int(__m2));
    }

    inline __attribute__((__always_inline__)) bool
    compare_exchange_strong(__int_type &__i1, __int_type __i2,
                            memory_order __m = memory_order_seq_cst) noexcept {
      return compare_exchange_strong(__i1, __i2, __m,
                                     __cmpexch_failure_order(__m));
    }

    inline __attribute__((__always_inline__)) bool compare_exchange_strong(
        __int_type &__i1, __int_type __i2,
        memory_order __m = memory_order_seq_cst) volatile noexcept {
      return compare_exchange_strong(__i1, __i2, __m,
                                     __cmpexch_failure_order(__m));
    }

    inline __attribute__((__always_inline__)) void
    wait(__int_type __old,
         memory_order __m = memory_order_seq_cst) const noexcept {
      std::__atomic_wait_address_v(&_M_i, __old,
                                   [__m, this] { return this->load(__m); });
    }

    inline __attribute__((__always_inline__)) void notify_one() noexcept {
      std::__atomic_notify_address(&_M_i, false);
    }

    inline __attribute__((__always_inline__)) void notify_all() noexcept {
      std::__atomic_notify_address(&_M_i, true);
    }

    inline __attribute__((__always_inline__)) __int_type fetch_add(
        __int_type __i, memory_order __m = memory_order_seq_cst) noexcept {
      return __atomic_fetch_add(&_M_i, __i, int(__m));
    }

    inline __attribute__((__always_inline__)) __int_type
    fetch_add(__int_type __i,
              memory_order __m = memory_order_seq_cst) volatile noexcept {
      return __atomic_fetch_add(&_M_i, __i, int(__m));
    }

    inline __attribute__((__always_inline__)) __int_type fetch_sub(
        __int_type __i, memory_order __m = memory_order_seq_cst) noexcept {
      return __atomic_fetch_sub(&_M_i, __i, int(__m));
    }

    inline __attribute__((__always_inline__)) __int_type
    fetch_sub(__int_type __i,
              memory_order __m = memory_order_seq_cst) volatile noexcept {
      return __atomic_fetch_sub(&_M_i, __i, int(__m));
    }

    inline __attribute__((__always_inline__)) __int_type fetch_and(
        __int_type __i, memory_order __m = memory_order_seq_cst) noexcept {
      return __atomic_fetch_and(&_M_i, __i, int(__m));
    }

    inline __attribute__((__always_inline__)) __int_type
    fetch_and(__int_type __i,
              memory_order __m = memory_order_seq_cst) volatile noexcept {
      return __atomic_fetch_and(&_M_i, __i, int(__m));
    }

    inline __attribute__((__always_inline__)) __int_type
    fetch_or(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept {
      return __atomic_fetch_or(&_M_i, __i, int(__m));
    }

    inline __attribute__((__always_inline__)) __int_type
    fetch_or(__int_type __i,
             memory_order __m = memory_order_seq_cst) volatile noexcept {
      return __atomic_fetch_or(&_M_i, __i, int(__m));
    }

    inline __attribute__((__always_inline__)) __int_type fetch_xor(
        __int_type __i, memory_order __m = memory_order_seq_cst) noexcept {
      return __atomic_fetch_xor(&_M_i, __i, int(__m));
    }

    inline __attribute__((__always_inline__)) __int_type
    fetch_xor(__int_type __i,
              memory_order __m = memory_order_seq_cst) volatile noexcept {
      return __atomic_fetch_xor(&_M_i, __i, int(__m));
    }
  };

  template <typename _PTp> struct __atomic_base<_PTp *> {
  private:
    typedef _PTp *__pointer_type;

    __pointer_type _M_p = nullptr;

    constexpr ptrdiff_t _M_type_size(ptrdiff_t __d) const {
      return __d * sizeof(_PTp);
    }

    constexpr ptrdiff_t _M_type_size(ptrdiff_t __d) const volatile {
      return __d * sizeof(_PTp);
    }

  public:
    __atomic_base() noexcept = default;
    ~__atomic_base() noexcept = default;
    __atomic_base(const __atomic_base &) = delete;
    __atomic_base &operator=(const __atomic_base &) = delete;
    __atomic_base &operator=(const __atomic_base &) volatile = delete;

    constexpr __atomic_base(__pointer_type __p) noexcept : _M_p(__p) {}

    operator __pointer_type() const noexcept { return load(); }

    operator __pointer_type() const volatile noexcept { return load(); }

    __pointer_type operator=(__pointer_type __p) noexcept {
      store(__p);
      return __p;
    }

    __pointer_type operator=(__pointer_type __p) volatile noexcept {
      store(__p);
      return __p;
    }

    __pointer_type operator++(int) noexcept { return fetch_add(1); }

    __pointer_type operator++(int) volatile noexcept { return fetch_add(1); }

    __pointer_type operator--(int) noexcept { return fetch_sub(1); }

    __pointer_type operator--(int) volatile noexcept { return fetch_sub(1); }

    __pointer_type operator++() noexcept {
      return __atomic_add_fetch(&_M_p, _M_type_size(1),
                                int(memory_order_seq_cst));
    }

    __pointer_type operator++() volatile noexcept {
      return __atomic_add_fetch(&_M_p, _M_type_size(1),
                                int(memory_order_seq_cst));
    }

    __pointer_type operator--() noexcept {
      return __atomic_sub_fetch(&_M_p, _M_type_size(1),
                                int(memory_order_seq_cst));
    }

    __pointer_type operator--() volatile noexcept {
      return __atomic_sub_fetch(&_M_p, _M_type_size(1),
                                int(memory_order_seq_cst));
    }

    __pointer_type operator+=(ptrdiff_t __d) noexcept {
      return __atomic_add_fetch(&_M_p, _M_type_size(__d),
                                int(memory_order_seq_cst));
    }

    __pointer_type operator+=(ptrdiff_t __d) volatile noexcept {
      return __atomic_add_fetch(&_M_p, _M_type_size(__d),
                                int(memory_order_seq_cst));
    }

    __pointer_type operator-=(ptrdiff_t __d) noexcept {
      return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
                                int(memory_order_seq_cst));
    }

    __pointer_type operator-=(ptrdiff_t __d) volatile noexcept {
      return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
                                int(memory_order_seq_cst));
    }

    bool is_lock_free() const noexcept {

      return __atomic_is_lock_free(sizeof(_M_p),
                                   reinterpret_cast<void *>(-__alignof(_M_p)));
    }

    bool is_lock_free() const volatile noexcept {

      return __atomic_is_lock_free(sizeof(_M_p),
                                   reinterpret_cast<void *>(-__alignof(_M_p)));
    }

    inline __attribute__((__always_inline__)) void
    store(__pointer_type __p,
          memory_order __m = memory_order_seq_cst) noexcept {
      memory_order __b __attribute__((__unused__)) = __m & __memory_order_mask;

      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_acquire))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_acq_rel))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_consume))
          __builtin_unreachable();
      } while (false);

      __atomic_store_n(&_M_p, __p, int(__m));
    }

    inline __attribute__((__always_inline__)) void
    store(__pointer_type __p,
          memory_order __m = memory_order_seq_cst) volatile noexcept {
      memory_order __b __attribute__((__unused__)) = __m & __memory_order_mask;
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_acquire))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_acq_rel))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_consume))
          __builtin_unreachable();
      } while (false);

      __atomic_store_n(&_M_p, __p, int(__m));
    }

    inline __attribute__((__always_inline__)) __pointer_type
    load(memory_order __m = memory_order_seq_cst) const noexcept {
      memory_order __b __attribute__((__unused__)) = __m & __memory_order_mask;
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_release))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_acq_rel))
          __builtin_unreachable();
      } while (false);

      return __atomic_load_n(&_M_p, int(__m));
    }

    inline __attribute__((__always_inline__)) __pointer_type
    load(memory_order __m = memory_order_seq_cst) const volatile noexcept {
      memory_order __b __attribute__((__unused__)) = __m & __memory_order_mask;
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_release))
          __builtin_unreachable();
      } while (false);
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__b != memory_order_acq_rel))
          __builtin_unreachable();
      } while (false);

      return __atomic_load_n(&_M_p, int(__m));
    }

    inline __attribute__((__always_inline__)) __pointer_type exchange(
        __pointer_type __p, memory_order __m = memory_order_seq_cst) noexcept {
      return __atomic_exchange_n(&_M_p, __p, int(__m));
    }

    inline __attribute__((__always_inline__)) __pointer_type
    exchange(__pointer_type __p,
             memory_order __m = memory_order_seq_cst) volatile noexcept {
      return __atomic_exchange_n(&_M_p, __p, int(__m));
    }

    inline __attribute__((__always_inline__)) bool
    compare_exchange_weak(__pointer_type &__p1, __pointer_type __p2,
                          memory_order __m1, memory_order __m2) noexcept {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__is_valid_cmpexch_failure_order(__m2)))
          __builtin_unreachable();
      } while (false);

      return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 1, int(__m1),
                                         int(__m2));
    }

    inline __attribute__((__always_inline__)) bool
    compare_exchange_weak(__pointer_type &__p1, __pointer_type __p2,
                          memory_order __m1,
                          memory_order __m2) volatile noexcept {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__is_valid_cmpexch_failure_order(__m2)))
          __builtin_unreachable();
      } while (false);

      return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 1, int(__m1),
                                         int(__m2));
    }

    inline __attribute__((__always_inline__)) bool
    compare_exchange_strong(__pointer_type &__p1, __pointer_type __p2,
                            memory_order __m1, memory_order __m2) noexcept {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__is_valid_cmpexch_failure_order(__m2)))
          __builtin_unreachable();
      } while (false);

      return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, int(__m1),
                                         int(__m2));
    }

    inline __attribute__((__always_inline__)) bool
    compare_exchange_strong(__pointer_type &__p1, __pointer_type __p2,
                            memory_order __m1,
                            memory_order __m2) volatile noexcept {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__is_valid_cmpexch_failure_order(__m2)))
          __builtin_unreachable();
      } while (false);

      return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, int(__m1),
                                         int(__m2));
    }

    inline __attribute__((__always_inline__)) void
    wait(__pointer_type __old,
         memory_order __m = memory_order_seq_cst) const noexcept {
      std::__atomic_wait_address_v(&_M_p, __old,
                                   [__m, this] { return this->load(__m); });
    }

    inline __attribute__((__always_inline__)) void notify_one() const noexcept {
      std::__atomic_notify_address(&_M_p, false);
    }

    inline __attribute__((__always_inline__)) void notify_all() const noexcept {
      std::__atomic_notify_address(&_M_p, true);
    }

    inline __attribute__((__always_inline__)) __pointer_type
    fetch_add(ptrdiff_t __d, memory_order __m = memory_order_seq_cst) noexcept {
      return __atomic_fetch_add(&_M_p, _M_type_size(__d), int(__m));
    }

    inline __attribute__((__always_inline__)) __pointer_type
    fetch_add(ptrdiff_t __d,
              memory_order __m = memory_order_seq_cst) volatile noexcept {
      return __atomic_fetch_add(&_M_p, _M_type_size(__d), int(__m));
    }

    inline __attribute__((__always_inline__)) __pointer_type
    fetch_sub(ptrdiff_t __d, memory_order __m = memory_order_seq_cst) noexcept {
      return __atomic_fetch_sub(&_M_p, _M_type_size(__d), int(__m));
    }

    inline __attribute__((__always_inline__)) __pointer_type
    fetch_sub(ptrdiff_t __d,
              memory_order __m = memory_order_seq_cst) volatile noexcept {
      return __atomic_fetch_sub(&_M_p, _M_type_size(__d), int(__m));
    }
  };

  namespace __atomic_impl {

  template <typename _Tp> constexpr bool __maybe_has_padding() { return false; }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) _Tp *
  __clear_padding(_Tp &__val) noexcept {
    auto *__ptr = std::__addressof(__val);

    return __ptr;
  }

  template <typename _Tp> using _Val = typename remove_volatile<_Tp>::type;

  template <typename _Tp>
  inline __attribute__((__always_inline__)) bool
  __compare_exchange(_Tp &__val, _Val<_Tp> &__e, _Val<_Tp> &__i, bool __is_weak,
                     memory_order __s, memory_order __f) noexcept {
    do {
      if (std::__is_constant_evaluated() &&
          !bool(__is_valid_cmpexch_failure_order(__f)))
        __builtin_unreachable();
    } while (false);

    using _Vp = _Val<_Tp>;

    if constexpr (__atomic_impl::__maybe_has_padding<_Vp>()) {

      alignas(_Vp) unsigned char __buf[sizeof(_Vp)];
      _Vp *__exp = ::new ((void *)__buf) _Vp(__e);
      __atomic_impl::__clear_padding(*__exp);
      if (__atomic_compare_exchange(std::__addressof(__val), __exp,
                                    __atomic_impl::__clear_padding(__i),
                                    __is_weak, int(__s), int(__f)))
        return true;
      __builtin_memcpy(std::__addressof(__e), __exp, sizeof(_Vp));
      return false;
    } else
      return __atomic_compare_exchange(
          std::__addressof(__val), std::__addressof(__e), std::__addressof(__i),
          __is_weak, int(__s), int(__f));
  }
  } // namespace __atomic_impl

  namespace __atomic_impl {

  template <typename _Tp>
  using _Diff = __conditional_t<is_pointer_v<_Tp>, ptrdiff_t, _Val<_Tp>>;

  template <size_t _Size, size_t _Align>
  inline __attribute__((__always_inline__)) bool is_lock_free() noexcept {

    return __atomic_is_lock_free(_Size, reinterpret_cast<void *>(-_Align));
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) void
  store(_Tp *__ptr, _Val<_Tp> __t, memory_order __m) noexcept {
    __atomic_store(__ptr, __atomic_impl::__clear_padding(__t), int(__m));
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) _Val<_Tp>
  load(const _Tp *__ptr, memory_order __m) noexcept {
    alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
    auto *__dest = reinterpret_cast<_Val<_Tp> *>(__buf);
    __atomic_load(__ptr, __dest, int(__m));
    return *__dest;
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) _Val<_Tp>
  exchange(_Tp *__ptr, _Val<_Tp> __desired, memory_order __m) noexcept {
    alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
    auto *__dest = reinterpret_cast<_Val<_Tp> *>(__buf);
    __atomic_exchange(__ptr, __atomic_impl::__clear_padding(__desired), __dest,
                      int(__m));
    return *__dest;
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) bool
  compare_exchange_weak(_Tp *__ptr, _Val<_Tp> &__expected, _Val<_Tp> __desired,
                        memory_order __success,
                        memory_order __failure) noexcept {
    return __atomic_impl::__compare_exchange(*__ptr, __expected, __desired,
                                             true, __success, __failure);
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) bool
  compare_exchange_strong(_Tp *__ptr, _Val<_Tp> &__expected,
                          _Val<_Tp> __desired, memory_order __success,
                          memory_order __failure) noexcept {
    return __atomic_impl::__compare_exchange(*__ptr, __expected, __desired,
                                             false, __success, __failure);
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) void
  wait(const _Tp *__ptr, _Val<_Tp> __old,
       memory_order __m = memory_order_seq_cst) noexcept {
    std::__atomic_wait_address_v(__ptr, __old, [__ptr, __m]() {
      return __atomic_impl::load(__ptr, __m);
    });
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) void
  notify_one(const _Tp *__ptr) noexcept {
    std::__atomic_notify_address(__ptr, false);
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) void
  notify_all(const _Tp *__ptr) noexcept {
    std::__atomic_notify_address(__ptr, true);
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) _Tp
  fetch_add(_Tp *__ptr, _Diff<_Tp> __i, memory_order __m) noexcept {
    return __atomic_fetch_add(__ptr, __i, int(__m));
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) _Tp
  fetch_sub(_Tp *__ptr, _Diff<_Tp> __i, memory_order __m) noexcept {
    return __atomic_fetch_sub(__ptr, __i, int(__m));
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) _Tp
  fetch_and(_Tp *__ptr, _Val<_Tp> __i, memory_order __m) noexcept {
    return __atomic_fetch_and(__ptr, __i, int(__m));
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) _Tp
  fetch_or(_Tp *__ptr, _Val<_Tp> __i, memory_order __m) noexcept {
    return __atomic_fetch_or(__ptr, __i, int(__m));
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) _Tp
  fetch_xor(_Tp *__ptr, _Val<_Tp> __i, memory_order __m) noexcept {
    return __atomic_fetch_xor(__ptr, __i, int(__m));
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) _Tp
  __add_fetch(_Tp *__ptr, _Diff<_Tp> __i) noexcept {
    return __atomic_add_fetch(__ptr, __i, 5);
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) _Tp
  __sub_fetch(_Tp *__ptr, _Diff<_Tp> __i) noexcept {
    return __atomic_sub_fetch(__ptr, __i, 5);
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) _Tp
  __and_fetch(_Tp *__ptr, _Val<_Tp> __i) noexcept {
    return __atomic_and_fetch(__ptr, __i, 5);
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) _Tp
  __or_fetch(_Tp *__ptr, _Val<_Tp> __i) noexcept {
    return __atomic_or_fetch(__ptr, __i, 5);
  }

  template <typename _Tp>
  inline __attribute__((__always_inline__)) _Tp
  __xor_fetch(_Tp *__ptr, _Val<_Tp> __i) noexcept {
    return __atomic_xor_fetch(__ptr, __i, 5);
  }

  template <typename _Tp>
  _Tp __fetch_add_flt(_Tp *__ptr, _Val<_Tp> __i, memory_order __m) noexcept {
    _Val<_Tp> __oldval = load(__ptr, memory_order_relaxed);
    _Val<_Tp> __newval = __oldval + __i;
    while (!compare_exchange_weak(__ptr, __oldval, __newval, __m,
                                  memory_order_relaxed))
      __newval = __oldval + __i;
    return __oldval;
  }

  template <typename _Tp>
  _Tp __fetch_sub_flt(_Tp *__ptr, _Val<_Tp> __i, memory_order __m) noexcept {
    _Val<_Tp> __oldval = load(__ptr, memory_order_relaxed);
    _Val<_Tp> __newval = __oldval - __i;
    while (!compare_exchange_weak(__ptr, __oldval, __newval, __m,
                                  memory_order_relaxed))
      __newval = __oldval - __i;
    return __oldval;
  }

  template <typename _Tp>
  _Tp __add_fetch_flt(_Tp *__ptr, _Val<_Tp> __i) noexcept {
    _Val<_Tp> __oldval = load(__ptr, memory_order_relaxed);
    _Val<_Tp> __newval = __oldval + __i;
    while (!compare_exchange_weak(__ptr, __oldval, __newval,
                                  memory_order_seq_cst, memory_order_relaxed))
      __newval = __oldval + __i;
    return __newval;
  }

  template <typename _Tp>
  _Tp __sub_fetch_flt(_Tp *__ptr, _Val<_Tp> __i) noexcept {
    _Val<_Tp> __oldval = load(__ptr, memory_order_relaxed);
    _Val<_Tp> __newval = __oldval - __i;
    while (!compare_exchange_weak(__ptr, __oldval, __newval,
                                  memory_order_seq_cst, memory_order_relaxed))
      __newval = __oldval - __i;
    return __newval;
  }
  } // namespace __atomic_impl

  template <typename _Fp> struct __atomic_float {
    static_assert(is_floating_point_v<_Fp>);

    static constexpr size_t _S_alignment = __alignof__(_Fp);

  public:
    using value_type = _Fp;
    using difference_type = value_type;

    static constexpr bool is_always_lock_free =
        __atomic_always_lock_free(sizeof(_Fp), 0);

    __atomic_float() = default;

    constexpr __atomic_float(_Fp __t) : _M_fp(__t) {}

    __atomic_float(const __atomic_float &) = delete;
    __atomic_float &operator=(const __atomic_float &) = delete;
    __atomic_float &operator=(const __atomic_float &) volatile = delete;

    _Fp operator=(_Fp __t) volatile noexcept {
      this->store(__t);
      return __t;
    }

    _Fp operator=(_Fp __t) noexcept {
      this->store(__t);
      return __t;
    }

    bool is_lock_free() const volatile noexcept {
      return __atomic_impl::is_lock_free<sizeof(_Fp), _S_alignment>();
    }

    bool is_lock_free() const noexcept {
      return __atomic_impl::is_lock_free<sizeof(_Fp), _S_alignment>();
    }

    void store(_Fp __t,
               memory_order __m = memory_order_seq_cst) volatile noexcept {
      __atomic_impl::store(&_M_fp, __t, __m);
    }

    void store(_Fp __t, memory_order __m = memory_order_seq_cst) noexcept {
      __atomic_impl::store(&_M_fp, __t, __m);
    }

    _Fp load(memory_order __m = memory_order_seq_cst) const volatile noexcept {
      return __atomic_impl::load(&_M_fp, __m);
    }

    _Fp load(memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::load(&_M_fp, __m);
    }

    operator _Fp() const volatile noexcept { return this->load(); }
    operator _Fp() const noexcept { return this->load(); }

    _Fp exchange(_Fp __desired,
                 memory_order __m = memory_order_seq_cst) volatile noexcept {
      return __atomic_impl::exchange(&_M_fp, __desired, __m);
    }

    _Fp exchange(_Fp __desired,
                 memory_order __m = memory_order_seq_cst) noexcept {
      return __atomic_impl::exchange(&_M_fp, __desired, __m);
    }

    bool compare_exchange_weak(_Fp &__expected, _Fp __desired,
                               memory_order __success,
                               memory_order __failure) noexcept {
      return __atomic_impl::compare_exchange_weak(&_M_fp, __expected, __desired,
                                                  __success, __failure);
    }

    bool compare_exchange_weak(_Fp &__expected, _Fp __desired,
                               memory_order __success,
                               memory_order __failure) volatile noexcept {
      return __atomic_impl::compare_exchange_weak(&_M_fp, __expected, __desired,
                                                  __success, __failure);
    }

    bool compare_exchange_strong(_Fp &__expected, _Fp __desired,
                                 memory_order __success,
                                 memory_order __failure) noexcept {
      return __atomic_impl::compare_exchange_strong(
          &_M_fp, __expected, __desired, __success, __failure);
    }

    bool compare_exchange_strong(_Fp &__expected, _Fp __desired,
                                 memory_order __success,
                                 memory_order __failure) volatile noexcept {
      return __atomic_impl::compare_exchange_strong(
          &_M_fp, __expected, __desired, __success, __failure);
    }

    bool compare_exchange_weak(
        _Fp &__expected, _Fp __desired,
        memory_order __order = memory_order_seq_cst) noexcept {
      return compare_exchange_weak(__expected, __desired, __order,
                                   __cmpexch_failure_order(__order));
    }

    bool compare_exchange_weak(
        _Fp &__expected, _Fp __desired,
        memory_order __order = memory_order_seq_cst) volatile noexcept {
      return compare_exchange_weak(__expected, __desired, __order,
                                   __cmpexch_failure_order(__order));
    }

    bool compare_exchange_strong(
        _Fp &__expected, _Fp __desired,
        memory_order __order = memory_order_seq_cst) noexcept {
      return compare_exchange_strong(__expected, __desired, __order,
                                     __cmpexch_failure_order(__order));
    }

    bool compare_exchange_strong(
        _Fp &__expected, _Fp __desired,
        memory_order __order = memory_order_seq_cst) volatile noexcept {
      return compare_exchange_strong(__expected, __desired, __order,
                                     __cmpexch_failure_order(__order));
    }

    inline __attribute__((__always_inline__)) void
    wait(_Fp __old, memory_order __m = memory_order_seq_cst) const noexcept {
      __atomic_impl::wait(&_M_fp, __old, __m);
    }

    inline __attribute__((__always_inline__)) void notify_one() const noexcept {
      __atomic_impl::notify_one(&_M_fp);
    }

    inline __attribute__((__always_inline__)) void notify_all() const noexcept {
      __atomic_impl::notify_all(&_M_fp);
    }

    value_type fetch_add(value_type __i,
                         memory_order __m = memory_order_seq_cst) noexcept {
      return __atomic_impl::__fetch_add_flt(&_M_fp, __i, __m);
    }

    value_type
    fetch_add(value_type __i,
              memory_order __m = memory_order_seq_cst) volatile noexcept {
      return __atomic_impl::__fetch_add_flt(&_M_fp, __i, __m);
    }

    value_type fetch_sub(value_type __i,
                         memory_order __m = memory_order_seq_cst) noexcept {
      return __atomic_impl::__fetch_sub_flt(&_M_fp, __i, __m);
    }

    value_type
    fetch_sub(value_type __i,
              memory_order __m = memory_order_seq_cst) volatile noexcept {
      return __atomic_impl::__fetch_sub_flt(&_M_fp, __i, __m);
    }

    value_type operator+=(value_type __i) noexcept {
      return __atomic_impl::__add_fetch_flt(&_M_fp, __i);
    }

    value_type operator+=(value_type __i) volatile noexcept {
      return __atomic_impl::__add_fetch_flt(&_M_fp, __i);
    }

    value_type operator-=(value_type __i) noexcept {
      return __atomic_impl::__sub_fetch_flt(&_M_fp, __i);
    }

    value_type operator-=(value_type __i) volatile noexcept {
      return __atomic_impl::__sub_fetch_flt(&_M_fp, __i);
    }

  private:
    alignas(_S_alignment) _Fp _M_fp = 0;
  };

  template <typename _Tp, bool = is_integral_v<_Tp>,
            bool = is_floating_point_v<_Tp>>
  struct __atomic_ref;

  template <typename _Tp> struct __atomic_ref<_Tp, false, false> {
    static_assert(is_trivially_copyable_v<_Tp>);

    static constexpr int _S_min_alignment = (sizeof(_Tp) & (sizeof(_Tp) - 1)) ||
                                                    sizeof(_Tp) > 16
                                                ? 0
                                                : sizeof(_Tp);

  public:
    using value_type = _Tp;

    static constexpr bool is_always_lock_free =
        __atomic_always_lock_free(sizeof(_Tp), 0);

    static constexpr size_t required_alignment = _S_min_alignment > alignof(_Tp)
                                                     ? _S_min_alignment
                                                     : alignof(_Tp);

    __atomic_ref &operator=(const __atomic_ref &) = delete;

    explicit __atomic_ref(_Tp &__t) : _M_ptr(std::__addressof(__t)) {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(((uintptr_t)_M_ptr % required_alignment) == 0))
          __builtin_unreachable();
      } while (false);
    }

    __atomic_ref(const __atomic_ref &) noexcept = default;

    _Tp operator=(_Tp __t) const noexcept {
      this->store(__t);
      return __t;
    }

    operator _Tp() const noexcept { return this->load(); }

    bool is_lock_free() const noexcept {
      return __atomic_impl::is_lock_free<sizeof(_Tp), required_alignment>();
    }

    void store(_Tp __t,
               memory_order __m = memory_order_seq_cst) const noexcept {
      __atomic_impl::store(_M_ptr, __t, __m);
    }

    _Tp load(memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::load(_M_ptr, __m);
    }

    _Tp exchange(_Tp __desired,
                 memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::exchange(_M_ptr, __desired, __m);
    }

    bool compare_exchange_weak(_Tp &__expected, _Tp __desired,
                               memory_order __success,
                               memory_order __failure) const noexcept {
      return __atomic_impl::compare_exchange_weak(_M_ptr, __expected, __desired,
                                                  __success, __failure);
    }

    bool compare_exchange_strong(_Tp &__expected, _Tp __desired,
                                 memory_order __success,
                                 memory_order __failure) const noexcept {
      return __atomic_impl::compare_exchange_strong(
          _M_ptr, __expected, __desired, __success, __failure);
    }

    bool compare_exchange_weak(
        _Tp &__expected, _Tp __desired,
        memory_order __order = memory_order_seq_cst) const noexcept {
      return compare_exchange_weak(__expected, __desired, __order,
                                   __cmpexch_failure_order(__order));
    }

    bool compare_exchange_strong(
        _Tp &__expected, _Tp __desired,
        memory_order __order = memory_order_seq_cst) const noexcept {
      return compare_exchange_strong(__expected, __desired, __order,
                                     __cmpexch_failure_order(__order));
    }

    inline __attribute__((__always_inline__)) void
    wait(_Tp __old, memory_order __m = memory_order_seq_cst) const noexcept {
      __atomic_impl::wait(_M_ptr, __old, __m);
    }

    inline __attribute__((__always_inline__)) void notify_one() const noexcept {
      __atomic_impl::notify_one(_M_ptr);
    }

    inline __attribute__((__always_inline__)) void notify_all() const noexcept {
      __atomic_impl::notify_all(_M_ptr);
    }

  private:
    _Tp *_M_ptr;
  };

  template <typename _Tp> struct __atomic_ref<_Tp, true, false> {
    static_assert(is_integral_v<_Tp>);

  public:
    using value_type = _Tp;
    using difference_type = value_type;

    static constexpr bool is_always_lock_free =
        __atomic_always_lock_free(sizeof(_Tp), 0);

    static constexpr size_t required_alignment = sizeof(_Tp) > alignof(_Tp)
                                                     ? sizeof(_Tp)
                                                     : alignof(_Tp);

    __atomic_ref() = delete;
    __atomic_ref &operator=(const __atomic_ref &) = delete;

    explicit __atomic_ref(_Tp &__t) : _M_ptr(&__t) {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(((uintptr_t)_M_ptr % required_alignment) == 0))
          __builtin_unreachable();
      } while (false);
    }

    __atomic_ref(const __atomic_ref &) noexcept = default;

    _Tp operator=(_Tp __t) const noexcept {
      this->store(__t);
      return __t;
    }

    operator _Tp() const noexcept { return this->load(); }

    bool is_lock_free() const noexcept {
      return __atomic_impl::is_lock_free<sizeof(_Tp), required_alignment>();
    }

    void store(_Tp __t,
               memory_order __m = memory_order_seq_cst) const noexcept {
      __atomic_impl::store(_M_ptr, __t, __m);
    }

    _Tp load(memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::load(_M_ptr, __m);
    }

    _Tp exchange(_Tp __desired,
                 memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::exchange(_M_ptr, __desired, __m);
    }

    bool compare_exchange_weak(_Tp &__expected, _Tp __desired,
                               memory_order __success,
                               memory_order __failure) const noexcept {
      return __atomic_impl::compare_exchange_weak(_M_ptr, __expected, __desired,
                                                  __success, __failure);
    }

    bool compare_exchange_strong(_Tp &__expected, _Tp __desired,
                                 memory_order __success,
                                 memory_order __failure) const noexcept {
      return __atomic_impl::compare_exchange_strong(
          _M_ptr, __expected, __desired, __success, __failure);
    }

    bool compare_exchange_weak(
        _Tp &__expected, _Tp __desired,
        memory_order __order = memory_order_seq_cst) const noexcept {
      return compare_exchange_weak(__expected, __desired, __order,
                                   __cmpexch_failure_order(__order));
    }

    bool compare_exchange_strong(
        _Tp &__expected, _Tp __desired,
        memory_order __order = memory_order_seq_cst) const noexcept {
      return compare_exchange_strong(__expected, __desired, __order,
                                     __cmpexch_failure_order(__order));
    }

    inline __attribute__((__always_inline__)) void
    wait(_Tp __old, memory_order __m = memory_order_seq_cst) const noexcept {
      __atomic_impl::wait(_M_ptr, __old, __m);
    }

    inline __attribute__((__always_inline__)) void notify_one() const noexcept {
      __atomic_impl::notify_one(_M_ptr);
    }

    inline __attribute__((__always_inline__)) void notify_all() const noexcept {
      __atomic_impl::notify_all(_M_ptr);
    }

    value_type
    fetch_add(value_type __i,
              memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::fetch_add(_M_ptr, __i, __m);
    }

    value_type
    fetch_sub(value_type __i,
              memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::fetch_sub(_M_ptr, __i, __m);
    }

    value_type
    fetch_and(value_type __i,
              memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::fetch_and(_M_ptr, __i, __m);
    }

    value_type
    fetch_or(value_type __i,
             memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::fetch_or(_M_ptr, __i, __m);
    }

    value_type
    fetch_xor(value_type __i,
              memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::fetch_xor(_M_ptr, __i, __m);
    }

    inline __attribute__((__always_inline__)) value_type
    operator++(int) const noexcept {
      return fetch_add(1);
    }

    inline __attribute__((__always_inline__)) value_type
    operator--(int) const noexcept {
      return fetch_sub(1);
    }

    value_type operator++() const noexcept {
      return __atomic_impl::__add_fetch(_M_ptr, value_type(1));
    }

    value_type operator--() const noexcept {
      return __atomic_impl::__sub_fetch(_M_ptr, value_type(1));
    }

    value_type operator+=(value_type __i) const noexcept {
      return __atomic_impl::__add_fetch(_M_ptr, __i);
    }

    value_type operator-=(value_type __i) const noexcept {
      return __atomic_impl::__sub_fetch(_M_ptr, __i);
    }

    value_type operator&=(value_type __i) const noexcept {
      return __atomic_impl::__and_fetch(_M_ptr, __i);
    }

    value_type operator|=(value_type __i) const noexcept {
      return __atomic_impl::__or_fetch(_M_ptr, __i);
    }

    value_type operator^=(value_type __i) const noexcept {
      return __atomic_impl::__xor_fetch(_M_ptr, __i);
    }

  private:
    _Tp *_M_ptr;
  };

  template <typename _Fp> struct __atomic_ref<_Fp, false, true> {
    static_assert(is_floating_point_v<_Fp>);

  public:
    using value_type = _Fp;
    using difference_type = value_type;

    static constexpr bool is_always_lock_free =
        __atomic_always_lock_free(sizeof(_Fp), 0);

    static constexpr size_t required_alignment = __alignof__(_Fp);

    __atomic_ref() = delete;
    __atomic_ref &operator=(const __atomic_ref &) = delete;

    explicit __atomic_ref(_Fp &__t) : _M_ptr(&__t) {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(((uintptr_t)_M_ptr % required_alignment) == 0))
          __builtin_unreachable();
      } while (false);
    }

    __atomic_ref(const __atomic_ref &) noexcept = default;

    _Fp operator=(_Fp __t) const noexcept {
      this->store(__t);
      return __t;
    }

    operator _Fp() const noexcept { return this->load(); }

    bool is_lock_free() const noexcept {
      return __atomic_impl::is_lock_free<sizeof(_Fp), required_alignment>();
    }

    void store(_Fp __t,
               memory_order __m = memory_order_seq_cst) const noexcept {
      __atomic_impl::store(_M_ptr, __t, __m);
    }

    _Fp load(memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::load(_M_ptr, __m);
    }

    _Fp exchange(_Fp __desired,
                 memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::exchange(_M_ptr, __desired, __m);
    }

    bool compare_exchange_weak(_Fp &__expected, _Fp __desired,
                               memory_order __success,
                               memory_order __failure) const noexcept {
      return __atomic_impl::compare_exchange_weak(_M_ptr, __expected, __desired,
                                                  __success, __failure);
    }

    bool compare_exchange_strong(_Fp &__expected, _Fp __desired,
                                 memory_order __success,
                                 memory_order __failure) const noexcept {
      return __atomic_impl::compare_exchange_strong(
          _M_ptr, __expected, __desired, __success, __failure);
    }

    bool compare_exchange_weak(
        _Fp &__expected, _Fp __desired,
        memory_order __order = memory_order_seq_cst) const noexcept {
      return compare_exchange_weak(__expected, __desired, __order,
                                   __cmpexch_failure_order(__order));
    }

    bool compare_exchange_strong(
        _Fp &__expected, _Fp __desired,
        memory_order __order = memory_order_seq_cst) const noexcept {
      return compare_exchange_strong(__expected, __desired, __order,
                                     __cmpexch_failure_order(__order));
    }

    inline __attribute__((__always_inline__)) void
    wait(_Fp __old, memory_order __m = memory_order_seq_cst) const noexcept {
      __atomic_impl::wait(_M_ptr, __old, __m);
    }

    inline __attribute__((__always_inline__)) void notify_one() const noexcept {
      __atomic_impl::notify_one(_M_ptr);
    }

    inline __attribute__((__always_inline__)) void notify_all() const noexcept {
      __atomic_impl::notify_all(_M_ptr);
    }

    value_type
    fetch_add(value_type __i,
              memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::__fetch_add_flt(_M_ptr, __i, __m);
    }

    value_type
    fetch_sub(value_type __i,
              memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::__fetch_sub_flt(_M_ptr, __i, __m);
    }

    value_type operator+=(value_type __i) const noexcept {
      return __atomic_impl::__add_fetch_flt(_M_ptr, __i);
    }

    value_type operator-=(value_type __i) const noexcept {
      return __atomic_impl::__sub_fetch_flt(_M_ptr, __i);
    }

  private:
    _Fp *_M_ptr;
  };

  template <typename _Tp> struct __atomic_ref<_Tp *, false, false> {
  public:
    using value_type = _Tp *;
    using difference_type = ptrdiff_t;

    static constexpr bool is_always_lock_free = 2 == 2;

    static constexpr size_t required_alignment = __alignof__(_Tp *);

    __atomic_ref() = delete;
    __atomic_ref &operator=(const __atomic_ref &) = delete;

    explicit __atomic_ref(_Tp *&__t) : _M_ptr(std::__addressof(__t)) {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(((uintptr_t)_M_ptr % required_alignment) == 0))
          __builtin_unreachable();
      } while (false);
    }

    __atomic_ref(const __atomic_ref &) noexcept = default;

    _Tp *operator=(_Tp *__t) const noexcept {
      this->store(__t);
      return __t;
    }

    operator _Tp *() const noexcept { return this->load(); }

    bool is_lock_free() const noexcept {
      return __atomic_impl::is_lock_free<sizeof(_Tp *), required_alignment>();
    }

    void store(_Tp *__t,
               memory_order __m = memory_order_seq_cst) const noexcept {
      __atomic_impl::store(_M_ptr, __t, __m);
    }

    _Tp *load(memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::load(_M_ptr, __m);
    }

    _Tp *exchange(_Tp *__desired,
                  memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::exchange(_M_ptr, __desired, __m);
    }

    bool compare_exchange_weak(_Tp *&__expected, _Tp *__desired,
                               memory_order __success,
                               memory_order __failure) const noexcept {
      return __atomic_impl::compare_exchange_weak(_M_ptr, __expected, __desired,
                                                  __success, __failure);
    }

    bool compare_exchange_strong(_Tp *&__expected, _Tp *__desired,
                                 memory_order __success,
                                 memory_order __failure) const noexcept {
      return __atomic_impl::compare_exchange_strong(
          _M_ptr, __expected, __desired, __success, __failure);
    }

    bool compare_exchange_weak(
        _Tp *&__expected, _Tp *__desired,
        memory_order __order = memory_order_seq_cst) const noexcept {
      return compare_exchange_weak(__expected, __desired, __order,
                                   __cmpexch_failure_order(__order));
    }

    bool compare_exchange_strong(
        _Tp *&__expected, _Tp *__desired,
        memory_order __order = memory_order_seq_cst) const noexcept {
      return compare_exchange_strong(__expected, __desired, __order,
                                     __cmpexch_failure_order(__order));
    }

    inline __attribute__((__always_inline__)) void
    wait(_Tp *__old, memory_order __m = memory_order_seq_cst) const noexcept {
      __atomic_impl::wait(_M_ptr, __old, __m);
    }

    inline __attribute__((__always_inline__)) void notify_one() const noexcept {
      __atomic_impl::notify_one(_M_ptr);
    }

    inline __attribute__((__always_inline__)) void notify_all() const noexcept {
      __atomic_impl::notify_all(_M_ptr);
    }

    inline __attribute__((__always_inline__)) value_type
    fetch_add(difference_type __d,
              memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::fetch_add(_M_ptr, _S_type_size(__d), __m);
    }

    inline __attribute__((__always_inline__)) value_type
    fetch_sub(difference_type __d,
              memory_order __m = memory_order_seq_cst) const noexcept {
      return __atomic_impl::fetch_sub(_M_ptr, _S_type_size(__d), __m);
    }

    value_type operator++(int) const noexcept { return fetch_add(1); }

    value_type operator--(int) const noexcept { return fetch_sub(1); }

    value_type operator++() const noexcept {
      return __atomic_impl::__add_fetch(_M_ptr, _S_type_size(1));
    }

    value_type operator--() const noexcept {
      return __atomic_impl::__sub_fetch(_M_ptr, _S_type_size(1));
    }

    value_type operator+=(difference_type __d) const noexcept {
      return __atomic_impl::__add_fetch(_M_ptr, _S_type_size(__d));
    }

    value_type operator-=(difference_type __d) const noexcept {
      return __atomic_impl::__sub_fetch(_M_ptr, _S_type_size(__d));
    }

  private:
    static constexpr ptrdiff_t _S_type_size(ptrdiff_t __d) noexcept {
      static_assert(is_object_v<_Tp>);
      return __d * sizeof(_Tp);
    }

    _Tp **_M_ptr;
  };

} // namespace std
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_atomic.h" 2 3
# 61 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_atomic.h" 3
namespace std __attribute__((__visibility__("default"))) {
# 73 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_atomic.h" 3
  struct _Sp_locker {
    _Sp_locker(const _Sp_locker &) = delete;
    _Sp_locker &operator=(const _Sp_locker &) = delete;

    explicit _Sp_locker(const void *) noexcept;
    _Sp_locker(const void *, const void *) noexcept;
    ~_Sp_locker();

  private:
    unsigned char _M_key1;
    unsigned char _M_key2;
  };
# 100 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_atomic.h" 3
  template <typename _Tp, _Lock_policy _Lp>
  inline bool atomic_is_lock_free(const __shared_ptr<_Tp, _Lp> *) {

    return __gthread_active_p() == 0;
  }

  template <typename _Tp>
  inline bool atomic_is_lock_free(const shared_ptr<_Tp> *__p) {
    return std::atomic_is_lock_free<_Tp, __default_lock_policy>(__p);
  }
# 127 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_atomic.h" 3
  template <typename _Tp>
  inline shared_ptr<_Tp> atomic_load_explicit(const shared_ptr<_Tp> *__p,
                                              memory_order) {
    _Sp_locker __lock{__p};
    return *__p;
  }

  template <typename _Tp>
  inline shared_ptr<_Tp> atomic_load(const shared_ptr<_Tp> *__p) {
    return std::atomic_load_explicit(__p, memory_order_seq_cst);
  }

  template <typename _Tp, _Lock_policy _Lp>
  inline __shared_ptr<_Tp, _Lp> atomic_load_explicit(
      const __shared_ptr<_Tp, _Lp> *__p, memory_order) {
    _Sp_locker __lock{__p};
    return *__p;
  }

  template <typename _Tp, _Lock_policy _Lp>
  inline __shared_ptr<_Tp, _Lp> atomic_load(const __shared_ptr<_Tp, _Lp> *__p) {
    return std::atomic_load_explicit(__p, memory_order_seq_cst);
  }
# 163 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_atomic.h" 3
  template <typename _Tp>
  inline void atomic_store_explicit(shared_ptr<_Tp> * __p, shared_ptr<_Tp> __r,
                                    memory_order) {
    _Sp_locker __lock{__p};
    __p->swap(__r);
  }

  template <typename _Tp>
  inline void atomic_store(shared_ptr<_Tp> * __p, shared_ptr<_Tp> __r) {
    std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst);
  }

  template <typename _Tp, _Lock_policy _Lp>
  inline void atomic_store_explicit(__shared_ptr<_Tp, _Lp> * __p,
                                    __shared_ptr<_Tp, _Lp> __r, memory_order) {
    _Sp_locker __lock{__p};
    __p->swap(__r);
  }

  template <typename _Tp, _Lock_policy _Lp>
  inline void atomic_store(__shared_ptr<_Tp, _Lp> * __p,
                           __shared_ptr<_Tp, _Lp> __r) {
    std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst);
  }
# 200 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_atomic.h" 3
  template <typename _Tp>
  inline shared_ptr<_Tp> atomic_exchange_explicit(
      shared_ptr<_Tp> * __p, shared_ptr<_Tp> __r, memory_order) {
    _Sp_locker __lock{__p};
    __p->swap(__r);
    return __r;
  }

  template <typename _Tp>
  inline shared_ptr<_Tp> atomic_exchange(shared_ptr<_Tp> * __p,
                                         shared_ptr<_Tp> __r) {
    return std::atomic_exchange_explicit(__p, std::move(__r),
                                         memory_order_seq_cst);
  }

  template <typename _Tp, _Lock_policy _Lp>
  inline __shared_ptr<_Tp, _Lp> atomic_exchange_explicit(
      __shared_ptr<_Tp, _Lp> * __p, __shared_ptr<_Tp, _Lp> __r, memory_order) {
    _Sp_locker __lock{__p};
    __p->swap(__r);
    return __r;
  }

  template <typename _Tp, _Lock_policy _Lp>
  inline __shared_ptr<_Tp, _Lp> atomic_exchange(__shared_ptr<_Tp, _Lp> * __p,
                                                __shared_ptr<_Tp, _Lp> __r) {
    return std::atomic_exchange_explicit(__p, std::move(__r),
                                         memory_order_seq_cst);
  }
# 249 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/shared_ptr_atomic.h" 3
  template <typename _Tp>
  bool atomic_compare_exchange_strong_explicit(
      shared_ptr<_Tp> * __p, shared_ptr<_Tp> * __v, shared_ptr<_Tp> __w,
      memory_order, memory_order) {
    shared_ptr<_Tp> __x;
    _Sp_locker __lock{__p, __v};
    owner_less<shared_ptr<_Tp>> __less;
    if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p)) {
      __x = std::move(*__p);
      *__p = std::move(__w);
      return true;
    }
    __x = std::move(*__v);
    *__v = *__p;
    return false;
  }

  template <typename _Tp>
  inline bool atomic_compare_exchange_strong(
      shared_ptr<_Tp> * __p, shared_ptr<_Tp> * __v, shared_ptr<_Tp> __w) {
    return std::atomic_compare_exchange_strong_explicit(
        __p, __v, std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
  }

  template <typename _Tp>
  inline bool atomic_compare_exchange_weak_explicit(
      shared_ptr<_Tp> * __p, shared_ptr<_Tp> * __v, shared_ptr<_Tp> __w,
      memory_order __success, memory_order __failure) {
    return std::atomic_compare_exchange_strong_explicit(
        __p, __v, std::move(__w), __success, __failure);
  }

  template <typename _Tp>
  inline bool atomic_compare_exchange_weak(
      shared_ptr<_Tp> * __p, shared_ptr<_Tp> * __v, shared_ptr<_Tp> __w) {
    return std::atomic_compare_exchange_weak_explicit(
        __p, __v, std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
  }

  template <typename _Tp, _Lock_policy _Lp>
  bool atomic_compare_exchange_strong_explicit(
      __shared_ptr<_Tp, _Lp> * __p, __shared_ptr<_Tp, _Lp> * __v,
      __shared_ptr<_Tp, _Lp> __w, memory_order, memory_order) {
    __shared_ptr<_Tp, _Lp> __x;
    _Sp_locker __lock{__p, __v};
    owner_less<__shared_ptr<_Tp, _Lp>> __less;
    if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p)) {
      __x = std::move(*__p);
      *__p = std::move(__w);
      return true;
    }
    __x = std::move(*__v);
    *__v = *__p;
    return false;
  }

  template <typename _Tp, _Lock_policy _Lp>
  inline bool atomic_compare_exchange_strong(__shared_ptr<_Tp, _Lp> * __p,
                                             __shared_ptr<_Tp, _Lp> * __v,
                                             __shared_ptr<_Tp, _Lp> __w) {
    return std::atomic_compare_exchange_strong_explicit(
        __p, __v, std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
  }

  template <typename _Tp, _Lock_policy _Lp>
  inline bool atomic_compare_exchange_weak_explicit(
      __shared_ptr<_Tp, _Lp> * __p, __shared_ptr<_Tp, _Lp> * __v,
      __shared_ptr<_Tp, _Lp> __w, memory_order __success,
      memory_order __failure) {
    return std::atomic_compare_exchange_strong_explicit(
        __p, __v, std::move(__w), __success, __failure);
  }

  template <typename _Tp, _Lock_policy _Lp>
  inline bool atomic_compare_exchange_weak(__shared_ptr<_Tp, _Lp> * __p,
                                           __shared_ptr<_Tp, _Lp> * __v,
                                           __shared_ptr<_Tp, _Lp> __w) {
    return std::atomic_compare_exchange_weak_explicit(
        __p, __v, std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
  }

  template <typename _Tp> struct atomic;

  template <typename _Up> static constexpr bool __is_shared_ptr = false;
  template <typename _Up>
  static constexpr bool __is_shared_ptr<shared_ptr<_Up>> = true;

  template <typename _Tp> class _Sp_atomic {
    using value_type = _Tp;

    friend struct atomic<_Tp>;

    struct _Atomic_count {

      using __count_type = decltype(_Tp::_M_refcount);

      using pointer = decltype(__count_type::_M_pi);

      static_assert(alignof(remove_pointer_t<pointer>) > 1);

      constexpr _Atomic_count() noexcept = default;

      explicit _Atomic_count(__count_type &&__c) noexcept
          : _M_val(reinterpret_cast<uintptr_t>(__c._M_pi)) {
        __c._M_pi = nullptr;
      }

      ~_Atomic_count() {
        auto __val = _M_val.load(memory_order_relaxed);
        ;
        do {
          if (std::__is_constant_evaluated() && !bool(!(__val & _S_lock_bit)))
            __builtin_unreachable();
        } while (false);
        if (auto __pi = reinterpret_cast<pointer>(__val)) {
          if constexpr (__is_shared_ptr<_Tp>)
            __pi->_M_release();
          else
            __pi->_M_weak_release();
        }
      }

      _Atomic_count(const _Atomic_count &) = delete;
      _Atomic_count &operator=(const _Atomic_count &) = delete;

      pointer lock(memory_order __o) const noexcept {

        auto __current = _M_val.load(memory_order_relaxed);
        while (__current & _S_lock_bit) {

          __detail::__thread_relax();

          __current = _M_val.load(memory_order_relaxed);
        }

        ;

        while (!_M_val.compare_exchange_strong(
            __current, __current | _S_lock_bit, __o, memory_order_relaxed)) {
          ;

          __detail::__thread_relax();

          __current = __current & ~_S_lock_bit;
          ;
        };
        return reinterpret_cast<pointer>(__current);
      }

      void unlock(memory_order __o) const noexcept {
        ;
        _M_val.fetch_sub(1, __o);
        ;
      }

      void _M_swap_unlock(__count_type &__c, memory_order __o) noexcept {
        if (__o != memory_order_seq_cst)
          __o = memory_order_release;
        auto __x = reinterpret_cast<uintptr_t>(__c._M_pi);
        ;
        __x = _M_val.exchange(__x, __o);
        ;
        __c._M_pi = reinterpret_cast<pointer>(__x & ~_S_lock_bit);
      }

      void _M_wait_unlock(memory_order __o) const noexcept {
        ;
        auto __v = _M_val.fetch_sub(1, memory_order_relaxed);
        ;
        _M_val.wait(__v & ~_S_lock_bit, __o);
      }

      void notify_one() noexcept {
        ;
        _M_val.notify_one();
        ;
      }

      void notify_all() noexcept {
        ;
        _M_val.notify_all();
        ;
      }

    private:
      mutable __atomic_base<uintptr_t> _M_val{0};
      static constexpr uintptr_t _S_lock_bit{1};
    };

    typename _Tp::element_type *_M_ptr = nullptr;
    _Atomic_count _M_refcount;

    static typename _Atomic_count::pointer
    _S_add_ref(typename _Atomic_count::pointer __p) {
      if (__p) {
        if constexpr (__is_shared_ptr<_Tp>)
          __p->_M_add_ref_copy();
        else
          __p->_M_weak_add_ref();
      }
      return __p;
    }

    constexpr _Sp_atomic() noexcept = default;

    explicit _Sp_atomic(value_type __r) noexcept
        : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount)) {}

    ~_Sp_atomic() = default;

    _Sp_atomic(const _Sp_atomic &) = delete;
    void operator=(const _Sp_atomic &) = delete;

    value_type load(memory_order __o) const noexcept {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__o != memory_order_release && __o != memory_order_acq_rel))
          __builtin_unreachable();
      } while (false);

      if (__o != memory_order_seq_cst)
        __o = memory_order_acquire;

      value_type __ret;
      auto __pi = _M_refcount.lock(__o);
      __ret._M_ptr = _M_ptr;
      __ret._M_refcount._M_pi = _S_add_ref(__pi);
      _M_refcount.unlock(memory_order_relaxed);
      return __ret;
    }

    void swap(value_type &__r, memory_order __o) noexcept {
      _M_refcount.lock(memory_order_acquire);
      std::swap(_M_ptr, __r._M_ptr);
      _M_refcount._M_swap_unlock(__r._M_refcount, __o);
    }

    bool compare_exchange_strong(value_type &__expected, value_type __desired,
                                 memory_order __o, memory_order __o2) noexcept {
      bool __result = true;
      auto __pi = _M_refcount.lock(memory_order_acquire);
      if (_M_ptr == __expected._M_ptr && __pi == __expected._M_refcount._M_pi) {
        _M_ptr = __desired._M_ptr;
        _M_refcount._M_swap_unlock(__desired._M_refcount, __o);
      } else {
        _Tp __sink = std::move(__expected);
        __expected._M_ptr = _M_ptr;
        __expected._M_refcount._M_pi = _S_add_ref(__pi);
        _M_refcount.unlock(__o2);
        __result = false;
      }
      return __result;
    }

    void wait(value_type __old, memory_order __o) const noexcept {
      auto __pi = _M_refcount.lock(memory_order_acquire);
      if (_M_ptr == __old._M_ptr && __pi == __old._M_refcount._M_pi)
        _M_refcount._M_wait_unlock(__o);
      else
        _M_refcount.unlock(memory_order_relaxed);
    }

    void notify_one() noexcept { _M_refcount.notify_one(); }

    void notify_all() noexcept { _M_refcount.notify_all(); }
  };

  template <typename _Tp> struct atomic<shared_ptr<_Tp>> {
  public:
    using value_type = shared_ptr<_Tp>;

    static constexpr bool is_always_lock_free = false;

    bool is_lock_free() const noexcept { return false; }

    constexpr atomic() noexcept = default;

    constexpr atomic(nullptr_t) noexcept : atomic() {}

    atomic(shared_ptr<_Tp> __r) noexcept : _M_impl(std::move(__r)) {}

    atomic(const atomic &) = delete;
    void operator=(const atomic &) = delete;

    shared_ptr<_Tp>
    load(memory_order __o = memory_order_seq_cst) const noexcept {
      return _M_impl.load(__o);
    }

    operator shared_ptr<_Tp>() const noexcept {
      return _M_impl.load(memory_order_seq_cst);
    }

    void store(shared_ptr<_Tp> __desired,
               memory_order __o = memory_order_seq_cst) noexcept {
      _M_impl.swap(__desired, __o);
    }

    void operator=(shared_ptr<_Tp> __desired) noexcept {
      _M_impl.swap(__desired, memory_order_seq_cst);
    }

    void operator=(nullptr_t) noexcept { store(nullptr); }

    shared_ptr<_Tp> exchange(shared_ptr<_Tp> __desired,
                             memory_order __o = memory_order_seq_cst) noexcept {
      _M_impl.swap(__desired, __o);
      return __desired;
    }

    bool compare_exchange_strong(shared_ptr<_Tp> &__expected,
                                 shared_ptr<_Tp> __desired, memory_order __o,
                                 memory_order __o2) noexcept {
      return _M_impl.compare_exchange_strong(__expected, __desired, __o, __o2);
    }

    bool
    compare_exchange_strong(value_type &__expected, value_type __desired,
                            memory_order __o = memory_order_seq_cst) noexcept {
      memory_order __o2;
      switch (__o) {
      case memory_order_acq_rel:
        __o2 = memory_order_acquire;
        break;
      case memory_order_release:
        __o2 = memory_order_relaxed;
        break;
      default:
        __o2 = __o;
      }
      return compare_exchange_strong(__expected, std::move(__desired), __o,
                                     __o2);
    }

    bool compare_exchange_weak(value_type &__expected, value_type __desired,
                               memory_order __o, memory_order __o2) noexcept {
      return compare_exchange_strong(__expected, std::move(__desired), __o,
                                     __o2);
    }

    bool
    compare_exchange_weak(value_type &__expected, value_type __desired,
                          memory_order __o = memory_order_seq_cst) noexcept {
      return compare_exchange_strong(__expected, std::move(__desired), __o);
    }

    void wait(value_type __old,
              memory_order __o = memory_order_seq_cst) const noexcept {
      _M_impl.wait(std::move(__old), __o);
    }

    void notify_one() noexcept { _M_impl.notify_one(); }

    void notify_all() noexcept { _M_impl.notify_all(); }

  private:
    _Sp_atomic<shared_ptr<_Tp>> _M_impl;
  };

  template <typename _Tp> struct atomic<weak_ptr<_Tp>> {
  public:
    using value_type = weak_ptr<_Tp>;

    static constexpr bool is_always_lock_free = false;

    bool is_lock_free() const noexcept { return false; }

    constexpr atomic() noexcept = default;

    atomic(weak_ptr<_Tp> __r) noexcept : _M_impl(move(__r)) {}

    atomic(const atomic &) = delete;
    void operator=(const atomic &) = delete;

    weak_ptr<_Tp> load(memory_order __o = memory_order_seq_cst) const noexcept {
      return _M_impl.load(__o);
    }

    operator weak_ptr<_Tp>() const noexcept {
      return _M_impl.load(memory_order_seq_cst);
    }

    void store(weak_ptr<_Tp> __desired,
               memory_order __o = memory_order_seq_cst) noexcept {
      _M_impl.swap(__desired, __o);
    }

    void operator=(weak_ptr<_Tp> __desired) noexcept {
      _M_impl.swap(__desired, memory_order_seq_cst);
    }

    weak_ptr<_Tp> exchange(weak_ptr<_Tp> __desired,
                           memory_order __o = memory_order_seq_cst) noexcept {
      _M_impl.swap(__desired, __o);
      return __desired;
    }

    bool compare_exchange_strong(weak_ptr<_Tp> &__expected,
                                 weak_ptr<_Tp> __desired, memory_order __o,
                                 memory_order __o2) noexcept {
      return _M_impl.compare_exchange_strong(__expected, __desired, __o, __o2);
    }

    bool
    compare_exchange_strong(value_type &__expected, value_type __desired,
                            memory_order __o = memory_order_seq_cst) noexcept {
      memory_order __o2;
      switch (__o) {
      case memory_order_acq_rel:
        __o2 = memory_order_acquire;
        break;
      case memory_order_release:
        __o2 = memory_order_relaxed;
        break;
      default:
        __o2 = __o;
      }
      return compare_exchange_strong(__expected, std::move(__desired), __o,
                                     __o2);
    }

    bool compare_exchange_weak(value_type &__expected, value_type __desired,
                               memory_order __o, memory_order __o2) noexcept {
      return compare_exchange_strong(__expected, std::move(__desired), __o,
                                     __o2);
    }

    bool
    compare_exchange_weak(value_type &__expected, value_type __desired,
                          memory_order __o = memory_order_seq_cst) noexcept {
      return compare_exchange_strong(__expected, std::move(__desired), __o);
    }

    void wait(value_type __old,
              memory_order __o = memory_order_seq_cst) const noexcept {
      _M_impl.wait(std::move(__old), __o);
    }

    void notify_one() noexcept { _M_impl.notify_one(); }

    void notify_all() noexcept { _M_impl.notify_all(); }

  private:
    _Sp_atomic<weak_ptr<_Tp>> _M_impl;
  };

} // namespace std
# 82 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/memory" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/auto_ptr.h" 1 3
# 36 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/auto_ptr.h" 3
namespace std __attribute__((__visibility__("default"))) {
# 47 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/auto_ptr.h" 3
  template <typename _Tp1> struct auto_ptr_ref {
    _Tp1 *_M_ptr;

    explicit auto_ptr_ref(_Tp1 *__p) : _M_ptr(__p) {}
  } __attribute__((__deprecated__));

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 92 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/auto_ptr.h" 3
  template <typename _Tp> class auto_ptr {
  private:
    _Tp *_M_ptr;

  public:
    typedef _Tp element_type;

    explicit auto_ptr(element_type *__p = 0) throw() : _M_ptr(__p) {}
# 118 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/auto_ptr.h" 3
    auto_ptr(auto_ptr &__a) throw() : _M_ptr(__a.release()) {}
# 130 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/auto_ptr.h" 3
    template <typename _Tp1>
    auto_ptr(auto_ptr<_Tp1> &__a) throw() : _M_ptr(__a.release()) {}
# 141 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/auto_ptr.h" 3
    auto_ptr &operator=(auto_ptr &__a) throw() {
      reset(__a.release());
      return *this;
    }
# 158 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/auto_ptr.h" 3
    template <typename _Tp1> auto_ptr &operator=(auto_ptr<_Tp1> &__a) throw() {
      reset(__a.release());
      return *this;
    }
# 176 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/auto_ptr.h" 3
    ~auto_ptr() { delete _M_ptr; }
# 186 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/auto_ptr.h" 3
    element_type &operator*() const throw() {
      do {
        if (std::__is_constant_evaluated() && !bool(_M_ptr != 0))
          __builtin_unreachable();
      } while (false);
      return *_M_ptr;
    }

    element_type *operator->() const throw() {
      do {
        if (std::__is_constant_evaluated() && !bool(_M_ptr != 0))
          __builtin_unreachable();
      } while (false);
      return _M_ptr;
    }
# 216 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/auto_ptr.h" 3
    element_type *get() const throw() { return _M_ptr; }
# 230 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/auto_ptr.h" 3
    element_type *release() throw() {
      element_type *__tmp = _M_ptr;
      _M_ptr = 0;
      return __tmp;
    }
# 245 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/auto_ptr.h" 3
    void reset(element_type *__p = 0) throw() {
      if (__p != _M_ptr) {
        delete _M_ptr;
        _M_ptr = __p;
      }
    }
# 270 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/backward/auto_ptr.h" 3
    auto_ptr(auto_ptr_ref<element_type> __ref) throw() : _M_ptr(__ref._M_ptr) {}

    auto_ptr &operator=(auto_ptr_ref<element_type> __ref) throw() {
      if (__ref._M_ptr != this->get()) {
        delete _M_ptr;
        _M_ptr = __ref._M_ptr;
      }
      return *this;
    }

    template <typename _Tp1> operator auto_ptr_ref<_Tp1>() throw() {
      return auto_ptr_ref<_Tp1>(this->release());
    }

    template <typename _Tp1> operator auto_ptr<_Tp1>() throw() {
      return auto_ptr<_Tp1>(this->release());
    }
  } __attribute__((__deprecated__("use '"
                                  "std::unique_ptr"
                                  "' instead")));

  template <> class auto_ptr<void> {
  public:
    typedef void element_type;
  } __attribute__((__deprecated__));

  template <_Lock_policy _Lp>
  template <typename _Tp>
  inline __shared_count<_Lp>::__shared_count(std::auto_ptr<_Tp> && __r)
      : _M_pi(new _Sp_counted_ptr<_Tp *, _Lp>(__r.get())) {
    __r.release();
  }

  template <typename _Tp, _Lock_policy _Lp>
  template <typename _Tp1, typename>
  inline __shared_ptr<_Tp, _Lp>::__shared_ptr(std::auto_ptr<_Tp1> && __r)
      : _M_ptr(__r.get()), _M_refcount() {

    static_assert(sizeof(_Tp1) > 0, "incomplete type");
    _Tp1 *__tmp = __r.get();
    _M_refcount = __shared_count<_Lp>(std::move(__r));
    _M_enable_shared_from_this_with(__tmp);
  }

  template <typename _Tp>
  template <typename _Tp1, typename>
  inline shared_ptr<_Tp>::shared_ptr(std::auto_ptr<_Tp1> && __r)
      : __shared_ptr<_Tp>(std::move(__r)) {}

  template <typename _Tp, typename _Dp>
  template <typename _Up, typename>
  inline unique_ptr<_Tp, _Dp>::unique_ptr(auto_ptr<_Up> && __u) noexcept
      : _M_t(__u.release(), deleter_type()) {}

#pragma GCC diagnostic pop

} // namespace std
# 87 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/memory" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_uninitialized.h" 1 3
# 36 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_uninitialized.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_algobase.h" 1 3
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_algobase.h" 3
namespace std __attribute__((__visibility__("default"))) {

  namespace ranges {
  namespace __detail {
  template <typename _Tp> constexpr inline bool __is_normal_iterator = false;

  template <typename _Iterator, typename _Container>
  constexpr inline bool __is_normal_iterator<
      __gnu_cxx::__normal_iterator<_Iterator, _Container>> = true;

  template <typename _Tp> constexpr inline bool __is_reverse_iterator = false;

  template <typename _Iterator>
  constexpr inline bool __is_reverse_iterator<reverse_iterator<_Iterator>> =
      true;

  template <typename _Tp> constexpr inline bool __is_move_iterator = false;

  template <typename _Iterator>
  constexpr inline bool __is_move_iterator<move_iterator<_Iterator>> = true;
  } // namespace __detail

  struct __equal_fn {
    template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
              typename _Pred = ranges::equal_to, typename _Proj1 = identity,
              typename _Proj2 = identity>
      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
    constexpr bool operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2,
                              _Sent2 __last2, _Pred __pred = {},
                              _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {

      if constexpr (__detail::__is_normal_iterator<_Iter1> &&
                    same_as<_Iter1, _Sent1>)
        return (*this)(__first1.base(), __last1.base(), std::move(__first2),
                       std::move(__last2), std::move(__pred),
                       std::move(__proj1), std::move(__proj2));
      else if constexpr (__detail::__is_normal_iterator<_Iter2> &&
                         same_as<_Iter2, _Sent2>)
        return (*this)(std::move(__first1), std::move(__last1), __first2.base(),
                       __last2.base(), std::move(__pred), std::move(__proj1),
                       std::move(__proj2));
      else if constexpr (sized_sentinel_for<_Sent1, _Iter1> &&
                         sized_sentinel_for<_Sent2, _Iter2>) {
        auto __d1 = ranges::distance(__first1, __last1);
        auto __d2 = ranges::distance(__first2, __last2);
        if (__d1 != __d2)
          return false;

        using _ValueType1 = iter_value_t<_Iter1>;
        constexpr bool __use_memcmp =
            ((is_integral_v<_ValueType1> || is_pointer_v<_ValueType1>) &&
             __memcmpable<_Iter1, _Iter2>::__value &&
             is_same_v<_Pred, ranges::equal_to> &&
             is_same_v<_Proj1, identity> && is_same_v<_Proj2, identity>);
        if constexpr (__use_memcmp) {
          if (const size_t __len = (__last1 - __first1))
            return !std::__memcmp(__first1, __first2, __len);
          return true;
        } else {
          for (; __first1 != __last1; ++__first1, (void)++__first2)
            if (!(bool)std::__invoke(__pred, std::__invoke(__proj1, *__first1),
                                     std::__invoke(__proj2, *__first2)))
              return false;
          return true;
        }
      } else {
        for (; __first1 != __last1 && __first2 != __last2;
             ++__first1, (void)++__first2)
          if (!(bool)std::__invoke(__pred, std::__invoke(__proj1, *__first1),
                                   std::__invoke(__proj2, *__first2)))
            return false;
        return __first1 == __last1 && __first2 == __last2;
      }
    }

    template <input_range _Range1, input_range _Range2,
              typename _Pred = ranges::equal_to, typename _Proj1 = identity,
              typename _Proj2 = identity>
      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
                                     _Pred, _Proj1, _Proj2>
    constexpr bool operator()(_Range1 &&__r1, _Range2 &&__r2, _Pred __pred = {},
                              _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      return (*this)(ranges::begin(__r1), ranges::end(__r1),
                     ranges::begin(__r2), ranges::end(__r2), std::move(__pred),
                     std::move(__proj1), std::move(__proj2));
    }
  };

  inline constexpr __equal_fn equal{};

  template <typename _Iter, typename _Out> struct in_out_result {
    [[no_unique_address]] _Iter in;
    [[no_unique_address]] _Out out;

    template <typename _Iter2, typename _Out2>
      requires convertible_to<const _Iter &, _Iter2> &&
               convertible_to<const _Out &, _Out2>
    constexpr operator in_out_result<_Iter2, _Out2>() const & {
      return {in, out};
    }

    template <typename _Iter2, typename _Out2>
      requires convertible_to<_Iter, _Iter2> && convertible_to<_Out, _Out2>
    constexpr operator in_out_result<_Iter2, _Out2>() && {
      return {std::move(in), std::move(out)};
    }
  };

  template <typename _Iter, typename _Out>
  using copy_result = in_out_result<_Iter, _Out>;

  template <typename _Iter, typename _Out>
  using move_result = in_out_result<_Iter, _Out>;

  template <typename _Iter1, typename _Iter2>
  using move_backward_result = in_out_result<_Iter1, _Iter2>;

  template <typename _Iter1, typename _Iter2>
  using copy_backward_result = in_out_result<_Iter1, _Iter2>;

  template <bool _IsMove, bidirectional_iterator _Iter,
            sentinel_for<_Iter> _Sent, bidirectional_iterator _Out>
    requires(_IsMove ? indirectly_movable<_Iter, _Out>
                     : indirectly_copyable<_Iter, _Out>)
  constexpr __conditional_t<_IsMove, move_backward_result<_Iter, _Out>,
                            copy_backward_result<_Iter, _Out>>
  __copy_or_move_backward(_Iter __first, _Sent __last, _Out __result);

  template <bool _IsMove, input_iterator _Iter, sentinel_for<_Iter> _Sent,
            weakly_incrementable _Out>
    requires(_IsMove ? indirectly_movable<_Iter, _Out>
                     : indirectly_copyable<_Iter, _Out>)
  constexpr __conditional_t<_IsMove, move_result<_Iter, _Out>,
                            copy_result<_Iter, _Out>>
  __copy_or_move(_Iter __first, _Sent __last, _Out __result) {

    using __detail::__is_move_iterator;
    using __detail::__is_normal_iterator;
    using __detail::__is_reverse_iterator;
    if constexpr (__is_move_iterator<_Iter> && same_as<_Iter, _Sent>) {
      auto [__in, __out] = ranges::__copy_or_move<true>(
          std::move(__first).base(), std::move(__last).base(),
          std::move(__result));
      return {move_iterator{std::move(__in)}, std::move(__out)};
    } else if constexpr (__is_reverse_iterator<_Iter> &&
                         same_as<_Iter, _Sent> && __is_reverse_iterator<_Out>) {
      auto [__in, __out] = ranges::__copy_or_move_backward<_IsMove>(
          std::move(__last).base(), std::move(__first).base(),
          std::move(__result).base());
      return {reverse_iterator{std::move(__in)},
              reverse_iterator{std::move(__out)}};
    } else if constexpr (__is_normal_iterator<_Iter> && same_as<_Iter, _Sent>) {
      auto [__in, __out] = ranges::__copy_or_move<_IsMove>(
          __first.base(), __last.base(), std::move(__result));
      return {decltype(__first){__in}, std::move(__out)};
    } else if constexpr (__is_normal_iterator<_Out>) {
      auto [__in, __out] = ranges::__copy_or_move<_IsMove>(
          std::move(__first), __last, __result.base());
      return {std::move(__in), decltype(__result){__out}};
    } else if constexpr (sized_sentinel_for<_Sent, _Iter>) {
      if (!std::__is_constant_evaluated()) {
        if constexpr (__memcpyable<_Iter, _Out>::__value) {
          using _ValueTypeI = iter_value_t<_Iter>;
          static_assert(_IsMove ? is_move_assignable_v<_ValueTypeI>
                                : is_copy_assignable_v<_ValueTypeI>);
          auto __num = __last - __first;
          if (__num)
            __builtin_memmove(__result, __first, sizeof(_ValueTypeI) * __num);
          return {__first + __num, __result + __num};
        }
      }

      for (auto __n = __last - __first; __n > 0; --__n) {
        if constexpr (_IsMove)
          *__result = std::move(*__first);
        else
          *__result = *__first;
        ++__first;
        ++__result;
      }
      return {std::move(__first), std::move(__result)};
    } else {
      while (__first != __last) {
        if constexpr (_IsMove)
          *__result = std::move(*__first);
        else
          *__result = *__first;
        ++__first;
        ++__result;
      }
      return {std::move(__first), std::move(__result)};
    }
  }

  struct __copy_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              weakly_incrementable _Out>
      requires indirectly_copyable<_Iter, _Out>
    constexpr copy_result<_Iter, _Out> operator()(_Iter __first, _Sent __last,
                                                  _Out __result) const {
      return ranges::__copy_or_move<false>(
          std::move(__first), std::move(__last), std::move(__result));
    }

    template <input_range _Range, weakly_incrementable _Out>
      requires indirectly_copyable<iterator_t<_Range>, _Out>
    constexpr copy_result<borrowed_iterator_t<_Range>, _Out>
    operator()(_Range &&__r, _Out __result) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__result));
    }
  };

  inline constexpr __copy_fn copy{};

  struct __move_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              weakly_incrementable _Out>
      requires indirectly_movable<_Iter, _Out>
    constexpr move_result<_Iter, _Out> operator()(_Iter __first, _Sent __last,
                                                  _Out __result) const {
      return ranges::__copy_or_move<true>(std::move(__first), std::move(__last),
                                          std::move(__result));
    }

    template <input_range _Range, weakly_incrementable _Out>
      requires indirectly_movable<iterator_t<_Range>, _Out>
    constexpr move_result<borrowed_iterator_t<_Range>, _Out>
    operator()(_Range &&__r, _Out __result) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__result));
    }
  };

  inline constexpr __move_fn move{};

  template <bool _IsMove, bidirectional_iterator _Iter,
            sentinel_for<_Iter> _Sent, bidirectional_iterator _Out>
    requires(_IsMove ? indirectly_movable<_Iter, _Out>
                     : indirectly_copyable<_Iter, _Out>)
  constexpr __conditional_t<_IsMove, move_backward_result<_Iter, _Out>,
                            copy_backward_result<_Iter, _Out>>
  __copy_or_move_backward(_Iter __first, _Sent __last, _Out __result) {

    using __detail::__is_normal_iterator;
    using __detail::__is_reverse_iterator;
    if constexpr (__is_reverse_iterator<_Iter> && same_as<_Iter, _Sent> &&
                  __is_reverse_iterator<_Out>) {
      auto [__in, __out] = ranges::__copy_or_move<_IsMove>(
          std::move(__last).base(), std::move(__first).base(),
          std::move(__result).base());
      return {reverse_iterator{std::move(__in)},
              reverse_iterator{std::move(__out)}};
    } else if constexpr (__is_normal_iterator<_Iter> && same_as<_Iter, _Sent>) {
      auto [__in, __out] = ranges::__copy_or_move_backward<_IsMove>(
          __first.base(), __last.base(), std::move(__result));
      return {decltype(__first){__in}, std::move(__out)};
    } else if constexpr (__is_normal_iterator<_Out>) {
      auto [__in, __out] = ranges::__copy_or_move_backward<_IsMove>(
          std::move(__first), std::move(__last), __result.base());
      return {std::move(__in), decltype(__result){__out}};
    } else if constexpr (sized_sentinel_for<_Sent, _Iter>) {
      if (!std::__is_constant_evaluated()) {
        if constexpr (__memcpyable<_Out, _Iter>::__value) {
          using _ValueTypeI = iter_value_t<_Iter>;
          static_assert(_IsMove ? is_move_assignable_v<_ValueTypeI>
                                : is_copy_assignable_v<_ValueTypeI>);
          auto __num = __last - __first;
          if (__num)
            __builtin_memmove(__result - __num, __first,
                              sizeof(_ValueTypeI) * __num);
          return {__first + __num, __result - __num};
        }
      }

      auto __lasti = ranges::next(__first, __last);
      auto __tail = __lasti;

      for (auto __n = __last - __first; __n > 0; --__n) {
        --__tail;
        --__result;
        if constexpr (_IsMove)
          *__result = std::move(*__tail);
        else
          *__result = *__tail;
      }
      return {std::move(__lasti), std::move(__result)};
    } else {
      auto __lasti = ranges::next(__first, __last);
      auto __tail = __lasti;

      while (__first != __tail) {
        --__tail;
        --__result;
        if constexpr (_IsMove)
          *__result = std::move(*__tail);
        else
          *__result = *__tail;
      }
      return {std::move(__lasti), std::move(__result)};
    }
  }

  struct __copy_backward_fn {
    template <bidirectional_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              bidirectional_iterator _Iter2>
      requires indirectly_copyable<_Iter1, _Iter2>
    constexpr copy_backward_result<_Iter1, _Iter2>
    operator()(_Iter1 __first, _Sent1 __last, _Iter2 __result) const {
      return ranges::__copy_or_move_backward<false>(
          std::move(__first), std::move(__last), std::move(__result));
    }

    template <bidirectional_range _Range, bidirectional_iterator _Iter>
      requires indirectly_copyable<iterator_t<_Range>, _Iter>
    constexpr copy_backward_result<borrowed_iterator_t<_Range>, _Iter>
    operator()(_Range &&__r, _Iter __result) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__result));
    }
  };

  inline constexpr __copy_backward_fn copy_backward{};

  struct __move_backward_fn {
    template <bidirectional_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              bidirectional_iterator _Iter2>
      requires indirectly_movable<_Iter1, _Iter2>
    constexpr move_backward_result<_Iter1, _Iter2>
    operator()(_Iter1 __first, _Sent1 __last, _Iter2 __result) const {
      return ranges::__copy_or_move_backward<true>(
          std::move(__first), std::move(__last), std::move(__result));
    }

    template <bidirectional_range _Range, bidirectional_iterator _Iter>
      requires indirectly_movable<iterator_t<_Range>, _Iter>
    constexpr move_backward_result<borrowed_iterator_t<_Range>, _Iter>
    operator()(_Range &&__r, _Iter __result) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__result));
    }
  };

  inline constexpr __move_backward_fn move_backward{};

  template <typename _Iter, typename _Out>
  using copy_n_result = in_out_result<_Iter, _Out>;

  struct __copy_n_fn {
    template <input_iterator _Iter, weakly_incrementable _Out>
      requires indirectly_copyable<_Iter, _Out>
    constexpr copy_n_result<_Iter, _Out>
    operator()(_Iter __first, iter_difference_t<_Iter> __n,
               _Out __result) const {
      if constexpr (random_access_iterator<_Iter>) {
        if (__n > 0)
          return ranges::copy(__first, __first + __n, std::move(__result));
      } else {
        for (; __n > 0; --__n, (void)++__result, (void)++__first)
          *__result = *__first;
      }
      return {std::move(__first), std::move(__result)};
    }
  };

  inline constexpr __copy_n_fn copy_n{};

  struct __fill_n_fn {
    template <typename _Tp, output_iterator<const _Tp &> _Out>
    constexpr _Out operator()(_Out __first, iter_difference_t<_Out> __n,
                              const _Tp &__value) const {

      if (__n <= 0)
        return __first;

      if constexpr (is_scalar_v<_Tp>) {

        if constexpr (is_pointer_v<_Out>

                      && __is_byte<remove_pointer_t<_Out>>::__value &&
                      integral<_Tp>) {
          if (!std::__is_constant_evaluated()) {
            __builtin_memset(__first, static_cast<unsigned char>(__value), __n);
            return __first + __n;
          }
        }

        const auto __tmp = __value;
        for (; __n > 0; --__n, (void)++__first)
          *__first = __tmp;
        return __first;
      } else {
        for (; __n > 0; --__n, (void)++__first)
          *__first = __value;
        return __first;
      }
    }
  };

  inline constexpr __fill_n_fn fill_n{};

  struct __fill_fn {
    template <typename _Tp, output_iterator<const _Tp &> _Out,
              sentinel_for<_Out> _Sent>
    constexpr _Out operator()(_Out __first, _Sent __last,
                              const _Tp &__value) const {

      if constexpr (sized_sentinel_for<_Sent, _Out>) {
        const auto __len = __last - __first;
        return ranges::fill_n(__first, __len, __value);
      } else if constexpr (is_scalar_v<_Tp>) {
        const auto __tmp = __value;
        for (; __first != __last; ++__first)
          *__first = __tmp;
        return __first;
      } else {
        for (; __first != __last; ++__first)
          *__first = __value;
        return __first;
      }
    }

    template <typename _Tp, output_range<const _Tp &> _Range>
    constexpr borrowed_iterator_t<_Range> operator()(_Range &&__r,
                                                     const _Tp &__value) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), __value);
    }
  };

  inline constexpr __fill_fn fill{};
  } // namespace ranges

} // namespace std
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_uninitialized.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  namespace ranges {
  namespace __detail {
  template <typename _Tp> constexpr void *__voidify(_Tp &__obj) noexcept {
    return const_cast<void *>(
        static_cast<const volatile void *>(std::__addressof(__obj)));
  }

  template <typename _Iter>
  concept __nothrow_input_iterator =
      (input_iterator<_Iter> &&
       is_lvalue_reference_v<iter_reference_t<_Iter>> &&
       same_as<remove_cvref_t<iter_reference_t<_Iter>>, iter_value_t<_Iter>>);

  template <typename _Sent, typename _Iter>
  concept __nothrow_sentinel = sentinel_for<_Sent, _Iter>;

  template <typename _Range>
  concept __nothrow_input_range =
      (range<_Range> && __nothrow_input_iterator<iterator_t<_Range>> &&
       __nothrow_sentinel<sentinel_t<_Range>, iterator_t<_Range>>);

  template <typename _Iter>
  concept __nothrow_forward_iterator =
      (__nothrow_input_iterator<_Iter> && forward_iterator<_Iter> &&
       __nothrow_sentinel<_Iter, _Iter>);

  template <typename _Range>
  concept __nothrow_forward_range =
      (__nothrow_input_range<_Range> &&
       __nothrow_forward_iterator<iterator_t<_Range>>);
  } // namespace __detail

  struct __destroy_fn {
    template <__detail::__nothrow_input_iterator _Iter,
              __detail::__nothrow_sentinel<_Iter> _Sent>
      requires destructible<iter_value_t<_Iter>>
    constexpr _Iter operator()(_Iter __first, _Sent __last) const noexcept;

    template <__detail::__nothrow_input_range _Range>
      requires destructible<range_value_t<_Range>>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r) const noexcept;
  };

  inline constexpr __destroy_fn destroy{};

  namespace __detail {
  template <typename _Iter>
    requires destructible<iter_value_t<_Iter>>
  struct _DestroyGuard {
  private:
    _Iter _M_first;
    const _Iter *_M_cur;

  public:
    explicit _DestroyGuard(const _Iter &__iter)
        : _M_first(__iter), _M_cur(std::__addressof(__iter)) {}

    void release() noexcept { _M_cur = nullptr; }

    ~_DestroyGuard() {
      if (_M_cur != nullptr)
        ranges::destroy(std::move(_M_first), *_M_cur);
    }
  };

  template <typename _Iter>
    requires destructible<iter_value_t<_Iter>> &&
             is_trivially_destructible_v<iter_value_t<_Iter>>
  struct _DestroyGuard<_Iter> {
    explicit _DestroyGuard(const _Iter &) {}

    void release() noexcept {}
  };
  } // namespace __detail

  struct __uninitialized_default_construct_fn {
    template <__detail::__nothrow_forward_iterator _Iter,
              __detail::__nothrow_sentinel<_Iter> _Sent>
      requires default_initializable<iter_value_t<_Iter>>
    _Iter operator()(_Iter __first, _Sent __last) const {
      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;
      if constexpr (is_trivially_default_constructible_v<_ValueType>)
        return ranges::next(__first, __last);
      else {
        auto __guard = __detail::_DestroyGuard(__first);
        for (; __first != __last; ++__first)
          ::new (__detail::__voidify(*__first)) _ValueType;
        __guard.release();
        return __first;
      }
    }

    template <__detail::__nothrow_forward_range _Range>
      requires default_initializable<range_value_t<_Range>>
    borrowed_iterator_t<_Range> operator()(_Range &&__r) const {
      return (*this)(ranges::begin(__r), ranges::end(__r));
    }
  };

  inline constexpr __uninitialized_default_construct_fn
      uninitialized_default_construct{};

  struct __uninitialized_default_construct_n_fn {
    template <__detail::__nothrow_forward_iterator _Iter>
      requires default_initializable<iter_value_t<_Iter>>
    _Iter operator()(_Iter __first, iter_difference_t<_Iter> __n) const {
      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;
      if constexpr (is_trivially_default_constructible_v<_ValueType>)
        return ranges::next(__first, __n);
      else {
        auto __guard = __detail::_DestroyGuard(__first);
        for (; __n > 0; ++__first, (void)--__n)
          ::new (__detail::__voidify(*__first)) _ValueType;
        __guard.release();
        return __first;
      }
    }
  };

  inline constexpr __uninitialized_default_construct_n_fn
      uninitialized_default_construct_n;

  struct __uninitialized_value_construct_fn {
    template <__detail::__nothrow_forward_iterator _Iter,
              __detail::__nothrow_sentinel<_Iter> _Sent>
      requires default_initializable<iter_value_t<_Iter>>
    _Iter operator()(_Iter __first, _Sent __last) const {
      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;
      if constexpr (is_trivial_v<_ValueType> &&
                    is_copy_assignable_v<_ValueType>)
        return ranges::fill(__first, __last, _ValueType());
      else {
        auto __guard = __detail::_DestroyGuard(__first);
        for (; __first != __last; ++__first)
          ::new (__detail::__voidify(*__first)) _ValueType();
        __guard.release();
        return __first;
      }
    }

    template <__detail::__nothrow_forward_range _Range>
      requires default_initializable<range_value_t<_Range>>
    borrowed_iterator_t<_Range> operator()(_Range &&__r) const {
      return (*this)(ranges::begin(__r), ranges::end(__r));
    }
  };

  inline constexpr __uninitialized_value_construct_fn
      uninitialized_value_construct{};

  struct __uninitialized_value_construct_n_fn {
    template <__detail::__nothrow_forward_iterator _Iter>
      requires default_initializable<iter_value_t<_Iter>>
    _Iter operator()(_Iter __first, iter_difference_t<_Iter> __n) const {
      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;
      if constexpr (is_trivial_v<_ValueType> &&
                    is_copy_assignable_v<_ValueType>)
        return ranges::fill_n(__first, __n, _ValueType());
      else {
        auto __guard = __detail::_DestroyGuard(__first);
        for (; __n > 0; ++__first, (void)--__n)
          ::new (__detail::__voidify(*__first)) _ValueType();
        __guard.release();
        return __first;
      }
    }
  };

  inline constexpr __uninitialized_value_construct_n_fn
      uninitialized_value_construct_n;

  template <typename _Iter, typename _Out>
  using uninitialized_copy_result = in_out_result<_Iter, _Out>;

  struct __uninitialized_copy_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _ISent,
              __detail::__nothrow_forward_iterator _Out,
              __detail::__nothrow_sentinel<_Out> _OSent>
      requires constructible_from<iter_value_t<_Out>, iter_reference_t<_Iter>>
    uninitialized_copy_result<_Iter, _Out>
    operator()(_Iter __ifirst, _ISent __ilast, _Out __ofirst,
               _OSent __olast) const {
      using _OutType = remove_reference_t<iter_reference_t<_Out>>;
      if constexpr (sized_sentinel_for<_ISent, _Iter> &&
                    sized_sentinel_for<_OSent, _Out> &&
                    is_trivial_v<_OutType> &&
                    is_nothrow_assignable_v<_OutType &,
                                            iter_reference_t<_Iter>>) {
        auto __d1 = __ilast - __ifirst;
        auto __d2 = __olast - __ofirst;
        return ranges::copy_n(std::move(__ifirst), std::min(__d1, __d2),
                              __ofirst);
      } else {
        auto __guard = __detail::_DestroyGuard(__ofirst);
        for (; __ifirst != __ilast && __ofirst != __olast;
             ++__ofirst, (void)++__ifirst)
          ::new (__detail::__voidify(*__ofirst)) _OutType(*__ifirst);
        __guard.release();
        return {std::move(__ifirst), __ofirst};
      }
    }

    template <input_range _IRange, __detail::__nothrow_forward_range _ORange>
      requires constructible_from<range_value_t<_ORange>,
                                  range_reference_t<_IRange>>
    uninitialized_copy_result<borrowed_iterator_t<_IRange>,
                              borrowed_iterator_t<_ORange>>
    operator()(_IRange &&__inr, _ORange &&__outr) const {
      return (*this)(ranges::begin(__inr), ranges::end(__inr),
                     ranges::begin(__outr), ranges::end(__outr));
    }
  };

  inline constexpr __uninitialized_copy_fn uninitialized_copy{};

  template <typename _Iter, typename _Out>
  using uninitialized_copy_n_result = in_out_result<_Iter, _Out>;

  struct __uninitialized_copy_n_fn {
    template <input_iterator _Iter, __detail::__nothrow_forward_iterator _Out,
              __detail::__nothrow_sentinel<_Out> _Sent>
      requires constructible_from<iter_value_t<_Out>, iter_reference_t<_Iter>>
    uninitialized_copy_n_result<_Iter, _Out>
    operator()(_Iter __ifirst, iter_difference_t<_Iter> __n, _Out __ofirst,
               _Sent __olast) const {
      using _OutType = remove_reference_t<iter_reference_t<_Out>>;
      if constexpr (sized_sentinel_for<_Sent, _Out> && is_trivial_v<_OutType> &&
                    is_nothrow_assignable_v<_OutType &,
                                            iter_reference_t<_Iter>>) {
        auto __d = __olast - __ofirst;
        return ranges::copy_n(std::move(__ifirst), std::min(__n, __d),
                              __ofirst);
      } else {
        auto __guard = __detail::_DestroyGuard(__ofirst);
        for (; __n > 0 && __ofirst != __olast;
             ++__ofirst, (void)++__ifirst, (void)--__n)
          ::new (__detail::__voidify(*__ofirst)) _OutType(*__ifirst);
        __guard.release();
        return {std::move(__ifirst), __ofirst};
      }
    }
  };

  inline constexpr __uninitialized_copy_n_fn uninitialized_copy_n{};

  template <typename _Iter, typename _Out>
  using uninitialized_move_result = in_out_result<_Iter, _Out>;

  struct __uninitialized_move_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _ISent,
              __detail::__nothrow_forward_iterator _Out,
              __detail::__nothrow_sentinel<_Out> _OSent>
      requires constructible_from<iter_value_t<_Out>,
                                  iter_rvalue_reference_t<_Iter>>
    uninitialized_move_result<_Iter, _Out>
    operator()(_Iter __ifirst, _ISent __ilast, _Out __ofirst,
               _OSent __olast) const {
      using _OutType = remove_reference_t<iter_reference_t<_Out>>;
      if constexpr (sized_sentinel_for<_ISent, _Iter> &&
                    sized_sentinel_for<_OSent, _Out> &&
                    is_trivial_v<_OutType> &&
                    is_nothrow_assignable_v<_OutType &,
                                            iter_rvalue_reference_t<_Iter>>) {
        auto __d1 = __ilast - __ifirst;
        auto __d2 = __olast - __ofirst;
        auto [__in, __out] =
            ranges::copy_n(std::make_move_iterator(std::move(__ifirst)),
                           std::min(__d1, __d2), __ofirst);
        return {std::move(__in).base(), __out};
      } else {
        auto __guard = __detail::_DestroyGuard(__ofirst);
        for (; __ifirst != __ilast && __ofirst != __olast;
             ++__ofirst, (void)++__ifirst)
          ::new (__detail::__voidify(*__ofirst))
              _OutType(ranges::iter_move(__ifirst));
        __guard.release();
        return {std::move(__ifirst), __ofirst};
      }
    }

    template <input_range _IRange, __detail::__nothrow_forward_range _ORange>
      requires constructible_from<range_value_t<_ORange>,
                                  range_rvalue_reference_t<_IRange>>
    uninitialized_move_result<borrowed_iterator_t<_IRange>,
                              borrowed_iterator_t<_ORange>>
    operator()(_IRange &&__inr, _ORange &&__outr) const {
      return (*this)(ranges::begin(__inr), ranges::end(__inr),
                     ranges::begin(__outr), ranges::end(__outr));
    }
  };

  inline constexpr __uninitialized_move_fn uninitialized_move{};

  template <typename _Iter, typename _Out>
  using uninitialized_move_n_result = in_out_result<_Iter, _Out>;

  struct __uninitialized_move_n_fn {
    template <input_iterator _Iter, __detail::__nothrow_forward_iterator _Out,
              __detail::__nothrow_sentinel<_Out> _Sent>
      requires constructible_from<iter_value_t<_Out>,
                                  iter_rvalue_reference_t<_Iter>>
    uninitialized_move_n_result<_Iter, _Out>
    operator()(_Iter __ifirst, iter_difference_t<_Iter> __n, _Out __ofirst,
               _Sent __olast) const {
      using _OutType = remove_reference_t<iter_reference_t<_Out>>;
      if constexpr (sized_sentinel_for<_Sent, _Out> && is_trivial_v<_OutType> &&
                    is_nothrow_assignable_v<_OutType &,
                                            iter_rvalue_reference_t<_Iter>>) {
        auto __d = __olast - __ofirst;
        auto [__in, __out] =
            ranges::copy_n(std::make_move_iterator(std::move(__ifirst)),
                           std::min(__n, __d), __ofirst);
        return {std::move(__in).base(), __out};
      } else {
        auto __guard = __detail::_DestroyGuard(__ofirst);
        for (; __n > 0 && __ofirst != __olast;
             ++__ofirst, (void)++__ifirst, (void)--__n)
          ::new (__detail::__voidify(*__ofirst))
              _OutType(ranges::iter_move(__ifirst));
        __guard.release();
        return {std::move(__ifirst), __ofirst};
      }
    }
  };

  inline constexpr __uninitialized_move_n_fn uninitialized_move_n{};

  struct __uninitialized_fill_fn {
    template <__detail::__nothrow_forward_iterator _Iter,
              __detail::__nothrow_sentinel<_Iter> _Sent, typename _Tp>
      requires constructible_from<iter_value_t<_Iter>, const _Tp &>
    _Iter operator()(_Iter __first, _Sent __last, const _Tp &__x) const {
      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;
      if constexpr (is_trivial_v<_ValueType> &&
                    is_nothrow_assignable_v<_ValueType &, const _Tp &>)
        return ranges::fill(__first, __last, __x);
      else {
        auto __guard = __detail::_DestroyGuard(__first);
        for (; __first != __last; ++__first)
          ::new (__detail::__voidify(*__first)) _ValueType(__x);
        __guard.release();
        return __first;
      }
    }

    template <__detail::__nothrow_forward_range _Range, typename _Tp>
      requires constructible_from<range_value_t<_Range>, const _Tp &>
    borrowed_iterator_t<_Range> operator()(_Range &&__r, const _Tp &__x) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), __x);
    }
  };

  inline constexpr __uninitialized_fill_fn uninitialized_fill{};

  struct __uninitialized_fill_n_fn {
    template <__detail::__nothrow_forward_iterator _Iter, typename _Tp>
      requires constructible_from<iter_value_t<_Iter>, const _Tp &>
    _Iter operator()(_Iter __first, iter_difference_t<_Iter> __n,
                     const _Tp &__x) const {
      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;
      if constexpr (is_trivial_v<_ValueType> &&
                    is_nothrow_assignable_v<_ValueType &, const _Tp &>)
        return ranges::fill_n(__first, __n, __x);
      else {
        auto __guard = __detail::_DestroyGuard(__first);
        for (; __n > 0; ++__first, (void)--__n)
          ::new (__detail::__voidify(*__first)) _ValueType(__x);
        __guard.release();
        return __first;
      }
    }
  };

  inline constexpr __uninitialized_fill_n_fn uninitialized_fill_n{};

  struct __construct_at_fn {
    template <typename _Tp, typename... _Args>
      requires requires {
        ::new (std::declval<void *>()) _Tp(std::declval<_Args>()...);
      }
    constexpr _Tp *operator()(_Tp *__location, _Args &&...__args) const
        noexcept(noexcept(std::construct_at(__location,
                                            std::forward<_Args>(__args)...))) {
      return std::construct_at(__location, std::forward<_Args>(__args)...);
    }
  };

  inline constexpr __construct_at_fn construct_at{};

  struct __destroy_at_fn {
    template <destructible _Tp>
    constexpr void operator()(_Tp *__location) const noexcept {
      if constexpr (is_array_v<_Tp>)
        ranges::destroy(ranges::begin(*__location), ranges::end(*__location));
      else
        __location->~_Tp();
    }
  };

  inline constexpr __destroy_at_fn destroy_at{};

  template <__detail::__nothrow_input_iterator _Iter,
            __detail::__nothrow_sentinel<_Iter> _Sent>
    requires destructible<iter_value_t<_Iter>>
  constexpr _Iter __destroy_fn::operator()(_Iter __first,
                                           _Sent __last) const noexcept {
    if constexpr (is_trivially_destructible_v<iter_value_t<_Iter>>)
      return ranges::next(std::move(__first), __last);
    else {
      for (; __first != __last; ++__first)
        ranges::destroy_at(std::__addressof(*__first));
      return __first;
    }
  }

  template <__detail::__nothrow_input_range _Range>
    requires destructible<range_value_t<_Range>>
  constexpr borrowed_iterator_t<_Range>
  __destroy_fn::operator()(_Range &&__r) const noexcept {
    return (*this)(ranges::begin(__r), ranges::end(__r));
  }

  struct __destroy_n_fn {
    template <__detail::__nothrow_input_iterator _Iter>
      requires destructible<iter_value_t<_Iter>>
    constexpr _Iter operator()(_Iter __first,
                               iter_difference_t<_Iter> __n) const noexcept {
      if constexpr (is_trivially_destructible_v<iter_value_t<_Iter>>)
        return ranges::next(std::move(__first), __n);
      else {
        for (; __n > 0; ++__first, (void)--__n)
          ranges::destroy_at(std::__addressof(*__first));
        return __first;
      }
    }
  };

  inline constexpr __destroy_n_fn destroy_n{};
  } // namespace ranges

} // namespace std
# 91 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/memory" 2 3
# 101 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/memory" 3
namespace std __attribute__((__visibility__("default"))) {
# 119 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/memory" 3
  enum class pointer_safety { relaxed, preferred, strict };

  inline void declare_reachable(void *) {}

  template <typename _Tp> inline _Tp *undeclare_reachable(_Tp * __p) {
    return __p;
  }

  inline void declare_no_pointers(char *, size_t) {}

  inline void undeclare_no_pointers(char *, size_t) {}

  inline pointer_safety get_pointer_safety() noexcept {
    return pointer_safety::relaxed;
  }

} // namespace std
# 154 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/memory" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_memory_defs.h" 1 3
# 13 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_memory_defs.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/execution_defs.h" 1 3
# 15 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/execution_defs.h" 3
namespace __pstl {
namespace execution {
inline namespace v1 {

class sequenced_policy {
public:
  static constexpr std::false_type __allow_unsequenced() {
    return std::false_type{};
  }
  static constexpr std::false_type __allow_vector() {
    return std::false_type{};
  }
  static constexpr std::false_type __allow_parallel() {
    return std::false_type{};
  }
};

class parallel_policy {
public:
  static constexpr std::false_type __allow_unsequenced() {
    return std::false_type{};
  }
  static constexpr std::false_type __allow_vector() {
    return std::false_type{};
  }
  static constexpr std::true_type __allow_parallel() {
    return std::true_type{};
  }
};

class parallel_unsequenced_policy {
public:
  static constexpr std::true_type __allow_unsequenced() {
    return std::true_type{};
  }
  static constexpr std::true_type __allow_vector() { return std::true_type{}; }
  static constexpr std::true_type __allow_parallel() {
    return std::true_type{};
  }
};

class unsequenced_policy {
public:
  static constexpr std::true_type __allow_unsequenced() {
    return std::true_type{};
  }
  static constexpr std::true_type __allow_vector() { return std::true_type{}; }
  static constexpr std::false_type __allow_parallel() {
    return std::false_type{};
  }
};

inline constexpr sequenced_policy seq{};
inline constexpr parallel_policy par{};
inline constexpr parallel_unsequenced_policy par_unseq{};
inline constexpr unsequenced_policy unseq{};

template <class _Tp> struct is_execution_policy : std::false_type {};

template <>
struct is_execution_policy<__pstl::execution::sequenced_policy>
    : std::true_type {};
template <>
struct is_execution_policy<__pstl::execution::parallel_policy>
    : std::true_type {};
template <>
struct is_execution_policy<__pstl::execution::parallel_unsequenced_policy>
    : std::true_type {};
template <>
struct is_execution_policy<__pstl::execution::unsequenced_policy>
    : std::true_type {};

template <class _Tp>
constexpr bool is_execution_policy_v =
    __pstl::execution::is_execution_policy<_Tp>::value;

} // namespace v1
} // namespace execution

namespace __internal {
template <class _ExecPolicy, class _Tp>

using __enable_if_execution_policy =
    typename std::enable_if<__pstl::execution::is_execution_policy<
                                std::__remove_cvref_t<_ExecPolicy>>::value,
                            _Tp>::type;

}

} // namespace __pstl
# 14 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_memory_defs.h" 2 3

namespace std {

template <class _ExecutionPolicy, class _InputIterator, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
uninitialized_copy(_ExecutionPolicy &&__exec, _InputIterator __first,
                   _InputIterator __last, _ForwardIterator __result);

template <class _ExecutionPolicy, class _InputIterator, class _Size,
          class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
uninitialized_copy_n(_ExecutionPolicy &&__exec, _InputIterator __first,
                     _Size __n, _ForwardIterator __result);

template <class _ExecutionPolicy, class _InputIterator, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
uninitialized_move(_ExecutionPolicy &&__exec, _InputIterator __first,
                   _InputIterator __last, _ForwardIterator __result);

template <class _ExecutionPolicy, class _InputIterator, class _Size,
          class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
uninitialized_move_n(_ExecutionPolicy &&__exec, _InputIterator __first,
                     _Size __n, _ForwardIterator __result);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
uninitialized_fill(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                   _ForwardIterator __last, const _Tp &__value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
uninitialized_fill_n(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                     _Size __n, const _Tp &__value);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
destroy(_ExecutionPolicy &&__exec, _ForwardIterator __first,
        _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
destroy_n(_ExecutionPolicy &&__exec, _ForwardIterator __first, _Size __n);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
uninitialized_default_construct(_ExecutionPolicy &&__exec,
                                _ForwardIterator __first,
                                _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
uninitialized_default_construct_n(_ExecutionPolicy &&__exec,
                                  _ForwardIterator __first, _Size __n);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
uninitialized_value_construct(_ExecutionPolicy &&__exec,
                              _ForwardIterator __first,
                              _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
uninitialized_value_construct_n(_ExecutionPolicy &&__exec,
                                _ForwardIterator __first, _Size __n);

} // namespace std
# 155 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/memory" 2 3
# 25 "./../stdexec/include/stdexec/__detail/__variant.hpp" 2
# 35 "./../stdexec/include/stdexec/__detail/__variant.hpp"
#pragma GCC diagnostic push
# 35 "./../stdexec/include/stdexec/__detail/__variant.hpp"
#pragma GCC diagnostic ignored "-Wpragmas"
# 35 "./../stdexec/include/stdexec/__detail/__variant.hpp"
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
# 35 "./../stdexec/include/stdexec/__detail/__variant.hpp"
#pragma GCC diagnostic ignored "-Wunknown-warning-option"
# 35 "./../stdexec/include/stdexec/__detail/__variant.hpp"
#pragma GCC diagnostic ignored "-Wunknown-attributes"
# 35 "./../stdexec/include/stdexec/__detail/__variant.hpp"
#pragma GCC diagnostic ignored "-Wattributes"
#pragma GCC diagnostic ignored "-Wmissing-braces"

namespace stdexec {

inline constexpr std::size_t __variant_npos = ~0UL;

struct __monostate {};

namespace __var {

inline auto __mk_index_guard(std::size_t &__index, std::size_t __new) noexcept {
  __index = __new;
  return __scope_guard{[&__index]() noexcept { __index = __variant_npos; }};
}

template <auto _Idx, class... _Ts> class __variant;

template <> class __variant<__indices<>{}> {
public:
  template <class _Fn, class... _Us>

  void visit(_Fn &&, _Us &&...) const noexcept {
    do {
      static_assert(noexcept(false));
      (static_cast<bool>(false)
           ? void(0)
           : __assert_fail("false", __builtin_FILE(), __builtin_LINE(),
                           __extension__ __PRETTY_FUNCTION__));
    } while (false);
  }

  static constexpr auto index() noexcept -> std::size_t {
    return __variant_npos;
  }

  static constexpr auto is_valueless() noexcept -> bool { return true; }
};

template <std::size_t... _Is, __indices<_Is...> _Idx, class... _Ts>
class __variant<_Idx, _Ts...> {
  static constexpr std::size_t __max_size = stdexec::__umax({sizeof(_Ts)...});
  static_assert(__max_size != 0);
  std::size_t __index_{__variant_npos};
  alignas(_Ts...) unsigned char __storage_[__max_size];

  void __destroy() noexcept {
    auto __index = std::exchange(__index_, __variant_npos);
    if (__variant_npos != __index) {
      ((_Is == __index ? std::destroy_at(static_cast<_Ts *>(__get_ptr()))
                       : void(0)),
       ...);
    }
  }

  template <std::size_t _Ny> using __at = __m_at_c<_Ny, _Ts...>;

public:
  __variant(__variant &&) = delete;

  __variant() noexcept = default;

  ~__variant() { __destroy(); }

  [[nodiscard]]
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline auto __get_ptr() noexcept -> void * {
    return __storage_;
  }

  [[nodiscard]]
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  index() const noexcept -> std::size_t {
    return __index_;
  }

  [[nodiscard]]
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  is_valueless() const noexcept -> bool {
    return __index_ == __variant_npos;
  }
# 133 "./../stdexec/include/stdexec/__detail/__variant.hpp"
  template <class _Ty, class... _As>

  auto emplace(_As &&...__as) noexcept(
      __nothrow_constructible_from<_Ty, _As...>) -> _Ty & {
    constexpr std::size_t __new_index = stdexec::__index_of<_Ty, _Ts...>();
    static_assert(__new_index != __variant_npos, "Type not in variant");

    __destroy();
    auto __sg = __mk_index_guard(__index_, __new_index);
    auto *__p = ::new (__storage_) _Ty{static_cast<_As &&>(__as)...};
    __sg.__dismiss();
    return *std::launder(__p);
  }

  template <std::size_t _Ny, class... _As>

  auto emplace(_As &&...__as) noexcept(
      __nothrow_constructible_from<__at<_Ny>, _As...>) -> __at<_Ny> & {
    static_assert(_Ny < sizeof...(_Ts), "variant index is too large");

    __destroy();
    auto __sg = __mk_index_guard(__index_, _Ny);
    auto *__p = ::new (__storage_) __at<_Ny>{static_cast<_As &&>(__as)...};
    __sg.__dismiss();
    return *std::launder(__p);
  }

  template <std::size_t _Ny, class _Fn, class... _As>

  auto emplace_from_at(_Fn &&__fn, _As &&...__as) noexcept(
      __nothrow_callable<_Fn, _As...>) -> __at<_Ny> & {
    static_assert(__same_as<__call_result_t<_Fn, _As...>, __at<_Ny>>,
                  "callable does not return the correct type");

    __destroy();
    auto __sg = __mk_index_guard(__index_, _Ny);
    auto *__p = ::new (__storage_)
        __at<_Ny>(static_cast<_Fn &&>(__fn)(static_cast<_As &&>(__as)...));
    __sg.__dismiss();
    return *std::launder(__p);
  }

  template <class _Fn, class... _As>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  emplace_from(_Fn &&__fn, _As &&...__as) noexcept(
      __nothrow_callable<_Fn, _As...>) -> __call_result_t<_Fn, _As...> & {
    using __result_t = __call_result_t<_Fn, _As...>;
    constexpr std::size_t __new_index =
        stdexec::__index_of<__result_t, _Ts...>();
    static_assert(__new_index != __variant_npos, "Type not in variant");
    return emplace_from_at<__new_index>(static_cast<_Fn &&>(__fn),
                                        static_cast<_As &&>(__as)...);
  }

  template <class _Fn, class _Self, class... _As>

  static void visit(_Fn &&__fn, _Self &&__self, _As &&...__as) noexcept(
      (__nothrow_callable<_Fn, _As..., __copy_cvref_t<_Self, _Ts>> && ...)) {
    do {
      static_assert(noexcept(__self.__index_ != __variant_npos));
      (static_cast<bool>(__self.__index_ != __variant_npos)
           ? void(0)
           : __assert_fail("__self.__index_ != __variant_npos",
                           __builtin_FILE(), __builtin_LINE(),
                           __extension__ __PRETTY_FUNCTION__));
    } while (false);
    auto __index = __self.__index_;
    ((_Is == __index ? static_cast<_Fn &&>(__fn)(
                           static_cast<_As &&>(__as)...,
                           static_cast<_Self &&>(__self).template get<_Is>())
                     : void()),
     ...);
  }

  template <std::size_t _Ny>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  get() && noexcept -> decltype(auto) {
    do {
      static_assert(noexcept(_Ny == __index_));
      (static_cast<bool>(_Ny == __index_)
           ? void(0)
           : __assert_fail("_Ny == __index_", __builtin_FILE(),
                           __builtin_LINE(),
                           __extension__ __PRETTY_FUNCTION__));
    } while (false);
    return static_cast<__at<_Ny> &&>(
        *reinterpret_cast<__at<_Ny> *>(__storage_));
  }

  template <std::size_t _Ny>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  get() & noexcept -> decltype(auto) {
    do {
      static_assert(noexcept(_Ny == __index_));
      (static_cast<bool>(_Ny == __index_)
           ? void(0)
           : __assert_fail("_Ny == __index_", __builtin_FILE(),
                           __builtin_LINE(),
                           __extension__ __PRETTY_FUNCTION__));
    } while (false);
    return *reinterpret_cast<__at<_Ny> *>(__storage_);
  }

  template <std::size_t _Ny>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  get() const & noexcept -> decltype(auto) {
    do {
      static_assert(noexcept(_Ny == __index_));
      (static_cast<bool>(_Ny == __index_)
           ? void(0)
           : __assert_fail("_Ny == __index_", __builtin_FILE(),
                           __builtin_LINE(),
                           __extension__ __PRETTY_FUNCTION__));
    } while (false);
    return *reinterpret_cast<const __at<_Ny> *>(__storage_);
  }
};
} // namespace __var

using __var::__variant;

template <class... _Ts>
using __variant_for = __variant<__indices_for<_Ts...>{}, _Ts...>;

template <class... Ts>
using __uniqued_variant_for =
    __mcall<__munique<__qq<__variant_for>>, __decay_t<Ts>...>;

template <auto _Idx, class... _Ts> struct __muncurry_<__variant<_Idx, _Ts...>> {
  template <class _Fn> using __f = __minvoke<_Fn, _Ts...>;
};
} // namespace stdexec

#pragma GCC diagnostic pop
# 32 "./../stdexec/include/stdexec/__detail/__schedule_from.hpp" 2

namespace stdexec {

namespace __schfr {
# 49 "./../stdexec/include/stdexec/__detail/__schedule_from.hpp"
template <class _CvrefSender, class _Env>
using __results_of = __for_each_completion_signature<
    __completion_signatures_of_t<_CvrefSender, _Env>, __decayed_tuple,
    __munique<__qq<stdexec::__variant_for>>::__f>;

template <class... _Values>
using __decay_value_sig = set_value_t (*)(__decay_t<_Values>...);

template <class _Error>
using __decay_error_sig = set_error_t (*)(__decay_t<_Error>);

template <class _Scheduler, class _Completions, class... _Env>
using __completions_impl_t = __mtry_q<__concat_completion_signatures>::__f<
    __transform_completion_signatures<_Completions, __decay_value_sig,
                                      __decay_error_sig, set_stopped_t (*)(),
                                      __completion_signature_ptrs>,
    transform_completion_signatures<
        __completion_signatures_of_t<schedule_result_t<_Scheduler>, _Env...>,
        __eptr_completion_if_t<
            __nothrow_decay_copyable_results_t<_Completions>>,
        __mconst<completion_signatures<>>::__f>>;

template <class _Scheduler, class _CvrefSender, class... _Env>
using __completions_t = __completions_impl_t<
    _Scheduler, __completion_signatures_of_t<_CvrefSender, _Env...>, _Env...>;

template <class _Scheduler, class _Sexpr, class _Receiver> struct __state;

template <class _State>
__attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
__make_visitor_fn(_State *__state) noexcept {
  return [__state]<class _Tup>(_Tup &__tupl) noexcept -> void {
    __tupl.apply(
        [&]<class... _Args>(auto __tag, _Args &...__args) noexcept -> void {
          __tag(std::move(__state->__receiver()),
                static_cast<_Args &&>(__args)...);
        },
        __tupl);
  };
}

template <class _SchedulerId, class _SexprId, class _ReceiverId>
struct __rcvr2 {
  using _Scheduler = stdexec::__t<_SchedulerId>;
  using _Sexpr = stdexec::__t<_SexprId>;
  using _Receiver = stdexec::__t<_ReceiverId>;

  struct __t {
    using receiver_concept = receiver_t;
    using __id = __rcvr2;

    void set_value() noexcept {
      __state_->__data_.visit(__schfr::__make_visitor_fn(__state_),
                              __state_->__data_);
    }

    template <class _Error> void set_error(_Error &&__err) noexcept {
      stdexec::set_error(static_cast<_Receiver &&>(__state_->__receiver()),
                         static_cast<_Error &&>(__err));
    }

    void set_stopped() noexcept {
      stdexec::set_stopped(static_cast<_Receiver &&>(__state_->__receiver()));
    }

    auto get_env() const noexcept -> env_of_t<_Receiver> {
      return stdexec::get_env(__state_->__receiver());
    }

    __state<_Scheduler, _Sexpr, _Receiver> *__state_;
  };
};

template <class _Scheduler, class _Sexpr, class _Receiver>
using __receiver2 =
    __t<__rcvr2<__id<_Scheduler>, __id<_Sexpr>, __id<_Receiver>>>;

template <class _Scheduler, class _Sexpr, class _Receiver>
struct __state
    : __enable_receiver_from_this<_Sexpr, _Receiver,
                                  __state<_Scheduler, _Sexpr, _Receiver>>,
      __immovable {
  using __variant_t = __results_of<__child_of<_Sexpr>, env_of_t<_Receiver>>;
  using __receiver2_t = __receiver2<_Scheduler, _Sexpr, _Receiver>;

  __variant_t __data_;
  connect_result_t<schedule_result_t<_Scheduler>, __receiver2_t> __state2_;

  explicit __state(_Scheduler __sched)
      : __data_(), __state2_(connect(schedule(__sched), __receiver2_t{this})) {}
};

struct schedule_from_t {
  template <scheduler _Scheduler, sender _Sender>
  auto operator()(_Scheduler __sched,
                  _Sender &&__sndr) const -> __well_formed_sender auto {
    auto __domain = query_or(get_domain, __sched, default_domain());
    return stdexec::transform_sender(
        __domain,
        __make_sexpr<schedule_from_t>(static_cast<_Scheduler &&>(__sched),
                                      static_cast<_Sender &&>(__sndr)));
  }
};

struct __schedule_from_impl : __sexpr_defaults {
  template <class _Sender>
  using __scheduler_t =
      __decay_t<__call_result_t<get_completion_scheduler_t<set_value_t>,
                                env_of_t<_Sender>>>;

  static constexpr auto get_attrs =
      []<class _Data, class _Child>(const _Data &__data,
                                    const _Child &__child) noexcept {
        auto __domain = query_or(get_domain, __data, default_domain{});
        return __env::__join(__sched_attrs{std::cref(__data), __domain},
                             stdexec::get_env(__child));
      };

  static constexpr auto get_completion_signatures =
      []<class _Sender, class... _Env>(_Sender &&, _Env &&...) noexcept
      -> __completions_t<__scheduler_t<_Sender>, __child_of<_Sender>, _Env...> {
    static_assert(sender_expr_for<_Sender, schedule_from_t>);
    return {};
  };

  static constexpr auto get_state =
      []<class _Sender, class _Receiver>(_Sender &&__sndr, _Receiver &) {
        static_assert(sender_expr_for<_Sender, schedule_from_t>);
        auto __sched =
            get_completion_scheduler<set_value_t>(stdexec::get_env(__sndr));
        using _Scheduler = decltype(__sched);
        return __state<_Scheduler, _Sender, _Receiver>{__sched};
      };

  static constexpr auto complete =
      []<class _State, class _Receiver, class _Tag, class... _Args>(
          __ignore, _State &__state, _Receiver &__rcvr, _Tag __tag,
          _Args &&...__args) noexcept -> void {
    if constexpr (__nothrow_callable<__tup::__mktuple_t, _Tag, _Args...>) {
      __state.__data_.emplace_from(__tup::__mktuple, __tag,
                                   static_cast<_Args &&>(__args)...);
    } else {
      try {
        __state.__data_.emplace_from(__tup::__mktuple, __tag,
                                     static_cast<_Args &&>(__args)...);
      } catch (...) {
        stdexec::set_error(static_cast<_Receiver &&>(__rcvr),
                           std::current_exception());
        return;
      }
    }

    stdexec::start(__state.__state2_);
  };
};
} // namespace __schfr

using __schfr::schedule_from_t;
inline constexpr schedule_from_t schedule_from{};

template <>
struct __sexpr_impl<schedule_from_t> : __schfr::__schedule_from_impl {};
} // namespace stdexec
# 25 "./../stdexec/include/stdexec/__detail/__continues_on.hpp" 2

namespace stdexec {

namespace __continues_on {
template <class _Env>
using __scheduler_t = __result_of<get_completion_scheduler<set_value_t>, _Env>;

template <class _Sender>
using __lowered_t =
    __result_of<schedule_from, __scheduler_t<__data_of<_Sender>>,
                __child_of<_Sender>>;

struct continues_on_t {
  template <sender _Sender, scheduler _Scheduler>
  auto operator()(_Sender &&__sndr,
                  _Scheduler __sched) const -> __well_formed_sender auto {
    auto __domain = __get_early_domain(__sndr);
    return stdexec::transform_sender(
        __domain,
        __make_sexpr<continues_on_t>(static_cast<_Scheduler &&>(__sched),
                                     static_cast<_Sender &&>(__sndr)));
  }

  template <scheduler _Scheduler>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Scheduler __sched) const
      -> __binder_back<continues_on_t, _Scheduler> {
    return {{static_cast<_Scheduler &&>(__sched)}, {}, {}};
  }

  static auto __transform_sender_fn() {
    return [&]<class _Data, class _Child>(__ignore, _Data &&__data,
                                          _Child &&__child) {
      return schedule_from(static_cast<_Data &&>(__data),
                           static_cast<_Child &&>(__child));
    };
  }

  template <class _Sender, class _Env>
  static auto transform_sender(_Sender &&__sndr, const _Env &) {
    return __sexpr_apply(static_cast<_Sender &&>(__sndr),
                         __transform_sender_fn());
  }
};

struct __continues_on_impl : __sexpr_defaults {
  static constexpr auto get_attrs =
      []<class _Data, class _Child>(
          const _Data &__data,
          const _Child &__child) noexcept -> decltype(auto) {
    using __domain_t = __detail::__early_domain_of_t<_Child, __none_such>;
    return __env::__join(__sched_attrs{std::cref(__data), __domain_t{}},
                         stdexec::get_env(__child));
  };

  static constexpr auto get_completion_signatures =
      []<class _Sender>(_Sender &&) noexcept
      -> __completion_signatures_of_t<
          transform_sender_result_t<default_domain, _Sender, env<>>> {
    return {};
  };
};
} // namespace __continues_on

using __continues_on::continues_on_t;
inline constexpr continues_on_t continues_on{};

using transfer_t = continues_on_t;
inline constexpr continues_on_t transfer{};

using continue_on_t = continues_on_t;
inline constexpr continues_on_t continue_on{};

template <>
struct __sexpr_impl<continues_on_t> : __continues_on::__continues_on_impl {};
} // namespace stdexec
# 27 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__ensure_started.hpp" 1
# 26 "./../stdexec/include/stdexec/__detail/__ensure_started.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__shared.hpp" 1
# 23 "./../stdexec/include/stdexec/__detail/__shared.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__intrusive_slist.hpp" 1
# 21 "./../stdexec/include/stdexec/__detail/__intrusive_slist.hpp"
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 1 3
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cassert" 2 3
# 22 "./../stdexec/include/stdexec/__detail/__intrusive_slist.hpp" 2
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/iterator" 1 3
# 59 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/iterator" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stream_iterator.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stream_iterator.h" 3

namespace std __attribute__((__visibility__("default"))) {

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

  template <typename _Tp, typename _CharT = char,
            typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
  class istream_iterator : public iterator<input_iterator_tag, _Tp, _Dist,
                                           const _Tp *, const _Tp &> {
  public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_istream<_CharT, _Traits> istream_type;

  private:
    istream_type *_M_stream;
    _Tp _M_value;

    bool _M_ok;

  public:
    constexpr istream_iterator() noexcept(
        is_nothrow_default_constructible<_Tp>::value)
        : _M_stream(0), _M_value(), _M_ok(false) {}

    istream_iterator(istream_type &__s)
        : _M_stream(std::__addressof(__s)), _M_ok(true) {
      _M_read();
    }

    constexpr istream_iterator(const istream_iterator &__obj) noexcept(
        is_nothrow_copy_constructible<_Tp>::value)
        : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
          _M_ok(__obj._M_ok) {}

    constexpr istream_iterator(default_sentinel_t) noexcept(
        is_nothrow_default_constructible_v<_Tp>)
        : istream_iterator() {}

    istream_iterator &operator=(const istream_iterator &) = default;
    ~istream_iterator() = default;

    [[__nodiscard__]]
    const _Tp &operator*() const noexcept {

      ;
      return _M_value;
    }

    [[__nodiscard__]]
    const _Tp *operator->() const noexcept {
      return std::__addressof((operator*()));
    }

    istream_iterator &operator++() {

      ;
      _M_read();
      return *this;
    }

    istream_iterator operator++(int) {

      ;
      istream_iterator __tmp = *this;
      _M_read();
      return __tmp;
    }

  private:
    bool _M_equal(const istream_iterator &__x) const noexcept {

      return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream);
    }

    void _M_read() {
      if (_M_stream && !(*_M_stream >> _M_value)) {
        _M_stream = 0;
        _M_ok = false;
      }
    }

    [[__nodiscard__]]
    friend bool operator==(const istream_iterator &__x,
                           const istream_iterator &__y) noexcept {
      return __x._M_equal(__y);
    }
# 176 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stream_iterator.h" 3
    [[nodiscard]]
    friend bool operator==(const istream_iterator &__i,
                           default_sentinel_t) noexcept {
      return !__i._M_stream;
    }
  };
# 194 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stream_iterator.h" 3
  template <typename _Tp, typename _CharT = char,
            typename _Traits = char_traits<_CharT>>
  class ostream_iterator
      : public iterator<output_iterator_tag, void, void, void, void> {
  public:
    using difference_type = ptrdiff_t;

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_ostream<_CharT, _Traits> ostream_type;

  private:
    ostream_type *_M_stream;
    const _CharT *_M_string;

  public:
    ostream_iterator(ostream_type &__s) noexcept
        : _M_stream(std::__addressof(__s)), _M_string(0) {}
# 229 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stream_iterator.h" 3
    ostream_iterator(ostream_type &__s, const _CharT *__c) noexcept
        : _M_stream(std::__addressof(__s)), _M_string(__c) {}

    ostream_iterator(const ostream_iterator &__obj) noexcept
        : _M_stream(__obj._M_stream), _M_string(__obj._M_string) {}

    ostream_iterator &operator=(const ostream_iterator &) = default;

    ostream_iterator &operator=(const _Tp &__value) {

      ;
      *_M_stream << __value;
      if (_M_string)
        *_M_stream << _M_string;
      return *this;
    }

    [[__nodiscard__]]
    ostream_iterator &operator*() noexcept {
      return *this;
    }

    ostream_iterator &operator++() noexcept { return *this; }

    ostream_iterator &operator++(int) noexcept { return *this; }
  };
#pragma GCC diagnostic pop

} // namespace std
# 66 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/iterator" 2 3
# 23 "./../stdexec/include/stdexec/__detail/__intrusive_slist.hpp" 2

namespace stdexec {
namespace __slist {
template <auto _Next> class __intrusive_slist;

template <class _Item, _Item *_Item::*_Next> class __intrusive_slist<_Next> {
public:
  __intrusive_slist() noexcept = default;

  __intrusive_slist(__intrusive_slist &&__other) noexcept
      : __head_(std::exchange(__other.__head_, nullptr)) {}

  __intrusive_slist(_Item *__head) noexcept : __head_(__head) {}

  auto swap(__intrusive_slist &__other) noexcept -> void {
    std::swap(__head_, __other.__head_);
  }

  auto operator=(__intrusive_slist __other) noexcept -> __intrusive_slist & {
    swap(__other);
    return *this;
  }

  [[nodiscard]]
  auto empty() const noexcept -> bool {
    return __head_ == nullptr;
  }

  auto front() const noexcept -> _Item * { return __head_; }

  void clear() noexcept { __head_ = nullptr; }

  [[nodiscard]]
  auto pop_front() noexcept -> _Item * {
    do {
      static_assert(noexcept(!empty()));
      (static_cast<bool>(!empty())
           ? void(0)
           : __assert_fail("!empty()", __builtin_FILE(), __builtin_LINE(),
                           __extension__ __PRETTY_FUNCTION__));
    } while (false);
    return std::exchange(__head_, __head_->*_Next);
  }

  void push_front(_Item *__item) noexcept {
    do {
      static_assert(noexcept(__item != nullptr));
      (static_cast<bool>(__item != nullptr)
           ? void(0)
           : __assert_fail("__item != nullptr", __builtin_FILE(),
                           __builtin_LINE(),
                           __extension__ __PRETTY_FUNCTION__));
    } while (false);
    __item->*_Next = std::exchange(__head_, __item);
  }

  [[nodiscard]]
  auto remove(_Item *__item) noexcept -> _Item * {
    do {
      static_assert(noexcept(__item != nullptr));
      (static_cast<bool>(__item != nullptr)
           ? void(0)
           : __assert_fail("__item != nullptr", __builtin_FILE(),
                           __builtin_LINE(),
                           __extension__ __PRETTY_FUNCTION__));
    } while (false);
    if (__head_ == __item) {
      return pop_front();
    }

    for (_Item *__current : *this) {
      if (__current->*_Next == __item) {
        __current->*_Next = __item->*_Next;
        return __item;
      }
    }

    return nullptr;
  }

  struct iterator {
    using iterator_category = std::forward_iterator_tag;
    using difference_type = std::ptrdiff_t;
    using value_type = _Item *;
    using reference = _Item *;
    using pointer = _Item **;

    _Item *__item_ = nullptr;

    iterator() noexcept = default;

    explicit iterator(_Item *__item) noexcept : __item_(__item) {}

    [[nodiscard]]
    auto operator*() const noexcept -> _Item * {
      do {
        static_assert(noexcept(__item_ != nullptr));
        (static_cast<bool>(__item_ != nullptr)
             ? void(0)
             : __assert_fail("__item_ != nullptr", __builtin_FILE(),
                             __builtin_LINE(),
                             __extension__ __PRETTY_FUNCTION__));
      } while (false);
      return __item_;
    }

    [[nodiscard]]
    auto operator->() const noexcept -> _Item ** {
      do {
        static_assert(noexcept(__item_ != nullptr));
        (static_cast<bool>(__item_ != nullptr)
             ? void(0)
             : __assert_fail("__item_ != nullptr", __builtin_FILE(),
                             __builtin_LINE(),
                             __extension__ __PRETTY_FUNCTION__));
      } while (false);
      return &__item_;
    }

    auto operator++() noexcept -> iterator & {
      do {
        static_assert(noexcept(__item_ != nullptr));
        (static_cast<bool>(__item_ != nullptr)
             ? void(0)
             : __assert_fail("__item_ != nullptr", __builtin_FILE(),
                             __builtin_LINE(),
                             __extension__ __PRETTY_FUNCTION__));
      } while (false);
      __item_ = __item_->*_Next;
      return *this;
    }

    auto operator++(int) noexcept -> iterator {
      iterator __result = *this;
      ++*this;
      return __result;
    }

    auto operator==(const iterator &) const noexcept -> bool = default;
  };

  [[nodiscard]]
  auto begin() const noexcept -> iterator {
    return iterator(__head_);
  }

  [[nodiscard]]
  auto end() const noexcept -> iterator {
    return iterator(nullptr);
  }

private:
  _Item *__head_ = nullptr;
};
} // namespace __slist

using __slist::__intrusive_slist;

} // namespace stdexec
# 24 "./../stdexec/include/stdexec/__detail/__shared.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__optional.hpp" 1
# 29 "./../stdexec/include/stdexec/__detail/__optional.hpp"
namespace stdexec {
namespace __opt {
struct __bad_optional_access : std::exception {
  [[nodiscard]]
  auto what() const noexcept -> const char * override {
    return "stdexec::__optional: bad access";
  }
};

inline auto __mk_has_value_guard(bool &__has_value) noexcept {
  __has_value = true;
  return __scope_guard{[&]() noexcept { __has_value = false; }};
}

inline constexpr struct __nullopt_t {
} __nullopt{};

template <class _Tp> struct __optional {
  static_assert(destructible<_Tp>);

  union {
    _Tp __value_;
  };

  bool __has_value_ = false;

  __optional() noexcept {}

  __optional(__nullopt_t) noexcept {}

  __optional(__optional &&) = delete;

  template <__not_decays_to<__optional> _Up>
    requires constructible_from<_Tp, _Up>
  __optional(_Up &&__v) noexcept(__nothrow_constructible_from<_Tp, _Up>) {
    emplace(static_cast<_Up &&>(__v));
  }

  template <class... _Us>
    requires constructible_from<_Tp, _Us...>
  __optional(std::in_place_t, _Us &&...__us) noexcept(
      __nothrow_constructible_from<_Tp, _Us...>) {
    emplace(static_cast<_Us &&>(__us)...);
  }

  ~__optional() {
    if (__has_value_) {
      std::destroy_at(std::addressof(__value_));
    }
  }
# 97 "./../stdexec/include/stdexec/__detail/__optional.hpp"
  template <class... _Us>
    requires constructible_from<_Tp, _Us...>
  auto emplace(_Us &&...__us) noexcept(
      __nothrow_constructible_from<_Tp, _Us...>) -> _Tp & {
    reset();
    auto __sg = __mk_has_value_guard(__has_value_);
    auto *__p = ::new (static_cast<void *>(std::addressof(__value_)))
        _Tp{static_cast<_Us &&>(__us)...};
    __sg.__dismiss();
    return *std::launder(__p);
  }

  auto value() & -> _Tp & {
    if (!__has_value_) {
      throw __bad_optional_access();
    }
    return __value_;
  }

  auto value() const & -> const _Tp & {
    if (!__has_value_) {
      throw __bad_optional_access();
    }
    return __value_;
  }

  auto value() && -> _Tp && {
    if (!__has_value_) {
      throw __bad_optional_access();
    }
    return static_cast<_Tp &&>(__value_);
  }

  auto operator*() & noexcept -> _Tp & {
    do {
      static_assert(noexcept(__has_value_));
      (static_cast<bool>(__has_value_)
           ? void(0)
           : __assert_fail("__has_value_", __builtin_FILE(), __builtin_LINE(),
                           __extension__ __PRETTY_FUNCTION__));
    } while (false);
    return __value_;
  }

  auto operator*() const & noexcept -> const _Tp & {
    do {
      static_assert(noexcept(__has_value_));
      (static_cast<bool>(__has_value_)
           ? void(0)
           : __assert_fail("__has_value_", __builtin_FILE(), __builtin_LINE(),
                           __extension__ __PRETTY_FUNCTION__));
    } while (false);
    return __value_;
  }

  auto operator*() && noexcept -> _Tp && {
    do {
      static_assert(noexcept(__has_value_));
      (static_cast<bool>(__has_value_)
           ? void(0)
           : __assert_fail("__has_value_", __builtin_FILE(), __builtin_LINE(),
                           __extension__ __PRETTY_FUNCTION__));
    } while (false);
    return static_cast<_Tp &&>(__value_);
  }

  auto operator->() & noexcept -> _Tp * {
    do {
      static_assert(noexcept(__has_value_));
      (static_cast<bool>(__has_value_)
           ? void(0)
           : __assert_fail("__has_value_", __builtin_FILE(), __builtin_LINE(),
                           __extension__ __PRETTY_FUNCTION__));
    } while (false);
    return &__value_;
  }

  auto operator->() const & noexcept -> const _Tp * {
    do {
      static_assert(noexcept(__has_value_));
      (static_cast<bool>(__has_value_)
           ? void(0)
           : __assert_fail("__has_value_", __builtin_FILE(), __builtin_LINE(),
                           __extension__ __PRETTY_FUNCTION__));
    } while (false);
    return &__value_;
  }

  [[nodiscard]]
  auto has_value() const noexcept -> bool {
    return __has_value_;
  }

  void reset() noexcept {
    if (__has_value_) {
      std::destroy_at(std::addressof(__value_));
      __has_value_ = false;
    }
  }
};
} // namespace __opt

using __opt::__bad_optional_access;
using __opt::__nullopt;
using __opt::__optional;
} // namespace stdexec
# 25 "./../stdexec/include/stdexec/__detail/__shared.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/../stop_token.hpp" 1
# 25 "./../stdexec/include/stdexec/__detail/../stop_token.hpp"
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/atomic" 1 3
# 36 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/atomic" 3

namespace std __attribute__((__visibility__("default"))) {
# 56 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/atomic" 3
  template <typename _Tp> struct atomic;

  template <> struct atomic<bool> {
    using value_type = bool;

  private:
    __atomic_base<bool> _M_base;

  public:
    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(bool __i) noexcept : _M_base(__i) {}

    bool operator=(bool __i) noexcept { return _M_base.operator=(__i); }

    bool operator=(bool __i) volatile noexcept {
      return _M_base.operator=(__i);
    }

    operator bool() const noexcept { return _M_base.load(); }

    operator bool() const volatile noexcept { return _M_base.load(); }

    bool is_lock_free() const noexcept { return _M_base.is_lock_free(); }

    bool is_lock_free() const volatile noexcept {
      return _M_base.is_lock_free();
    }

    static constexpr bool is_always_lock_free = 2 == 2;

    void store(bool __i, memory_order __m = memory_order_seq_cst) noexcept {
      _M_base.store(__i, __m);
    }

    void store(bool __i,
               memory_order __m = memory_order_seq_cst) volatile noexcept {
      _M_base.store(__i, __m);
    }

    bool load(memory_order __m = memory_order_seq_cst) const noexcept {
      return _M_base.load(__m);
    }

    bool load(memory_order __m = memory_order_seq_cst) const volatile noexcept {
      return _M_base.load(__m);
    }

    bool exchange(bool __i, memory_order __m = memory_order_seq_cst) noexcept {
      return _M_base.exchange(__i, __m);
    }

    bool exchange(bool __i,
                  memory_order __m = memory_order_seq_cst) volatile noexcept {
      return _M_base.exchange(__i, __m);
    }

    bool compare_exchange_weak(bool &__i1, bool __i2, memory_order __m1,
                               memory_order __m2) noexcept {
      return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2);
    }

    bool compare_exchange_weak(bool &__i1, bool __i2, memory_order __m1,
                               memory_order __m2) volatile noexcept {
      return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2);
    }

    bool
    compare_exchange_weak(bool &__i1, bool __i2,
                          memory_order __m = memory_order_seq_cst) noexcept {
      return _M_base.compare_exchange_weak(__i1, __i2, __m);
    }

    bool compare_exchange_weak(
        bool &__i1, bool __i2,
        memory_order __m = memory_order_seq_cst) volatile noexcept {
      return _M_base.compare_exchange_weak(__i1, __i2, __m);
    }

    bool compare_exchange_strong(bool &__i1, bool __i2, memory_order __m1,
                                 memory_order __m2) noexcept {
      return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2);
    }

    bool compare_exchange_strong(bool &__i1, bool __i2, memory_order __m1,
                                 memory_order __m2) volatile noexcept {
      return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2);
    }

    bool
    compare_exchange_strong(bool &__i1, bool __i2,
                            memory_order __m = memory_order_seq_cst) noexcept {
      return _M_base.compare_exchange_strong(__i1, __i2, __m);
    }

    bool compare_exchange_strong(
        bool &__i1, bool __i2,
        memory_order __m = memory_order_seq_cst) volatile noexcept {
      return _M_base.compare_exchange_strong(__i1, __i2, __m);
    }

    void wait(bool __old,
              memory_order __m = memory_order_seq_cst) const noexcept {
      _M_base.wait(__old, __m);
    }

    void notify_one() noexcept { _M_base.notify_one(); }

    void notify_all() noexcept { _M_base.notify_all(); }
  };
# 197 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/atomic" 3
  template <typename _Tp> struct atomic {
    using value_type = _Tp;

  private:
    static constexpr int _S_min_alignment = (sizeof(_Tp) & (sizeof(_Tp) - 1)) ||
                                                    sizeof(_Tp) > 16
                                                ? 0
                                                : sizeof(_Tp);

    static constexpr int _S_alignment = _S_min_alignment > alignof(_Tp)
                                            ? _S_min_alignment
                                            : alignof(_Tp);

    alignas(_S_alignment) _Tp _M_i = _Tp();

    static_assert(__is_trivially_copyable(_Tp),
                  "std::atomic requires a trivially copyable type");

    static_assert(sizeof(_Tp) > 0,
                  "Incomplete or zero-sized types are not supported");

    static_assert(is_copy_constructible_v<_Tp>);
    static_assert(is_move_constructible_v<_Tp>);
    static_assert(is_copy_assignable_v<_Tp>);
    static_assert(is_move_assignable_v<_Tp>);

  public:
    atomic() = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(_Tp __i) noexcept : _M_i(__i) {}

    operator _Tp() const noexcept { return load(); }

    operator _Tp() const volatile noexcept { return load(); }

    _Tp operator=(_Tp __i) noexcept {
      store(__i);
      return __i;
    }

    _Tp operator=(_Tp __i) volatile noexcept {
      store(__i);
      return __i;
    }

    bool is_lock_free() const noexcept {

      return __atomic_is_lock_free(sizeof(_M_i),
                                   reinterpret_cast<void *>(-_S_alignment));
    }

    bool is_lock_free() const volatile noexcept {

      return __atomic_is_lock_free(sizeof(_M_i),
                                   reinterpret_cast<void *>(-_S_alignment));
    }

    static constexpr bool is_always_lock_free =
        __atomic_always_lock_free(sizeof(_M_i), 0);

    void store(_Tp __i, memory_order __m = memory_order_seq_cst) noexcept {
      __atomic_store(std::__addressof(_M_i),
                     __atomic_impl::__clear_padding(__i), int(__m));
    }

    void store(_Tp __i,
               memory_order __m = memory_order_seq_cst) volatile noexcept {
      __atomic_store(std::__addressof(_M_i),
                     __atomic_impl::__clear_padding(__i), int(__m));
    }

    _Tp load(memory_order __m = memory_order_seq_cst) const noexcept {
      alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
      _Tp *__ptr = reinterpret_cast<_Tp *>(__buf);
      __atomic_load(std::__addressof(_M_i), __ptr, int(__m));
      return *__ptr;
    }

    _Tp load(memory_order __m = memory_order_seq_cst) const volatile noexcept {
      alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
      _Tp *__ptr = reinterpret_cast<_Tp *>(__buf);
      __atomic_load(std::__addressof(_M_i), __ptr, int(__m));
      return *__ptr;
    }

    _Tp exchange(_Tp __i, memory_order __m = memory_order_seq_cst) noexcept {
      alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
      _Tp *__ptr = reinterpret_cast<_Tp *>(__buf);
      __atomic_exchange(std::__addressof(_M_i),
                        __atomic_impl::__clear_padding(__i), __ptr, int(__m));
      return *__ptr;
    }

    _Tp exchange(_Tp __i,
                 memory_order __m = memory_order_seq_cst) volatile noexcept {
      alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
      _Tp *__ptr = reinterpret_cast<_Tp *>(__buf);
      __atomic_exchange(std::__addressof(_M_i),
                        __atomic_impl::__clear_padding(__i), __ptr, int(__m));
      return *__ptr;
    }

    bool compare_exchange_weak(_Tp &__e, _Tp __i, memory_order __s,
                               memory_order __f) noexcept {
      return __atomic_impl::__compare_exchange(_M_i, __e, __i, true, __s, __f);
    }

    bool compare_exchange_weak(_Tp &__e, _Tp __i, memory_order __s,
                               memory_order __f) volatile noexcept {
      return __atomic_impl::__compare_exchange(_M_i, __e, __i, true, __s, __f);
    }

    bool
    compare_exchange_weak(_Tp &__e, _Tp __i,
                          memory_order __m = memory_order_seq_cst) noexcept {
      return compare_exchange_weak(__e, __i, __m, __cmpexch_failure_order(__m));
    }

    bool compare_exchange_weak(
        _Tp &__e, _Tp __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept {
      return compare_exchange_weak(__e, __i, __m, __cmpexch_failure_order(__m));
    }

    bool compare_exchange_strong(_Tp &__e, _Tp __i, memory_order __s,
                                 memory_order __f) noexcept {
      return __atomic_impl::__compare_exchange(_M_i, __e, __i, false, __s, __f);
    }

    bool compare_exchange_strong(_Tp &__e, _Tp __i, memory_order __s,
                                 memory_order __f) volatile noexcept {
      return __atomic_impl::__compare_exchange(_M_i, __e, __i, false, __s, __f);
    }

    bool
    compare_exchange_strong(_Tp &__e, _Tp __i,
                            memory_order __m = memory_order_seq_cst) noexcept {
      return compare_exchange_strong(__e, __i, __m,
                                     __cmpexch_failure_order(__m));
    }

    bool compare_exchange_strong(
        _Tp &__e, _Tp __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept {
      return compare_exchange_strong(__e, __i, __m,
                                     __cmpexch_failure_order(__m));
    }

    void wait(_Tp __old,
              memory_order __m = memory_order_seq_cst) const noexcept {
      std::__atomic_wait_address_v(&_M_i, __old,
                                   [__m, this] { return this->load(__m); });
    }

    void notify_one() noexcept { std::__atomic_notify_address(&_M_i, false); }

    void notify_all() noexcept { std::__atomic_notify_address(&_M_i, true); }
  };

  template <typename _Tp> struct atomic<_Tp *> {
    using value_type = _Tp *;
    using difference_type = ptrdiff_t;

    typedef _Tp *__pointer_type;
    typedef __atomic_base<_Tp *> __base_type;
    __base_type _M_b;

    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(__pointer_type __p) noexcept : _M_b(__p) {}

    operator __pointer_type() const noexcept { return __pointer_type(_M_b); }

    operator __pointer_type() const volatile noexcept {
      return __pointer_type(_M_b);
    }

    __pointer_type operator=(__pointer_type __p) noexcept {
      return _M_b.operator=(__p);
    }

    __pointer_type operator=(__pointer_type __p) volatile noexcept {
      return _M_b.operator=(__p);
    }

    __pointer_type operator++(int) noexcept {

      static_assert(is_object<_Tp>::value, "pointer to object type");

      return _M_b++;
    }

    __pointer_type operator++(int) volatile noexcept {

      static_assert(is_object<_Tp>::value, "pointer to object type");

      return _M_b++;
    }

    __pointer_type operator--(int) noexcept {

      static_assert(is_object<_Tp>::value, "pointer to object type");

      return _M_b--;
    }

    __pointer_type operator--(int) volatile noexcept {

      static_assert(is_object<_Tp>::value, "pointer to object type");

      return _M_b--;
    }

    __pointer_type operator++() noexcept {

      static_assert(is_object<_Tp>::value, "pointer to object type");

      return ++_M_b;
    }

    __pointer_type operator++() volatile noexcept {

      static_assert(is_object<_Tp>::value, "pointer to object type");

      return ++_M_b;
    }

    __pointer_type operator--() noexcept {

      static_assert(is_object<_Tp>::value, "pointer to object type");

      return --_M_b;
    }

    __pointer_type operator--() volatile noexcept {

      static_assert(is_object<_Tp>::value, "pointer to object type");

      return --_M_b;
    }

    __pointer_type operator+=(ptrdiff_t __d) noexcept {

      static_assert(is_object<_Tp>::value, "pointer to object type");

      return _M_b.operator+=(__d);
    }

    __pointer_type operator+=(ptrdiff_t __d) volatile noexcept {

      static_assert(is_object<_Tp>::value, "pointer to object type");

      return _M_b.operator+=(__d);
    }

    __pointer_type operator-=(ptrdiff_t __d) noexcept {

      static_assert(is_object<_Tp>::value, "pointer to object type");

      return _M_b.operator-=(__d);
    }

    __pointer_type operator-=(ptrdiff_t __d) volatile noexcept {

      static_assert(is_object<_Tp>::value, "pointer to object type");

      return _M_b.operator-=(__d);
    }

    bool is_lock_free() const noexcept { return _M_b.is_lock_free(); }

    bool is_lock_free() const volatile noexcept { return _M_b.is_lock_free(); }

    static constexpr bool is_always_lock_free = 2 == 2;

    void store(__pointer_type __p,
               memory_order __m = memory_order_seq_cst) noexcept {
      return _M_b.store(__p, __m);
    }

    void store(__pointer_type __p,
               memory_order __m = memory_order_seq_cst) volatile noexcept {
      return _M_b.store(__p, __m);
    }

    __pointer_type
    load(memory_order __m = memory_order_seq_cst) const noexcept {
      return _M_b.load(__m);
    }

    __pointer_type load(memory_order __m = memory_order_seq_cst) const
        volatile noexcept {
      return _M_b.load(__m);
    }

    __pointer_type exchange(__pointer_type __p,
                            memory_order __m = memory_order_seq_cst) noexcept {
      return _M_b.exchange(__p, __m);
    }

    __pointer_type
    exchange(__pointer_type __p,
             memory_order __m = memory_order_seq_cst) volatile noexcept {
      return _M_b.exchange(__p, __m);
    }

    bool compare_exchange_weak(__pointer_type &__p1, __pointer_type __p2,
                               memory_order __m1, memory_order __m2) noexcept {
      return _M_b.compare_exchange_weak(__p1, __p2, __m1, __m2);
    }

    bool compare_exchange_weak(__pointer_type &__p1, __pointer_type __p2,
                               memory_order __m1,
                               memory_order __m2) volatile noexcept {
      return _M_b.compare_exchange_weak(__p1, __p2, __m1, __m2);
    }

    bool
    compare_exchange_weak(__pointer_type &__p1, __pointer_type __p2,
                          memory_order __m = memory_order_seq_cst) noexcept {
      return compare_exchange_weak(__p1, __p2, __m,
                                   __cmpexch_failure_order(__m));
    }

    bool compare_exchange_weak(
        __pointer_type &__p1, __pointer_type __p2,
        memory_order __m = memory_order_seq_cst) volatile noexcept {
      return compare_exchange_weak(__p1, __p2, __m,
                                   __cmpexch_failure_order(__m));
    }

    bool compare_exchange_strong(__pointer_type &__p1, __pointer_type __p2,
                                 memory_order __m1,
                                 memory_order __m2) noexcept {
      return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2);
    }

    bool compare_exchange_strong(__pointer_type &__p1, __pointer_type __p2,
                                 memory_order __m1,
                                 memory_order __m2) volatile noexcept {
      return _M_b.compare_exchange_strong(__p1, __p2, __m1, __m2);
    }

    bool
    compare_exchange_strong(__pointer_type &__p1, __pointer_type __p2,
                            memory_order __m = memory_order_seq_cst) noexcept {
      return _M_b.compare_exchange_strong(__p1, __p2, __m,
                                          __cmpexch_failure_order(__m));
    }

    bool compare_exchange_strong(
        __pointer_type &__p1, __pointer_type __p2,
        memory_order __m = memory_order_seq_cst) volatile noexcept {
      return _M_b.compare_exchange_strong(__p1, __p2, __m,
                                          __cmpexch_failure_order(__m));
    }

    void wait(__pointer_type __old,
              memory_order __m = memory_order_seq_cst) const noexcept {
      _M_b.wait(__old, __m);
    }

    void notify_one() noexcept { _M_b.notify_one(); }

    void notify_all() noexcept { _M_b.notify_all(); }

    __pointer_type fetch_add(ptrdiff_t __d,
                             memory_order __m = memory_order_seq_cst) noexcept {

      static_assert(is_object<_Tp>::value, "pointer to object type");

      return _M_b.fetch_add(__d, __m);
    }

    __pointer_type
    fetch_add(ptrdiff_t __d,
              memory_order __m = memory_order_seq_cst) volatile noexcept {

      static_assert(is_object<_Tp>::value, "pointer to object type");

      return _M_b.fetch_add(__d, __m);
    }

    __pointer_type fetch_sub(ptrdiff_t __d,
                             memory_order __m = memory_order_seq_cst) noexcept {

      static_assert(is_object<_Tp>::value, "pointer to object type");

      return _M_b.fetch_sub(__d, __m);
    }

    __pointer_type
    fetch_sub(ptrdiff_t __d,
              memory_order __m = memory_order_seq_cst) volatile noexcept {

      static_assert(is_object<_Tp>::value, "pointer to object type");

      return _M_b.fetch_sub(__d, __m);
    }
  };

  template <> struct atomic<char> : __atomic_base<char> {
    typedef char __integral_type;
    typedef __atomic_base<char> __base_type;

    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(__integral_type __i) noexcept : __base_type(__i) {}

    using __base_type::operator __integral_type;
    using __base_type::operator=;

    static constexpr bool is_always_lock_free = 2 == 2;
  };

  template <> struct atomic<signed char> : __atomic_base<signed char> {
    typedef signed char __integral_type;
    typedef __atomic_base<signed char> __base_type;

    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(__integral_type __i) noexcept : __base_type(__i) {}

    using __base_type::operator __integral_type;
    using __base_type::operator=;

    static constexpr bool is_always_lock_free = 2 == 2;
  };

  template <> struct atomic<unsigned char> : __atomic_base<unsigned char> {
    typedef unsigned char __integral_type;
    typedef __atomic_base<unsigned char> __base_type;

    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(__integral_type __i) noexcept : __base_type(__i) {}

    using __base_type::operator __integral_type;
    using __base_type::operator=;

    static constexpr bool is_always_lock_free = 2 == 2;
  };

  template <> struct atomic<short> : __atomic_base<short> {
    typedef short __integral_type;
    typedef __atomic_base<short> __base_type;

    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(__integral_type __i) noexcept : __base_type(__i) {}

    using __base_type::operator __integral_type;
    using __base_type::operator=;

    static constexpr bool is_always_lock_free = 2 == 2;
  };

  template <> struct atomic<unsigned short> : __atomic_base<unsigned short> {
    typedef unsigned short __integral_type;
    typedef __atomic_base<unsigned short> __base_type;

    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(__integral_type __i) noexcept : __base_type(__i) {}

    using __base_type::operator __integral_type;
    using __base_type::operator=;

    static constexpr bool is_always_lock_free = 2 == 2;
  };

  template <> struct atomic<int> : __atomic_base<int> {
    typedef int __integral_type;
    typedef __atomic_base<int> __base_type;

    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(__integral_type __i) noexcept : __base_type(__i) {}

    using __base_type::operator __integral_type;
    using __base_type::operator=;

    static constexpr bool is_always_lock_free = 2 == 2;
  };

  template <> struct atomic<unsigned int> : __atomic_base<unsigned int> {
    typedef unsigned int __integral_type;
    typedef __atomic_base<unsigned int> __base_type;

    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(__integral_type __i) noexcept : __base_type(__i) {}

    using __base_type::operator __integral_type;
    using __base_type::operator=;

    static constexpr bool is_always_lock_free = 2 == 2;
  };

  template <> struct atomic<long> : __atomic_base<long> {
    typedef long __integral_type;
    typedef __atomic_base<long> __base_type;

    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(__integral_type __i) noexcept : __base_type(__i) {}

    using __base_type::operator __integral_type;
    using __base_type::operator=;

    static constexpr bool is_always_lock_free = 2 == 2;
  };

  template <> struct atomic<unsigned long> : __atomic_base<unsigned long> {
    typedef unsigned long __integral_type;
    typedef __atomic_base<unsigned long> __base_type;

    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(__integral_type __i) noexcept : __base_type(__i) {}

    using __base_type::operator __integral_type;
    using __base_type::operator=;

    static constexpr bool is_always_lock_free = 2 == 2;
  };

  template <> struct atomic<long long> : __atomic_base<long long> {
    typedef long long __integral_type;
    typedef __atomic_base<long long> __base_type;

    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(__integral_type __i) noexcept : __base_type(__i) {}

    using __base_type::operator __integral_type;
    using __base_type::operator=;

    static constexpr bool is_always_lock_free = 2 == 2;
  };

  template <>
  struct atomic<unsigned long long> : __atomic_base<unsigned long long> {
    typedef unsigned long long __integral_type;
    typedef __atomic_base<unsigned long long> __base_type;

    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(__integral_type __i) noexcept : __base_type(__i) {}

    using __base_type::operator __integral_type;
    using __base_type::operator=;

    static constexpr bool is_always_lock_free = 2 == 2;
  };

  template <> struct atomic<wchar_t> : __atomic_base<wchar_t> {
    typedef wchar_t __integral_type;
    typedef __atomic_base<wchar_t> __base_type;

    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(__integral_type __i) noexcept : __base_type(__i) {}

    using __base_type::operator __integral_type;
    using __base_type::operator=;

    static constexpr bool is_always_lock_free = 2 == 2;
  };

  template <> struct atomic<char8_t> : __atomic_base<char8_t> {
    typedef char8_t __integral_type;
    typedef __atomic_base<char8_t> __base_type;

    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(__integral_type __i) noexcept : __base_type(__i) {}

    using __base_type::operator __integral_type;
    using __base_type::operator=;

    static constexpr bool is_always_lock_free = 2 == 2;
  };

  template <> struct atomic<char16_t> : __atomic_base<char16_t> {
    typedef char16_t __integral_type;
    typedef __atomic_base<char16_t> __base_type;

    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(__integral_type __i) noexcept : __base_type(__i) {}

    using __base_type::operator __integral_type;
    using __base_type::operator=;

    static constexpr bool is_always_lock_free = 2 == 2;
  };

  template <> struct atomic<char32_t> : __atomic_base<char32_t> {
    typedef char32_t __integral_type;
    typedef __atomic_base<char32_t> __base_type;

    atomic() noexcept = default;
    ~atomic() noexcept = default;
    atomic(const atomic &) = delete;
    atomic &operator=(const atomic &) = delete;
    atomic &operator=(const atomic &) volatile = delete;

    constexpr atomic(__integral_type __i) noexcept : __base_type(__i) {}

    using __base_type::operator __integral_type;
    using __base_type::operator=;

    static constexpr bool is_always_lock_free = 2 == 2;
  };

  typedef atomic<bool> atomic_bool;

  typedef atomic<char> atomic_char;

  typedef atomic<signed char> atomic_schar;

  typedef atomic<unsigned char> atomic_uchar;

  typedef atomic<short> atomic_short;

  typedef atomic<unsigned short> atomic_ushort;

  typedef atomic<int> atomic_int;

  typedef atomic<unsigned int> atomic_uint;

  typedef atomic<long> atomic_long;

  typedef atomic<unsigned long> atomic_ulong;

  typedef atomic<long long> atomic_llong;

  typedef atomic<unsigned long long> atomic_ullong;

  typedef atomic<wchar_t> atomic_wchar_t;

  typedef atomic<char8_t> atomic_char8_t;

  typedef atomic<char16_t> atomic_char16_t;

  typedef atomic<char32_t> atomic_char32_t;

  typedef atomic<int8_t> atomic_int8_t;

  typedef atomic<uint8_t> atomic_uint8_t;

  typedef atomic<int16_t> atomic_int16_t;

  typedef atomic<uint16_t> atomic_uint16_t;

  typedef atomic<int32_t> atomic_int32_t;

  typedef atomic<uint32_t> atomic_uint32_t;

  typedef atomic<int64_t> atomic_int64_t;

  typedef atomic<uint64_t> atomic_uint64_t;

  typedef atomic<int_least8_t> atomic_int_least8_t;

  typedef atomic<uint_least8_t> atomic_uint_least8_t;

  typedef atomic<int_least16_t> atomic_int_least16_t;

  typedef atomic<uint_least16_t> atomic_uint_least16_t;

  typedef atomic<int_least32_t> atomic_int_least32_t;

  typedef atomic<uint_least32_t> atomic_uint_least32_t;

  typedef atomic<int_least64_t> atomic_int_least64_t;

  typedef atomic<uint_least64_t> atomic_uint_least64_t;

  typedef atomic<int_fast8_t> atomic_int_fast8_t;

  typedef atomic<uint_fast8_t> atomic_uint_fast8_t;

  typedef atomic<int_fast16_t> atomic_int_fast16_t;

  typedef atomic<uint_fast16_t> atomic_uint_fast16_t;

  typedef atomic<int_fast32_t> atomic_int_fast32_t;

  typedef atomic<uint_fast32_t> atomic_uint_fast32_t;

  typedef atomic<int_fast64_t> atomic_int_fast64_t;

  typedef atomic<uint_fast64_t> atomic_uint_fast64_t;

  typedef atomic<intptr_t> atomic_intptr_t;

  typedef atomic<uintptr_t> atomic_uintptr_t;

  typedef atomic<size_t> atomic_size_t;

  typedef atomic<ptrdiff_t> atomic_ptrdiff_t;

  typedef atomic<intmax_t> atomic_intmax_t;

  typedef atomic<uintmax_t> atomic_uintmax_t;

  inline bool atomic_flag_test_and_set_explicit(atomic_flag * __a,
                                                memory_order __m) noexcept {
    return __a->test_and_set(__m);
  }

  inline bool atomic_flag_test_and_set_explicit(volatile atomic_flag * __a,
                                                memory_order __m) noexcept {
    return __a->test_and_set(__m);
  }

  inline bool atomic_flag_test(const atomic_flag *__a) noexcept {
    return __a->test();
  }

  inline bool atomic_flag_test(const volatile atomic_flag *__a) noexcept {
    return __a->test();
  }

  inline bool atomic_flag_test_explicit(const atomic_flag *__a,
                                        memory_order __m) noexcept {
    return __a->test(__m);
  }

  inline bool atomic_flag_test_explicit(const volatile atomic_flag *__a,
                                        memory_order __m) noexcept {
    return __a->test(__m);
  }

  inline void atomic_flag_clear_explicit(atomic_flag * __a,
                                         memory_order __m) noexcept {
    __a->clear(__m);
  }

  inline void atomic_flag_clear_explicit(volatile atomic_flag * __a,
                                         memory_order __m) noexcept {
    __a->clear(__m);
  }

  inline bool atomic_flag_test_and_set(atomic_flag * __a) noexcept {
    return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst);
  }

  inline bool atomic_flag_test_and_set(volatile atomic_flag * __a) noexcept {
    return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst);
  }

  inline void atomic_flag_clear(atomic_flag * __a) noexcept {
    atomic_flag_clear_explicit(__a, memory_order_seq_cst);
  }

  inline void atomic_flag_clear(volatile atomic_flag * __a) noexcept {
    atomic_flag_clear_explicit(__a, memory_order_seq_cst);
  }

  inline void atomic_flag_wait(atomic_flag * __a, bool __old) noexcept {
    __a->wait(__old);
  }

  inline void atomic_flag_wait_explicit(atomic_flag * __a, bool __old,
                                        memory_order __m) noexcept {
    __a->wait(__old, __m);
  }

  inline void atomic_flag_notify_one(atomic_flag * __a) noexcept {
    __a->notify_one();
  }

  inline void atomic_flag_notify_all(atomic_flag * __a) noexcept {
    __a->notify_all();
  }

  template <typename _Tp> using __atomic_val_t = __type_identity_t<_Tp>;
  template <typename _Tp>
  using __atomic_diff_t = typename atomic<_Tp>::difference_type;

  template <typename _ITp>
  inline bool atomic_is_lock_free(const atomic<_ITp> *__a) noexcept {
    return __a->is_lock_free();
  }

  template <typename _ITp>
  inline bool atomic_is_lock_free(const volatile atomic<_ITp> *__a) noexcept {
    return __a->is_lock_free();
  }

  template <typename _ITp>
  inline void atomic_init(atomic<_ITp> * __a,
                          __atomic_val_t<_ITp> __i) noexcept {
    __a->store(__i, memory_order_relaxed);
  }

  template <typename _ITp>
  inline void atomic_init(volatile atomic<_ITp> * __a,
                          __atomic_val_t<_ITp> __i) noexcept {
    __a->store(__i, memory_order_relaxed);
  }

  template <typename _ITp>
  inline void atomic_store_explicit(
      atomic<_ITp> * __a, __atomic_val_t<_ITp> __i, memory_order __m) noexcept {
    __a->store(__i, __m);
  }

  template <typename _ITp>
  inline void atomic_store_explicit(volatile atomic<_ITp> * __a,
                                    __atomic_val_t<_ITp> __i,
                                    memory_order __m) noexcept {
    __a->store(__i, __m);
  }

  template <typename _ITp>
  inline _ITp atomic_load_explicit(const atomic<_ITp> *__a,
                                   memory_order __m) noexcept {
    return __a->load(__m);
  }

  template <typename _ITp>
  inline _ITp atomic_load_explicit(const volatile atomic<_ITp> *__a,
                                   memory_order __m) noexcept {
    return __a->load(__m);
  }

  template <typename _ITp>
  inline _ITp atomic_exchange_explicit(
      atomic<_ITp> * __a, __atomic_val_t<_ITp> __i, memory_order __m) noexcept {
    return __a->exchange(__i, __m);
  }

  template <typename _ITp>
  inline _ITp atomic_exchange_explicit(volatile atomic<_ITp> * __a,
                                       __atomic_val_t<_ITp> __i,
                                       memory_order __m) noexcept {
    return __a->exchange(__i, __m);
  }

  template <typename _ITp>
  inline bool atomic_compare_exchange_weak_explicit(
      atomic<_ITp> * __a, __atomic_val_t<_ITp> * __i1,
      __atomic_val_t<_ITp> __i2, memory_order __m1,
      memory_order __m2) noexcept {
    return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2);
  }

  template <typename _ITp>
  inline bool atomic_compare_exchange_weak_explicit(
      volatile atomic<_ITp> * __a, __atomic_val_t<_ITp> * __i1,
      __atomic_val_t<_ITp> __i2, memory_order __m1,
      memory_order __m2) noexcept {
    return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2);
  }

  template <typename _ITp>
  inline bool atomic_compare_exchange_strong_explicit(
      atomic<_ITp> * __a, __atomic_val_t<_ITp> * __i1,
      __atomic_val_t<_ITp> __i2, memory_order __m1,
      memory_order __m2) noexcept {
    return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2);
  }

  template <typename _ITp>
  inline bool atomic_compare_exchange_strong_explicit(
      volatile atomic<_ITp> * __a, __atomic_val_t<_ITp> * __i1,
      __atomic_val_t<_ITp> __i2, memory_order __m1,
      memory_order __m2) noexcept {
    return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2);
  }

  template <typename _ITp>
  inline void atomic_store(atomic<_ITp> * __a,
                           __atomic_val_t<_ITp> __i) noexcept {
    atomic_store_explicit(__a, __i, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline void atomic_store(volatile atomic<_ITp> * __a,
                           __atomic_val_t<_ITp> __i) noexcept {
    atomic_store_explicit(__a, __i, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline _ITp atomic_load(const atomic<_ITp> *__a) noexcept {
    return atomic_load_explicit(__a, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline _ITp atomic_load(const volatile atomic<_ITp> *__a) noexcept {
    return atomic_load_explicit(__a, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline _ITp atomic_exchange(atomic<_ITp> * __a,
                              __atomic_val_t<_ITp> __i) noexcept {
    return atomic_exchange_explicit(__a, __i, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline _ITp atomic_exchange(volatile atomic<_ITp> * __a,
                              __atomic_val_t<_ITp> __i) noexcept {
    return atomic_exchange_explicit(__a, __i, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline bool atomic_compare_exchange_weak(atomic<_ITp> * __a,
                                           __atomic_val_t<_ITp> * __i1,
                                           __atomic_val_t<_ITp> __i2) noexcept {
    return atomic_compare_exchange_weak_explicit(
        __a, __i1, __i2, memory_order_seq_cst, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline bool atomic_compare_exchange_weak(volatile atomic<_ITp> * __a,
                                           __atomic_val_t<_ITp> * __i1,
                                           __atomic_val_t<_ITp> __i2) noexcept {
    return atomic_compare_exchange_weak_explicit(
        __a, __i1, __i2, memory_order_seq_cst, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline bool atomic_compare_exchange_strong(
      atomic<_ITp> * __a, __atomic_val_t<_ITp> * __i1,
      __atomic_val_t<_ITp> __i2) noexcept {
    return atomic_compare_exchange_strong_explicit(
        __a, __i1, __i2, memory_order_seq_cst, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline bool atomic_compare_exchange_strong(
      volatile atomic<_ITp> * __a, __atomic_val_t<_ITp> * __i1,
      __atomic_val_t<_ITp> __i2) noexcept {
    return atomic_compare_exchange_strong_explicit(
        __a, __i1, __i2, memory_order_seq_cst, memory_order_seq_cst);
  }

  template <typename _Tp>
  inline void atomic_wait(
      const atomic<_Tp> *__a,
      typename std::atomic<_Tp>::value_type __old) noexcept {
    __a->wait(__old);
  }

  template <typename _Tp>
  inline void atomic_wait_explicit(const atomic<_Tp> *__a,
                                   typename std::atomic<_Tp>::value_type __old,
                                   std::memory_order __m) noexcept {
    __a->wait(__old, __m);
  }

  template <typename _Tp>
  inline void atomic_notify_one(atomic<_Tp> * __a) noexcept {
    __a->notify_one();
  }

  template <typename _Tp>
  inline void atomic_notify_all(atomic<_Tp> * __a) noexcept {
    __a->notify_all();
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_add_explicit(atomic<_ITp> * __a,
                                        __atomic_diff_t<_ITp> __i,
                                        memory_order __m) noexcept {
    return __a->fetch_add(__i, __m);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_add_explicit(volatile atomic<_ITp> * __a,
                                        __atomic_diff_t<_ITp> __i,
                                        memory_order __m) noexcept {
    return __a->fetch_add(__i, __m);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_sub_explicit(atomic<_ITp> * __a,
                                        __atomic_diff_t<_ITp> __i,
                                        memory_order __m) noexcept {
    return __a->fetch_sub(__i, __m);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_sub_explicit(volatile atomic<_ITp> * __a,
                                        __atomic_diff_t<_ITp> __i,
                                        memory_order __m) noexcept {
    return __a->fetch_sub(__i, __m);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_and_explicit(__atomic_base<_ITp> * __a,
                                        __atomic_val_t<_ITp> __i,
                                        memory_order __m) noexcept {
    return __a->fetch_and(__i, __m);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_and_explicit(volatile __atomic_base<_ITp> * __a,
                                        __atomic_val_t<_ITp> __i,
                                        memory_order __m) noexcept {
    return __a->fetch_and(__i, __m);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_or_explicit(__atomic_base<_ITp> * __a,
                                       __atomic_val_t<_ITp> __i,
                                       memory_order __m) noexcept {
    return __a->fetch_or(__i, __m);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_or_explicit(volatile __atomic_base<_ITp> * __a,
                                       __atomic_val_t<_ITp> __i,
                                       memory_order __m) noexcept {
    return __a->fetch_or(__i, __m);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_xor_explicit(__atomic_base<_ITp> * __a,
                                        __atomic_val_t<_ITp> __i,
                                        memory_order __m) noexcept {
    return __a->fetch_xor(__i, __m);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_xor_explicit(volatile __atomic_base<_ITp> * __a,
                                        __atomic_val_t<_ITp> __i,
                                        memory_order __m) noexcept {
    return __a->fetch_xor(__i, __m);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_add(atomic<_ITp> * __a,
                               __atomic_diff_t<_ITp> __i) noexcept {
    return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_add(volatile atomic<_ITp> * __a,
                               __atomic_diff_t<_ITp> __i) noexcept {
    return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_sub(atomic<_ITp> * __a,
                               __atomic_diff_t<_ITp> __i) noexcept {
    return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_sub(volatile atomic<_ITp> * __a,
                               __atomic_diff_t<_ITp> __i) noexcept {
    return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_and(__atomic_base<_ITp> * __a,
                               __atomic_val_t<_ITp> __i) noexcept {
    return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_and(volatile __atomic_base<_ITp> * __a,
                               __atomic_val_t<_ITp> __i) noexcept {
    return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_or(__atomic_base<_ITp> * __a,
                              __atomic_val_t<_ITp> __i) noexcept {
    return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_or(volatile __atomic_base<_ITp> * __a,
                              __atomic_val_t<_ITp> __i) noexcept {
    return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_xor(__atomic_base<_ITp> * __a,
                               __atomic_val_t<_ITp> __i) noexcept {
    return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst);
  }

  template <typename _ITp>
  inline _ITp atomic_fetch_xor(volatile __atomic_base<_ITp> * __a,
                               __atomic_val_t<_ITp> __i) noexcept {
    return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst);
  }

  template <> struct atomic<float> : __atomic_float<float> {
    atomic() noexcept = default;

    constexpr atomic(float __fp) noexcept : __atomic_float<float>(__fp) {}

    atomic &operator=(const atomic &) volatile = delete;
    atomic &operator=(const atomic &) = delete;

    using __atomic_float<float>::operator=;
  };

  template <> struct atomic<double> : __atomic_float<double> {
    atomic() noexcept = default;

    constexpr atomic(double __fp) noexcept : __atomic_float<double>(__fp) {}

    atomic &operator=(const atomic &) volatile = delete;
    atomic &operator=(const atomic &) = delete;

    using __atomic_float<double>::operator=;
  };

  template <> struct atomic<long double> : __atomic_float<long double> {
    atomic() noexcept = default;

    constexpr atomic(long double __fp) noexcept
        : __atomic_float<long double>(__fp) {}

    atomic &operator=(const atomic &) volatile = delete;
    atomic &operator=(const atomic &) = delete;

    using __atomic_float<long double>::operator=;
  };
# 1755 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/atomic" 3
  template <typename _Tp> struct atomic_ref : __atomic_ref<_Tp> {
    explicit atomic_ref(_Tp &__t) noexcept : __atomic_ref<_Tp>(__t) {}

    atomic_ref &operator=(const atomic_ref &) = delete;

    atomic_ref(const atomic_ref &) = default;

    using __atomic_ref<_Tp>::operator=;
  };

  using atomic_signed_lock_free =
      atomic<make_signed_t<__detail::__platform_wait_t>>;
  using atomic_unsigned_lock_free =
      atomic<make_unsigned_t<__detail::__platform_wait_t>>;
# 1791 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/atomic" 3
} // namespace std
# 26 "./../stdexec/include/stdexec/__detail/../stop_token.hpp" 2
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/thread" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/thread" 3
# 42 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/thread" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/stop_token" 1 3
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/stop_token" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_thread.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_thread.h" 3
# 52 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_thread.h" 3
namespace std __attribute__((__visibility__("default"))) {
# 78 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_thread.h" 3
  class thread {
  public:
    using native_handle_type = __gthread_t;
# 92 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_thread.h" 3
    class id {
      native_handle_type _M_thread;

    public:
      id() noexcept : _M_thread() {}

      explicit id(native_handle_type __id) : _M_thread(__id) {}

    private:
      friend class thread;
      friend struct hash<id>;

      friend bool operator==(id __x, id __y) noexcept;

      friend strong_ordering operator<=>(id __x, id __y) noexcept;

      template <class _CharT, class _Traits>
      friend basic_ostream<_CharT, _Traits> &
      operator<<(basic_ostream<_CharT, _Traits> &__out, id __id);
    };

  private:
    id _M_id;

    template <typename _Tp>
    using __not_same = __not_<is_same<__remove_cvref_t<_Tp>, thread>>;

  public:
    thread() noexcept = default;

  private:
    static void _M_thread_deps_never_run() {}

  public:
    template <typename _Callable, typename... _Args,
              typename = _Require<__not_same<_Callable>>>
    explicit thread(_Callable &&__f, _Args &&...__args) {
      static_assert(__is_invocable<typename decay<_Callable>::type,
                                   typename decay<_Args>::type...>::value,
                    "std::thread arguments must be invocable after conversion "
                    "to rvalues");

      using _Wrapper = _Call_wrapper<_Callable, _Args...>;

      _M_start_thread(
          _State_ptr(new _State_impl<_Wrapper>(std::forward<_Callable>(__f),
                                               std::forward<_Args>(__args)...)),
          _M_thread_deps_never_run);
    }

    ~thread() {
      if (joinable())
        std::__terminate();
    }

    thread(const thread &) = delete;

    thread(thread &&__t) noexcept { swap(__t); }

    thread &operator=(const thread &) = delete;

    thread &operator=(thread &&__t) noexcept {
      if (joinable())
        std::__terminate();
      swap(__t);
      return *this;
    }

    void swap(thread &__t) noexcept { std::swap(_M_id, __t._M_id); }

    bool joinable() const noexcept { return !(_M_id == id()); }

    void join();

    void detach();

    id get_id() const noexcept { return _M_id; }

    native_handle_type native_handle() { return _M_id._M_thread; }

    static unsigned int hardware_concurrency() noexcept;

  private:
    struct _State {
      virtual ~_State();
      virtual void _M_run() = 0;
    };
    using _State_ptr = unique_ptr<_State>;

  private:
    template <typename _Callable> struct _State_impl : public _State {
      _Callable _M_func;

      template <typename... _Args>
      _State_impl(_Args &&...__args)
          : _M_func(std::forward<_Args>(__args)...) {}

      void _M_run() { _M_func(); }
    };

    void _M_start_thread(_State_ptr, void (*)());
# 269 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_thread.h" 3
  private:
    template <typename _Tuple> struct _Invoker {
      template <typename... _Args>
      explicit _Invoker(_Args &&...__args)
          : _M_t(std::forward<_Args>(__args)...) {}

      _Tuple _M_t;

      template <typename> struct __result;
      template <typename _Fn, typename... _Args>
      struct __result<tuple<_Fn, _Args...>> : __invoke_result<_Fn, _Args...> {};

      template <size_t... _Ind>
      typename __result<_Tuple>::type _M_invoke(_Index_tuple<_Ind...>) {
        return std::__invoke(std::get<_Ind>(std::move(_M_t))...);
      }

      typename __result<_Tuple>::type operator()() {
        using _Indices =
            typename _Build_index_tuple<tuple_size<_Tuple>::value>::__type;
        return _M_invoke(_Indices());
      }
    };

  public:
    template <typename... _Tp>
    using _Call_wrapper = _Invoker<tuple<typename decay<_Tp>::type...>>;
  };
# 318 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_thread.h" 3
  inline void swap(thread & __x, thread & __y) noexcept { __x.swap(__y); }

  inline bool operator==(thread::id __x, thread::id __y) noexcept {

    return __x._M_thread == __y._M_thread;
  }

  template <> struct hash<thread::id> : public __hash_base<size_t, thread::id> {
    size_t operator()(const thread::id &__id) const noexcept {
      return std::_Hash_impl::hash(__id._M_thread);
    }
  };

  namespace this_thread {

  inline thread::id get_id() noexcept { return thread::id(pthread_self()); }

  inline void yield() noexcept { __gthread_yield(); }

  } // namespace this_thread

} // namespace std
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/stop_token" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/semaphore" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/semaphore" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/semaphore_base.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/semaphore_base.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ratio" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ratio" 3

namespace std __attribute__((__visibility__("default"))) {
# 56 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ratio" 3
  template <intmax_t _Pn>
  struct __static_sign : integral_constant<intmax_t, (_Pn < 0) ? -1 : 1> {};

  template <intmax_t _Pn>
  struct __static_abs
      : integral_constant<intmax_t, _Pn * __static_sign<_Pn>::value> {};

  template <intmax_t _Pn, intmax_t _Qn>
  struct __static_gcd : __static_gcd<_Qn, (_Pn % _Qn)> {};

  template <intmax_t _Pn>
  struct __static_gcd<_Pn, 0>
      : integral_constant<intmax_t, __static_abs<_Pn>::value> {};

  template <intmax_t _Qn>
  struct __static_gcd<0, _Qn>
      : integral_constant<intmax_t, __static_abs<_Qn>::value> {};

  template <intmax_t _Pn, intmax_t _Qn> struct __safe_multiply {
  private:
    static const uintmax_t __c = uintmax_t(1) << (sizeof(intmax_t) * 4);

    static const uintmax_t __a0 = __static_abs<_Pn>::value % __c;
    static const uintmax_t __a1 = __static_abs<_Pn>::value / __c;
    static const uintmax_t __b0 = __static_abs<_Qn>::value % __c;
    static const uintmax_t __b1 = __static_abs<_Qn>::value / __c;

    static_assert(__a1 == 0 || __b1 == 0, "overflow in multiplication");
    static_assert(__a0 * __b1 + __b0 * __a1 < (__c >> 1),
                  "overflow in multiplication");
    static_assert(__b0 * __a0 <= 9223372036854775807L,
                  "overflow in multiplication");
    static_assert((__a0 * __b1 + __b0 * __a1) * __c <=
                      9223372036854775807L - __b0 * __a0,
                  "overflow in multiplication");

  public:
    static const intmax_t value = _Pn * _Qn;
  };

  template <uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2>
  struct __big_less
      : integral_constant<bool, (__hi1 < __hi2 ||
                                 (__hi1 == __hi2 && __lo1 < __lo2))> {};

  template <uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2>
  struct __big_add {
    static constexpr uintmax_t __lo = __lo1 + __lo2;
    static constexpr uintmax_t __hi = (__hi1 + __hi2 + (__lo1 + __lo2 < __lo1));
  };

  template <uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2>
  struct __big_sub {
    static_assert(!__big_less<__hi1, __lo1, __hi2, __lo2>::value,
                  "Internal library error");
    static constexpr uintmax_t __lo = __lo1 - __lo2;
    static constexpr uintmax_t __hi = (__hi1 - __hi2 - (__lo1 < __lo2));
  };

  template <uintmax_t __x, uintmax_t __y> struct __big_mul {
  private:
    static constexpr uintmax_t __c = uintmax_t(1) << (sizeof(intmax_t) * 4);
    static constexpr uintmax_t __x0 = __x % __c;
    static constexpr uintmax_t __x1 = __x / __c;
    static constexpr uintmax_t __y0 = __y % __c;
    static constexpr uintmax_t __y1 = __y / __c;
    static constexpr uintmax_t __x0y0 = __x0 * __y0;
    static constexpr uintmax_t __x0y1 = __x0 * __y1;
    static constexpr uintmax_t __x1y0 = __x1 * __y0;
    static constexpr uintmax_t __x1y1 = __x1 * __y1;
    static constexpr uintmax_t __mix = __x0y1 + __x1y0;
    static constexpr uintmax_t __mix_lo = __mix * __c;
    static constexpr uintmax_t __mix_hi =
        __mix / __c + ((__mix < __x0y1) ? __c : 0);
    typedef __big_add<__mix_hi, __mix_lo, __x1y1, __x0y0> _Res;

  public:
    static constexpr uintmax_t __hi = _Res::__hi;
    static constexpr uintmax_t __lo = _Res::__lo;
  };

  template <uintmax_t __n1, uintmax_t __n0, uintmax_t __d>
  struct __big_div_impl {
  private:
    static_assert(__d >= (uintmax_t(1) << (sizeof(intmax_t) * 8 - 1)),
                  "Internal library error");
    static_assert(__n1 < __d, "Internal library error");
    static constexpr uintmax_t __c = uintmax_t(1) << (sizeof(intmax_t) * 4);
    static constexpr uintmax_t __d1 = __d / __c;
    static constexpr uintmax_t __d0 = __d % __c;

    static constexpr uintmax_t __q1x = __n1 / __d1;
    static constexpr uintmax_t __r1x = __n1 % __d1;
    static constexpr uintmax_t __m = __q1x * __d0;
    static constexpr uintmax_t __r1y = __r1x * __c + __n0 / __c;
    static constexpr uintmax_t __r1z = __r1y + __d;
    static constexpr uintmax_t __r1 =
        ((__r1y < __m)
             ? ((__r1z >= __d) && (__r1z < __m)) ? (__r1z + __d) : __r1z
             : __r1y) -
        __m;
    static constexpr uintmax_t __q1 =
        __q1x - ((__r1y < __m) ? ((__r1z >= __d) && (__r1z < __m)) ? 2 : 1 : 0);
    static constexpr uintmax_t __q0x = __r1 / __d1;
    static constexpr uintmax_t __r0x = __r1 % __d1;
    static constexpr uintmax_t __n = __q0x * __d0;
    static constexpr uintmax_t __r0y = __r0x * __c + __n0 % __c;
    static constexpr uintmax_t __r0z = __r0y + __d;
    static constexpr uintmax_t __r0 =
        ((__r0y < __n)
             ? ((__r0z >= __d) && (__r0z < __n)) ? (__r0z + __d) : __r0z
             : __r0y) -
        __n;
    static constexpr uintmax_t __q0 =
        __q0x - ((__r0y < __n) ? ((__r0z >= __d) && (__r0z < __n)) ? 2 : 1 : 0);

  public:
    static constexpr uintmax_t __quot = __q1 * __c + __q0;
    static constexpr uintmax_t __rem = __r0;

  private:
    typedef __big_mul<__quot, __d> _Prod;
    typedef __big_add<_Prod::__hi, _Prod::__lo, 0, __rem> _Sum;
    static_assert(_Sum::__hi == __n1 && _Sum::__lo == __n0,
                  "Internal library error");
  };

  template <uintmax_t __n1, uintmax_t __n0, uintmax_t __d> struct __big_div {
  private:
    static_assert(__d != 0, "Internal library error");
    static_assert(sizeof(uintmax_t) == sizeof(unsigned long long),
                  "This library calls __builtin_clzll on uintmax_t, which "
                  "is unsafe on your platform. Please complain to "
                  "http://gcc.gnu.org/bugzilla/");
    static constexpr int __shift = __builtin_clzll(__d);
    static constexpr int __coshift_ = sizeof(uintmax_t) * 8 - __shift;
    static constexpr int __coshift = (__shift != 0) ? __coshift_ : 0;
    static constexpr uintmax_t __c1 = uintmax_t(1) << __shift;
    static constexpr uintmax_t __c2 = uintmax_t(1) << __coshift;
    static constexpr uintmax_t __new_d = __d * __c1;
    static constexpr uintmax_t __new_n0 = __n0 * __c1;
    static constexpr uintmax_t __n1_shifted = (__n1 % __d) * __c1;
    static constexpr uintmax_t __n0_top = (__shift != 0) ? (__n0 / __c2) : 0;
    static constexpr uintmax_t __new_n1 = __n1_shifted + __n0_top;
    typedef __big_div_impl<__new_n1, __new_n0, __new_d> _Res;

  public:
    static constexpr uintmax_t __quot_hi = __n1 / __d;
    static constexpr uintmax_t __quot_lo = _Res::__quot;
    static constexpr uintmax_t __rem = _Res::__rem / __c1;

  private:
    typedef __big_mul<__quot_lo, __d> _P0;
    typedef __big_mul<__quot_hi, __d> _P1;
    typedef __big_add<_P0::__hi, _P0::__lo, _P1::__lo, __rem> _Sum;

    static_assert(_P1::__hi == 0, "Internal library error");
    static_assert(_Sum::__hi >= _P0::__hi, "Internal library error");

    static_assert(_Sum::__hi == __n1 && _Sum::__lo == __n0,
                  "Internal library error");
    static_assert(__rem < __d, "Internal library error");
  };
# 265 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ratio" 3
  template <intmax_t _Num, intmax_t _Den = 1> struct ratio {
    static_assert(_Den != 0, "denominator cannot be zero");
    static_assert(_Num >= -9223372036854775807L &&
                      _Den >= -9223372036854775807L,
                  "out of range");

    static constexpr intmax_t num =
        _Num * __static_sign<_Den>::value / __static_gcd<_Num, _Den>::value;

    static constexpr intmax_t den =
        __static_abs<_Den>::value / __static_gcd<_Num, _Den>::value;

    typedef ratio<num, den> type;
  };
# 292 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ratio" 3
  template <typename _Tp> struct __is_ratio : std::false_type {};

  template <intmax_t _Num, intmax_t _Den>
  struct __is_ratio<ratio<_Num, _Den>> : std::true_type {};

  template <typename _Tp> constexpr bool __is_ratio_v = false;
  template <intmax_t _Num, intmax_t _Den>
  constexpr bool __is_ratio_v<ratio<_Num, _Den>> = true;

  template <typename _R1, typename _R2>
  constexpr bool __are_both_ratios() noexcept {

    if constexpr (__is_ratio_v<_R1>)
      if constexpr (__is_ratio_v<_R2>)
        return true;
    return false;
  }

  template <typename _R1, typename _R2> struct __ratio_multiply {
    static_assert(std::__are_both_ratios<_R1, _R2>(),
                  "both template arguments must be a std::ratio");

  private:
    static const intmax_t __gcd1 = __static_gcd<_R1::num, _R2::den>::value;
    static const intmax_t __gcd2 = __static_gcd<_R2::num, _R1::den>::value;

  public:
    typedef ratio<
        __safe_multiply<(_R1::num / __gcd1), (_R2::num / __gcd2)>::value,
        __safe_multiply<(_R1::den / __gcd2), (_R2::den / __gcd1)>::value>
        type;

    static constexpr intmax_t num = type::num;
    static constexpr intmax_t den = type::den;
  };
# 357 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ratio" 3
  template <typename _R1, typename _R2>
  using ratio_multiply = typename __ratio_multiply<_R1, _R2>::type;

  template <typename _R1, typename _R2> struct __ratio_divide {
    static_assert(_R2::num != 0, "division by 0");

    typedef
        typename __ratio_multiply<_R1, ratio<_R2::den, _R2::num>>::type type;

    static constexpr intmax_t num = type::num;
    static constexpr intmax_t den = type::den;
  };
# 386 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ratio" 3
  template <typename _R1, typename _R2>
  using ratio_divide = typename __ratio_divide<_R1, _R2>::type;

  template <typename _R1, typename _R2>
  struct ratio_equal
      : integral_constant<bool, _R1::num == _R2::num && _R1::den == _R2::den> {
    static_assert(std::__are_both_ratios<_R1, _R2>(),
                  "both template arguments must be a std::ratio");
  };

  template <typename _R1, typename _R2>
  struct ratio_not_equal
      : integral_constant<bool, !ratio_equal<_R1, _R2>::value> {};

  template <typename _R1, typename _R2,
            typename _Left = __big_mul<_R1::num, _R2::den>,
            typename _Right = __big_mul<_R2::num, _R1::den>>
  struct __ratio_less_impl_1
      : integral_constant<bool, __big_less<_Left::__hi, _Left::__lo,
                                           _Right::__hi, _Right::__lo>::value> {
  };

  template <typename _R1, typename _R2,
            bool = (_R1::num == 0 || _R2::num == 0 ||
                    (__static_sign<_R1::num>::value !=
                     __static_sign<_R2::num>::value)),
            bool = (__static_sign<_R1::num>::value == -1 &&
                    __static_sign<_R2::num>::value == -1)>
  struct __ratio_less_impl : __ratio_less_impl_1<_R1, _R2>::type {};

  template <typename _R1, typename _R2>
      struct __ratio_less_impl<_R1, _R2, true, false> : integral_constant <
                                                        bool,
      _R1::num<_R2::num> {};

  template <typename _R1, typename _R2>
  struct __ratio_less_impl<_R1, _R2, false, true>
      : __ratio_less_impl_1<ratio<-_R2::num, _R2::den>,
                            ratio<-_R1::num, _R1::den>>::type {};

  template <typename _R1, typename _R2>
  struct ratio_less : __ratio_less_impl<_R1, _R2>::type {
    static_assert(std::__are_both_ratios<_R1, _R2>(),
                  "both template arguments must be a std::ratio");
  };

  template <typename _R1, typename _R2>
  struct ratio_less_equal
      : integral_constant<bool, !ratio_less<_R2, _R1>::value> {};

  template <typename _R1, typename _R2>
  struct ratio_greater : integral_constant<bool, ratio_less<_R2, _R1>::value> {
  };

  template <typename _R1, typename _R2>
  struct ratio_greater_equal
      : integral_constant<bool, !ratio_less<_R1, _R2>::value> {};

  template <typename _R1, typename _R2>
  inline constexpr bool ratio_equal_v = ratio_equal<_R1, _R2>::value;
  template <typename _R1, typename _R2>
  inline constexpr bool ratio_not_equal_v = ratio_not_equal<_R1, _R2>::value;
  template <typename _R1, typename _R2>
  inline constexpr bool ratio_less_v = ratio_less<_R1, _R2>::value;
  template <typename _R1, typename _R2>
  inline constexpr bool ratio_less_equal_v = ratio_less_equal<_R1, _R2>::value;
  template <typename _R1, typename _R2>
  inline constexpr bool ratio_greater_v = ratio_greater<_R1, _R2>::value;
  template <typename _R1, typename _R2>
  inline constexpr bool ratio_greater_equal_v =
      ratio_greater_equal<_R1, _R2>::value;

  template <
      typename _R1, typename _R2, bool = (_R1::num >= 0),
      bool = (_R2::num >= 0),
      bool = ratio_less<ratio<__static_abs<_R1::num>::value, _R1::den>,
                        ratio<__static_abs<_R2::num>::value, _R2::den>>::value>
  struct __ratio_add_impl {
  private:
    typedef typename __ratio_add_impl<ratio<-_R1::num, _R1::den>,
                                      ratio<-_R2::num, _R2::den>>::type __t;

  public:
    typedef ratio<-__t::num, __t::den> type;
  };

  template <typename _R1, typename _R2, bool __b>
  struct __ratio_add_impl<_R1, _R2, true, true, __b> {
  private:
    static constexpr uintmax_t __g = __static_gcd<_R1::den, _R2::den>::value;
    static constexpr uintmax_t __d2 = _R2::den / __g;
    typedef __big_mul<_R1::den, __d2> __d;
    typedef __big_mul<_R1::num, _R2::den / __g> __x;
    typedef __big_mul<_R2::num, _R1::den / __g> __y;
    typedef __big_add<__x::__hi, __x::__lo, __y::__hi, __y::__lo> __n;
    static_assert(__n::__hi >= __x::__hi, "Internal library error");
    typedef __big_div<__n::__hi, __n::__lo, __g> __ng;
    static constexpr uintmax_t __g2 = __static_gcd<__ng::__rem, __g>::value;
    typedef __big_div<__n::__hi, __n::__lo, __g2> __n_final;
    static_assert(__n_final::__rem == 0, "Internal library error");
    static_assert(__n_final::__quot_hi == 0 &&
                      __n_final::__quot_lo <= 9223372036854775807L,
                  "overflow in addition");
    typedef __big_mul<_R1::den / __g2, __d2> __d_final;
    static_assert(__d_final::__hi == 0 &&
                      __d_final::__lo <= 9223372036854775807L,
                  "overflow in addition");

  public:
    typedef ratio<__n_final::__quot_lo, __d_final::__lo> type;
  };

  template <typename _R1, typename _R2>
  struct __ratio_add_impl<_R1, _R2, false, true, true>
      : __ratio_add_impl<_R2, _R1> {};

  template <typename _R1, typename _R2>
  struct __ratio_add_impl<_R1, _R2, true, false, false> {
  private:
    static constexpr uintmax_t __g = __static_gcd<_R1::den, _R2::den>::value;
    static constexpr uintmax_t __d2 = _R2::den / __g;
    typedef __big_mul<_R1::den, __d2> __d;
    typedef __big_mul<_R1::num, _R2::den / __g> __x;
    typedef __big_mul<-_R2::num, _R1::den / __g> __y;
    typedef __big_sub<__x::__hi, __x::__lo, __y::__hi, __y::__lo> __n;
    typedef __big_div<__n::__hi, __n::__lo, __g> __ng;
    static constexpr uintmax_t __g2 = __static_gcd<__ng::__rem, __g>::value;
    typedef __big_div<__n::__hi, __n::__lo, __g2> __n_final;
    static_assert(__n_final::__rem == 0, "Internal library error");
    static_assert(__n_final::__quot_hi == 0 &&
                      __n_final::__quot_lo <= 9223372036854775807L,
                  "overflow in addition");
    typedef __big_mul<_R1::den / __g2, __d2> __d_final;
    static_assert(__d_final::__hi == 0 &&
                      __d_final::__lo <= 9223372036854775807L,
                  "overflow in addition");

  public:
    typedef ratio<__n_final::__quot_lo, __d_final::__lo> type;
  };

  template <typename _R1, typename _R2> struct __ratio_add {
    static_assert(std::__are_both_ratios<_R1, _R2>(),
                  "both template arguments must be a std::ratio");

    typedef typename __ratio_add_impl<_R1, _R2>::type type;
    static constexpr intmax_t num = type::num;
    static constexpr intmax_t den = type::den;
  };
# 575 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ratio" 3
  template <typename _R1, typename _R2>
  using ratio_add = typename __ratio_add<_R1, _R2>::type;

  template <typename _R1, typename _R2> struct __ratio_subtract {
    typedef typename __ratio_add<_R1, ratio<-_R2::num, _R2::den>>::type type;

    static constexpr intmax_t num = type::num;
    static constexpr intmax_t den = type::den;
  };
# 602 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ratio" 3
  template <typename _R1, typename _R2>
  using ratio_subtract = typename __ratio_subtract<_R1, _R2>::type;

  typedef ratio<1, 1000000000000000000> atto;
  typedef ratio<1, 1000000000000000> femto;
  typedef ratio<1, 1000000000000> pico;
  typedef ratio<1, 1000000000> nano;
  typedef ratio<1, 1000000> micro;
  typedef ratio<1, 1000> milli;
  typedef ratio<1, 100> centi;
  typedef ratio<1, 10> deci;
  typedef ratio<10, 1> deca;
  typedef ratio<100, 1> hecto;
  typedef ratio<1000, 1> kilo;
  typedef ratio<1000000, 1> mega;
  typedef ratio<1000000000, 1> giga;
  typedef ratio<1000000000000, 1> tera;
  typedef ratio<1000000000000000, 1> peta;
  typedef ratio<1000000000000000000, 1> exa;

} // namespace std
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ctime" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ctime" 3
# 58 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ctime" 3
namespace std {
using ::clock_t;
using ::time_t;
using ::tm;

using ::asctime;
using ::clock;
using ::ctime;
using ::difftime;
using ::gmtime;
using ::localtime;
using ::mktime;
using ::strftime;
using ::time;
} // namespace std

namespace std {
using ::timespec;
using ::timespec_get;
} // namespace std
# 41 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  namespace filesystem {
  struct __file_clock;
  };

  namespace chrono {

  template <typename _Rep, typename _Period = ratio<1>> class duration;

  template <typename _Clock, typename _Dur = typename _Clock::duration>
  class time_point;

  } // namespace chrono
# 77 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _CT, typename _Period1, typename _Period2, typename = void>
  struct __duration_common_type {};

  template <typename _CT, typename _Period1, typename _Period2>
  struct __duration_common_type<_CT, _Period1, _Period2,
                                __void_t<typename _CT::type>> {
  private:
    using __gcd_num = __static_gcd<_Period1::num, _Period2::num>;
    using __gcd_den = __static_gcd<_Period1::den, _Period2::den>;
    using __cr = typename _CT::type;
    using __r = ratio<__gcd_num::value,
                      (_Period1::den / __gcd_den::value) * _Period2::den>;

  public:
    using type = chrono::duration<__cr, typename __r::type>;
  };

  template <typename _Rep1, typename _Period1, typename _Rep2,
            typename _Period2>
  struct common_type<chrono::duration<_Rep1, _Period1>,
                     chrono::duration<_Rep2, _Period2>>
      : __duration_common_type<common_type<_Rep1, _Rep2>,
                               typename _Period1::type,
                               typename _Period2::type> {};

  template <typename _Rep, typename _Period>
  struct common_type<chrono::duration<_Rep, _Period>,
                     chrono::duration<_Rep, _Period>> {
    using type = chrono::duration<typename common_type<_Rep>::type,
                                  typename _Period::type>;
  };

  template <typename _Rep, typename _Period>
  struct common_type<chrono::duration<_Rep, _Period>> {
    using type = chrono::duration<typename common_type<_Rep>::type,
                                  typename _Period::type>;
  };

  template <typename _CT, typename _Clock, typename = void>
  struct __timepoint_common_type {};

  template <typename _CT, typename _Clock>
  struct __timepoint_common_type<_CT, _Clock, __void_t<typename _CT::type>> {
    using type = chrono::time_point<_Clock, typename _CT::type>;
  };

  template <typename _Clock, typename _Duration1, typename _Duration2>
  struct common_type<chrono::time_point<_Clock, _Duration1>,
                     chrono::time_point<_Clock, _Duration2>>
      : __timepoint_common_type<common_type<_Duration1, _Duration2>, _Clock> {};

  template <typename _Clock, typename _Duration>
  struct common_type<chrono::time_point<_Clock, _Duration>,
                     chrono::time_point<_Clock, _Duration>> {
    using type = chrono::time_point<_Clock, _Duration>;
  };

  template <typename _Clock, typename _Duration>
  struct common_type<chrono::time_point<_Clock, _Duration>> {
    using type = chrono::time_point<_Clock, _Duration>;
  };

  namespace chrono {

  template <typename _ToDur, typename _CF, typename _CR, bool _NumIsOne = false,
            bool _DenIsOne = false>
  struct __duration_cast_impl {
    template <typename _Rep, typename _Period>
    static constexpr _ToDur __cast(const duration<_Rep, _Period> &__d) {
      typedef typename _ToDur::rep __to_rep;
      return _ToDur(static_cast<__to_rep>(static_cast<_CR>(__d.count()) *
                                          static_cast<_CR>(_CF::num) /
                                          static_cast<_CR>(_CF::den)));
    }
  };

  template <typename _ToDur, typename _CF, typename _CR>
  struct __duration_cast_impl<_ToDur, _CF, _CR, true, true> {
    template <typename _Rep, typename _Period>
    static constexpr _ToDur __cast(const duration<_Rep, _Period> &__d) {
      typedef typename _ToDur::rep __to_rep;
      return _ToDur(static_cast<__to_rep>(__d.count()));
    }
  };

  template <typename _ToDur, typename _CF, typename _CR>
  struct __duration_cast_impl<_ToDur, _CF, _CR, true, false> {
    template <typename _Rep, typename _Period>
    static constexpr _ToDur __cast(const duration<_Rep, _Period> &__d) {
      typedef typename _ToDur::rep __to_rep;
      return _ToDur(static_cast<__to_rep>(static_cast<_CR>(__d.count()) /
                                          static_cast<_CR>(_CF::den)));
    }
  };

  template <typename _ToDur, typename _CF, typename _CR>
  struct __duration_cast_impl<_ToDur, _CF, _CR, false, true> {
    template <typename _Rep, typename _Period>
    static constexpr _ToDur __cast(const duration<_Rep, _Period> &__d) {
      typedef typename _ToDur::rep __to_rep;
      return _ToDur(static_cast<__to_rep>(static_cast<_CR>(__d.count()) *
                                          static_cast<_CR>(_CF::num)));
    }
  };

  template <typename _Tp> struct __is_duration : std::false_type {};

  template <typename _Rep, typename _Period>
  struct __is_duration<duration<_Rep, _Period>> : std::true_type {};

  template <typename _Tp>
  using __enable_if_is_duration =
      typename enable_if<__is_duration<_Tp>::value, _Tp>::type;

  template <typename _Tp>
  using __disable_if_is_duration =
      typename enable_if<!__is_duration<_Tp>::value, _Tp>::type;

  template <typename _Tp> inline constexpr bool __is_duration_v = false;
  template <typename _Rep, typename _Period>
  inline constexpr bool __is_duration_v<duration<_Rep, _Period>> = true;
  template <typename _Tp> inline constexpr bool __is_time_point_v = false;
  template <typename _Clock, typename _Dur>
  inline constexpr bool __is_time_point_v<time_point<_Clock, _Dur>> = true;
# 270 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _ToDur, typename _Rep, typename _Period>
  [[__nodiscard__]]
  constexpr __enable_if_is_duration<_ToDur>
  duration_cast(const duration<_Rep, _Period> &__d) {

    if constexpr (is_same_v<_ToDur, duration<_Rep, _Period>>)
      return __d;
    else {

      using __to_period = typename _ToDur::period;
      using __to_rep = typename _ToDur::rep;
      using __cf = ratio_divide<_Period, __to_period>;
      using __cr = typename common_type<__to_rep, _Rep, intmax_t>::type;
      using __dc = __duration_cast_impl<_ToDur, __cf, __cr, __cf::num == 1,
                                        __cf::den == 1>;
      return __dc::__cast(__d);
    }
  }
# 304 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _Rep>
  struct treat_as_floating_point : is_floating_point<_Rep> {};

  template <typename _Rep>
  inline constexpr bool treat_as_floating_point_v =
      treat_as_floating_point<_Rep>::value;

  template <> inline constexpr bool treat_as_floating_point_v<int> = false;
  template <> inline constexpr bool treat_as_floating_point_v<long> = false;
  template <>
  inline constexpr bool treat_as_floating_point_v<long long> = false;
  template <> inline constexpr bool treat_as_floating_point_v<float> = true;
  template <> inline constexpr bool treat_as_floating_point_v<double> = true;
  template <>
  inline constexpr bool treat_as_floating_point_v<long double> = true;

  template <typename _Tp> inline constexpr bool is_clock_v = false;

  template <typename _Tp>
    requires requires {
      typename _Tp::rep;
      typename _Tp::period;
      typename _Tp::duration;
      typename _Tp::time_point::clock;
      typename _Tp::time_point::duration;
      { &_Tp::is_steady } -> same_as<const bool *>;
      { _Tp::now() } -> same_as<typename _Tp::time_point>;
      requires same_as<typename _Tp::duration,
                       duration<typename _Tp::rep, typename _Tp::period>>;
      requires same_as<typename _Tp::time_point::duration,
                       typename _Tp::duration>;
    }
  inline constexpr bool is_clock_v<_Tp> = true;
# 367 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _Tp> struct is_clock : bool_constant<is_clock_v<_Tp>> {};
# 386 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _ToDur, typename _Rep, typename _Period>
  [[nodiscard]] constexpr __enable_if_is_duration<_ToDur>
  floor(const duration<_Rep, _Period> &__d) {
    auto __to = chrono::duration_cast<_ToDur>(__d);
    if (__to > __d)
      return __to - _ToDur{1};
    return __to;
  }
# 406 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _ToDur, typename _Rep, typename _Period>
  [[nodiscard]] constexpr __enable_if_is_duration<_ToDur>
  ceil(const duration<_Rep, _Period> &__d) {
    auto __to = chrono::duration_cast<_ToDur>(__d);
    if (__to < __d)
      return __to + _ToDur{1};
    return __to;
  }
# 427 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _ToDur, typename _Rep, typename _Period>
  [[nodiscard]] constexpr enable_if_t<
      __and_<__is_duration<_ToDur>,
             __not_<treat_as_floating_point<typename _ToDur::rep>>>::value,
      _ToDur>
  round(const duration<_Rep, _Period> &__d) {
    _ToDur __t0 = chrono::floor<_ToDur>(__d);
    _ToDur __t1 = __t0 + _ToDur{1};
    auto __diff0 = __d - __t0;
    auto __diff1 = __t1 - __d;
    if (__diff0 == __diff1) {
      if (__t0.count() & 1)
        return __t1;
      return __t0;
    } else if (__diff0 < __diff1)
      return __t0;
    return __t1;
  }

  template <typename _Rep, typename _Period>
  [[nodiscard]] constexpr enable_if_t<numeric_limits<_Rep>::is_signed,
                                      duration<_Rep, _Period>>
  abs(duration<_Rep, _Period> __d) {
    if (__d >= __d.zero())
      return __d;
    return -__d;
  }

  namespace __detail {
  using chrono::ceil;
  }
# 494 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _Rep> struct duration_values {
    static constexpr _Rep zero() noexcept { return _Rep(0); }

    static constexpr _Rep max() noexcept { return numeric_limits<_Rep>::max(); }

    static constexpr _Rep min() noexcept {
      return numeric_limits<_Rep>::lowest();
    }
  };

  template <typename _Rep, typename _Period> class duration {
    static_assert(!__is_duration<_Rep>::value,
                  "rep cannot be a std::chrono::duration");
    static_assert(__is_ratio<_Period>::value,
                  "period must be a specialization of std::ratio");
    static_assert(_Period::num > 0, "period must be positive");

    template <typename _Rep2> using __is_float = treat_as_floating_point<_Rep2>;

    static constexpr intmax_t _S_gcd(intmax_t __m, intmax_t __n) noexcept {

      do {
        intmax_t __rem = __m % __n;
        __m = __n;
        __n = __rem;
      } while (__n != 0);
      return __m;
    }

    template <typename _R1, typename _R2,
              intmax_t __gcd1 = _S_gcd(_R1::num, _R2::num),
              intmax_t __gcd2 = _S_gcd(_R1::den, _R2::den)>
    using __divide = ratio<(_R1::num / __gcd1) * (_R2::den / __gcd2),
                           (_R1::den / __gcd2) * (_R2::num / __gcd1)>;

    template <typename _Period2>
    using __is_harmonic =
        __bool_constant<__divide<_Period2, _Period>::den == 1>;

  public:
    using rep = _Rep;
    using period = typename _Period::type;

    constexpr duration() = default;

    duration(const duration &) = default;

    template <
        typename _Rep2,
        typename = _Require<is_convertible<const _Rep2 &, rep>,
                            __or_<__is_float<rep>, __not_<__is_float<_Rep2>>>>>
    constexpr explicit duration(const _Rep2 &__rep)
        : __r(static_cast<rep>(__rep)) {}

    template <typename _Rep2, typename _Period2,
              typename = _Require<
                  is_convertible<const _Rep2 &, rep>,
                  __or_<__is_float<rep>, __and_<__is_harmonic<_Period2>,
                                                __not_<__is_float<_Rep2>>>>>>
    constexpr duration(const duration<_Rep2, _Period2> &__d)
        : __r(duration_cast<duration>(__d).count()) {}

    ~duration() = default;
    duration &operator=(const duration &) = default;

    constexpr rep count() const { return __r; }

    constexpr duration<typename common_type<rep>::type, period>
    operator+() const {
      return duration<typename common_type<rep>::type, period>(__r);
    }

    constexpr duration<typename common_type<rep>::type, period>
    operator-() const {
      return duration<typename common_type<rep>::type, period>(-__r);
    }

    constexpr duration &operator++() {
      ++__r;
      return *this;
    }

    constexpr duration operator++(int) { return duration(__r++); }

    constexpr duration &operator--() {
      --__r;
      return *this;
    }

    constexpr duration operator--(int) { return duration(__r--); }

    constexpr duration &operator+=(const duration &__d) {
      __r += __d.count();
      return *this;
    }

    constexpr duration &operator-=(const duration &__d) {
      __r -= __d.count();
      return *this;
    }

    constexpr duration &operator*=(const rep &__rhs) {
      __r *= __rhs;
      return *this;
    }

    constexpr duration &operator/=(const rep &__rhs) {
      __r /= __rhs;
      return *this;
    }

    template <typename _Rep2 = rep>
    constexpr __enable_if_t<!treat_as_floating_point<_Rep2>::value, duration &>
    operator%=(const rep &__rhs) {
      __r %= __rhs;
      return *this;
    }

    template <typename _Rep2 = rep>
    constexpr __enable_if_t<!treat_as_floating_point<_Rep2>::value, duration &>
    operator%=(const duration &__d) {
      __r %= __d.count();
      return *this;
    }

    static constexpr duration zero() noexcept {
      return duration(duration_values<rep>::zero());
    }

    static constexpr duration min() noexcept {
      return duration(duration_values<rep>::min());
    }

    static constexpr duration max() noexcept {
      return duration(duration_values<rep>::max());
    }

  private:
    rep __r;
  };

  template <typename _Rep1, typename _Period1, typename _Rep2,
            typename _Period2>
  constexpr typename common_type<duration<_Rep1, _Period1>,
                                 duration<_Rep2, _Period2>>::type
  operator+(const duration<_Rep1, _Period1> &__lhs,
            const duration<_Rep2, _Period2> &__rhs) {
    typedef duration<_Rep1, _Period1> __dur1;
    typedef duration<_Rep2, _Period2> __dur2;
    typedef typename common_type<__dur1, __dur2>::type __cd;
    return __cd(__cd(__lhs).count() + __cd(__rhs).count());
  }

  template <typename _Rep1, typename _Period1, typename _Rep2,
            typename _Period2>
  constexpr typename common_type<duration<_Rep1, _Period1>,
                                 duration<_Rep2, _Period2>>::type
  operator-(const duration<_Rep1, _Period1> &__lhs,
            const duration<_Rep2, _Period2> &__rhs) {
    typedef duration<_Rep1, _Period1> __dur1;
    typedef duration<_Rep2, _Period2> __dur2;
    typedef typename common_type<__dur1, __dur2>::type __cd;
    return __cd(__cd(__lhs).count() - __cd(__rhs).count());
  }
# 727 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _Rep1, typename _Rep2,
            typename _CRep = typename common_type<_Rep1, _Rep2>::type>
  using __common_rep_t =
      typename enable_if<is_convertible<const _Rep2 &, _CRep>::value,
                         _CRep>::type;
# 739 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _Rep1, typename _Period, typename _Rep2>
  constexpr duration<__common_rep_t<_Rep1, _Rep2>, _Period>
  operator*(const duration<_Rep1, _Period> &__d, const _Rep2 &__s) {
    typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period> __cd;
    return __cd(__cd(__d).count() * __s);
  }

  template <typename _Rep1, typename _Rep2, typename _Period>
  constexpr duration<__common_rep_t<_Rep2, _Rep1>, _Period>
  operator*(const _Rep1 &__s, const duration<_Rep2, _Period> &__d) {
    return __d * __s;
  }

  template <typename _Rep1, typename _Period, typename _Rep2>
  constexpr duration<__common_rep_t<_Rep1, __disable_if_is_duration<_Rep2>>,
                     _Period>
  operator/(const duration<_Rep1, _Period> &__d, const _Rep2 &__s) {
    typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period> __cd;
    return __cd(__cd(__d).count() / __s);
  }

  template <typename _Rep1, typename _Period1, typename _Rep2,
            typename _Period2>
  constexpr typename common_type<_Rep1, _Rep2>::type
  operator/(const duration<_Rep1, _Period1> &__lhs,
            const duration<_Rep2, _Period2> &__rhs) {
    typedef duration<_Rep1, _Period1> __dur1;
    typedef duration<_Rep2, _Period2> __dur2;
    typedef typename common_type<__dur1, __dur2>::type __cd;
    return __cd(__lhs).count() / __cd(__rhs).count();
  }

  template <typename _Rep1, typename _Period, typename _Rep2>
  constexpr duration<__common_rep_t<_Rep1, __disable_if_is_duration<_Rep2>>,
                     _Period>
  operator%(const duration<_Rep1, _Period> &__d, const _Rep2 &__s) {
    typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period> __cd;
    return __cd(__cd(__d).count() % __s);
  }

  template <typename _Rep1, typename _Period1, typename _Rep2,
            typename _Period2>
  constexpr typename common_type<duration<_Rep1, _Period1>,
                                 duration<_Rep2, _Period2>>::type
  operator%(const duration<_Rep1, _Period1> &__lhs,
            const duration<_Rep2, _Period2> &__rhs) {
    typedef duration<_Rep1, _Period1> __dur1;
    typedef duration<_Rep2, _Period2> __dur2;
    typedef typename common_type<__dur1, __dur2>::type __cd;
    return __cd(__cd(__lhs).count() % __cd(__rhs).count());
  }
# 807 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _Rep1, typename _Period1, typename _Rep2,
            typename _Period2>
  constexpr bool operator==(const duration<_Rep1, _Period1> &__lhs,
                            const duration<_Rep2, _Period2> &__rhs) {
    typedef duration<_Rep1, _Period1> __dur1;
    typedef duration<_Rep2, _Period2> __dur2;
    typedef typename common_type<__dur1, __dur2>::type __ct;
    return __ct(__lhs).count() == __ct(__rhs).count();
  }

  template <typename _Rep1, typename _Period1, typename _Rep2,
            typename _Period2>
  constexpr bool operator<(const duration<_Rep1, _Period1> &__lhs,
                           const duration<_Rep2, _Period2> &__rhs) {
    typedef duration<_Rep1, _Period1> __dur1;
    typedef duration<_Rep2, _Period2> __dur2;
    typedef typename common_type<__dur1, __dur2>::type __ct;
    return __ct(__lhs).count() < __ct(__rhs).count();
  }

  template <typename _Rep1, typename _Period1, typename _Rep2,
            typename _Period2>
    requires three_way_comparable<common_type_t<_Rep1, _Rep2>>
  constexpr auto operator<=>(const duration<_Rep1, _Period1> &__lhs,
                             const duration<_Rep2, _Period2> &__rhs) {
    using __ct =
        common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
    return __ct(__lhs).count() <=> __ct(__rhs).count();
  }
# 852 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _Rep1, typename _Period1, typename _Rep2,
            typename _Period2>
  constexpr bool operator<=(const duration<_Rep1, _Period1> &__lhs,
                            const duration<_Rep2, _Period2> &__rhs) {
    return !(__rhs < __lhs);
  }

  template <typename _Rep1, typename _Period1, typename _Rep2,
            typename _Period2>
  constexpr bool operator>(const duration<_Rep1, _Period1> &__lhs,
                           const duration<_Rep2, _Period2> &__rhs) {
    return __rhs < __lhs;
  }

  template <typename _Rep1, typename _Period1, typename _Rep2,
            typename _Period2>
  constexpr bool operator>=(const duration<_Rep1, _Period1> &__lhs,
                            const duration<_Rep2, _Period2> &__rhs) {
    return !(__lhs < __rhs);
  }
# 888 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  using nanoseconds = duration<int64_t, nano>;

  using microseconds = duration<int64_t, micro>;

  using milliseconds = duration<int64_t, milli>;

  using seconds = duration<int64_t>;

  using minutes = duration<int64_t, ratio<60>>;

  using hours = duration<int64_t, ratio<3600>>;

  using days = duration<int64_t, ratio<86400>>;

  using weeks = duration<int64_t, ratio<604800>>;

  using years = duration<int64_t, ratio<31556952>>;

  using months = duration<int64_t, ratio<2629746>>;

  template <typename _Clock, typename _Dur> class time_point {
    static_assert(__is_duration<_Dur>::value,
                  "duration must be a specialization of std::chrono::duration");

  public:
    typedef _Clock clock;
    typedef _Dur duration;
    typedef typename duration::rep rep;
    typedef typename duration::period period;

    constexpr time_point() : __d(duration::zero()) {}

    constexpr explicit time_point(const duration &__dur) : __d(__dur) {}

    template <typename _Dur2, typename = _Require<is_convertible<_Dur2, _Dur>>>
    constexpr time_point(const time_point<clock, _Dur2> &__t)
        : __d(__t.time_since_epoch()) {}

    constexpr duration time_since_epoch() const { return __d; }

    constexpr time_point &operator++() {
      ++__d;
      return *this;
    }

    constexpr time_point operator++(int) { return time_point{__d++}; }

    constexpr time_point &operator--() {
      --__d;
      return *this;
    }

    constexpr time_point operator--(int) { return time_point{__d--}; }

    constexpr time_point &operator+=(const duration &__dur) {
      __d += __dur;
      return *this;
    }

    constexpr time_point &operator-=(const duration &__dur) {
      __d -= __dur;
      return *this;
    }

    static constexpr time_point min() noexcept {
      return time_point(duration::min());
    }

    static constexpr time_point max() noexcept {
      return time_point(duration::max());
    }

  private:
    duration __d;
  };
# 1016 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _ToDur, typename _Clock, typename _Dur>
  [[__nodiscard__]] constexpr __enable_if_t<__is_duration<_ToDur>::value,
                                            time_point<_Clock, _ToDur>>
  time_point_cast(const time_point<_Clock, _Dur> &__t) {
    typedef time_point<_Clock, _ToDur> __time_point;
    return __time_point(duration_cast<_ToDur>(__t.time_since_epoch()));
  }
# 1038 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _ToDur, typename _Clock, typename _Dur>
  [[nodiscard]] constexpr enable_if_t<__is_duration_v<_ToDur>,
                                      time_point<_Clock, _ToDur>>
  floor(const time_point<_Clock, _Dur> &__tp) {
    return time_point<_Clock, _ToDur>{
        chrono::floor<_ToDur>(__tp.time_since_epoch())};
  }
# 1059 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _ToDur, typename _Clock, typename _Dur>
  [[nodiscard]] constexpr enable_if_t<__is_duration_v<_ToDur>,
                                      time_point<_Clock, _ToDur>>
  ceil(const time_point<_Clock, _Dur> &__tp) {
    return time_point<_Clock, _ToDur>{
        chrono::ceil<_ToDur>(__tp.time_since_epoch())};
  }
# 1081 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _ToDur, typename _Clock, typename _Dur>
  [[nodiscard]] constexpr enable_if_t<
      __is_duration_v<_ToDur> &&
          !treat_as_floating_point_v<typename _ToDur::rep>,
      time_point<_Clock, _ToDur>>
  round(const time_point<_Clock, _Dur> &__tp) {
    return time_point<_Clock, _ToDur>{
        chrono::round<_ToDur>(__tp.time_since_epoch())};
  }

  template <typename _Clock, typename _Dur1, typename _Rep2, typename _Period2>
  constexpr time_point<
      _Clock, typename common_type<_Dur1, duration<_Rep2, _Period2>>::type>
  operator+(const time_point<_Clock, _Dur1> &__lhs,
            const duration<_Rep2, _Period2> &__rhs) {
    typedef duration<_Rep2, _Period2> __dur2;
    typedef typename common_type<_Dur1, __dur2>::type __ct;
    typedef time_point<_Clock, __ct> __time_point;
    return __time_point(__lhs.time_since_epoch() + __rhs);
  }

  template <typename _Rep1, typename _Period1, typename _Clock, typename _Dur2>
  constexpr time_point<
      _Clock, typename common_type<duration<_Rep1, _Period1>, _Dur2>::type>
  operator+(const duration<_Rep1, _Period1> &__lhs,
            const time_point<_Clock, _Dur2> &__rhs) {
    typedef duration<_Rep1, _Period1> __dur1;
    typedef typename common_type<__dur1, _Dur2>::type __ct;
    typedef time_point<_Clock, __ct> __time_point;
    return __time_point(__rhs.time_since_epoch() + __lhs);
  }

  template <typename _Clock, typename _Dur1, typename _Rep2, typename _Period2>
  constexpr time_point<
      _Clock, typename common_type<_Dur1, duration<_Rep2, _Period2>>::type>
  operator-(const time_point<_Clock, _Dur1> &__lhs,
            const duration<_Rep2, _Period2> &__rhs) {
    typedef duration<_Rep2, _Period2> __dur2;
    typedef typename common_type<_Dur1, __dur2>::type __ct;
    typedef time_point<_Clock, __ct> __time_point;
    return __time_point(__lhs.time_since_epoch() - __rhs);
  }

  template <typename _Clock, typename _Dur1, typename _Dur2>
  constexpr typename common_type<_Dur1, _Dur2>::type
  operator-(const time_point<_Clock, _Dur1> &__lhs,
            const time_point<_Clock, _Dur2> &__rhs) {
    return __lhs.time_since_epoch() - __rhs.time_since_epoch();
  }

  template <typename _Clock, typename _Dur1, typename _Dur2>
  constexpr bool operator==(const time_point<_Clock, _Dur1> &__lhs,
                            const time_point<_Clock, _Dur2> &__rhs) {
    return __lhs.time_since_epoch() == __rhs.time_since_epoch();
  }

  template <typename _Clock, typename _Dur1,
            three_way_comparable_with<_Dur1> _Dur2>
  constexpr auto operator<=>(const time_point<_Clock, _Dur1> &__lhs,
                             const time_point<_Clock, _Dur2> &__rhs) {
    return __lhs.time_since_epoch() <=> __rhs.time_since_epoch();
  }
# 1172 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  template <typename _Clock, typename _Dur1, typename _Dur2>
  constexpr bool operator<(const time_point<_Clock, _Dur1> &__lhs,
                           const time_point<_Clock, _Dur2> &__rhs) {
    return __lhs.time_since_epoch() < __rhs.time_since_epoch();
  }

  template <typename _Clock, typename _Dur1, typename _Dur2>
  constexpr bool operator<=(const time_point<_Clock, _Dur1> &__lhs,
                            const time_point<_Clock, _Dur2> &__rhs) {
    return !(__rhs < __lhs);
  }

  template <typename _Clock, typename _Dur1, typename _Dur2>
  constexpr bool operator>(const time_point<_Clock, _Dur1> &__lhs,
                           const time_point<_Clock, _Dur2> &__rhs) {
    return __rhs < __lhs;
  }

  template <typename _Clock, typename _Dur1, typename _Dur2>
  constexpr bool operator>=(const time_point<_Clock, _Dur1> &__lhs,
                            const time_point<_Clock, _Dur2> &__rhs) {
    return !(__lhs < __rhs);
  }
# 1217 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  inline namespace _V2 {

  struct system_clock {
    typedef chrono::nanoseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<system_clock, duration> time_point;

    static_assert(system_clock::duration::min() <
                      system_clock::duration::zero(),
                  "a clock's minimum duration cannot be less than its epoch");

    static constexpr bool is_steady = false;

    static time_point now() noexcept;

    static std::time_t to_time_t(const time_point &__t) noexcept {
      return std::time_t(
          duration_cast<chrono::seconds>(__t.time_since_epoch()).count());
    }

    static time_point from_time_t(std::time_t __t) noexcept {
      typedef chrono::time_point<system_clock, seconds> __from;
      return time_point_cast<system_clock::duration>(
          __from(chrono::seconds(__t)));
    }
  };
# 1267 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  struct steady_clock {
    typedef chrono::nanoseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<steady_clock, duration> time_point;

    static constexpr bool is_steady = true;

    static time_point now() noexcept;
  };
# 1289 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  using high_resolution_clock = system_clock;

  } // namespace _V2

  template <typename _Duration>
  using sys_time = time_point<system_clock, _Duration>;
  using sys_seconds = sys_time<seconds>;
  using sys_days = sys_time<days>;

  using file_clock = ::std::filesystem::__file_clock;

  template <typename _Duration>
  using file_time = time_point<file_clock, _Duration>;

  template <> struct is_clock<system_clock> : true_type {};
  template <> struct is_clock<steady_clock> : true_type {};
  template <> struct is_clock<file_clock> : true_type {};

  template <> inline constexpr bool is_clock_v<system_clock> = true;
  template <> inline constexpr bool is_clock_v<steady_clock> = true;
  template <> inline constexpr bool is_clock_v<file_clock> = true;

  } // namespace chrono

  inline namespace literals {
# 1346 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/chrono.h" 3
  inline namespace chrono_literals {

#pragma GCC diagnostic push

  template <typename _Dur, char... _Digits> constexpr _Dur __check_overflow() {
    using _Val = __parse_int::_Parse_int<_Digits...>;
    constexpr typename _Dur::rep __repval = _Val::value;
    static_assert(__repval >= 0 && __repval == _Val::value,
                  "literal value cannot be represented by duration type");
    return _Dur(__repval);
  }

  constexpr chrono::duration<long double, ratio<3600, 1>>
  operator""h(long double __hours) {
    return chrono::duration<long double, ratio<3600, 1>>{__hours};
  }

  template <char... _Digits> constexpr chrono::hours operator""h() {
    return __check_overflow<chrono::hours, _Digits...>();
  }

  constexpr chrono::duration<long double, ratio<60, 1>>
  operator""min(long double __mins) {
    return chrono::duration<long double, ratio<60, 1>>{__mins};
  }

  template <char... _Digits> constexpr chrono::minutes operator""min() {
    return __check_overflow<chrono::minutes, _Digits...>();
  }

  constexpr chrono::duration<long double> operator""s(long double __secs) {
    return chrono::duration<long double>{__secs};
  }

  template <char... _Digits> constexpr chrono::seconds operator""s() {
    return __check_overflow<chrono::seconds, _Digits...>();
  }

  constexpr chrono::duration<long double, milli>
  operator""ms(long double __msecs) {
    return chrono::duration<long double, milli>{__msecs};
  }

  template <char... _Digits> constexpr chrono::milliseconds operator""ms() {
    return __check_overflow<chrono::milliseconds, _Digits...>();
  }

  constexpr chrono::duration<long double, micro>
  operator""us(long double __usecs) {
    return chrono::duration<long double, micro>{__usecs};
  }

  template <char... _Digits> constexpr chrono::microseconds operator""us() {
    return __check_overflow<chrono::microseconds, _Digits...>();
  }

  constexpr chrono::duration<long double, nano>
  operator""ns(long double __nsecs) {
    return chrono::duration<long double, nano>{__nsecs};
  }

  template <char... _Digits> constexpr chrono::nanoseconds operator""ns() {
    return __check_overflow<chrono::nanoseconds, _Digits...>();
  }

#pragma GCC diagnostic pop

  } // namespace chrono_literals
  } // namespace literals

  namespace chrono {
  using namespace literals::chrono_literals;
  }

  namespace filesystem {
  struct __file_clock {
    using duration = chrono::nanoseconds;
    using rep = duration::rep;
    using period = duration::period;
    using time_point = chrono::time_point<__file_clock>;
    static constexpr bool is_steady = false;

    static time_point now() noexcept {
      return _S_from_sys(chrono::system_clock::now());
    }

    template <typename _Dur>
    static chrono::file_time<common_type_t<_Dur, chrono::seconds>>
    from_sys(const chrono::sys_time<_Dur> &__t) noexcept {
      return _S_from_sys(__t);
    }

    template <typename _Dur>
    static chrono::sys_time<common_type_t<_Dur, chrono::seconds>>
    to_sys(const chrono::file_time<_Dur> &__t) noexcept {
      return _S_to_sys(__t);
    }

  private:
    using __sys_clock = chrono::system_clock;

    static constexpr chrono::seconds _S_epoch_diff{6437664000};

  protected:
    template <typename _Dur>
    static chrono::time_point<__file_clock,
                              common_type_t<_Dur, chrono::seconds>>
    _S_from_sys(const chrono::time_point<__sys_clock, _Dur> &__t) noexcept {
      using _CDur = common_type_t<_Dur, chrono::seconds>;
      using __file_time = chrono::time_point<__file_clock, _CDur>;
      return __file_time{__t.time_since_epoch()} - _S_epoch_diff;
    }

    template <typename _Dur>
    static chrono::time_point<__sys_clock, common_type_t<_Dur, chrono::seconds>>
    _S_to_sys(const chrono::time_point<__file_clock, _Dur> &__t) noexcept {
      using _CDur = common_type_t<_Dur, chrono::seconds>;
      using __sys_time = chrono::time_point<__sys_clock, _CDur>;
      return __sys_time{__t.time_since_epoch()} + _S_epoch_diff;
    }
  };
  } // namespace filesystem

} // namespace std
# 37 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/semaphore_base.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_timed_wait.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_timed_wait.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/this_thread_sleep.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/this_thread_sleep.h" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cerrno" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cerrno" 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/this_thread_sleep.h" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 56 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/this_thread_sleep.h" 3
  namespace this_thread {
# 66 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/this_thread_sleep.h" 3
  template <typename _Rep, typename _Period>
  inline void sleep_for(const chrono::duration<_Rep, _Period> &__rtime) {
    if (__rtime <= __rtime.zero())
      return;
    auto __s = chrono::duration_cast<chrono::seconds>(__rtime);
    auto __ns = chrono::duration_cast<chrono::nanoseconds>(__rtime - __s);

    struct ::timespec __ts = {static_cast<std::time_t>(__s.count()),
                              static_cast<long>(__ns.count())};
    while (::nanosleep(&__ts, &__ts) == -1 && (*__errno_location()) == 4) {
    }
  }

  template <typename _Clock, typename _Duration>
  inline void
  sleep_until(const chrono::time_point<_Clock, _Duration> &__atime) {

    static_assert(chrono::is_clock_v<_Clock>);

    auto __now = _Clock::now();
    if (_Clock::is_steady) {
      if (__now < __atime)
        sleep_for(__atime - __now);
      return;
    }
    while (__now < __atime) {
      sleep_for(__atime - __now);
      __now = _Clock::now();
    }
  }

  } // namespace this_thread

} // namespace std
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_timed_wait.h" 2 3

# 1 "/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern "C" {
# 52 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
struct timezone {
  int tz_minuteswest;
  int tz_dsttime;
};
# 67 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday(struct timeval *__restrict __tv,
                        void *__restrict __tz) noexcept(true)
    __attribute__((__nonnull__(1)));
# 86 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int settimeofday(const struct timeval *__tv,
                        const struct timezone *__tz) noexcept(true);

extern int adjtime(const struct timeval *__delta,
                   struct timeval *__olddelta) noexcept(true);
# 114 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
enum __itimer_which {

  ITIMER_REAL = 0,

  ITIMER_VIRTUAL = 1,

  ITIMER_PROF = 2

};

struct itimerval {

  struct timeval it_interval;

  struct timeval it_value;
};

typedef int __itimer_which_t;

extern int getitimer(__itimer_which_t __which,
                     struct itimerval *__value) noexcept(true);

extern int setitimer(__itimer_which_t __which,
                     const struct itimerval *__restrict __new,
                     struct itimerval *__restrict __old) noexcept(true);

extern int utimes(const char *__file,
                  const struct timeval __tvp[2]) noexcept(true)
    __attribute__((__nonnull__(1)));
# 189 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int lutimes(const char *__file,
                   const struct timeval __tvp[2]) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int futimes(int __fd, const struct timeval __tvp[2]) noexcept(true);
# 214 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int futimesat(int __fd, const char *__file,
                     const struct timeval __tvp[2]) noexcept(true);
# 258 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
}
# 44 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_timed_wait.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  namespace __detail {
  using __wait_clock_t = chrono::steady_clock;

  template <typename _Clock, typename _Dur>
  __wait_clock_t::time_point
  __to_wait_clock(const chrono::time_point<_Clock, _Dur> &__atime) noexcept {
    const typename _Clock::time_point __c_entry = _Clock::now();
    const __wait_clock_t::time_point __w_entry = __wait_clock_t::now();
    const auto __delta = __atime - __c_entry;
    using __w_dur = typename __wait_clock_t::duration;
    return __w_entry + chrono::ceil<__w_dur>(__delta);
  }

  template <typename _Dur>
  __wait_clock_t::time_point __to_wait_clock(
      const chrono::time_point<__wait_clock_t, _Dur> &__atime) noexcept {
    using __w_dur = typename __wait_clock_t::duration;
    return chrono::ceil<__w_dur>(__atime);
  }

  template <typename _Dur>
  bool __platform_wait_until_impl(
      const __platform_wait_t *__addr, __platform_wait_t __old,
      const chrono::time_point<__wait_clock_t, _Dur> &__atime) noexcept {
    auto __s = chrono::time_point_cast<chrono::seconds>(__atime);
    auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);

    struct timespec __rt = {
        static_cast<std::time_t>(__s.time_since_epoch().count()),
        static_cast<long>(__ns.count())};

    auto __e =
        syscall(202, __addr,
                static_cast<int>(__futex_wait_flags::__wait_bitset_private),
                __old, &__rt, nullptr,
                static_cast<int>(__futex_wait_flags::__bitset_match_any));

    if (__e) {
      if ((*__errno_location()) == 110)
        return false;
      if ((*__errno_location()) != 4 && (*__errno_location()) != 11)
        __throw_system_error((*__errno_location()));
    }
    return true;
  }

  template <typename _Clock, typename _Dur>
  bool __platform_wait_until(const __platform_wait_t *__addr,
                             __platform_wait_t __old,
                             const chrono::time_point<_Clock, _Dur> &__atime) {
    if constexpr (is_same_v<__wait_clock_t, _Clock>) {
      return __platform_wait_until_impl(__addr, __old, __atime);
    } else {
      if (!__platform_wait_until_impl(__addr, __old,
                                      __to_wait_clock(__atime))) {

        if (_Clock::now() < __atime)
          return true;
      }
      return false;
    }
  }
# 143 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_timed_wait.h" 3
  template <typename _Clock, typename _Dur>
  bool __cond_wait_until_impl(__condvar &__cv, mutex &__mx,
                              const chrono::time_point<_Clock, _Dur> &__atime) {
    static_assert(std::__is_one_of<_Clock, chrono::steady_clock,
                                   chrono::system_clock>::value);

    auto __s = chrono::time_point_cast<chrono::seconds>(__atime);
    auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);

    __gthread_time_t __ts = {
        static_cast<std::time_t>(__s.time_since_epoch().count()),
        static_cast<long>(__ns.count())};

    if constexpr (is_same_v<chrono::steady_clock, _Clock>)
      __cv.wait_until(__mx, 1, __ts);
    else

      __cv.wait_until(__mx, __ts);
    return _Clock::now() < __atime;
  }

  template <typename _Clock, typename _Dur>
  bool __cond_wait_until(__condvar &__cv, mutex &__mx,
                         const chrono::time_point<_Clock, _Dur> &__atime) {

    if constexpr (is_same_v<_Clock, chrono::steady_clock>)
      return __detail::__cond_wait_until_impl(__cv, __mx, __atime);
    else

        if constexpr (is_same_v<_Clock, chrono::system_clock>)
      return __detail::__cond_wait_until_impl(__cv, __mx, __atime);
    else {
      if (__cond_wait_until_impl(__cv, __mx, __to_wait_clock(__atime))) {

        if (_Clock::now() < __atime)
          return true;
      }
      return false;
    }
  }

  struct __timed_waiter_pool : __waiter_pool_base {

    template <typename _Clock, typename _Dur>
    bool _M_do_wait_until(__platform_wait_t *__addr, __platform_wait_t __old,
                          const chrono::time_point<_Clock, _Dur> &__atime) {

      return __platform_wait_until(__addr, __old, __atime);
# 219 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/atomic_timed_wait.h" 3
    }
  };

  struct __timed_backoff_spin_policy {
    __wait_clock_t::time_point _M_deadline;
    __wait_clock_t::time_point _M_t0;

    template <typename _Clock, typename _Dur>
    __timed_backoff_spin_policy(
        chrono::time_point<_Clock, _Dur> __deadline = _Clock::time_point::max(),
        chrono::time_point<_Clock, _Dur> __t0 = _Clock::now()) noexcept
        : _M_deadline(__to_wait_clock(__deadline)),
          _M_t0(__to_wait_clock(__t0)) {}

    bool operator()() const noexcept {
      using namespace literals::chrono_literals;
      auto __now = __wait_clock_t::now();
      if (_M_deadline <= __now)
        return false;

      auto __elapsed = __now - _M_t0;
      if (__elapsed > 128ms) {
        this_thread::sleep_for(64ms);
      } else if (__elapsed > 64us) {
        this_thread::sleep_for(__elapsed / 2);
      } else if (__elapsed > 4us) {
        __thread_yield();
      } else
        return false;
      return true;
    }
  };

  template <typename _EntersWait>
  struct __timed_waiter : __waiter_base<__timed_waiter_pool> {
    using __base_type = __waiter_base<__timed_waiter_pool>;

    template <typename _Tp>
    __timed_waiter(const _Tp *__addr) noexcept : __base_type(__addr) {
      if constexpr (_EntersWait::value)
        _M_w._M_enter_wait();
    }

    ~__timed_waiter() {
      if constexpr (_EntersWait::value)
        _M_w._M_leave_wait();
    }

    template <typename _Tp, typename _ValFn, typename _Clock, typename _Dur>
    bool _M_do_wait_until_v(
        _Tp __old, _ValFn __vfn,
        const chrono::time_point<_Clock, _Dur> &__atime) noexcept {
      __platform_wait_t __val;
      if (_M_do_spin(__old, std::move(__vfn), __val,
                     __timed_backoff_spin_policy(__atime)))
        return true;
      return __base_type::_M_w._M_do_wait_until(__base_type::_M_addr, __val,
                                                __atime);
    }

    template <typename _Pred, typename _Clock, typename _Dur>
    bool
    _M_do_wait_until(_Pred __pred, __platform_wait_t __val,
                     const chrono::time_point<_Clock, _Dur> &__atime) noexcept {
      for (auto __now = _Clock::now(); __now < __atime; __now = _Clock::now()) {
        if (__base_type::_M_w._M_do_wait_until(__base_type::_M_addr, __val,
                                               __atime) &&
            __pred())
          return true;

        if (__base_type::_M_do_spin(
                __pred, __val, __timed_backoff_spin_policy(__atime, __now)))
          return true;
      }
      return false;
    }

    template <typename _Pred, typename _Clock, typename _Dur>
    bool
    _M_do_wait_until(_Pred __pred,
                     const chrono::time_point<_Clock, _Dur> &__atime) noexcept {
      __platform_wait_t __val;
      if (__base_type::_M_do_spin(__pred, __val,
                                  __timed_backoff_spin_policy(__atime)))
        return true;
      return _M_do_wait_until(__pred, __val, __atime);
    }

    template <typename _Tp, typename _ValFn, typename _Rep, typename _Period>
    bool
    _M_do_wait_for_v(_Tp __old, _ValFn __vfn,
                     const chrono::duration<_Rep, _Period> &__rtime) noexcept {
      __platform_wait_t __val;
      if (_M_do_spin_v(__old, std::move(__vfn), __val))
        return true;

      if (!__rtime.count())
        return false;

      auto __reltime = chrono::ceil<__wait_clock_t::duration>(__rtime);

      return __base_type::_M_w._M_do_wait_until(
          __base_type::_M_addr, __val, chrono::steady_clock::now() + __reltime);
    }

    template <typename _Pred, typename _Rep, typename _Period>
    bool
    _M_do_wait_for(_Pred __pred,
                   const chrono::duration<_Rep, _Period> &__rtime) noexcept {
      __platform_wait_t __val;
      if (__base_type::_M_do_spin(__pred, __val))
        return true;

      if (!__rtime.count())
        return false;

      auto __reltime = chrono::ceil<__wait_clock_t::duration>(__rtime);

      return _M_do_wait_until(__pred, __val,
                              chrono::steady_clock::now() + __reltime);
    }
  };

  using __enters_timed_wait = __timed_waiter<std::true_type>;
  using __bare_timed_wait = __timed_waiter<std::false_type>;
  } // namespace __detail

  template <typename _Tp, typename _ValFn, typename _Clock, typename _Dur>
  bool __atomic_wait_address_until_v(
      const _Tp *__addr, _Tp &&__old, _ValFn &&__vfn,
      const chrono::time_point<_Clock, _Dur> &__atime) noexcept {
    __detail::__enters_timed_wait __w{__addr};
    return __w._M_do_wait_until_v(__old, __vfn, __atime);
  }

  template <typename _Tp, typename _Pred, typename _Clock, typename _Dur>
  bool __atomic_wait_address_until(
      const _Tp *__addr, _Pred __pred,
      const chrono::time_point<_Clock, _Dur> &__atime) noexcept {
    __detail::__enters_timed_wait __w{__addr};
    return __w._M_do_wait_until(__pred, __atime);
  }

  template <typename _Pred, typename _Clock, typename _Dur>
  bool __atomic_wait_address_until_bare(
      const __detail::__platform_wait_t *__addr, _Pred __pred,
      const chrono::time_point<_Clock, _Dur> &__atime) noexcept {
    __detail::__bare_timed_wait __w{__addr};
    return __w._M_do_wait_until(__pred, __atime);
  }

  template <typename _Tp, typename _ValFn, typename _Rep, typename _Period>
  bool __atomic_wait_address_for_v(
      const _Tp *__addr, _Tp &&__old, _ValFn &&__vfn,
      const chrono::duration<_Rep, _Period> &__rtime) noexcept {
    __detail::__enters_timed_wait __w{__addr};
    return __w._M_do_wait_for_v(__old, __vfn, __rtime);
  }

  template <typename _Tp, typename _Pred, typename _Rep, typename _Period>
  bool __atomic_wait_address_for(
      const _Tp *__addr, _Pred __pred,
      const chrono::duration<_Rep, _Period> &__rtime) noexcept {

    __detail::__enters_timed_wait __w{__addr};
    return __w._M_do_wait_for(__pred, __rtime);
  }

  template <typename _Pred, typename _Rep, typename _Period>
  bool __atomic_wait_address_for_bare(
      const __detail::__platform_wait_t *__addr, _Pred __pred,
      const chrono::duration<_Rep, _Period> &__rtime) noexcept {
    __detail::__bare_timed_wait __w{__addr};
    return __w._M_do_wait_for(__pred, __rtime);
  }

} // namespace std
# 39 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/semaphore_base.h" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cerrno" 1 3
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/cerrno" 3
# 44 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/semaphore_base.h" 2 3
# 1 "/usr/lib/llvm-18/lib/clang/18/include/limits.h" 1 3
# 45 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/semaphore_base.h" 2 3
# 1 "/usr/include/semaphore.h" 1 3 4
# 28 "/usr/include/semaphore.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/semaphore.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/semaphore.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/semaphore.h" 2 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/semaphore.h" 3 4
typedef union {
  char __size[32];
  long int __align;
} sem_t;
# 29 "/usr/include/semaphore.h" 2 3 4

extern "C" {

extern int sem_init(sem_t *__sem, int __pshared,
                    unsigned int __value) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int sem_destroy(sem_t *__sem) noexcept(true)
    __attribute__((__nonnull__(1)));

extern sem_t *sem_open(const char *__name, int __oflag, ...) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int sem_close(sem_t *__sem) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int sem_unlink(const char *__name) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int sem_wait(sem_t *__sem) __attribute__((__nonnull__(1)));

extern int sem_timedwait(sem_t *__restrict __sem,
                         const struct timespec *__restrict __abstime)
    __attribute__((__nonnull__(1, 2)));
# 81 "/usr/include/semaphore.h" 3 4
extern int sem_clockwait(sem_t *__restrict __sem, clockid_t clock,
                         const struct timespec *__restrict __abstime)
    __attribute__((__nonnull__(1, 3)));
# 100 "/usr/include/semaphore.h" 3 4
extern int sem_trywait(sem_t *__sem) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int sem_post(sem_t *__sem) noexcept(true)
    __attribute__((__nonnull__(1)));

extern int sem_getvalue(sem_t *__restrict __sem,
                        int *__restrict __sval) noexcept(true)
    __attribute__((__nonnull__(1, 2)));
}
# 46 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/semaphore_base.h" 2 3

namespace std __attribute__((__visibility__("default"))) {

  struct __platform_semaphore {
    using __clock_t = chrono::system_clock;

    static constexpr ptrdiff_t _S_max = (2147483647);

    explicit __platform_semaphore(ptrdiff_t __count) noexcept {
      sem_init(&_M_semaphore, 0, __count);
    }

    __platform_semaphore(const __platform_semaphore &) = delete;
    __platform_semaphore &operator=(const __platform_semaphore &) = delete;

    ~__platform_semaphore() { sem_destroy(&_M_semaphore); }

    inline __attribute__((__always_inline__)) void _M_acquire() noexcept {
      for (;;) {
        auto __err = sem_wait(&_M_semaphore);
        if (__err && ((*__errno_location()) == 4))
          continue;
        else if (__err)
          std::__terminate();
        else
          break;
      }
    }

    inline __attribute__((__always_inline__)) bool _M_try_acquire() noexcept {
      for (;;) {
        auto __err = sem_trywait(&_M_semaphore);
        if (__err && ((*__errno_location()) == 4))
          continue;
        else if (__err && ((*__errno_location()) == 11))
          return false;
        else if (__err)
          std::__terminate();
        else
          break;
      }
      return true;
    }

    inline __attribute__((__always_inline__)) void
    _M_release(std::ptrdiff_t __update) noexcept {
      for (; __update != 0; --__update) {
        auto __err = sem_post(&_M_semaphore);
        if (__err)
          std::__terminate();
      }
    }

    bool _M_try_acquire_until_impl(
        const chrono::time_point<__clock_t> &__atime) noexcept {

      auto __s = chrono::time_point_cast<chrono::seconds>(__atime);
      auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);

      struct timespec __ts = {
          static_cast<std::time_t>(__s.time_since_epoch().count()),
          static_cast<long>(__ns.count())};

      for (;;) {
        if (auto __err = sem_timedwait(&_M_semaphore, &__ts)) {
          if ((*__errno_location()) == 4)
            continue;
          else if ((*__errno_location()) == 110 || (*__errno_location()) == 22)
            return false;
          else
            std::__terminate();
        } else
          break;
      }
      return true;
    }

    template <typename _Clock, typename _Duration>
    bool _M_try_acquire_until(
        const chrono::time_point<_Clock, _Duration> &__atime) noexcept {
      if constexpr (std::is_same_v<__clock_t, _Clock>) {
        return _M_try_acquire_until_impl(__atime);
      } else {
        const typename _Clock::time_point __c_entry = _Clock::now();
        const auto __s_entry = __clock_t::now();
        const auto __delta = __atime - __c_entry;
        const auto __s_atime = __s_entry + __delta;
        if (_M_try_acquire_until_impl(__s_atime))
          return true;

        return (_Clock::now() < __atime);
      }
    }

    template <typename _Rep, typename _Period>
    inline __attribute__((__always_inline__)) bool _M_try_acquire_for(
        const chrono::duration<_Rep, _Period> &__rtime) noexcept {
      return _M_try_acquire_until(__clock_t::now() + __rtime);
    }

  private:
    sem_t _M_semaphore;
  };

  struct __atomic_semaphore {
    static constexpr ptrdiff_t _S_max = __gnu_cxx::__int_traits<int>::__max;
    explicit __atomic_semaphore(__detail::__platform_wait_t __count) noexcept
        : _M_counter(__count) {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(__count >= 0 && __count <= _S_max))
          __builtin_unreachable();
      } while (false);
    }

    __atomic_semaphore(const __atomic_semaphore &) = delete;
    __atomic_semaphore &operator=(const __atomic_semaphore &) = delete;

    static inline __attribute__((__always_inline__)) bool
    _S_do_try_acquire(__detail::__platform_wait_t *__counter) noexcept {
      auto __old = __atomic_impl::load(__counter, memory_order::acquire);
      if (__old == 0)
        return false;

      return __atomic_impl::compare_exchange_strong(__counter, __old, __old - 1,
                                                    memory_order::acquire,
                                                    memory_order::relaxed);
    }

    inline __attribute__((__always_inline__)) void _M_acquire() noexcept {
      auto const __pred = [this] {
        return _S_do_try_acquire(&this->_M_counter);
      };
      std::__atomic_wait_address_bare(&_M_counter, __pred);
    }

    bool _M_try_acquire() noexcept {
      auto const __pred = [this] {
        return _S_do_try_acquire(&this->_M_counter);
      };
      return std::__detail::__atomic_spin(__pred);
    }

    template <typename _Clock, typename _Duration>
    inline __attribute__((__always_inline__)) bool _M_try_acquire_until(
        const chrono::time_point<_Clock, _Duration> &__atime) noexcept {
      auto const __pred = [this] {
        return _S_do_try_acquire(&this->_M_counter);
      };

      return __atomic_wait_address_until_bare(&_M_counter, __pred, __atime);
    }

    template <typename _Rep, typename _Period>
    inline __attribute__((__always_inline__)) bool _M_try_acquire_for(
        const chrono::duration<_Rep, _Period> &__rtime) noexcept {
      auto const __pred = [this] {
        return _S_do_try_acquire(&this->_M_counter);
      };

      return __atomic_wait_address_for_bare(&_M_counter, __pred, __rtime);
    }

    inline __attribute__((__always_inline__)) void
    _M_release(ptrdiff_t __update) noexcept {
      if (0 <
          __atomic_impl::fetch_add(&_M_counter, __update, memory_order_release))
        return;
      if (__update > 1)
        __atomic_notify_address_bare(&_M_counter, true);
      else
        __atomic_notify_address_bare(&_M_counter, true);
    }

  private:
    alignas(__detail::__platform_wait_alignment) __detail::__platform_wait_t
        _M_counter;
  };

  using __semaphore_impl = __atomic_semaphore;

} // namespace std
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/semaphore" 2 3

namespace std __attribute__((__visibility__("default"))) {

  template <ptrdiff_t __least_max_value = __semaphore_impl::_S_max>
  class counting_semaphore {
    static_assert(__least_max_value >= 0);
    static_assert(__least_max_value <= __semaphore_impl::_S_max);

    __semaphore_impl _M_sem;

  public:
    explicit counting_semaphore(ptrdiff_t __desired) noexcept
        : _M_sem(__desired) {}

    ~counting_semaphore() = default;

    counting_semaphore(const counting_semaphore &) = delete;
    counting_semaphore &operator=(const counting_semaphore &) = delete;

    static constexpr ptrdiff_t max() noexcept { return __least_max_value; }

    void
    release(ptrdiff_t __update = 1) noexcept(noexcept(_M_sem._M_release(1))) {
      _M_sem._M_release(__update);
    }

    void acquire() noexcept(noexcept(_M_sem._M_acquire())) {
      _M_sem._M_acquire();
    }

    bool try_acquire() noexcept(noexcept(_M_sem._M_try_acquire())) {
      return _M_sem._M_try_acquire();
    }

    template <typename _Rep, typename _Period>
    bool try_acquire_for(const std::chrono::duration<_Rep, _Period> &__rtime) {
      return _M_sem._M_try_acquire_for(__rtime);
    }

    template <typename _Clock, typename _Dur>
    bool
    try_acquire_until(const std::chrono::time_point<_Clock, _Dur> &__atime) {
      return _M_sem._M_try_acquire_until(__atime);
    }
  };

  using binary_semaphore = std::counting_semaphore<1>;

} // namespace std
# 40 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/stop_token" 2 3

namespace std __attribute__((__visibility__("default"))) {

  struct nostopstate_t {
    explicit nostopstate_t() = default;
  };
  inline constexpr nostopstate_t nostopstate{};

  class stop_source;

  class stop_token {
  public:
    stop_token() noexcept = default;

    stop_token(const stop_token &) noexcept = default;
    stop_token(stop_token &&) noexcept = default;

    ~stop_token() = default;

    stop_token &operator=(const stop_token &) noexcept = default;

    stop_token &operator=(stop_token &&) noexcept = default;

    [[nodiscard]]
    bool stop_possible() const noexcept {
      return static_cast<bool>(_M_state) && _M_state->_M_stop_possible();
    }

    [[nodiscard]]
    bool stop_requested() const noexcept {
      return static_cast<bool>(_M_state) && _M_state->_M_stop_requested();
    }

    void swap(stop_token &__rhs) noexcept { _M_state.swap(__rhs._M_state); }

    [[nodiscard]]
    friend bool operator==(const stop_token &__a, const stop_token &__b) {
      return __a._M_state == __b._M_state;
    }

    friend void swap(stop_token &__lhs, stop_token &__rhs) noexcept {
      __lhs.swap(__rhs);
    }

  private:
    friend class stop_source;
    template <typename _Callback> friend class stop_callback;

    static void _S_yield() noexcept {

      __builtin_ia32_pause();

      this_thread::yield();
    }
# 134 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/stop_token" 3
    struct _Stop_cb {
      using __cb_type = void(_Stop_cb *) noexcept;
      __cb_type *_M_callback;
      _Stop_cb *_M_prev = nullptr;
      _Stop_cb *_M_next = nullptr;
      bool *_M_destroyed = nullptr;
      binary_semaphore _M_done{0};

      [[__gnu__::__nonnull__]]
      explicit _Stop_cb(__cb_type *__cb)
          : _M_callback(__cb) {}

      void _M_run() noexcept { _M_callback(this); }
    };

    struct _Stop_state_t {
      using value_type = uint32_t;
      static constexpr value_type _S_stop_requested_bit = 1;
      static constexpr value_type _S_locked_bit = 2;
      static constexpr value_type _S_ssrc_counter_inc = 4;

      std::atomic<value_type> _M_owners{1};
      std::atomic<value_type> _M_value{_S_ssrc_counter_inc};
      _Stop_cb *_M_head = nullptr;
      std::thread::id _M_requester;

      _Stop_state_t() = default;

      bool _M_stop_possible() noexcept {

        return _M_value.load(memory_order::acquire) & ~_S_locked_bit;
      }

      bool _M_stop_requested() noexcept {
        return _M_value.load(memory_order::acquire) & _S_stop_requested_bit;
      }

      void _M_add_owner() noexcept {
        _M_owners.fetch_add(1, memory_order::relaxed);
      }

      void _M_release_ownership() noexcept {
        if (_M_owners.fetch_sub(1, memory_order::acq_rel) == 1)
          delete this;
      }

      void _M_add_ssrc() noexcept {
        _M_value.fetch_add(_S_ssrc_counter_inc, memory_order::relaxed);
      }

      void _M_sub_ssrc() noexcept {
        _M_value.fetch_sub(_S_ssrc_counter_inc, memory_order::release);
      }

      void _M_lock() noexcept {

        auto __old = _M_value.load(memory_order::relaxed);
        while (!_M_try_lock(__old, memory_order::relaxed)) {
        }
      }

      void _M_unlock() noexcept {
        _M_value.fetch_sub(_S_locked_bit, memory_order::release);
      }

      bool _M_request_stop() noexcept {

        auto __old = _M_value.load(memory_order::acquire);
        do {
          if (__old & _S_stop_requested_bit)
            return false;
        } while (!_M_try_lock_and_stop(__old));

        _M_requester = this_thread::get_id();

        while (_M_head) {
          bool __last_cb;
          _Stop_cb *__cb = _M_head;
          _M_head = _M_head->_M_next;
          if (_M_head) {
            _M_head->_M_prev = nullptr;
            __last_cb = false;
          } else
            __last_cb = true;

          _M_unlock();

          bool __destroyed = false;
          __cb->_M_destroyed = &__destroyed;

          __cb->_M_run();

          if (!__destroyed) {
            __cb->_M_destroyed = nullptr;

            if (!__gnu_cxx::__is_single_threaded())
              __cb->_M_done.release();
          }

          if (__last_cb)
            return true;

          _M_lock();
        }

        _M_unlock();
        return true;
      }

      [[__gnu__::__nonnull__]]
      bool _M_register_callback(_Stop_cb *__cb) noexcept {
        auto __old = _M_value.load(memory_order::acquire);
        do {
          if (__old & _S_stop_requested_bit) {
            __cb->_M_run();
            return false;
          }

          if (__old < _S_ssrc_counter_inc)

            return false;
        } while (!_M_try_lock(__old));

        __cb->_M_next = _M_head;
        if (_M_head) {
          _M_head->_M_prev = __cb;
        }
        _M_head = __cb;
        _M_unlock();
        return true;
      }

      [[__gnu__::__nonnull__]]
      void _M_remove_callback(_Stop_cb *__cb) {
        _M_lock();

        if (__cb == _M_head) {
          _M_head = _M_head->_M_next;
          if (_M_head)
            _M_head->_M_prev = nullptr;
          _M_unlock();
          return;
        } else if (__cb->_M_prev) {
          __cb->_M_prev->_M_next = __cb->_M_next;
          if (__cb->_M_next)
            __cb->_M_next->_M_prev = __cb->_M_prev;
          _M_unlock();
          return;
        }

        _M_unlock();

        if (!(_M_requester == this_thread::get_id())) {

          __cb->_M_done.acquire();

          return;
        }

        if (__cb->_M_destroyed)
          *__cb->_M_destroyed = true;
      }

      bool
      _M_try_lock(value_type &__curval,
                  memory_order __failure = memory_order::acquire) noexcept {
        return _M_do_try_lock(__curval, 0, memory_order::acquire, __failure);
      }

      bool _M_try_lock_and_stop(value_type &__curval) noexcept {
        return _M_do_try_lock(__curval, _S_stop_requested_bit,
                              memory_order::acq_rel, memory_order::acquire);
      }

      bool _M_do_try_lock(value_type &__curval, value_type __newbits,
                          memory_order __success,
                          memory_order __failure) noexcept {
        if (__curval & _S_locked_bit) {
          _S_yield();
          __curval = _M_value.load(__failure);
          return false;
        }
        __newbits |= _S_locked_bit;
        return _M_value.compare_exchange_weak(__curval, __curval | __newbits,
                                              __success, __failure);
      }
    };

    struct _Stop_state_ref {
      _Stop_state_ref() = default;

      [[__gnu__::__access__(__none__, 2)]]
      explicit _Stop_state_ref(const stop_source &)
          : _M_ptr(new _Stop_state_t()) {}

      _Stop_state_ref(const _Stop_state_ref &__other) noexcept
          : _M_ptr(__other._M_ptr) {
        if (_M_ptr)
          _M_ptr->_M_add_owner();
      }

      _Stop_state_ref(_Stop_state_ref &&__other) noexcept
          : _M_ptr(__other._M_ptr) {
        __other._M_ptr = nullptr;
      }

      _Stop_state_ref &operator=(const _Stop_state_ref &__other) noexcept {
        if (auto __ptr = __other._M_ptr; __ptr != _M_ptr) {
          if (__ptr)
            __ptr->_M_add_owner();
          if (_M_ptr)
            _M_ptr->_M_release_ownership();
          _M_ptr = __ptr;
        }
        return *this;
      }

      _Stop_state_ref &operator=(_Stop_state_ref &&__other) noexcept {
        _Stop_state_ref(std::move(__other)).swap(*this);
        return *this;
      }

      ~_Stop_state_ref() {
        if (_M_ptr)
          _M_ptr->_M_release_ownership();
      }

      void swap(_Stop_state_ref &__other) noexcept {
        std::swap(_M_ptr, __other._M_ptr);
      }

      explicit operator bool() const noexcept { return _M_ptr != nullptr; }

      _Stop_state_t *operator->() const noexcept { return _M_ptr; }

      friend bool operator==(const _Stop_state_ref &,
                             const _Stop_state_ref &) = default;
# 467 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/stop_token" 3
    private:
      _Stop_state_t *_M_ptr = nullptr;
    };

    _Stop_state_ref _M_state;

    explicit stop_token(const _Stop_state_ref &__state) noexcept
        : _M_state{__state} {}
  };

  class stop_source {
  public:
    stop_source() : _M_state(*this) {}

    explicit stop_source(std::nostopstate_t) noexcept {}

    stop_source(const stop_source &__other) noexcept
        : _M_state(__other._M_state) {
      if (_M_state)
        _M_state->_M_add_ssrc();
    }

    stop_source(stop_source &&) noexcept = default;

    stop_source &operator=(const stop_source &__other) noexcept {
      if (_M_state != __other._M_state) {
        stop_source __sink(std::move(*this));
        _M_state = __other._M_state;
        if (_M_state)
          _M_state->_M_add_ssrc();
      }
      return *this;
    }

    stop_source &operator=(stop_source &&) noexcept = default;

    ~stop_source() {
      if (_M_state)
        _M_state->_M_sub_ssrc();
    }

    [[nodiscard]]
    bool stop_possible() const noexcept {
      return static_cast<bool>(_M_state);
    }

    [[nodiscard]]
    bool stop_requested() const noexcept {
      return static_cast<bool>(_M_state) && _M_state->_M_stop_requested();
    }

    bool request_stop() const noexcept {
      if (stop_possible())
        return _M_state->_M_request_stop();
      return false;
    }

    [[nodiscard]]
    stop_token get_token() const noexcept {
      return stop_token{_M_state};
    }

    void swap(stop_source &__other) noexcept {
      _M_state.swap(__other._M_state);
    }

    [[nodiscard]]
    friend bool operator==(const stop_source &__a,
                           const stop_source &__b) noexcept {
      return __a._M_state == __b._M_state;
    }

    friend void swap(stop_source &__lhs, stop_source &__rhs) noexcept {
      __lhs.swap(__rhs);
    }

  private:
    stop_token::_Stop_state_ref _M_state;
  };

  template <typename _Callback> class [[nodiscard]] stop_callback {
    static_assert(is_nothrow_destructible_v<_Callback>);
    static_assert(is_invocable_v<_Callback>);

  public:
    using callback_type = _Callback;

    template <typename _Cb,
              enable_if_t<is_constructible_v<_Callback, _Cb>, int> = 0>
    explicit stop_callback(const stop_token &__token, _Cb &&__cb) noexcept(
        is_nothrow_constructible_v<_Callback, _Cb>)
        : _M_cb(std::forward<_Cb>(__cb)) {
      if (auto __state = __token._M_state) {
        if (__state->_M_register_callback(&_M_cb))
          _M_state.swap(__state);
      }
    }

    template <typename _Cb,
              enable_if_t<is_constructible_v<_Callback, _Cb>, int> = 0>
    explicit stop_callback(stop_token &&__token, _Cb &&__cb) noexcept(
        is_nothrow_constructible_v<_Callback, _Cb>)
        : _M_cb(std::forward<_Cb>(__cb)) {
      if (auto &__state = __token._M_state) {
        if (__state->_M_register_callback(&_M_cb))
          _M_state.swap(__state);
      }
    }

    ~stop_callback() {
      if (_M_state) {
        _M_state->_M_remove_callback(&_M_cb);
      }
    }

    stop_callback(const stop_callback &) = delete;
    stop_callback &operator=(const stop_callback &) = delete;
    stop_callback(stop_callback &&) = delete;
    stop_callback &operator=(stop_callback &&) = delete;

  private:
    struct _Cb_impl : stop_token::_Stop_cb {
      template <typename _Cb>
      explicit _Cb_impl(_Cb &&__cb)
          : _Stop_cb(&_S_execute), _M_cb(std::forward<_Cb>(__cb)) {}

      _Callback _M_cb;

      [[__gnu__::__nonnull__]]
      static void _S_execute(_Stop_cb *__that) noexcept {
        _Callback &__cb = static_cast<_Cb_impl *>(__that)->_M_cb;
        std::forward<_Callback>(__cb)();
      }
    };

    _Cb_impl _M_cb;
    stop_token::_Stop_state_ref _M_state;
  };

  template <typename _Callback>
  stop_callback(stop_token, _Callback) -> stop_callback<_Callback>;

} // namespace std
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/thread" 2 3

namespace std __attribute__((__visibility__("default"))) {
# 66 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/thread" 3
  inline strong_ordering operator<=>(thread::id __x, thread::id __y) noexcept {
    return __x._M_thread <=> __y._M_thread;
  }
# 95 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/thread" 3
  template <class _CharT, class _Traits>
  inline basic_ostream<_CharT, _Traits> &operator<<(
      basic_ostream<_CharT, _Traits> &__out, thread::id __id) {
    if (__id == thread::id())
      return __out << "thread::id of a non-executing thread";
    else
      return __out << __id._M_thread;
  }
# 134 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/thread" 3
  class jthread {
  public:
    using id = thread::id;
    using native_handle_type = thread::native_handle_type;

    jthread() noexcept : _M_stop_source{nostopstate} {}

    template <
        typename _Callable, typename... _Args,
        typename = enable_if_t<!is_same_v<remove_cvref_t<_Callable>, jthread>>>
    explicit jthread(_Callable &&__f, _Args &&...__args)
        : _M_thread{_S_create(_M_stop_source, std::forward<_Callable>(__f),
                              std::forward<_Args>(__args)...)} {}

    jthread(const jthread &) = delete;
    jthread(jthread &&) noexcept = default;

    ~jthread() {
      if (joinable()) {
        request_stop();
        join();
      }
    }

    jthread &operator=(const jthread &) = delete;

    jthread &operator=(jthread &&__other) noexcept {
      std::jthread(std::move(__other)).swap(*this);
      return *this;
    }

    void swap(jthread &__other) noexcept {
      std::swap(_M_stop_source, __other._M_stop_source);
      std::swap(_M_thread, __other._M_thread);
    }

    [[nodiscard]] bool joinable() const noexcept {
      return _M_thread.joinable();
    }

    void join() { _M_thread.join(); }

    void detach() { _M_thread.detach(); }

    [[nodiscard]] id get_id() const noexcept { return _M_thread.get_id(); }

    [[nodiscard]] native_handle_type native_handle() {
      return _M_thread.native_handle();
    }

    [[nodiscard]] static unsigned hardware_concurrency() noexcept {
      return thread::hardware_concurrency();
    }

    [[nodiscard]] stop_source get_stop_source() noexcept {
      return _M_stop_source;
    }

    [[nodiscard]] stop_token get_stop_token() const noexcept {
      return _M_stop_source.get_token();
    }

    bool request_stop() noexcept { return _M_stop_source.request_stop(); }

    friend void swap(jthread &__lhs, jthread &__rhs) noexcept {
      __lhs.swap(__rhs);
    }

  private:
    template <typename _Callable, typename... _Args>
    static thread _S_create(stop_source &__ssrc, _Callable &&__f,
                            _Args &&...__args) {

      if constexpr (is_invocable_v<decay_t<_Callable>, stop_token,
                                   decay_t<_Args>...>)
        return thread{std::forward<_Callable>(__f), __ssrc.get_token(),
                      std::forward<_Args>(__args)...};
      else {
        static_assert(is_invocable_v<decay_t<_Callable>, decay_t<_Args>...>,
                      "std::jthread arguments must be invocable after"
                      " conversion to rvalues");
        return thread{std::forward<_Callable>(__f),
                      std::forward<_Args>(__args)...};
      }
    }
# 276 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/thread" 3
    stop_source _M_stop_source;
    thread _M_thread;
  };

} // namespace std
# 27 "./../stdexec/include/stdexec/__detail/../stop_token.hpp" 2

namespace stdexec {
namespace __stok {
struct __inplace_stop_callback_base {
  void __execute() noexcept { this->__execute_(this); }

protected:
  using __execute_fn_t = void(__inplace_stop_callback_base *) noexcept;

  explicit __inplace_stop_callback_base(const inplace_stop_source *__source,
                                        __execute_fn_t *__execute) noexcept
      : __source_(__source), __execute_(__execute) {}

  void __register_callback_() noexcept;

  friend inplace_stop_source;

  const inplace_stop_source *__source_;
  __execute_fn_t *__execute_;
  __inplace_stop_callback_base *__next_ = nullptr;
  __inplace_stop_callback_base **__prev_ptr_ = nullptr;
  bool *__removed_during_callback_ = nullptr;
  std::atomic<bool> __callback_completed_{false};
};

struct __spin_wait {
  __spin_wait() noexcept = default;

  void __wait() noexcept {
    if (__count_++ < __yield_threshold_) {

    } else {
      if (__count_ == 0)
        __count_ = __yield_threshold_;
      std::this_thread::yield();
    }
  }

private:
  static constexpr uint32_t __yield_threshold_ = 20;
  uint32_t __count_ = 0;
};
} // namespace __stok

struct never_stop_token {
private:
  struct __callback_type {
    explicit __callback_type(never_stop_token, __ignore) noexcept {}
  };

public:
  template <class> using callback_type = __callback_type;

  static constexpr auto stop_requested() noexcept -> bool { return false; }

  static constexpr auto stop_possible() noexcept -> bool { return false; }

  auto operator==(const never_stop_token &) const noexcept -> bool = default;
};

template <class _Callback> class inplace_stop_callback;

class inplace_stop_source {
public:
  inplace_stop_source() noexcept = default;
  ~inplace_stop_source();
  inplace_stop_source(inplace_stop_source &&) = delete;

  auto get_token() const noexcept -> inplace_stop_token;

  auto request_stop() noexcept -> bool;

  auto stop_requested() const noexcept -> bool {
    return (__state_.load(std::memory_order_acquire) &
            __stop_requested_flag_) != 0;
  }

private:
  friend inplace_stop_token;
  friend __stok::__inplace_stop_callback_base;
  template <class> friend class inplace_stop_callback;

  auto __lock_() const noexcept -> uint8_t;
  void __unlock_(uint8_t) const noexcept;

  auto __try_lock_unless_stop_requested_(bool) const noexcept -> bool;

  auto __try_add_callback_(
      __stok::__inplace_stop_callback_base *) const noexcept -> bool;

  void
  __remove_callback_(__stok::__inplace_stop_callback_base *) const noexcept;

  static constexpr uint8_t __stop_requested_flag_ = 1;
  static constexpr uint8_t __locked_flag_ = 2;

  mutable std::atomic<uint8_t> __state_{0};
  mutable __stok::__inplace_stop_callback_base *__callbacks_ = nullptr;
  std::thread::id __notifying_thread_;
};

class inplace_stop_token {
public:
  template <class _Fun> using callback_type = inplace_stop_callback<_Fun>;

  inplace_stop_token() noexcept : __source_(nullptr) {}

  inplace_stop_token(const inplace_stop_token &__other) noexcept = default;

  inplace_stop_token(inplace_stop_token &&__other) noexcept
      : __source_(std::exchange(__other.__source_, {})) {}

  auto operator=(const inplace_stop_token &__other) noexcept
      -> inplace_stop_token & = default;

  auto
  operator=(inplace_stop_token &&__other) noexcept -> inplace_stop_token & {
    __source_ = std::exchange(__other.__source_, nullptr);
    return *this;
  }

  [[nodiscard]]
  auto stop_requested() const noexcept -> bool {
    return __source_ != nullptr && __source_->stop_requested();
  }

  [[nodiscard]]
  auto stop_possible() const noexcept -> bool {
    return __source_ != nullptr;
  }

  void swap(inplace_stop_token &__other) noexcept {
    std::swap(__source_, __other.__source_);
  }

  auto operator==(const inplace_stop_token &) const noexcept -> bool = default;

private:
  friend inplace_stop_source;
  template <class> friend class inplace_stop_callback;

  explicit inplace_stop_token(const inplace_stop_source *__source) noexcept
      : __source_(__source) {}

  const inplace_stop_source *__source_;
};

inline auto
inplace_stop_source::get_token() const noexcept -> inplace_stop_token {
  return inplace_stop_token{this};
}

template <class _Fun>
class inplace_stop_callback : __stok::__inplace_stop_callback_base {
public:
  template <class _Fun2>
    requires constructible_from<_Fun, _Fun2>
  explicit inplace_stop_callback(
      inplace_stop_token __token,
      _Fun2 &&__fun) noexcept(__nothrow_constructible_from<_Fun, _Fun2>)
      : __stok::__inplace_stop_callback_base(
            __token.__source_, &inplace_stop_callback::__execute_impl_),
        __fun_(static_cast<_Fun2 &&>(__fun)) {
    __register_callback_();
  }

  ~inplace_stop_callback() {
    if (__source_ != nullptr)
      __source_->__remove_callback_(this);
  }

private:
  static void
  __execute_impl_(__stok::__inplace_stop_callback_base *cb) noexcept {
    std::move(static_cast<inplace_stop_callback *>(cb)->__fun_)();
  }

  [[no_unique_address]] _Fun __fun_;
};

namespace __stok {
inline void __inplace_stop_callback_base::__register_callback_() noexcept {
  if (__source_ != nullptr) {
    if (!__source_->__try_add_callback_(this)) {
      __source_ = nullptr;

      __execute();
    }
  }
}
} // namespace __stok

inline inplace_stop_source::~inplace_stop_source() {
  do {
    static_assert(noexcept(
        (__state_.load(std::memory_order_relaxed) & __locked_flag_) == 0));
    (static_cast<bool>(
         (__state_.load(std::memory_order_relaxed) & __locked_flag_) == 0)
         ? void(0)
         : __assert_fail("(__state_.load(std::memory_order_relaxed) & "
                         "__locked_flag_) == 0",
                         __builtin_FILE(), __builtin_LINE(),
                         __extension__ __PRETTY_FUNCTION__));
  } while (false);
  do {
    static_assert(noexcept(__callbacks_ == nullptr));
    (static_cast<bool>(__callbacks_ == nullptr)
         ? void(0)
         : __assert_fail("__callbacks_ == nullptr", __builtin_FILE(),
                         __builtin_LINE(), __extension__ __PRETTY_FUNCTION__));
  } while (false);
}

inline auto inplace_stop_source::request_stop() noexcept -> bool {
  if (!__try_lock_unless_stop_requested_(true))
    return true;

  __notifying_thread_ = std::this_thread::get_id();

  while (__callbacks_ != nullptr) {
    auto *__callbk = __callbacks_;
    __callbk->__prev_ptr_ = nullptr;
    __callbacks_ = __callbk->__next_;
    if (__callbacks_ != nullptr)
      __callbacks_->__prev_ptr_ = &__callbacks_;

    __state_.store(__stop_requested_flag_, std::memory_order_release);

    bool __removed_during_callback = false;
    __callbk->__removed_during_callback_ = &__removed_during_callback;

    __callbk->__execute();

    if (!__removed_during_callback) {
      __callbk->__removed_during_callback_ = nullptr;
      __callbk->__callback_completed_.store(true, std::memory_order_release);
    }

    __lock_();
  }

  __state_.store(__stop_requested_flag_, std::memory_order_release);
  return false;
}

inline auto inplace_stop_source::__lock_() const noexcept -> uint8_t {
  __stok::__spin_wait __spin;
  auto __old_state = __state_.load(std::memory_order_relaxed);
  do {
    while ((__old_state & __locked_flag_) != 0) {
      __spin.__wait();
      __old_state = __state_.load(std::memory_order_relaxed);
    }
  } while (!__state_.compare_exchange_weak(
      __old_state, __old_state | __locked_flag_, std::memory_order_acquire,
      std::memory_order_relaxed));

  return __old_state;
}

inline void inplace_stop_source::__unlock_(uint8_t __old_state) const noexcept {
  (void)__state_.store(__old_state, std::memory_order_release);
}

inline auto inplace_stop_source::__try_lock_unless_stop_requested_(
    bool __set_stop_requested) const noexcept -> bool {
  __stok::__spin_wait __spin;
  auto __old_state = __state_.load(std::memory_order_relaxed);
  do {
    while (true) {
      if ((__old_state & __stop_requested_flag_) != 0) {

        return false;
      } else if (__old_state == 0) {
        break;
      } else {
        __spin.__wait();
        __old_state = __state_.load(std::memory_order_relaxed);
      }
    }
  } while (!__state_.compare_exchange_weak(
      __old_state,
      __set_stop_requested ? (__locked_flag_ | __stop_requested_flag_)
                           : __locked_flag_,
      std::memory_order_acq_rel, std::memory_order_relaxed));

  return true;
}

inline auto inplace_stop_source::__try_add_callback_(
    __stok::__inplace_stop_callback_base *__callbk) const noexcept -> bool {
  if (!__try_lock_unless_stop_requested_(false)) {
    return false;
  }

  __callbk->__next_ = __callbacks_;
  __callbk->__prev_ptr_ = &__callbacks_;
  if (__callbacks_ != nullptr) {
    __callbacks_->__prev_ptr_ = &__callbk->__next_;
  }
  __callbacks_ = __callbk;

  __unlock_(0);

  return true;
}

inline void inplace_stop_source::__remove_callback_(
    __stok::__inplace_stop_callback_base *__callbk) const noexcept {
  auto __old_state = __lock_();

  if (__callbk->__prev_ptr_ != nullptr) {

    *__callbk->__prev_ptr_ = __callbk->__next_;
    if (__callbk->__next_ != nullptr) {
      __callbk->__next_->__prev_ptr_ = __callbk->__prev_ptr_;
    }
    __unlock_(__old_state);
  } else {
    auto __notifying_thread = __notifying_thread_;
    __unlock_(__old_state);

    if (std::this_thread::get_id() == __notifying_thread) {
      if (__callbk->__removed_during_callback_ != nullptr) {
        *__callbk->__removed_during_callback_ = true;
      }
    } else {

      __stok::__spin_wait __spin;
      while (!__callbk->__callback_completed_.load(std::memory_order_acquire)) {
        __spin.__wait();
      }
    }
  }
}

using in_place_stop_token
    [[deprecated("in_place_stop_token has been renamed inplace_stop_token")]] =
        inplace_stop_token;

using in_place_stop_source
    [[deprecated("in_place_stop_token has been renamed inplace_stop_source")]] =
        inplace_stop_source;

template <class _Fun>
using in_place_stop_callback [[deprecated(
    "in_place_stop_callback has been renamed inplace_stop_callback")]] =
    inplace_stop_callback<_Fun>;
} // namespace stdexec
# 32 "./../stdexec/include/stdexec/__detail/__shared.hpp" 2

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/mutex" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/mutex" 3
# 46 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/mutex" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_lock.h" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_lock.h" 3
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_lock.h" 3
namespace std __attribute__((__visibility__("default"))) {
# 58 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/unique_lock.h" 3
  template <typename _Mutex> class unique_lock {
  public:
    typedef _Mutex mutex_type;

    unique_lock() noexcept : _M_device(0), _M_owns(false) {}

    explicit unique_lock(mutex_type &__m)
        : _M_device(std::__addressof(__m)), _M_owns(false) {
      lock();
      _M_owns = true;
    }

    unique_lock(mutex_type &__m, defer_lock_t) noexcept
        : _M_device(std::__addressof(__m)), _M_owns(false) {}

    unique_lock(mutex_type &__m, try_to_lock_t)
        : _M_device(std::__addressof(__m)), _M_owns(_M_device->try_lock()) {}

    unique_lock(mutex_type &__m, adopt_lock_t) noexcept
        : _M_device(std::__addressof(__m)), _M_owns(true) {}

    template <typename _Clock, typename _Duration>
    unique_lock(mutex_type &__m,
                const chrono::time_point<_Clock, _Duration> &__atime)
        : _M_device(std::__addressof(__m)),
          _M_owns(_M_device->try_lock_until(__atime)) {}

    template <typename _Rep, typename _Period>
    unique_lock(mutex_type &__m, const chrono::duration<_Rep, _Period> &__rtime)
        : _M_device(std::__addressof(__m)),
          _M_owns(_M_device->try_lock_for(__rtime)) {}

    ~unique_lock() {
      if (_M_owns)
        unlock();
    }

    unique_lock(const unique_lock &) = delete;
    unique_lock &operator=(const unique_lock &) = delete;

    unique_lock(unique_lock &&__u) noexcept
        : _M_device(__u._M_device), _M_owns(__u._M_owns) {
      __u._M_device = 0;
      __u._M_owns = false;
    }

    unique_lock &operator=(unique_lock &&__u) noexcept {
      if (_M_owns)
        unlock();

      unique_lock(std::move(__u)).swap(*this);

      __u._M_device = 0;
      __u._M_owns = false;

      return *this;
    }

    void lock() {
      if (!_M_device)
        __throw_system_error(int(errc::operation_not_permitted));
      else if (_M_owns)
        __throw_system_error(int(errc::resource_deadlock_would_occur));
      else {
        _M_device->lock();
        _M_owns = true;
      }
    }

    [[__nodiscard__]]
    bool try_lock() {
      if (!_M_device)
        __throw_system_error(int(errc::operation_not_permitted));
      else if (_M_owns)
        __throw_system_error(int(errc::resource_deadlock_would_occur));
      else {
        _M_owns = _M_device->try_lock();
        return _M_owns;
      }
    }

    template <typename _Clock, typename _Duration>
    [[__nodiscard__]]
    bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__atime) {
      if (!_M_device)
        __throw_system_error(int(errc::operation_not_permitted));
      else if (_M_owns)
        __throw_system_error(int(errc::resource_deadlock_would_occur));
      else {
        _M_owns = _M_device->try_lock_until(__atime);
        return _M_owns;
      }
    }

    template <typename _Rep, typename _Period>
    [[__nodiscard__]]
    bool try_lock_for(const chrono::duration<_Rep, _Period> &__rtime) {
      if (!_M_device)
        __throw_system_error(int(errc::operation_not_permitted));
      else if (_M_owns)
        __throw_system_error(int(errc::resource_deadlock_would_occur));
      else {
        _M_owns = _M_device->try_lock_for(__rtime);
        return _M_owns;
      }
    }

    void unlock() {
      if (!_M_owns)
        __throw_system_error(int(errc::operation_not_permitted));
      else if (_M_device) {
        _M_device->unlock();
        _M_owns = false;
      }
    }

    void swap(unique_lock &__u) noexcept {
      std::swap(_M_device, __u._M_device);
      std::swap(_M_owns, __u._M_owns);
    }

    mutex_type *release() noexcept {
      mutex_type *__ret = _M_device;
      _M_device = 0;
      _M_owns = false;
      return __ret;
    }

    [[__nodiscard__]]
    bool owns_lock() const noexcept {
      return _M_owns;
    }

    explicit operator bool() const noexcept { return owns_lock(); }

    [[__nodiscard__]]
    mutex_type *mutex() const noexcept {
      return _M_device;
    }

  private:
    mutex_type *_M_device;
    bool _M_owns;
  };

  template <typename _Mutex>
  inline void swap(unique_lock<_Mutex> & __x,
                   unique_lock<_Mutex> & __y) noexcept {
    __x.swap(__y);
  }

} // namespace std
# 47 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/mutex" 2 3
# 57 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/mutex" 3
namespace std __attribute__((__visibility__("default"))) {
# 70 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/mutex" 3
  class __recursive_mutex_base {
  protected:
    typedef __gthread_recursive_mutex_t __native_type;

    __recursive_mutex_base(const __recursive_mutex_base &) = delete;
    __recursive_mutex_base &operator=(const __recursive_mutex_base &) = delete;

    __native_type _M_mutex = {
        {0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, 0, {0, 0}}};

    __recursive_mutex_base() = default;
# 94 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/mutex" 3
  };
# 106 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/mutex" 3
  class recursive_mutex : private __recursive_mutex_base {
  public:
    typedef __native_type *native_handle_type;

    recursive_mutex() = default;
    ~recursive_mutex() = default;

    recursive_mutex(const recursive_mutex &) = delete;
    recursive_mutex &operator=(const recursive_mutex &) = delete;

    void lock() {
      int __e = __gthread_recursive_mutex_lock(&_M_mutex);

      if (__e)
        __throw_system_error(__e);
    }

    [[__nodiscard__]]
    bool try_lock() noexcept {

      return !__gthread_recursive_mutex_trylock(&_M_mutex);
    }

    void unlock() { __gthread_recursive_mutex_unlock(&_M_mutex); }

    native_handle_type native_handle() noexcept { return &_M_mutex; }
  };

  template <typename _Derived> class __timed_mutex_impl {
  protected:
    template <typename _Rep, typename _Period>
    bool _M_try_lock_for(const chrono::duration<_Rep, _Period> &__rtime) {

      using __clock = chrono::steady_clock;

      auto __rt = chrono::duration_cast<__clock::duration>(__rtime);
      if (ratio_greater<__clock::period, _Period>())
        ++__rt;
      return _M_try_lock_until(__clock::now() + __rt);
    }

    template <typename _Duration>
    bool _M_try_lock_until(
        const chrono::time_point<chrono::system_clock, _Duration> &__atime) {
      auto __s = chrono::time_point_cast<chrono::seconds>(__atime);
      auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);

      __gthread_time_t __ts = {
          static_cast<std::time_t>(__s.time_since_epoch().count()),
          static_cast<long>(__ns.count())};

      return static_cast<_Derived *>(this)->_M_timedlock(__ts);
    }

    template <typename _Duration>
    bool _M_try_lock_until(
        const chrono::time_point<chrono::steady_clock, _Duration> &__atime) {
      auto __s = chrono::time_point_cast<chrono::seconds>(__atime);
      auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);

      __gthread_time_t __ts = {
          static_cast<std::time_t>(__s.time_since_epoch().count()),
          static_cast<long>(__ns.count())};

      return static_cast<_Derived *>(this)->_M_clocklock(1, __ts);
    }

    template <typename _Clock, typename _Duration>
    bool
    _M_try_lock_until(const chrono::time_point<_Clock, _Duration> &__atime) {

      static_assert(chrono::is_clock_v<_Clock>);

      auto __now = _Clock::now();
      do {
        auto __rtime = __atime - __now;
        if (_M_try_lock_for(__rtime))
          return true;
        __now = _Clock::now();
      } while (__atime > __now);
      return false;
    }
  };
# 235 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/mutex" 3
  class timed_mutex : private __mutex_base,
                      public __timed_mutex_impl<timed_mutex> {
  public:
    typedef __native_type *native_handle_type;

    timed_mutex() = default;
    ~timed_mutex() = default;

    timed_mutex(const timed_mutex &) = delete;
    timed_mutex &operator=(const timed_mutex &) = delete;

    void lock() {
      int __e = __gthread_mutex_lock(&_M_mutex);

      if (__e)
        __throw_system_error(__e);
    }

    [[__nodiscard__]]
    bool try_lock() noexcept {

      return !__gthread_mutex_trylock(&_M_mutex);
    }

    template <class _Rep, class _Period>
    [[__nodiscard__]]
    bool try_lock_for(const chrono::duration<_Rep, _Period> &__rtime) {
      return _M_try_lock_for(__rtime);
    }

    template <class _Clock, class _Duration>
    [[__nodiscard__]]
    bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__atime) {
      return _M_try_lock_until(__atime);
    }

    void unlock() { __gthread_mutex_unlock(&_M_mutex); }

    native_handle_type native_handle() noexcept { return &_M_mutex; }

  private:
    friend class __timed_mutex_impl<timed_mutex>;

    bool _M_timedlock(const __gthread_time_t &__ts) {
      return !__gthread_mutex_timedlock(&_M_mutex, &__ts);
    }

    bool _M_clocklock(clockid_t __clockid, const __gthread_time_t &__ts) {
      return !pthread_mutex_clocklock(&_M_mutex, __clockid, &__ts);
    }
  };
# 312 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/mutex" 3
  class recursive_timed_mutex
      : private __recursive_mutex_base,
        public __timed_mutex_impl<recursive_timed_mutex> {
  public:
    typedef __native_type *native_handle_type;

    recursive_timed_mutex() = default;
    ~recursive_timed_mutex() = default;

    recursive_timed_mutex(const recursive_timed_mutex &) = delete;
    recursive_timed_mutex &operator=(const recursive_timed_mutex &) = delete;

    void lock() {
      int __e = __gthread_recursive_mutex_lock(&_M_mutex);

      if (__e)
        __throw_system_error(__e);
    }

    [[__nodiscard__]]
    bool try_lock() noexcept {

      return !__gthread_recursive_mutex_trylock(&_M_mutex);
    }

    template <class _Rep, class _Period>
    [[__nodiscard__]]
    bool try_lock_for(const chrono::duration<_Rep, _Period> &__rtime) {
      return _M_try_lock_for(__rtime);
    }

    template <class _Clock, class _Duration>
    [[__nodiscard__]]
    bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__atime) {
      return _M_try_lock_until(__atime);
    }

    void unlock() { __gthread_recursive_mutex_unlock(&_M_mutex); }

    native_handle_type native_handle() noexcept { return &_M_mutex; }

  private:
    friend class __timed_mutex_impl<recursive_timed_mutex>;

    bool _M_timedlock(const __gthread_time_t &__ts) {
      return !__gthread_recursive_mutex_timedlock(&_M_mutex, &__ts);
    }

    bool _M_clocklock(clockid_t __clockid, const __gthread_time_t &__ts) {
      return !pthread_mutex_clocklock(&_M_mutex, __clockid, &__ts);
    }
  };
# 559 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/mutex" 3
  namespace __detail {

  template <typename _Lockable> inline int __try_lock_impl(_Lockable &__l) {
    if (unique_lock<_Lockable> __lock{__l, try_to_lock}) {
      __lock.release();
      return -1;
    } else
      return 0;
  }

  template <typename _L0, typename... _Lockables>
  inline int __try_lock_impl(_L0 &__l0, _Lockables &...__lockables) {

    if constexpr ((is_same_v<_L0, _Lockables> && ...)) {
      constexpr int _Np = 1 + sizeof...(_Lockables);
      unique_lock<_L0> __locks[_Np] = {{__l0, defer_lock},
                                       {__lockables, defer_lock}...};
      for (int __i = 0; __i < _Np; ++__i) {
        if (!__locks[__i].try_lock()) {
          const int __failed = __i;
          while (__i--)
            __locks[__i].unlock();
          return __failed;
        }
      }
      for (auto &__l : __locks)
        __l.release();
      return -1;
    } else

        if (unique_lock<_L0> __lock{__l0, try_to_lock}) {
      int __idx = __detail::__try_lock_impl(__lockables...);
      if (__idx == -1) {
        __lock.release();
        return -1;
      }
      return __idx + 1;
    } else
      return 0;
  }

  } // namespace __detail
# 631 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/mutex" 3
  template <typename _L1, typename _L2, typename... _L3>
  [[__nodiscard__]]
  inline int try_lock(_L1 & __l1, _L2 & __l2, _L3 & ...__l3) {
    return __detail::__try_lock_impl(__l1, __l2, __l3...);
  }

  namespace __detail {

  template <typename _L0, typename... _L1>
  void __lock_impl(int &__i, int __depth, _L0 &__l0, _L1 &...__l1) {
    while (__i >= __depth) {
      if (__i == __depth) {
        int __failed = 1;
        {
          unique_lock<_L0> __first(__l0);
          __failed += __detail::__try_lock_impl(__l1...);
          if (!__failed) {
            __i = -1;
            __first.release();
            return;
          }
        }

        __gthread_yield();

        constexpr auto __n = 1 + sizeof...(_L1);
        __i = (__depth + __failed) % __n;
      } else
        __detail::__lock_impl(__i, __depth + 1, __l1..., __l0);
    }
  }

  } // namespace __detail
# 691 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/mutex" 3
  template <typename _L1, typename _L2, typename... _L3>
  void lock(_L1 & __l1, _L2 & __l2, _L3 & ...__l3) {

    if constexpr (is_same_v<_L1, _L2> && (is_same_v<_L1, _L3> && ...)) {
      constexpr int _Np = 2 + sizeof...(_L3);
      unique_lock<_L1> __locks[] = {
          {__l1, defer_lock}, {__l2, defer_lock}, {__l3, defer_lock}...};
      int __first = 0;
      do {
        __locks[__first].lock();
        for (int __j = 1; __j < _Np; ++__j) {
          const int __idx = (__first + __j) % _Np;
          if (!__locks[__idx].try_lock()) {
            for (int __k = __j; __k != 0; --__k)
              __locks[(__first + __k - 1) % _Np].unlock();
            __first = __idx;
            break;
          }
        }
      } while (!__locks[__first].owns_lock());

      for (auto &__l : __locks)
        __l.release();
    } else

    {
      int __i = 0;
      __detail::__lock_impl(__i, 0, __l1, __l2, __l3...);
    }
  }
# 739 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/mutex" 3
  template <typename... _MutexTypes> class scoped_lock {
  public:
    explicit scoped_lock(_MutexTypes &...__m) : _M_devices(std::tie(__m...)) {
      std::lock(__m...);
    }

    explicit scoped_lock(adopt_lock_t, _MutexTypes &...__m) noexcept
        : _M_devices(std::tie(__m...)) {}

    ~scoped_lock() {
      std::apply([](auto &...__m) { (__m.unlock(), ...); }, _M_devices);
    }

    scoped_lock(const scoped_lock &) = delete;
    scoped_lock &operator=(const scoped_lock &) = delete;

  private:
    tuple<_MutexTypes &...> _M_devices;
  };

  template <> class scoped_lock<> {
  public:
    explicit scoped_lock() = default;
    explicit scoped_lock(adopt_lock_t) noexcept {}
    ~scoped_lock() = default;

    scoped_lock(const scoped_lock &) = delete;
    scoped_lock &operator=(const scoped_lock &) = delete;
  };

  template <typename _Mutex> class scoped_lock<_Mutex> {
  public:
    using mutex_type = _Mutex;

    explicit scoped_lock(mutex_type &__m) : _M_device(__m) { _M_device.lock(); }

    explicit scoped_lock(adopt_lock_t, mutex_type &__m) noexcept
        : _M_device(__m) {}

    ~scoped_lock() { _M_device.unlock(); }

    scoped_lock(const scoped_lock &) = delete;
    scoped_lock &operator=(const scoped_lock &) = delete;

  private:
    mutex_type &_M_device;
  };

  struct once_flag {
    constexpr once_flag() noexcept = default;

    once_flag(const once_flag &) = delete;

    once_flag &operator=(const once_flag &) = delete;

  private:
    __gthread_once_t _M_once = 0;

    struct _Prepare_execution;

    template <typename _Callable, typename... _Args>
    friend void call_once(once_flag &__once, _Callable &&__f,
                          _Args &&...__args);
  };

  extern __thread void *__once_callable;
  extern __thread void (*__once_call)();

  struct once_flag::_Prepare_execution {
    template <typename _Callable> explicit _Prepare_execution(_Callable &__c) {

      __once_callable = std::__addressof(__c);

      __once_call = [] { (*static_cast<_Callable *>(__once_callable))(); };
    }

    ~_Prepare_execution() {

      __once_callable = nullptr;
      __once_call = nullptr;
    }

    _Prepare_execution(const _Prepare_execution &) = delete;
    _Prepare_execution &operator=(const _Prepare_execution &) = delete;
  };
# 891 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/mutex" 3
  extern "C" void __once_proxy(void);

  template <typename _Callable, typename... _Args>
  void call_once(once_flag & __once, _Callable && __f, _Args && ...__args) {

    auto __callable = [&] {
      std::__invoke(std::forward<_Callable>(__f),
                    std::forward<_Args>(__args)...);
    };

    once_flag::_Prepare_execution __exec(__callable);

    if (int __e = __gthread_once(&__once._M_once, &__once_proxy))
      __throw_system_error(__e);
  }
# 1013 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/mutex" 3
} // namespace std
# 36 "./../stdexec/include/stdexec/__detail/__shared.hpp" 2
# 59 "./../stdexec/include/stdexec/__detail/__shared.hpp"
namespace stdexec::__shared {
template <class _BaseEnv>
using __env_t =
    __join_env_t<prop<get_stop_token_t, inplace_stop_token>, _BaseEnv>;

template <class _Receiver>
auto __make_notify_visitor(_Receiver &__rcvr) noexcept {
  return [&]<class _Tuple>(_Tuple &&__tupl) noexcept -> void {
    __tupl.apply(
        [&](auto __tag, auto &&...__args) noexcept -> void {
          __tag(static_cast<_Receiver &&>(__rcvr),
                __forward_like<_Tuple>(__args)...);
        },
        __tupl);
  };
}

struct __local_state_base : __immovable {
  using __notify_fn = void(__local_state_base *) noexcept;

  void __notify() noexcept { __notify_(this); }

  __notify_fn *__notify_{};
  __local_state_base *__next_{};
};

template <class _CvrefSender, class _Env> struct __shared_state;

template <class _CvrefSender, class _Receiver>
struct __local_state
    : __local_state_base,
      __enable_receiver_from_this<_CvrefSender, _Receiver,
                                  __local_state<_CvrefSender, _Receiver>> {
  using __tag_t = tag_of_t<_CvrefSender>;
  using __stok_t = stop_token_of_t<env_of_t<_Receiver>>;
  static_assert(__one_of<__tag_t, __split::__split_t,
                         __ensure_started::__ensure_started_t>);

  explicit __local_state(_CvrefSender &&__sndr) noexcept
      : __local_state::__local_state_base{{},
                                          &__notify<tag_of_t<_CvrefSender>>},
        __sh_state_(__get_sh_state(__sndr)) {}

  ~__local_state() {
    if (__sh_state_) {
      __sh_state_->__detach();
    }
  }

  void operator()() noexcept {

    if (std::unique_lock __lock{__sh_state_->__mutex_}) {
# 127 "./../stdexec/include/stdexec/__detail/__shared.hpp"
      if (!__sh_state_->__waiters_.remove(this))
        return;
    }

    std::exchange(__sh_state_, nullptr)->__detach();
    stdexec::set_stopped(static_cast<_Receiver &&>(this->__receiver()));
  }

  template <class _Tag>
  static void __notify(__local_state_base *__base) noexcept {
    auto *const __self = static_cast<__local_state *>(__base);

    constexpr bool __is_split = same_as<__split::__split_t, _Tag>;
    using __variant_t = decltype(__self->__sh_state_->__results_);
    using __cv_variant_t = __if_c<__is_split, const __variant_t &, __variant_t>;

    __self->__on_stop_.reset();

    auto __visitor = __make_notify_visitor(__self->__receiver());
    __variant_t::visit(__visitor, static_cast<__cv_variant_t &&>(
                                      __self->__sh_state_->__results_));
  }

  static auto __get_sh_state(_CvrefSender &__sndr) noexcept {
    auto __box = __sndr.apply(static_cast<_CvrefSender &&>(__sndr),
                              __detail::__get_data());
    return std::exchange(__box.__sh_state_, nullptr);
  }

  using __sh_state_ptr_t = __result_of<__get_sh_state, _CvrefSender &>;
  using __sh_state_t = std::remove_pointer_t<__sh_state_ptr_t>;

  __optional<stop_callback_for_t<__stok_t, __local_state &>> __on_stop_{};
  __sh_state_ptr_t __sh_state_;
};

template <class _CvrefSenderId, class _EnvId> struct __receiver {
  using _CvrefSender = stdexec::__cvref_t<_CvrefSenderId>;
  using _Env = stdexec::__t<_EnvId>;

  struct __t {
    using receiver_concept = receiver_t;
    using __id = __receiver;

    template <class... _As>
    __attribute__((__always_inline__, __artificial__, __nodebug__)) inline void
    set_value(_As &&...__as) noexcept {
      __sh_state_->__complete(set_value_t(), static_cast<_As &&>(__as)...);
    }

    template <class _Error>
    __attribute__((__always_inline__, __artificial__, __nodebug__)) inline void
    set_error(_Error &&__err) noexcept {
      __sh_state_->__complete(set_error_t(), static_cast<_Error &&>(__err));
    }

    __attribute__((__always_inline__, __artificial__, __nodebug__)) inline void
    set_stopped() noexcept {
      __sh_state_->__complete(set_stopped_t());
    }

    auto get_env() const noexcept -> const __env_t<_Env> & {
      return __sh_state_->__env_;
    }

    __shared_state<_CvrefSender, _Env> *__sh_state_;
  };
};

template <class _CvrefSender, class _Env> struct __shared_state {
  using __receiver_t = __t<__receiver<__cvref_id<_CvrefSender>, __id<_Env>>>;
  using __waiters_list_t = __intrusive_slist<&__local_state_base::__next_>;

  using __variant_t = __transform_completion_signatures<
      __completion_signatures_of_t<_CvrefSender, _Env>,
      __mbind_front_q<__decayed_tuple, set_value_t>::__f,
      __mbind_front_q<__decayed_tuple, set_error_t>::__f,
      __tuple_for<set_error_t, std::exception_ptr>,
      __munique<
          __mbind_front_q<__variant_for, __tuple_for<set_stopped_t>>>::__f,
      __tuple_for<set_error_t, std::exception_ptr>>;

  inplace_stop_source __stop_source_{};
  __env_t<_Env> __env_;
  __variant_t __results_{};
  std::mutex __mutex_;
  __waiters_list_t __waiters_{};
  connect_result_t<_CvrefSender, __receiver_t> __shared_op_;
  std::atomic_flag __started_{};
  std::atomic<std::size_t> __ref_count_{2};
  __local_state_base __tombstone_{};
# 237 "./../stdexec/include/stdexec/__detail/__shared.hpp"
  explicit __shared_state(_CvrefSender &&__sndr, _Env __env)
      : __env_(__env::__join(prop{get_stop_token, __stop_source_.get_token()},
                             static_cast<_Env &&>(__env))),
        __shared_op_(connect(static_cast<_CvrefSender &&>(__sndr),
                             __receiver_t{this})) {}

  void __inc_ref() noexcept {
    __ref_count_.fetch_add(2ul, std::memory_order_relaxed);
  }

  void __dec_ref() noexcept {
    if (2ul == __ref_count_.fetch_sub(2ul, std::memory_order_acq_rel)) {
      delete this;
    }
  }

  auto __set_started() noexcept -> bool {
    if (__started_.test_and_set(std::memory_order_acq_rel)) {
      return false;
    }
    __ref_count_.fetch_add(1ul, std::memory_order_relaxed);
    return true;
  }

  void __set_completed() noexcept {
    if (1ul == __ref_count_.fetch_sub(1ul, std::memory_order_acq_rel)) {
      delete this;
    }
  }

  void __detach() noexcept {
    if (__ref_count_.load() < 4ul) {

      __stop_source_.request_stop();
    }
    __dec_ref();
  }

  void __try_start() noexcept {

    if (__set_started()) {

      if (__stop_source_.stop_requested()) {

        __notify_waiters();
      } else {
        stdexec::start(__shared_op_);
      }
    }
  }

  template <class _StopToken>
  auto __try_add_waiter(__local_state_base *__waiter,
                        _StopToken __stok) noexcept -> bool {
    std::unique_lock __lock{__mutex_};
    if (__waiters_.front() == &__tombstone_) {

      __lock.unlock();
      __waiter->__notify();
      return true;
    } else if (__stok.stop_requested()) {

      return false;
    } else {

      __waiters_.push_front(__waiter);
      return true;
    }
  }

  template <class _Tag, class... _As>
  void __complete(_Tag, _As &&...__as) noexcept {
    try {
      using __tuple_t = __decayed_tuple<_Tag, _As...>;
      __results_.template emplace<__tuple_t>(_Tag(),
                                             static_cast<_As &&>(__as)...);
    } catch (...) {
      using __tuple_t = __decayed_tuple<set_error_t, std::exception_ptr>;
      __results_.template emplace<__tuple_t>(set_error,
                                             std::current_exception());
    }

    __notify_waiters();
  }

  void __notify_waiters() noexcept {
    __waiters_list_t __waiters_copy{&__tombstone_};

    {
      std::lock_guard __lock{__mutex_};
      __waiters_.swap(__waiters_copy);
    }

    do {
      static_assert(noexcept(__waiters_copy.front() != &__tombstone_));
      (static_cast<bool>(__waiters_copy.front() != &__tombstone_)
           ? void(0)
           : __assert_fail("__waiters_copy.front() != &__tombstone_",
                           __builtin_FILE(), __builtin_LINE(),
                           __extension__ __PRETTY_FUNCTION__));
    } while (false);
    for (auto __itr = __waiters_copy.begin(); __itr != __waiters_copy.end();) {
      __local_state_base *__item = *__itr;

      ++__itr;
      __item->__notify();
    }

    __set_completed();
  }
};

template <class _CvrefSender, class _Env>
__shared_state(_CvrefSender &&, _Env) -> __shared_state<_CvrefSender, _Env>;

template <class _Cvref, class _CvrefSender, class _Env>
using __make_completions = __try_make_completion_signatures<

    _CvrefSender, __env_t<_Env>,
    completion_signatures<set_error_t(__minvoke<_Cvref, std::exception_ptr>),
                          set_stopped_t()>,
    __mtransform<_Cvref,
                 __mcompose<__q<completion_signatures>, __qf<set_value_t>>>,
    __mtransform<_Cvref,
                 __mcompose<__q<completion_signatures>, __qf<set_error_t>>>>;

template <class _Tag>
using __cvref_results_t =
    __mcompose<__if_c<same_as<_Tag, __split::__split_t>, __cpclr, __cp>,
               __q<__decay_t>>;

template <class _Tag, class _ShState>
using __completions =
    __mapply<__mbind_front_q<__make_completions, __cvref_results_t<_Tag>>,
             _ShState>;

template <class _CvrefSender, class _Env, bool _Copyable = true> struct __box {
  using __tag_t = __if_c<_Copyable, __split::__split_t,
                         __ensure_started::__ensure_started_t>;
  using __sh_state_t = __shared_state<_CvrefSender, _Env>;

  __box(__tag_t, __sh_state_t *__sh_state) noexcept : __sh_state_(__sh_state) {}

  __box(__box &&__other) noexcept
      : __sh_state_(std::exchange(__other.__sh_state_, nullptr)) {}

  __box(const __box &__other) noexcept
    requires _Copyable
      : __sh_state_(__other.__sh_state_) {
    __sh_state_->__inc_ref();
  }

  ~__box() {
    if (__sh_state_) {
      __sh_state_->__detach();
    }
  }

  __sh_state_t *__sh_state_;
};

template <class _CvrefSender, class _Env>
__box(__split::__split_t,
      __shared_state<_CvrefSender, _Env> *) -> __box<_CvrefSender, _Env, true>;

template <class _CvrefSender, class _Env>
__box(__ensure_started::__ensure_started_t,
      __shared_state<_CvrefSender, _Env> *) -> __box<_CvrefSender, _Env, false>;

template <class _Tag> struct __shared_impl : __sexpr_defaults {
  static constexpr auto get_state =
      []<class _CvrefSender, class _Receiver>(
          _CvrefSender &&__sndr,
          _Receiver &) noexcept -> __local_state<_CvrefSender, _Receiver> {
    static_assert(sender_expr_for<_CvrefSender, _Tag>);
    return __local_state<_CvrefSender, _Receiver>{
        static_cast<_CvrefSender &&>(__sndr)};
  };

  static constexpr auto get_completion_signatures =
      []<class _Self>(const _Self &, auto &&...) noexcept
      -> __completions<_Tag, typename __data_of<_Self>::__sh_state_t> {
    static_assert(sender_expr_for<_Self, _Tag>);
    return {};
  };

  static constexpr auto start = []<class _Sender, class _Receiver>(
                                    __local_state<_Sender, _Receiver> &__self,
                                    _Receiver &__rcvr) noexcept -> void {
    const auto __stok = stdexec::get_stop_token(stdexec::get_env(__rcvr));
    __self.__on_stop_.emplace(__stok, __self);

    if (!__stok.stop_requested()) {
      __self.__sh_state_->__try_start();
      if (__self.__sh_state_->__try_add_waiter(&__self, __stok)) {

        return;
      }
    }

    __self.__on_stop_.reset();
    std::exchange(__self.__sh_state_, nullptr)->__detach();
    stdexec::set_stopped(static_cast<_Receiver &&>(__rcvr));
  };
};
} // namespace stdexec::__shared
# 27 "./../stdexec/include/stdexec/__detail/__ensure_started.hpp" 2

namespace stdexec {

namespace __ensure_started {
using namespace __shared;

struct __ensure_started_t {};

struct ensure_started_t {
  template <sender _Sender, class _Env = env<>>
    requires sender_in<_Sender, _Env> && __decay_copyable<env_of_t<_Sender>>
  [[nodiscard]]
  auto operator()(_Sender &&__sndr,
                  _Env &&__env = {}) const -> __well_formed_sender auto {
    if constexpr (sender_expr_for<_Sender, __ensure_started_t>) {
      return static_cast<_Sender &&>(__sndr);
    } else {
      auto __early_domain = __get_early_domain(__sndr);
      auto __domain = __get_late_domain(__sndr, __env, __early_domain);
      return stdexec::transform_sender(
          __domain,
          __make_sexpr<ensure_started_t>(static_cast<_Env &&>(__env),
                                         static_cast<_Sender &&>(__sndr)));
    }
  }

  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline

      auto
      operator()() const noexcept -> __binder_back<ensure_started_t> {
    return {{}, {}, {}};
  }

  template <class _CvrefSender, class _Env>
  using __receiver_t =
      __t<__meval<__receiver, __cvref_id<_CvrefSender>, __id<_Env>>>;

  template <class _Sender> static auto transform_sender(_Sender &&__sndr) {
    using _Receiver =
        __receiver_t<__child_of<_Sender>, __decay_t<__data_of<_Sender>>>;
    static_assert(sender_to<__child_of<_Sender>, _Receiver>);

    return __sexpr_apply(static_cast<_Sender &&>(__sndr),
                         [&]<class _Env, class _Child>(__ignore, _Env &&__env,
                                                       _Child &&__child) {
                           auto *__sh_state = new __shared_state{
                               static_cast<_Child &&>(__child),
                               static_cast<_Env &&>(__env)};

                           __sh_state->__try_start();

                           return __make_sexpr<__ensure_started_t>(
                               __box{__ensure_started_t(), __sh_state});
                         });
  }
};
} // namespace __ensure_started

using __ensure_started::ensure_started_t;
inline constexpr ensure_started_t ensure_started{};

template <>
struct __sexpr_impl<__ensure_started::__ensure_started_t>
    : __shared::__shared_impl<__ensure_started::__ensure_started_t> {};

template <> struct __sexpr_impl<ensure_started_t> : __sexpr_defaults {
  static constexpr auto get_completion_signatures =
      []<class _Sender>(_Sender &&) noexcept
      -> __completion_signatures_of_t<
          transform_sender_result_t<default_domain, _Sender, env<>>> {};
};
} // namespace stdexec
# 31 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__execute.hpp" 1
# 24 "./../stdexec/include/stdexec/__detail/__execute.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__start_detached.hpp" 1
# 27 "./../stdexec/include/stdexec/__detail/__start_detached.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__submit.hpp" 1
# 20 "./../stdexec/include/stdexec/__detail/__submit.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__manual_lifetime.hpp" 1
# 24 "./../stdexec/include/stdexec/__detail/__manual_lifetime.hpp"
namespace stdexec {

template <class _Ty> class __manual_lifetime {
public:
  constexpr __manual_lifetime() noexcept = default;

  constexpr ~__manual_lifetime() = default;

  __manual_lifetime(const __manual_lifetime &) = delete;
  auto operator=(const __manual_lifetime &) -> __manual_lifetime & = delete;

  __manual_lifetime(__manual_lifetime &&) = delete;
  auto operator=(__manual_lifetime &&) -> __manual_lifetime & = delete;

  template <class... _Args>
  auto __construct(_Args &&...__args) noexcept(
      stdexec::__nothrow_constructible_from<_Ty, _Args...>) -> _Ty & {

    return *std::launder(::new (static_cast<void *>(__buffer_))
                             _Ty{static_cast<_Args &&>(__args)...});
  }

  template <class _Func, class... _Args>
  auto __construct_from(_Func &&func, _Args &&...__args) -> _Ty & {

    return *std::launder(::new (static_cast<void *>(__buffer_)) _Ty{
        (static_cast<_Func &&>(func))(static_cast<_Args &&>(__args)...)});
  }

  void __destroy() noexcept { std::destroy_at(&__get()); }

  auto __get() & noexcept -> _Ty & {
    return *reinterpret_cast<_Ty *>(__buffer_);
  }

  auto __get() && noexcept -> _Ty && {
    return static_cast<_Ty &&>(*reinterpret_cast<_Ty *>(__buffer_));
  }

  auto __get() const & noexcept -> const _Ty & {
    return *reinterpret_cast<const _Ty *>(__buffer_);
  }

  auto __get() const && noexcept -> const _Ty && = delete;

private:
  alignas(_Ty) unsigned char __buffer_[sizeof(_Ty)]{};
};
} // namespace stdexec
# 21 "./../stdexec/include/stdexec/__detail/__submit.hpp" 2

namespace stdexec {
namespace __submit {
template <class _Sender, class _Receiver>
concept __has_memfn =
    requires(_Sender && (*__sndr)(), _Receiver && (*__rcvr)()) {
      __sndr().submit(__rcvr());
    };

template <class _Sender, class _Receiver>
concept __has_static_memfn =
    requires(_Sender && (*__sndr)(), _Receiver && (*__rcvr)()) {
      __decay_t<_Sender>::submit(__sndr(), __rcvr());
    };

struct __submit_t {
  struct __void {};

  template <class _Sender, class _Receiver, class _Default = __void>
    requires sender_to<_Sender, _Receiver> &&
             __submit::__has_memfn<_Sender, _Receiver>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Sender &&__sndr, _Receiver __rcvr,
             [[maybe_unused]] _Default __def = {}) const
      noexcept(noexcept(static_cast<_Sender &&>(__sndr).submit(
          static_cast<_Receiver &&>(__rcvr)))) {
    using __result_t = decltype(static_cast<_Sender &&>(__sndr).submit(
        static_cast<_Receiver &&>(__rcvr)));
    if constexpr (__same_as<__result_t, void> && !__same_as<_Default, __void>) {
      static_cast<_Sender &&>(__sndr).submit(static_cast<_Receiver &&>(__rcvr));
      return __def;
    } else {
      return static_cast<_Sender &&>(__sndr).submit(
          static_cast<_Receiver &&>(__rcvr));
    }
  }

  template <class _Sender, class _Receiver, class _Default = __void>
    requires sender_to<_Sender, _Receiver> &&
             __submit::__has_static_memfn<_Sender, _Receiver>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Sender &&__sndr, _Receiver __rcvr,
             [[maybe_unused]] _Default __def = {}) const
      noexcept(noexcept(__sndr.submit(static_cast<_Sender &&>(__sndr),
                                      static_cast<_Receiver &&>(__rcvr)))) {
    using __result_t = decltype(__sndr.submit(
        static_cast<_Sender &&>(__sndr), static_cast<_Receiver &&>(__rcvr)));
    if constexpr (__same_as<__result_t, void> && !__same_as<_Default, __void>) {
      __sndr.submit(static_cast<_Sender &&>(__sndr),
                    static_cast<_Receiver &&>(__rcvr));
      return __def;
    } else {
      return __sndr.submit(static_cast<_Sender &&>(__sndr),
                           static_cast<_Receiver &&>(__rcvr));
    }
  }
};

inline constexpr __submit_t __submit{};
} // namespace __submit

template <class _Sender, class _Receiver,
          class _Default = __submit::__submit_t::__void>
using __submit_result_t =
    __call_result_t<__submit::__submit_t, _Sender, _Receiver, _Default>;

template <class _Sender, class _Receiver>
concept __submittable = requires(_Sender &&__sndr, _Receiver &&__rcvr) {
  __submit::__submit(static_cast<_Sender &&>(__sndr),
                     static_cast<_Receiver &&>(__rcvr));
};

template <class _Sender, class _Receiver>
concept __nothrow_submittable =
    __submittable<_Sender, _Receiver> &&
    requires(_Sender &&__sndr, _Receiver &&__rcvr) {
      {
        __submit::__submit(static_cast<_Sender &&>(__sndr),
                           static_cast<_Receiver &&>(__rcvr))
      } noexcept;
    };

enum class __submit_result_kind {
  __connect,
  __submit,
  __submit_void,
  __submit_nothrow,
};

template <class _Sender, class _Receiver>
constexpr auto __get_submit_result_kind() noexcept -> __submit_result_kind {
  if constexpr (__submittable<_Sender, _Receiver>) {
    using __result_t = __submit_result_t<_Sender, _Receiver>;
    constexpr std::size_t __opstate_size =
        sizeof(connect_result_t<_Sender, _Receiver>);

    if constexpr (std::is_void_v<__result_t>) {
      return __submit_result_kind::__submit_void;
    } else if constexpr (__nothrow_submittable<_Sender, _Receiver>) {
      return __opstate_size > sizeof(__result_t)
                 ? __submit_result_kind::__submit_nothrow
                 : __submit_result_kind::__connect;
    } else {
      return __opstate_size > sizeof(__optional<__result_t>)
                 ? __submit_result_kind::__submit
                 : __submit_result_kind::__connect;
    }
  }
  return __submit_result_kind::__connect;
}

template <class _Sender, class _Receiver,
          __submit_result_kind _Kind =
              __get_submit_result_kind<_Sender, _Receiver>()>
struct submit_result {
  using __result_t = connect_result_t<_Sender, _Receiver>;

  explicit submit_result(_Sender &&__sndr, _Receiver &&__rcvr) noexcept(
      __nothrow_connectable<_Sender, _Receiver>)
      : __result_(connect(static_cast<_Sender &&>(__sndr),
                          static_cast<_Receiver &&>(__rcvr))) {}

  void submit(_Sender &&__sndr, _Receiver &&) noexcept {
    stdexec::start(__result_);
  }

  __result_t __result_;
};

template <class _Sender, class _Receiver>
struct submit_result<_Sender, _Receiver, __submit_result_kind::__submit> {
  using __result_t = __submit_result_t<_Sender, _Receiver>;

  submit_result(_Sender &&, _Receiver &&) noexcept {}

  void submit(_Sender &&__sndr, _Receiver &&__rcvr) {
    __result_.__emplace_from(__submit::__submit,
                             static_cast<_Sender &&>(__sndr),
                             static_cast<_Receiver &&>(__rcvr));
  }

  __optional<__result_t> __result_;
};

template <class _Sender, class _Receiver>
struct submit_result<_Sender, _Receiver, __submit_result_kind::__submit_void> {
  using __result_t = __submit_result_t<_Sender, _Receiver>;

  explicit submit_result(_Sender &&, _Receiver &&) noexcept {}

  void submit(_Sender &&__sndr, _Receiver &&__rcvr) noexcept(
      __nothrow_submittable<_Sender, _Receiver>) {
    __submit::__submit(static_cast<_Sender &&>(__sndr),
                       static_cast<_Receiver &&>(__rcvr));
  }
};

template <class _Sender, class _Receiver>
struct submit_result<_Sender, _Receiver,
                     __submit_result_kind::__submit_nothrow> {
  using __result_t = __submit_result_t<_Sender, _Receiver>;

  submit_result(_Sender &&, _Receiver &&) noexcept {}

  void submit(_Sender &&__sndr, _Receiver &&__rcvr) noexcept {
    __result_.__construct_from(__submit::__submit,
                               static_cast<_Sender &&>(__sndr),
                               static_cast<_Receiver &&>(__rcvr));
  }

  ~submit_result() { __result_.__destroy(); }

  __manual_lifetime<__result_t> __result_;
};

template <class _Sender, class _Receiver>
submit_result(_Sender &&, _Receiver) -> submit_result<_Sender, _Receiver>;

} // namespace stdexec
# 28 "./../stdexec/include/stdexec/__detail/__start_detached.hpp" 2

namespace stdexec {

namespace __start_detached {
struct __submit_receiver {
  using receiver_concept = receiver_t;
  using __t = __submit_receiver;
  using __id = __submit_receiver;

  template <class... _As> void set_value(_As &&...) noexcept {}

  template <class _Error>
  [[noreturn]]
  void set_error(_Error &&) noexcept {

    std::terminate();
  }

  void set_stopped() noexcept {}

  [[nodiscard]]
  auto get_env() const noexcept -> __root_env {
    return {};
  }
};

template <class _SenderId, class _EnvId> struct __operation : __immovable {
  using _Sender = __cvref_t<_SenderId>;
  using _Env = __t<_EnvId>;

  explicit __operation(connect_t, _Sender &&__sndr, _Env __env)
      : __env_(static_cast<_Env &&>(__env)),
        __op_data_(static_cast<_Sender &&>(__sndr), __receiver{this}) {}

  explicit __operation(_Sender &&__sndr, _Env __env)
      : __operation(connect, static_cast<_Sender &&>(__sndr),
                    static_cast<_Env &&>(__env)) {

    __op_data_.submit(static_cast<_Sender &&>(__sndr), __receiver{this});
  }

  static void __destroy_delete(__operation *__self) noexcept {
    if constexpr (__callable<get_allocator_t, _Env>) {
      auto __alloc = stdexec::get_allocator(__self->__env_);
      using _Alloc = decltype(__alloc);
      using _OpAlloc = typename std::allocator_traits<
          _Alloc>::template rebind_alloc<__operation>;
      _OpAlloc __op_alloc{__alloc};
      std::allocator_traits<_OpAlloc>::destroy(__op_alloc, __self);
      std::allocator_traits<_OpAlloc>::deallocate(__op_alloc, __self, 1);
    } else {
      delete __self;
    }
  }

  struct __receiver {
    using receiver_concept = receiver_t;
    using __t = __receiver;
    using __id = __receiver;

    template <class... _As> void set_value(_As &&...) noexcept {
      __operation::__destroy_delete(__op_);
    }

    template <class _Error>
    [[noreturn]]
    void set_error(_Error &&) noexcept {

      std::terminate();
    }

    void set_stopped() noexcept { __operation::__destroy_delete(__op_); }

    auto get_env() const noexcept -> const _Env & { return __op_->__env_; }

    __operation *__op_;
  };

  [[no_unique_address]] _Env __env_;
  [[no_unique_address]] submit_result<_Sender, __receiver> __op_data_;
};

template <class _Sender, class _Env>
concept __use_submit =
    __submittable<_Sender, __submit_receiver> && __same_as<_Env, __root_env> &&
    __same_as<void, __submit_result_t<_Sender, __submit_receiver>>;

struct start_detached_t {
  template <sender_in<__root_env> _Sender>
    requires __callable<
        apply_sender_t,
        __late_domain_of_t<_Sender, __root_env, __early_domain_of_t<_Sender>>,
        start_detached_t, _Sender>
  void operator()(_Sender &&__sndr) const {
    auto __domain =
        __get_late_domain(__sndr, __root_env{}, __get_early_domain(__sndr));
    stdexec::apply_sender(__domain, *this, static_cast<_Sender &&>(__sndr));
  }

  template <class _Env, sender_in<__as_root_env_t<_Env>> _Sender>
    requires __callable<apply_sender_t,
                        __late_domain_of_t<_Sender, __as_root_env_t<_Env>,
                                           __early_domain_of_t<_Sender>>,
                        start_detached_t, _Sender, __as_root_env_t<_Env>>
  void operator()(_Sender &&__sndr, _Env &&__env) const {
    auto __env2 = __as_root_env(static_cast<_Env &&>(__env));
    auto __domain =
        __get_late_domain(__sndr, __env2, __get_early_domain(__sndr));
    stdexec::apply_sender(__domain, *this, static_cast<_Sender &&>(__sndr),
                          __env2);
  }

  template <class _Sender, class _Env = __root_env>
    requires sender_in<_Sender, __as_root_env_t<_Env>>
  void apply_sender(_Sender &&__sndr, _Env &&__env = {}) const noexcept(false) {
    using _Op = __operation<__cvref_id<_Sender>, __id<__decay_t<_Env>>>;

    if constexpr (__use_submit<_Sender, _Env>) {

      stdexec::__submit::__submit(static_cast<_Sender &&>(__sndr),
                                  __submit_receiver{});
    } else

        if constexpr (__callable<get_allocator_t, _Env>) {

      auto __alloc = get_allocator(__env);
      using _Alloc = decltype(__alloc);
      using _OpAlloc =
          typename std::allocator_traits<_Alloc>::template rebind_alloc<_Op>;

      _OpAlloc __op_alloc{__alloc};
      _Op *__op = std::allocator_traits<_OpAlloc>::allocate(__op_alloc, 1);
      __scope_guard __g{[__op, &__op_alloc]() noexcept {
        std::allocator_traits<_OpAlloc>::deallocate(__op_alloc, __op, 1);
      }};

      std::allocator_traits<_OpAlloc>::construct(
          __op_alloc, __op, static_cast<_Sender &&>(__sndr),
          static_cast<_Env &&>(__env));

      __g.__dismiss();
    } else {

      [[maybe_unused]]
      _Op *__op =
          new _Op(static_cast<_Sender &&>(__sndr), static_cast<_Env &&>(__env));
    }
  }
};
} // namespace __start_detached

using __start_detached::start_detached_t;
inline constexpr start_detached_t start_detached{};
} // namespace stdexec
# 25 "./../stdexec/include/stdexec/__detail/__execute.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__then.hpp" 1
# 31 "./../stdexec/include/stdexec/__detail/__then.hpp"
namespace stdexec {

namespace __then {
inline constexpr __mstring __then_context =
    "In stdexec::then(Sender, Function)..."_mstr;
using __on_not_callable = __callable_error<__then_context>;

template <class _Fun, class _CvrefSender, class... _Env>
using __completions_t = transform_completion_signatures<
    __completion_signatures_of_t<_CvrefSender, _Env...>,
    __with_error_invoke_t<__on_not_callable, set_value_t, _Fun, _CvrefSender,
                          _Env...>,
    __mbind_front<__mtry_catch_q<__set_value_invoke_t, __on_not_callable>,
                  _Fun>::template __f>;

struct then_t {
  template <sender _Sender, __movable_value _Fun>
  auto operator()(_Sender &&__sndr, _Fun __fun) const -> __well_formed_sender
      auto {
    auto __domain = __get_early_domain(__sndr);
    return stdexec::transform_sender(
        __domain, __make_sexpr<then_t>(static_cast<_Fun &&>(__fun),
                                       static_cast<_Sender &&>(__sndr)));
  }

  template <__movable_value _Fun>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Fun __fun) const -> __binder_back<then_t, _Fun> {
    return {{static_cast<_Fun &&>(__fun)}, {}, {}};
  }
};

struct __then_impl : __sexpr_defaults {
  static constexpr auto get_attrs =
      []<class _Child>(__ignore, const _Child &__child) noexcept {
        return __env::__join(prop{__is_scheduler_affine_t{},
                                  __mbool<__is_scheduler_affine<_Child>>{}},
                             stdexec::get_env(__child));
      };

  static constexpr auto get_completion_signatures =
      []<class _Sender, class... _Env>(_Sender &&, _Env &&...) noexcept
      -> __completions_t<__decay_t<__data_of<_Sender>>, __child_of<_Sender>,
                         _Env...> {
    static_assert(sender_expr_for<_Sender, then_t>);
    return {};
  };

  struct __complete_fn {
    template <class _Tag, class _State, class _Receiver, class... _Args>

    void operator()(__ignore, _State &__state, _Receiver &__rcvr, _Tag,
                    _Args &&...__args) const noexcept {
      if constexpr (__same_as<_Tag, set_value_t>) {
        stdexec::__set_value_invoke(static_cast<_Receiver &&>(__rcvr),
                                    static_cast<_State &&>(__state),
                                    static_cast<_Args &&>(__args)...);
      } else {
        _Tag()(static_cast<_Receiver &&>(__rcvr),
               static_cast<_Args &&>(__args)...);
      }
    }
  };

  static constexpr auto complete = __complete_fn{};
};
} // namespace __then

using __then::then_t;

inline constexpr then_t then{};

template <> struct __sexpr_impl<then_t> : __then::__then_impl {};
} // namespace stdexec
# 26 "./../stdexec/include/stdexec/__detail/__execute.hpp" 2

namespace stdexec {

namespace __execute_ {
struct execute_t {
  template <scheduler _Scheduler, class _Fun>
    requires __callable<_Fun &> && move_constructible<_Fun>
  void operator()(_Scheduler &&__sched, _Fun __fun) const noexcept(false) {
    auto __domain = query_or(get_domain, __sched, default_domain());
    stdexec::apply_sender(__domain, *this,
                          schedule(static_cast<_Scheduler &&>(__sched)),
                          static_cast<_Fun &&>(__fun));
  }

  template <sender_of<set_value_t()> _Sender, class _Fun>
    requires __callable<_Fun &> && move_constructible<_Fun>
  void apply_sender(_Sender &&__sndr, _Fun __fun) const noexcept(false) {
    start_detached(
        then(static_cast<_Sender &&>(__sndr), static_cast<_Fun &&>(__fun)));
  }
};
} // namespace __execute_

using __execute_::execute_t;
inline constexpr execute_t execute{};
} // namespace stdexec
# 33 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__inline_scheduler.hpp" 1
# 27 "./../stdexec/include/stdexec/__detail/__inline_scheduler.hpp"
namespace stdexec {
namespace __inln {
struct __schedule_t {};

struct __scheduler {
  using __t = __scheduler;
  using __id = __scheduler;

  template <class _Tag = __schedule_t>

  friend auto tag_invoke(const schedule_t &, __scheduler) {
    return __make_sexpr<_Tag>();
  }

  [[nodiscard]]
  auto query(get_forward_progress_guarantee_t) const noexcept
      -> forward_progress_guarantee {
    return forward_progress_guarantee::weakly_parallel;
  }

  auto operator==(const __scheduler &) const noexcept -> bool = default;
};

struct __env {
  static constexpr auto query(__is_scheduler_affine_t) noexcept -> bool {
    return true;
  }

  [[nodiscard]]
  constexpr auto
  query(get_completion_scheduler_t<set_value_t>) const noexcept -> __scheduler {
    return {};
  }
};
} // namespace __inln

template <> struct __sexpr_impl<__inln::__schedule_t> : __sexpr_defaults {
  static constexpr auto get_attrs = [](__ignore) noexcept {
    return __inln::__env();
  };

  static constexpr auto get_completion_signatures =
      [](__ignore,
         __ignore = {}) noexcept -> completion_signatures<set_value_t()> {
    return {};
  };

  static constexpr auto start =
      []<class _Receiver>(__ignore, _Receiver &__rcvr) noexcept -> void {
    stdexec::set_value(static_cast<_Receiver &&>(__rcvr));
  };
};

static_assert(__is_scheduler_affine<schedule_result_t<__inln::__scheduler>>);
} // namespace stdexec
# 35 "./../stdexec/include/stdexec/execution.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__into_variant.hpp" 1
# 35 "./../stdexec/include/stdexec/__detail/__into_variant.hpp"
namespace stdexec {

namespace __into_variant {
template <class _Sender, class _Env>
  requires sender_in<_Sender, _Env>
using __into_variant_result_t = value_types_of_t<_Sender, _Env>;

template <class _Sender, class... _Env>
using __variant_t =
    __value_types_t<__completion_signatures_of_t<_Sender, _Env...>>;

template <class _Variant>
using __variant_completions =
    completion_signatures<set_value_t(_Variant),
                          set_error_t(std::exception_ptr)>;

template <class _Sender, class... _Env>
using __completions = transform_completion_signatures<
    __completion_signatures_of_t<_Sender, _Env...>,
    __meval<__variant_completions, __variant_t<_Sender, _Env...>>,
    __mconst<completion_signatures<>>::__f>;

struct into_variant_t {
  template <sender _Sender>
  auto operator()(_Sender &&__sndr) const -> __well_formed_sender auto {
    auto __domain = __get_early_domain(__sndr);
    return stdexec::transform_sender(
        __domain,
        __make_sexpr<into_variant_t>(__(), static_cast<_Sender &&>(__sndr)));
  }

  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline

      auto
      operator()() const noexcept -> __binder_back<into_variant_t> {
    return {{}, {}, {}};
  }
};

struct __into_variant_impl : __sexpr_defaults {
  static constexpr auto get_state =
      []<class _Self, class _Receiver>(_Self &&, _Receiver &) noexcept {
        using __variant_t =
            value_types_of_t<__child_of<_Self>, env_of_t<_Receiver>>;
        return __mtype<__variant_t>();
      };

  static constexpr auto complete =
      []<class _State, class _Receiver, class _Tag, class... _Args>(
          __ignore, _State, _Receiver &__rcvr, _Tag,
          _Args &&...__args) noexcept -> void {
    if constexpr (__same_as<_Tag, set_value_t>) {
      using __variant_t = __t<_State>;
      try {
        set_value(static_cast<_Receiver &&>(__rcvr),
                  __variant_t{std::tuple<_Args &&...>{
                      static_cast<_Args &&>(__args)...}});
      } catch (...) {
        stdexec::set_error(static_cast<_Receiver &&>(__rcvr),
                           std::current_exception());
      }
    } else {
      _Tag()(static_cast<_Receiver &&>(__rcvr),
             static_cast<_Args &&>(__args)...);
    }
  };

  static constexpr auto get_completion_signatures =
      []<class _Self, class... _Env>(
          _Self &&,
          _Env &&...) noexcept -> __completions<__child_of<_Self>, _Env...> {
    static_assert(sender_expr_for<_Self, into_variant_t>);
    return {};
  };
};
} // namespace __into_variant

using __into_variant::into_variant_t;
inline constexpr into_variant_t into_variant{};

template <>
struct __sexpr_impl<into_variant_t> : __into_variant::__into_variant_impl {};
} // namespace stdexec
# 36 "./../stdexec/include/stdexec/execution.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__intrusive_ptr.hpp" 1
# 30 "./../stdexec/include/stdexec/__detail/__intrusive_ptr.hpp"
namespace stdexec {
namespace __ptr {
template <std::size_t _ReservedBits> struct __count_and_bits {
  static constexpr std::size_t __ref_count_increment = 1ul << _ReservedBits;

  enum struct __bits : std::size_t {};

  friend constexpr auto __count(__bits __b) noexcept -> std::size_t {
    return static_cast<std::size_t>(__b) / __ref_count_increment;
  }

  template <std::size_t _Bit>
  friend constexpr auto __bit(__bits __b) noexcept -> bool {
    static_assert(_Bit < _ReservedBits, "Bit index out of range");
    return (static_cast<std::size_t>(__b) & (1ul << _Bit)) != 0;
  }
};

template <std::size_t _ReservedBits>
using __bits_t = typename __count_and_bits<_ReservedBits>::__bits;

template <class _Ty, std::size_t _ReservedBits> struct __make_intrusive_t;

template <class _Ty, std::size_t _ReservedBits = 0ul> class __intrusive_ptr;

template <class _Ty, std::size_t _ReservedBits = 0ul>
struct __enable_intrusive_from_this {
  auto __intrusive_from_this() noexcept -> __intrusive_ptr<_Ty, _ReservedBits>;
  auto __intrusive_from_this() const noexcept
      -> __intrusive_ptr<const _Ty, _ReservedBits>;

private:
  using __bits_t = typename __count_and_bits<_ReservedBits>::__bits;
  friend _Ty;
  auto __inc_ref() noexcept -> __bits_t;
  auto __dec_ref() noexcept -> __bits_t;

  template <std::size_t _Bit>
  [[nodiscard]]
  auto __is_set() const noexcept -> bool;
  template <std::size_t _Bit> auto __set_bit() noexcept -> __bits_t;
  template <std::size_t _Bit> auto __clear_bit() noexcept -> __bits_t;
};

#pragma GCC diagnostic push
# 78 "./../stdexec/include/stdexec/__detail/__intrusive_ptr.hpp"
#pragma GCC diagnostic ignored "-Wpragmas"
# 78 "./../stdexec/include/stdexec/__detail/__intrusive_ptr.hpp"
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
# 78 "./../stdexec/include/stdexec/__detail/__intrusive_ptr.hpp"
#pragma GCC diagnostic ignored "-Wunknown-warning-option"
# 78 "./../stdexec/include/stdexec/__detail/__intrusive_ptr.hpp"
#pragma GCC diagnostic ignored "-Wunknown-attributes"
# 78 "./../stdexec/include/stdexec/__detail/__intrusive_ptr.hpp"
#pragma GCC diagnostic ignored "-Wattributes"

template <class _Ty, std::size_t _ReservedBits> struct __control_block {
  using __bits_t = typename __count_and_bits<_ReservedBits>::__bits;
  static constexpr std::size_t __ref_count_increment = 1ul << _ReservedBits;

  alignas(_Ty) unsigned char __value_[sizeof(_Ty)];
  std::atomic<std::size_t> __ref_count_;

  template <class... _Us>
  explicit __control_block(_Us &&...__us) noexcept(noexcept(_Ty{
      __declval<_Us>()...}))
      : __ref_count_(__ref_count_increment) {

    ::new (static_cast<void *>(__value_)) _Ty{static_cast<_Us &&>(__us)...};
  }

  ~__control_block() { __value().~_Ty(); }

  auto __value() noexcept -> _Ty & {
    return *reinterpret_cast<_Ty *>(__value_);
  }

  auto __inc_ref_() noexcept -> __bits_t {
    auto __old = __ref_count_.fetch_add(__ref_count_increment,
                                        std::memory_order_relaxed);
    return static_cast<__bits_t>(__old);
  }

  auto __dec_ref_() noexcept -> __bits_t {
    auto __old = __ref_count_.fetch_sub(__ref_count_increment,
                                        std::memory_order_acq_rel);
    if (__count(static_cast<__bits_t>(__old)) == 1) {
      delete this;
    }
    return static_cast<__bits_t>(__old);
  }

  template <std::size_t _Bit>
  [[nodiscard]]
  auto __is_set_() const noexcept -> bool {
    auto __old = __ref_count_.load(std::memory_order_relaxed);
    return __bit<_Bit>(static_cast<__bits_t>(__old));
  }

  template <std::size_t _Bit> auto __set_bit_() noexcept -> __bits_t {
    static_assert(_Bit < _ReservedBits, "Bit index out of range");
    constexpr std::size_t __mask = 1ul << _Bit;
    auto __old = __ref_count_.fetch_or(__mask, std::memory_order_acq_rel);
    return static_cast<__bits_t>(__old);
  }

  template <std::size_t _Bit> auto __clear_bit_() noexcept -> __bits_t {
    static_assert(_Bit < _ReservedBits, "Bit index out of range");
    constexpr std::size_t __mask = 1ul << _Bit;
    auto __old = __ref_count_.fetch_and(~__mask, std::memory_order_acq_rel);
    return static_cast<__bits_t>(__old);
  }
};

#pragma GCC diagnostic pop

template <class _Ty, std::size_t _ReservedBits> class __intrusive_ptr {
  using _UncvTy = std::remove_cv_t<_Ty>;
  using __enable_intrusive_t =
      __enable_intrusive_from_this<_UncvTy, _ReservedBits>;
  friend _Ty;
  friend struct __make_intrusive_t<_Ty, _ReservedBits>;
  friend struct __enable_intrusive_from_this<_UncvTy, _ReservedBits>;

  __control_block<_UncvTy, _ReservedBits> *__data_{nullptr};

  explicit __intrusive_ptr(
      __control_block<_UncvTy, _ReservedBits> *__data) noexcept
      : __data_(__data) {}

  void __inc_ref_() noexcept {
    if (__data_) {
      __data_->__inc_ref_();
    }
  }

  void __dec_ref_() noexcept {
    if (__data_) {
      __data_->__dec_ref_();
    }
  }

  [[nodiscard]]
  auto __release_() noexcept -> __enable_intrusive_t * {
    auto *__data = std::exchange(__data_, nullptr);
    return __data ? &__c_upcast<__enable_intrusive_t>(__data->__value())
                  : nullptr;
  }

public:
  using element_type = _Ty;

  __intrusive_ptr() = default;

  __intrusive_ptr(__intrusive_ptr &&__that) noexcept
      : __data_(std::exchange(__that.__data_, nullptr)) {}

  __intrusive_ptr(const __intrusive_ptr &__that) noexcept
      : __data_(__that.__data_) {
    __inc_ref_();
  }

  __intrusive_ptr(
      __enable_intrusive_from_this<_Ty, _ReservedBits> *__that) noexcept
      : __intrusive_ptr(__that ? __that->__intrusive_from_this()
                               : __intrusive_ptr()) {}

  auto operator=(__intrusive_ptr &&__that) noexcept -> __intrusive_ptr & {
    [[maybe_unused]]
    __intrusive_ptr __old{
        std::exchange(__data_, std::exchange(__that.__data_, nullptr))};
    return *this;
  }

  auto operator=(const __intrusive_ptr &__that) noexcept -> __intrusive_ptr & {
    return operator=(__intrusive_ptr(__that));
  }

  auto
  operator=(__enable_intrusive_from_this<_Ty, _ReservedBits> *__that) noexcept
      -> __intrusive_ptr & {
    return operator=(__that ? __that->__intrusive_from_this()
                            : __intrusive_ptr());
  }

  ~__intrusive_ptr() { __dec_ref_(); }

  void reset() noexcept { operator=({}); }

  void swap(__intrusive_ptr &__that) noexcept {
    std::swap(__data_, __that.__data_);
  }

  auto get() const noexcept -> _Ty * { return &__data_->__value(); }

  auto operator->() const noexcept -> _Ty * { return &__data_->__value(); }

  auto operator*() const noexcept -> _Ty & { return __data_->__value(); }

  explicit operator bool() const noexcept { return __data_ != nullptr; }

  auto operator!() const noexcept -> bool { return __data_ == nullptr; }

  auto operator==(const __intrusive_ptr &) const -> bool = default;

  auto operator==(std::nullptr_t) const noexcept -> bool {
    return __data_ == nullptr;
  }
};

template <class _Ty, std::size_t _ReservedBits>
auto __enable_intrusive_from_this<
    _Ty, _ReservedBits>::__intrusive_from_this() noexcept
    -> __intrusive_ptr<_Ty, _ReservedBits> {
  auto *__data = reinterpret_cast<__control_block<_Ty, _ReservedBits> *>(
      &__c_downcast<_Ty>(*this));
  __data->__inc_ref_();
  return __intrusive_ptr<_Ty, _ReservedBits>{__data};
}

template <class _Ty, std::size_t _ReservedBits>
auto __enable_intrusive_from_this<_Ty, _ReservedBits>::__intrusive_from_this()
    const noexcept -> __intrusive_ptr<const _Ty, _ReservedBits> {
  auto *__data = reinterpret_cast<__control_block<_Ty, _ReservedBits> *>(
      &__c_downcast<_Ty>(*this));
  __data->__inc_ref_();
  return __intrusive_ptr<const _Ty, _ReservedBits>{__data};
}

template <class _Ty, std::size_t _ReservedBits>
auto __enable_intrusive_from_this<_Ty, _ReservedBits>::__inc_ref() noexcept
    -> __ptr::__bits_t<_ReservedBits> {
  auto *__data = reinterpret_cast<__control_block<_Ty, _ReservedBits> *>(
      &__c_downcast<_Ty>(*this));
  return __data->__inc_ref_();
}

template <class _Ty, std::size_t _ReservedBits>
auto __enable_intrusive_from_this<_Ty, _ReservedBits>::__dec_ref() noexcept
    -> __ptr::__bits_t<_ReservedBits> {

  auto *__data = reinterpret_cast<__control_block<_Ty, _ReservedBits> *>(
      &__c_downcast<_Ty>(*this));
  return __data->__dec_ref_();
}

template <class _Ty, std::size_t _ReservedBits>
template <std::size_t _Bit>
auto __enable_intrusive_from_this<_Ty, _ReservedBits>::__is_set() const noexcept
    -> bool {
  auto *__data = reinterpret_cast<const __control_block<_Ty, _ReservedBits> *>(
      &__c_downcast<_Ty>(*this));
  return __data->template __is_set_<_Bit>();
}

template <class _Ty, std::size_t _ReservedBits>
template <std::size_t _Bit>
auto __enable_intrusive_from_this<_Ty, _ReservedBits>::__set_bit() noexcept
    -> __ptr::__bits_t<_ReservedBits> {
  auto *__data = reinterpret_cast<__control_block<_Ty, _ReservedBits> *>(
      &__c_downcast<_Ty>(*this));
  return __data->template __set_bit_<_Bit>();
}

template <class _Ty, std::size_t _ReservedBits>
template <std::size_t _Bit>
auto __enable_intrusive_from_this<_Ty, _ReservedBits>::__clear_bit() noexcept
    -> __ptr::__bits_t<_ReservedBits> {
  auto *__data = reinterpret_cast<__control_block<_Ty, _ReservedBits> *>(
      &__c_downcast<_Ty>(*this));
  return __data->template __clear_bit_<_Bit>();
}

template <class _Ty, std::size_t _ReservedBits> struct __make_intrusive_t {
  template <class... _Us>
    requires constructible_from<_Ty, _Us...>
  auto operator()(_Us &&...__us) const -> __intrusive_ptr<_Ty, _ReservedBits> {
    using _UncvTy = std::remove_cv_t<_Ty>;
    return __intrusive_ptr<_Ty, _ReservedBits>{
        ::new __control_block<_UncvTy, _ReservedBits>{
            static_cast<_Us &&>(__us)...}};
  }
};
} // namespace __ptr

using __ptr::__enable_intrusive_from_this;
using __ptr::__intrusive_ptr;
template <class _Ty, std::size_t _ReservedBits = 0ul>
inline constexpr __ptr::__make_intrusive_t<_Ty, _ReservedBits>
    __make_intrusive{};

} // namespace stdexec
# 37 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__just.hpp" 1
# 26 "./../stdexec/include/stdexec/__detail/__just.hpp"
#pragma GCC diagnostic push
# 26 "./../stdexec/include/stdexec/__detail/__just.hpp"
#pragma GCC diagnostic ignored "-Wpragmas"
# 26 "./../stdexec/include/stdexec/__detail/__just.hpp"
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
# 26 "./../stdexec/include/stdexec/__detail/__just.hpp"
#pragma GCC diagnostic ignored "-Wunknown-warning-option"
# 26 "./../stdexec/include/stdexec/__detail/__just.hpp"
#pragma GCC diagnostic ignored "-Wunknown-attributes"
# 26 "./../stdexec/include/stdexec/__detail/__just.hpp"
#pragma GCC diagnostic ignored "-Wattributes"
#pragma GCC diagnostic ignored "-Wmissing-braces"

namespace stdexec {

namespace __just {
template <class _JustTag> struct __impl : __sexpr_defaults {
  using __tag_t = typename _JustTag::__tag_t;

  static constexpr auto get_attrs = [](__ignore) noexcept {
    return prop{__is_scheduler_affine_t{}, std::true_type{}};
  };

  static constexpr auto get_completion_signatures =
      []<class _Sender>(_Sender &&, auto &&...) noexcept {
        static_assert(sender_expr_for<_Sender, _JustTag>);
        return completion_signatures<
            __mapply<__qf<__tag_t>, __decay_t<__data_of<_Sender>>>>{};
      };

  static constexpr auto start =
      []<class _State, class _Receiver>(_State &__state,
                                        _Receiver &__rcvr) noexcept -> void {
    __state.apply(
        [&]<class... _Ts>(_Ts &...__ts) noexcept {
          __tag_t()(static_cast<_Receiver &&>(__rcvr),
                    static_cast<_Ts &&>(__ts)...);
        },
        __state);
  };

  static constexpr auto submit =
      []<class _Sender, class _Receiver>(_Sender &&__sndr,
                                         _Receiver __rcvr) noexcept -> void {
    static_assert(sender_expr_for<_Sender, _JustTag>);
    auto &&__state = get_state(static_cast<_Sender &&>(__sndr), __rcvr);
    __state.apply(
        [&]<class... _Ts>(_Ts &&...__ts) noexcept {
          __tag_t()(static_cast<_Receiver &&>(__rcvr),
                    static_cast<_Ts &&>(__ts)...);
        },
        static_cast<decltype(__state)>(__state));
  };
};

struct just_t {
  using __tag_t = set_value_t;

  template <__movable_value... _Ts>

  auto operator()(_Ts &&...__ts) const
      noexcept((__nothrow_decay_copyable<_Ts> && ...)) {
    return __make_sexpr<just_t>(__tuple{static_cast<_Ts &&>(__ts)...});
  }
};

struct just_error_t {
  using __tag_t = set_error_t;

  template <__movable_value _Error>

  auto operator()(_Error &&__err) const
      noexcept(__nothrow_decay_copyable<_Error>) {
    return __make_sexpr<just_error_t>(__tuple{static_cast<_Error &&>(__err)});
  }
};

struct just_stopped_t {
  using __tag_t = set_stopped_t;

  template <class _Tag = just_stopped_t>

  auto operator()() const noexcept {
    return __make_sexpr<_Tag>(__tuple{});
  }
};
} // namespace __just

using __just::just_error_t;
using __just::just_stopped_t;
using __just::just_t;

template <> struct __sexpr_impl<just_t> : __just::__impl<just_t> {};

template <> struct __sexpr_impl<just_error_t> : __just::__impl<just_error_t> {};

template <>
struct __sexpr_impl<just_stopped_t> : __just::__impl<just_stopped_t> {};

inline constexpr just_t just{};
inline constexpr just_error_t just_error{};
inline constexpr just_stopped_t just_stopped{};
} // namespace stdexec

#pragma GCC diagnostic pop
# 39 "./../stdexec/include/stdexec/execution.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__let.hpp" 1
# 26 "./../stdexec/include/stdexec/__detail/__let.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__any_receiver_ref.hpp" 1
# 25 "./../stdexec/include/stdexec/__detail/__any_receiver_ref.hpp"
namespace stdexec::__any_ {
template <class _Sig> struct __rcvr_vfun;

template <class _Tag, class... _Args> struct __rcvr_vfun<_Tag(_Args...)> {
  void (*__complete_)(void *, _Args...) noexcept;

  void operator()(void *__obj, _Tag, _Args... __args) const noexcept {
    __complete_(__obj, static_cast<_Args &&>(__args)...);
  }
};

template <class _GetReceiver = std::identity, class _Obj, class _Tag,
          class... _Args>
constexpr auto __rcvr_vfun_fn(_Obj *, _Tag (*)(_Args...)) noexcept {
  return +[](void *__ptr, _Args... __args) noexcept {
    _Obj *__obj = static_cast<_Obj *>(__ptr);
    _Tag()(std::move(_GetReceiver()(*__obj)), static_cast<_Args &&>(__args)...);
  };
}

template <class _Sigs, class _Env> struct __receiver_vtable_for;

template <class _Env, class... _Sigs>
struct __receiver_vtable_for<completion_signatures<_Sigs...>, _Env>
    : __rcvr_vfun<_Sigs>... {
  _Env (*__do_get_env)(const void *__op_state) noexcept;

  template <class _OpState, class _GetEnv>
  static auto __s_get_env(const void *__ptr) noexcept -> _Env {
    auto *__op_state = static_cast<const _OpState *>(__ptr);
    return _GetEnv()(*__op_state);
  }

  template <class _OpState, class _GetEnv, class _GetReceiver = std::identity>
  explicit constexpr __receiver_vtable_for(_OpState *__op, _GetEnv,
                                           _GetReceiver = {}) noexcept
      : __rcvr_vfun<_Sigs>{__rcvr_vfun_fn<_GetReceiver>(
            __op, static_cast<_Sigs *>(nullptr))}...,
        __do_get_env{&__s_get_env<_OpState, _GetEnv>} {}

  using __rcvr_vfun<_Sigs>::operator()...;

  auto __get_env(const void *__op_state) const noexcept -> _Env {
    return __do_get_env(__op_state);
  }
};

template <class _OpState, class _GetEnv, class _GetReceiver, class _Env,
          class _Sigs>
inline constexpr __receiver_vtable_for<_Sigs, _Env> __receiver_vtable_for_v{
    static_cast<_OpState *>(nullptr), _GetEnv{}, _GetReceiver{}};

template <class _Sigs, class _Env = env<>> class __receiver_ref {
public:
  using receiver_concept = receiver_t;
  using __t = __receiver_ref;
  using __id = __receiver_ref;

  template <class _OpState, class _GetEnv, class _GetReceiver = std::identity>
  __receiver_ref(_OpState &__op_state, _GetEnv, _GetReceiver = {}) noexcept
      : __vtable_{&__any_::__receiver_vtable_for_v<_OpState, _GetEnv,
                                                   _GetReceiver, _Env, _Sigs>},
        __op_state_{&__op_state} {}

  auto get_env() const noexcept -> decltype(auto) {
    return __vtable_->__get_env(__op_state_);
  }

  template <class... _As>
    requires __callable<__receiver_vtable_for<_Sigs, _Env>, void *, set_value_t,
                        _As...>
  void set_value(_As &&...__as) noexcept {
    (*__vtable_)(__op_state_, set_value_t(), static_cast<_As &&>(__as)...);
  }

  template <class _Error>
    requires __callable<__receiver_vtable_for<_Sigs, _Env>, void *, set_error_t,
                        _Error>
  void set_error(_Error &&__err) noexcept {
    (*__vtable_)(__op_state_, set_error_t(), static_cast<_Error &&>(__err));
  }

  void set_stopped() noexcept
    requires __callable<__receiver_vtable_for<_Sigs, _Env>, void *,
                        set_stopped_t>
  {
    (*__vtable_)(__op_state_, set_stopped_t());
  }

private:
  const __receiver_vtable_for<_Sigs, _Env> *__vtable_;
  void *__op_state_;
};
} // namespace stdexec::__any_
# 27 "./../stdexec/include/stdexec/__detail/__let.hpp" 2
# 37 "./../stdexec/include/stdexec/__detail/__let.hpp"
namespace stdexec {

namespace __let {

struct __unknown_scheduler {
  struct __env {
    static constexpr auto query(__is_scheduler_affine_t) noexcept -> bool {
      return true;
    }

    [[nodiscard]]
    constexpr auto
    query(get_completion_scheduler_t<set_value_t>) const noexcept {
      return __unknown_scheduler{};
    }
  };

  struct __sender {
    using sender_concept = sender_t;

    [[nodiscard]]
    constexpr auto get_env() const noexcept -> __env {
      return {};
    }
  };

  [[nodiscard]]
  auto schedule() const noexcept {
    return __sender();
  }

  auto operator==(const __unknown_scheduler &) const noexcept -> bool = default;
};

inline constexpr auto __get_rcvr =
    [](auto &__op_state) noexcept -> decltype(auto) {
  return (__op_state.__rcvr_);
};

inline constexpr auto __get_env =
    [](auto &__op_state) noexcept -> decltype(auto) {
  return __op_state.__state_.__get_env(__op_state.__rcvr_);
};

template <class _Set, class _Domain = dependent_domain> struct __let_t;

template <class _Set>
inline constexpr __mstring __in_which_let_msg{
    "In stdexec::let_value(Sender, Function)..."};

template <>
inline constexpr __mstring __in_which_let_msg<set_error_t>{
    "In stdexec::let_error(Sender, Function)..."};

template <>
inline constexpr __mstring __in_which_let_msg<set_stopped_t>{
    "In stdexec::let_stopped(Sender, Function)..."};

template <class _Set>
using __on_not_callable = __callable_error<__in_which_let_msg<_Set>>;

template <class _ReceiverId, class _SchedulerId> struct __rcvr_sch {
  using _Receiver = stdexec::__t<_ReceiverId>;
  using _Scheduler = stdexec::__t<_SchedulerId>;

  struct __t {
    using receiver_concept = receiver_t;
    using __id = __rcvr_sch;
    _Receiver __rcvr_;
    _Scheduler __sched_;

    template <class... _As> void set_value(_As &&...__as) noexcept {
      stdexec::set_value(static_cast<_Receiver &&>(__rcvr_),
                         static_cast<_As &&>(__as)...);
    }

    template <class _Error> void set_error(_Error &&__err) noexcept {
      stdexec::set_error(static_cast<_Receiver &&>(__rcvr_),
                         static_cast<_Error &&>(__err));
    }

    void set_stopped() noexcept {
      stdexec::set_stopped(static_cast<_Receiver &&>(__rcvr_));
    }

    auto get_env() const noexcept {
      return __env::__join(__sched_env{__sched_}, stdexec::get_env(__rcvr_));
    }
  };
};

template <class _Receiver, class _Scheduler>
using __receiver_with_sched_t =
    __t<__rcvr_sch<__id<_Receiver>, __id<_Scheduler>>>;

template <class _Scheduler, class _Env>
using __result_env_t =
    __if_c<__is_scheduler_affine<schedule_result_t<_Scheduler>>, _Env,
           __join_env_t<__sched_env<_Scheduler>, _Env>>;

template <__mstring _Where, __mstring _What>
struct _FUNCTION_MUST_RETURN_A_VALID_SENDER_IN_THE_CURRENT_ENVIRONMENT_ {};
# 158 "./../stdexec/include/stdexec/__detail/__let.hpp"
template <class _Sender, class _Set, class... _Env>
using __bad_result_sender = __mexception<
    _FUNCTION_MUST_RETURN_A_VALID_SENDER_IN_THE_CURRENT_ENVIRONMENT_<
        __in_which_let_msg<_Set>,
        "The function must return a valid sender for the current environment"_mstr>,
    _WITH_SENDER_<_Sender>, _WITH_ENVIRONMENT_<_Env>...>;

template <class _Sender, class... _Env>
concept __potentially_valid_sender_in =
    sender_in<_Sender, _Env...> || (sender<_Sender> && (sizeof...(_Env) == 0));

template <class _Set, class _Sender, class... _Env>
using __ensure_sender =
    __minvoke_if_c<__potentially_valid_sender_in<_Sender, _Env...>,
                   __q<__midentity>,
                   __mbind_back_q<__bad_result_sender, _Set, _Env...>, _Sender>;

template <class _Set, class _Fun, class _Sched, class... _Env>
struct __result_sender_fn {
  template <class... _Args>
  using __f =
      __meval<__ensure_sender, _Set,
              __mcall<__mtry_catch_q<__call_result_t, __on_not_callable<_Set>>,
                      _Fun, __decay_t<_Args> &...>,
              __result_env_t<_Sched, _Env>...>;
};

template <class _Receiver, class _Scheduler>
using __result_receiver_t =
    __if_c<__is_scheduler_affine<schedule_result_t<_Scheduler>>, _Receiver,
           __receiver_with_sched_t<_Receiver, _Scheduler>>;

template <class _ResultSender, class _Scheduler, class... _Env>
using __receiver_ref_t =
    __meval<__any_::__receiver_ref,
            __completion_signatures_of_t<_ResultSender,
                                         __result_env_t<_Scheduler, _Env>...>,
            __result_env_t<_Scheduler, _Env>...>;

template <class _ResultSender, class _Scheduler, class _Receiver>
concept __needs_receiver_ref =
    __nothrow_connectable<
        _ResultSender,
        __receiver_ref_t<_ResultSender, _Scheduler, env_of_t<_Receiver>>> &&
    !__nothrow_connectable<_ResultSender,
                           __result_receiver_t<_Receiver, _Scheduler>>;

template <class _Sender, class _Receiver>
using __nothrow_connectable_t =
    __mbool<__nothrow_connectable<_Sender, _Receiver>>;

template <class _ResultSender, class _Scheduler, class... _Env>
using __nothrow_connectable_receiver_ref_t =
    __meval<__nothrow_connectable_t, _ResultSender,
            __receiver_ref_t<_ResultSender, _Scheduler, _Env...>>;

template <class _ResultSender, class _Scheduler, class _Receiver>
using __checked_result_receiver_t =
    __if_c<__needs_receiver_ref<_ResultSender, _Scheduler, _Receiver>,
           __receiver_ref_t<_ResultSender, _Scheduler, env_of_t<_Receiver>>,
           __result_receiver_t<_Receiver, _Scheduler>>;

template <class _ResultSender, class _Scheduler, class _Receiver>
using __submit_result =
    submit_result<_ResultSender, __checked_result_receiver_t<
                                     _ResultSender, _Scheduler, _Receiver>>;

template <class _SetTag, class _Fun, class _Sched, class... _Env>
struct __transform_signal_fn {
  template <class... _Args>
  using __nothrow_connect = __mand<
      __mbool<(__nothrow_decay_copyable<_Args> && ...) &&
              __nothrow_callable<_Fun, _Args...>>,
      __nothrow_connectable_receiver_ref_t<
          __mcall<__result_sender_fn<_SetTag, _Fun, _Sched, _Env...>, _Args...>,
          _Sched, _Env...>>;

  template <class... _Args>
  using __f = __mcall<
      __mtry_q<__concat_completion_signatures>,
      __completion_signatures_of_t<
          __mcall<__result_sender_fn<_SetTag, _Fun, _Sched, _Env...>, _Args...>,
          __result_env_t<_Sched, _Env>...>,
      __eptr_completion_if_t<__nothrow_connect<_Args...>>>;
};

template <class _Sender, class _Set>
using __completion_sched =
    __query_result_or_t<get_completion_scheduler_t<_Set>, env_of_t<_Sender>,
                        __unknown_scheduler>;

template <class _LetTag, class _Fun, class _CvrefSender, class... _Env>
using __completions = __gather_completion_signatures<
    __completion_signatures_of_t<_CvrefSender, _Env...>, __t<_LetTag>,
    __transform_signal_fn<__t<_LetTag>, _Fun,
                          __completion_sched<_CvrefSender, __t<_LetTag>>,
                          _Env...>::template __f,
    __sigs::__default_completion,
    __mtry_q<__concat_completion_signatures>::__f>;

template <__mstring _Where, __mstring _What> struct _NO_COMMON_DOMAIN_ {};

template <class _Set>
using __no_common_domain_t = _NO_COMMON_DOMAIN_<
    __in_which_let_msg<_Set>,
    "The senders returned by Function do not all share a common domain"_mstr>;

template <class _Set, class _Sched> struct __try_common_domain_fn {
  struct __error_fn {
    template <class... _Senders>
    using __f =
        __mexception<__no_common_domain_t<_Set>, _WITH_SENDERS_<_Senders...>>;
  };

  template <class... _Senders>
  using __common_domain =
      __common_domain_t<__if_c<__is_scheduler_affine<_Senders>,
                               schedule_result_t<_Sched>, _Senders>...>;

  template <class... _Senders>
  using __f = __mcall<__mtry_catch_q<__common_domain, __error_fn>, _Senders...>;
};

template <class _Set, class _Child, class _Fun, class _Sched, class... _Env>
using __result_domain_t =
    __gather_completions<_Set, __completion_signatures_of_t<_Child, _Env...>,
                         __result_sender_fn<_Set, _Fun, _Sched, _Env...>,
                         __try_common_domain_fn<_Set, _Sched>>;

template <class _LetTag, class _Env>
auto __mk_transform_env_fn(_Env &&__env) noexcept {
  using _Set = __t<_LetTag>;
  return [&]<class _Fun, class _Child>(__ignore, _Fun &&,
                                       _Child &&__child) -> decltype(auto) {
    using __completions_t = __completion_signatures_of_t<_Child, _Env>;
    if constexpr (__merror<__completions_t>) {
      return __completions_t();
    } else {
      using _Scheduler = __completion_sched<_Child, _Set>;
      if constexpr (__is_scheduler_affine<schedule_result_t<_Scheduler>>) {
        return (__env);
      } else {
        return __env::__join(__sched_env{get_completion_scheduler<_Set>(
                                 stdexec::get_env(__child))},
                             static_cast<_Env &&>(__env));
      }
    }
  };
}

template <class _LetTag, class _Env>
auto __mk_transform_sender_fn(_Env &&) noexcept {
  using _Set = __t<_LetTag>;

  return
      []<class _Fun, class _Child>(__ignore, _Fun &&__fun, _Child &&__child) {
        using __completions_t = __completion_signatures_of_t<_Child, _Env>;

        if constexpr (__merror<__completions_t>) {
          return __completions_t();
        } else {
          using _Sched = __completion_sched<_Child, _Set>;
          using _Domain = __result_domain_t<_Set, _Child, _Fun, _Sched, _Env>;

          if constexpr (__merror<_Domain>) {
            return _Domain();
          } else if constexpr (same_as<_Domain, dependent_domain>) {
            using _Domain2 = __late_domain_of_t<_Child, _Env>;
            return __make_sexpr<__let_t<_Set, _Domain2>>(
                static_cast<_Fun &&>(__fun), static_cast<_Child &&>(__child));
          } else {
            static_assert(!same_as<_Domain, __unknown_scheduler>);
            return __make_sexpr<__let_t<_Set, _Domain>>(
                static_cast<_Fun &&>(__fun), static_cast<_Child &&>(__child));
          }
        }
      };
}

template <class _Receiver, class _Fun, class _Set, class _Sched>
struct __submit_datum_for {

  template <class... _Args>
  using __f = __submit_result<
      __mcall<__result_sender_fn<_Set, _Fun, _Sched, env_of_t<_Receiver>>,
              _Args...>,
      _Sched, _Receiver>;
};

template <class _Receiver, class _Fun, class _Set, class _Sched,
          class... _Tuples>
struct __let_state {
  using __fun_t = _Fun;
  using __sched_t = _Sched;
  using __env_t = __result_env_t<_Sched, env_of_t<_Receiver>>;
  using __rcvr_t = __receiver_with_sched_t<_Receiver, _Sched>;
  using __result_variant = __variant_for<__monostate, _Tuples...>;
  using __submit_variant = __variant_for<
      __monostate,
      __mapply<__submit_datum_for<_Receiver, _Fun, _Set, _Sched>, _Tuples>...>;

  template <class _ResultSender, class _OpState>
  auto __get_result_receiver(const _ResultSender &,
                             _OpState &__op_state) -> decltype(auto) {
    if constexpr (__needs_receiver_ref<_ResultSender, _Sched, _Receiver>) {
      using __receiver_ref =
          __receiver_ref_t<_ResultSender, _Sched, env_of_t<_Receiver>>;
      return __receiver_ref{__op_state, __let::__get_env, __let::__get_rcvr};
    } else {
      _Receiver &__rcvr = __op_state.__rcvr_;
      if constexpr (__is_scheduler_affine<schedule_result_t<_Sched>>) {
        return static_cast<_Receiver &&>(__rcvr);
      } else {
        return __rcvr_t{static_cast<_Receiver &&>(__rcvr), this->__sched_};
      }
    }
  }

  auto __get_env(const _Receiver &__rcvr) const noexcept -> __env_t {
    if constexpr (__is_scheduler_affine<schedule_result_t<_Sched>>) {
      return stdexec::get_env(__rcvr);
    } else {
      return __env::__join(__sched_env{__sched_}, stdexec::get_env(__rcvr));
    }
  }

  [[no_unique_address]]
  _Fun __fun_;
  [[no_unique_address]]
  _Sched __sched_;

  __result_variant __args_{};

  __submit_variant __storage_{};
};

template <class _Set, class _Domain> struct __let_t {
  using __domain_t = _Domain;
  using __t = _Set;

  template <sender _Sender, __movable_value _Fun>
  auto operator()(_Sender &&__sndr, _Fun __fun) const -> __well_formed_sender
      auto {
    auto __domain = __get_early_domain(__sndr);
    return stdexec::transform_sender(
        __domain, __make_sexpr<__let_t<_Set>>(static_cast<_Fun &&>(__fun),
                                              static_cast<_Sender &&>(__sndr)));
  }

  template <class _Fun>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Fun __fun) const -> __binder_back<__let_t, _Fun> {
    return {{static_cast<_Fun &&>(__fun)}, {}, {}};
  }

  template <sender_expr_for<__let_t<_Set>> _Sender, class _Env>
  static auto transform_env(_Sender &&__sndr,
                            const _Env &__env) -> decltype(auto) {
    return __sexpr_apply(static_cast<_Sender &&>(__sndr),
                         __mk_transform_env_fn<__let_t<_Set>>(__env));
  }

  template <sender_expr_for<__let_t<_Set>> _Sender, class _Env>
    requires same_as<__early_domain_of_t<_Sender>, dependent_domain>
  static auto transform_sender(_Sender &&__sndr,
                               const _Env &__env) -> decltype(auto) {
    return __sexpr_apply(static_cast<_Sender &&>(__sndr),
                         __mk_transform_sender_fn<__let_t<_Set>>(__env));
  }
};

template <class _Set, class _Domain> struct __let_impl : __sexpr_defaults {
  static constexpr auto get_attrs =
      []<class _Fun, class _Child>(const _Fun &,
                                   const _Child &__child) noexcept {
        if constexpr (!same_as<_Domain, dependent_domain>) {
          return __env::__join(prop{get_domain, _Domain()},
                               stdexec::get_env(__child));
        } else {
          using _Sched = __completion_sched<_Child, _Set>;
          using _Domain2 = __result_domain_t<_Set, _Child, _Fun, _Sched>;

          if constexpr (__merror<_Domain2>) {
            return __env::__join(prop{get_domain, dependent_domain()},
                                 stdexec::get_env(__child));
          } else {
            return __env::__join(prop{get_domain, _Domain2()},
                                 stdexec::get_env(__child));
          }
        }
      };

  static constexpr auto get_completion_signatures =
      []<class _Self, class... _Env>(_Self &&, _Env &&...) noexcept
      -> __completions<__let_t<_Set, _Domain>, __data_of<_Self>,
                       __child_of<_Self>, _Env...> {
    static_assert(sender_expr_for<_Self, __let_t<_Set, _Domain>>);
    return {};
  };

  static constexpr auto get_state = []<class _Sender, class _Receiver>(
                                        _Sender &&__sndr, _Receiver &) {
    static_assert(sender_expr_for<_Sender, __let_t<_Set, _Domain>>);
    using _Fun = __data_of<_Sender>;
    using _Child = __child_of<_Sender>;
    using _Sched = __decay_t<__completion_sched<_Child, _Set>>;
    using __mk_let_state =
        __mbind_front_q<__let_state, _Receiver, _Fun, _Set, _Sched>;

    using __let_state_t =
        __gather_completions_of<_Set, _Child, env_of_t<_Receiver>,
                                __q<__decayed_tuple>, __mk_let_state>;

    return __sndr.apply(
        static_cast<_Sender &&>(__sndr),
        [&]<class _Fn, class _Child>(__ignore, _Fn &&__fn, _Child &&__child) {
          _Sched __sched =
              query_or(get_completion_scheduler<_Set>,
                       stdexec::get_env(__child), __unknown_scheduler());
          return __let_state_t{static_cast<_Fn &&>(__fn), __sched};
        });
  };

  template <class _State, class _OpState, class... _As>
  static void __bind_(_State &__state, _OpState &__op_state, _As &&...__as) {

    auto &__args = __state.__args_.emplace_from(__tup::__mktuple,
                                                static_cast<_As &&>(__as)...);

    auto __sndr2 = __args.apply(std::move(__state.__fun_), __args);

    auto __rcvr2 = __state.__get_result_receiver(__sndr2, __op_state);

    using __result_t =
        decltype(submit_result{std::move(__sndr2), std::move(__rcvr2)});
    auto &__op = __state.__storage_.template emplace<__result_t>(
        std::move(__sndr2), std::move(__rcvr2));
    __op.submit(std::move(__sndr2), std::move(__rcvr2));
  }

  template <class _OpState, class... _As>
  static void __bind(_OpState &__op_state, _As &&...__as) noexcept {
    using _State = decltype(__op_state.__state_);
    using _Receiver = decltype(__op_state.__rcvr_);
    using _Fun = typename _State::__fun_t;
    using _Sched = typename _State::__sched_t;
    using _ResultSender =
        __mcall<__result_sender_fn<_Set, _Fun, _Sched, env_of_t<_Receiver>>,
                _As...>;

    _State &__state = __op_state.__state_;
    _Receiver &__rcvr = __op_state.__rcvr_;

    if constexpr ((__nothrow_decay_copyable<_As> && ...) &&
                  __nothrow_callable<_Fun, _As...> &&
                  __v<__nothrow_connectable_receiver_ref_t<
                      _ResultSender, _Sched, env_of_t<_Receiver>>>) {
      __bind_(__state, __op_state, static_cast<_As &&>(__as)...);
    } else {
      try {
        __bind_(__state, __op_state, static_cast<_As &&>(__as)...);
      } catch (...) {
        using _Receiver = decltype(__op_state.__rcvr_);
        stdexec::set_error(static_cast<_Receiver &&>(__rcvr),
                           std::current_exception());
      }
    }
  }

  static constexpr auto complete = []<class _OpState, class _Tag, class... _As>(
                                       __ignore, _OpState &__op_state, _Tag,
                                       _As &&...__as) noexcept -> void {
    if constexpr (__same_as<_Tag, _Set>) {

      __bind(__op_state, static_cast<_As &&>(__as)...);
    } else {

      using _Receiver = decltype(__op_state.__rcvr_);
      _Tag()(static_cast<_Receiver &&>(__op_state.__rcvr_),
             static_cast<_As &&>(__as)...);
    }
  };
};
} // namespace __let

using let_value_t = __let::__let_t<set_value_t>;
inline constexpr let_value_t let_value{};

using let_error_t = __let::__let_t<set_error_t>;
inline constexpr let_error_t let_error{};

using let_stopped_t = __let::__let_t<set_stopped_t>;
inline constexpr let_stopped_t let_stopped{};

template <class _Set, class _Domain>
struct __sexpr_impl<__let::__let_t<_Set, _Domain>>
    : __let::__let_impl<_Set, _Domain> {};
} // namespace stdexec
# 40 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__on.hpp" 1
# 36 "./../stdexec/include/stdexec/__detail/__on.hpp"
# 1 "./../stdexec/include/stdexec/__detail/__write_env.hpp" 1
# 26 "./../stdexec/include/stdexec/__detail/__write_env.hpp"
namespace stdexec {

namespace __write_ {
struct __write_env_t {
  template <sender _Sender, class _Env>
  auto operator()(_Sender &&__sndr, _Env __env) const {
    return __make_sexpr<__write_env_t>(static_cast<_Env &&>(__env),
                                       static_cast<_Sender &&>(__sndr));
  }

  template <class _Env>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Env __env) const -> __binder_back<__write_env_t, _Env> {
    return {{static_cast<_Env &&>(__env)}, {}, {}};
  }

  template <class _Env>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  __transform_env_fn(_Env &&__env) noexcept {
    return [&](__ignore, const auto &__state, __ignore) noexcept {
      return __env::__join(__state, static_cast<_Env &&>(__env));
    };
  }

  template <sender_expr_for<__write_env_t> _Self, class _Env>
  static auto transform_env(const _Self &__self, _Env &&__env) noexcept {
    return __sexpr_apply(__self,
                         __transform_env_fn(static_cast<_Env &&>(__env)));
  }
};

struct __write_env_impl : __sexpr_defaults {
  static constexpr auto get_attrs =
      []<class _Child>(__ignore, const _Child &__child) noexcept {
        return __env::__join(prop{__is_scheduler_affine_t{},
                                  __mbool<__is_scheduler_affine<_Child>>{}},
                             stdexec::get_env(__child));
      };

  static constexpr auto get_env = [](__ignore, const auto &__state,
                                     const auto &__rcvr) noexcept {
    return __env::__join(__state, stdexec::get_env(__rcvr));
  };

  static constexpr auto get_completion_signatures =
      []<class _Self, class... _Env>(_Self &&, _Env &&...) noexcept
      -> __completion_signatures_of_t<
          __child_of<_Self>,
          __meval<__join_env_t, const __decay_t<__data_of<_Self>> &, _Env...>> {
    static_assert(sender_expr_for<_Self, __write_env_t>);
    return {};
  };
};
} // namespace __write_

using __write_::__write_env_t;
inline constexpr __write_env_t __write{};
inline constexpr __write_env_t __write_env{};

template <> struct __sexpr_impl<__write_env_t> : __write_::__write_env_impl {};
} // namespace stdexec
# 37 "./../stdexec/include/stdexec/__detail/__on.hpp" 2

namespace stdexec {

namespace __on_v2 {
inline constexpr __mstring __on_context =
    "In stdexec::on(Scheduler, Sender)..."_mstr;
inline constexpr __mstring __no_scheduler_diag =
    "stdexec::on() requires a scheduler to transition back to."_mstr;
inline constexpr __mstring __no_scheduler_details =
    "The provided environment lacks a value for the get_scheduler() query."_mstr;

template <__mstring _Context = __on_context,
          __mstring _Diagnostic = __no_scheduler_diag,
          __mstring _Details = __no_scheduler_details>
struct _CANNOT_RESTORE_EXECUTION_CONTEXT_AFTER_ON_ {};

struct on_t;

template <class _Sender, class _Env> struct __no_scheduler_in_environment {
  using sender_concept = sender_t;

  static auto get_completion_signatures(const __no_scheduler_in_environment &,
                                        const auto &) noexcept {
    return __mexception<_CANNOT_RESTORE_EXECUTION_CONTEXT_AFTER_ON_<>,
                        _WITH_SENDER_<_Sender>, _WITH_ENVIRONMENT_<_Env>>{};
  }
};

template <class _Scheduler, class _Closure> struct __on_data {
  _Scheduler __sched_;
  _Closure __clsur_;
};
template <class _Scheduler, class _Closure>
__on_data(_Scheduler, _Closure) -> __on_data<_Scheduler, _Closure>;

template <class _Scheduler> struct __with_sched {
  using __t = __with_sched;
  using __id = __with_sched;

  _Scheduler __sched_;

  auto query(get_scheduler_t) const noexcept -> _Scheduler { return __sched_; }

  auto query(get_domain_t) const noexcept {
    return query_or(get_domain, __sched_, default_domain());
  }
};

template <class _Scheduler>
__with_sched(_Scheduler) -> __with_sched<_Scheduler>;

struct on_t {
  template <scheduler _Scheduler, sender _Sender>
  auto operator()(_Scheduler &&__sched,
                  _Sender &&__sndr) const -> __well_formed_sender auto {
    auto __domain = __get_early_domain(__sndr);
    return stdexec::transform_sender(
        __domain, __make_sexpr<on_t>(static_cast<_Scheduler &&>(__sched),
                                     static_cast<_Sender &&>(__sndr)));
  }

  template <sender _Sender, scheduler _Scheduler,
            __sender_adaptor_closure_for<_Sender> _Closure>
  auto operator()(_Sender &&__sndr, _Scheduler &&__sched,
                  _Closure &&__clsur) const -> __well_formed_sender auto {
    auto __domain = __get_early_domain(__sndr);
    return stdexec::transform_sender(
        __domain,
        __make_sexpr<on_t>(__on_data{static_cast<_Scheduler &&>(__sched),
                                     static_cast<_Closure &&>(__clsur)},
                           static_cast<_Sender &&>(__sndr)));
  }

  template <scheduler _Scheduler, __sender_adaptor_closure _Closure>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Scheduler &&__sched, _Closure &&__clsur) const {
    return __binder_back<on_t, __decay_t<_Scheduler>, __decay_t<_Closure>>{
        {{static_cast<_Scheduler &&>(__sched)},
         {static_cast<_Closure &&>(__clsur)}},
        {},
        {}};
  }

  template <class _Env>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  __transform_env_fn(_Env &&__env) noexcept {
    return [&]<class _Data>(__ignore, _Data &&__data,
                            __ignore) noexcept -> decltype(auto) {
      if constexpr (scheduler<_Data>) {
        return __env::__join(__sched_env{static_cast<_Data &&>(__data)},
                             static_cast<_Env &&>(__env));
      } else {
        return static_cast<_Env>(static_cast<_Env &&>(__env));
      }
    };
  }

  template <class _Env>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  __transform_sender_fn(const _Env &__env) noexcept {
    return [&]<class _Data, class _Child>(__ignore, _Data &&__data,
                                          _Child &&__child) {
      if constexpr (scheduler<_Data>) {

        auto __old = query_or(get_scheduler, __env, __none_such{});
        if constexpr (__same_as<decltype(__old), __none_such>) {
          if constexpr (__is_root_env<_Env>) {
            return continues_on(starts_on(static_cast<_Data &&>(__data),
                                          static_cast<_Child &&>(__child)),
                                __inln::__scheduler{});
          } else {
            return __none_such{};
          }
        } else {
          return continues_on(starts_on(static_cast<_Data &&>(__data),
                                        static_cast<_Child &&>(__child)),
                              static_cast<decltype(__old) &&>(__old));
        }
      } else {

        auto __old =
            query_or(get_completion_scheduler<set_value_t>, get_env(__child),
                     query_or(get_scheduler, __env, __none_such{}));
        if constexpr (__same_as<decltype(__old), __none_such>) {
          return __none_such{};
        } else {
          auto &&[__sched, __clsur] = static_cast<_Data &&>(__data);
          return __write_env(
              continues_on(__forward_like<_Data>(__clsur)(continues_on(
                               __write_env(static_cast<_Child &&>(__child),
                                           __with_sched{__old}),
                               __sched)),
                           __old),
              __with_sched{__sched});
        }
      }
    };
  }

  template <class _Sender, class _Env>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  transform_env(const _Sender &__sndr, _Env &&__env) noexcept {
    return __sexpr_apply(__sndr,
                         __transform_env_fn(static_cast<_Env &&>(__env)));
  }

  template <class _Sender, class _Env>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  transform_sender(_Sender &&__sndr, const _Env &__env) {
    auto __tfx_sndr_fn = __transform_sender_fn(__env);
    using _TfxSndrFn = decltype(__tfx_sndr_fn);
    using _NewSndr = __sexpr_apply_result_t<_Sender, _TfxSndrFn>;
    if constexpr (__same_as<_NewSndr, __none_such>) {
      return __no_scheduler_in_environment<_Sender, _Env>{};
    } else {
      return __sexpr_apply(static_cast<_Sender &&>(__sndr),
                           static_cast<_TfxSndrFn &&>(__tfx_sndr_fn));
    }
  }
};
} // namespace __on_v2

namespace v2 {
using __on_v2::on_t;
inline constexpr on_t on{};

using continue_on_t = v2::on_t;
inline constexpr continue_on_t continue_on{};
} // namespace v2

template <> struct __sexpr_impl<v2::on_t> : __sexpr_defaults {
  static constexpr auto get_completion_signatures =
      []<class _Sender>(_Sender &&) noexcept
      -> __merror_or_t<__completion_signatures_of_t<transform_sender_result_t<
                           default_domain, _Sender, env<>>>,
                       dependent_completions> { return {}; };
};
} // namespace stdexec
# 42 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__read_env.hpp" 1
# 33 "./../stdexec/include/stdexec/__detail/__read_env.hpp"
namespace stdexec {
namespace __read {
template <class _Tag, class _ReceiverId>
using __result_t = __call_result_t<_Tag, env_of_t<stdexec::__t<_ReceiverId>>>;

template <class _Tag, class _ReceiverId>
concept __nothrow_t =
    __nothrow_callable<_Tag, env_of_t<stdexec::__t<_ReceiverId>>>;

inline constexpr __mstring __query_failed_diag =
    "The current execution environment doesn't have a value for the given query."_mstr;

template <class _Tag, class _Env>
using __query_failed_error = __mexception<
    _NOT_CALLABLE_<"In stdexec::read_env()..."_mstr, __query_failed_diag>,
    _WITH_QUERY_<_Tag>, _WITH_ENVIRONMENT_<_Env>>;

template <class _Tag, class _Env>
  requires __callable<_Tag, _Env>
using __completions_t =
    __if_c<__nothrow_callable<_Tag, _Env>,
           completion_signatures<set_value_t(__call_result_t<_Tag, _Env>)>,
           completion_signatures<set_value_t(__call_result_t<_Tag, _Env>),
                                 set_error_t(std::exception_ptr)>>;

template <class _Tag, class _Ty> struct __state {
  using __query = _Tag;
  using __result = _Ty;
  __optional<_Ty> __result_;
};

template <class _Tag, class _Ty>
  requires __same_as<_Ty, _Ty &&>
struct __state<_Tag, _Ty> {
  using __query = _Tag;
  using __result = _Ty;
};

struct __read_env_t {
  template <class _Tag> constexpr auto operator()(_Tag) const noexcept {
    return __make_sexpr<__read_env_t>(_Tag());
  }
};

struct __read_env_impl : __sexpr_defaults {
  template <class _Tag, class _Env>
  using __completions_t = __minvoke<
      __mtry_catch_q<__read::__completions_t, __q<__query_failed_error>>, _Tag,
      _Env>;

  static constexpr auto get_attrs = [](__ignore) noexcept {
    return prop{__is_scheduler_affine_t{}, std::true_type{}};
  };

  static constexpr auto get_completion_signatures =
      []<class _Self, class _Env>(const _Self &, _Env &&) noexcept
      -> __completions_t<__data_of<_Self>, _Env> { return {}; };

  static constexpr auto get_state =
      []<class _Self, class _Receiver>(const _Self &, _Receiver &) noexcept {
        using __query = __data_of<_Self>;
        using __result = __call_result_t<__query, env_of_t<_Receiver>>;
        return __state<__query, __result>();
      };

  static constexpr auto start =
      []<class _State, class _Receiver>(_State &__state,
                                        _Receiver &__rcvr) noexcept -> void {
    using __query = typename _State::__query;
    using __result = typename _State::__result;
    if constexpr (__same_as<__result, __result &&>) {

      stdexec::__set_value_invoke(static_cast<_Receiver &&>(__rcvr), __query(),
                                  stdexec::get_env(__rcvr));
    } else {
      constexpr bool _Nothrow =
          __nothrow_callable<__query, env_of_t<_Receiver>>;
      auto __query_fn = [&]() noexcept(_Nothrow) -> __result && {
        __state.__result_.emplace(__emplace_from{[&]() noexcept(_Nothrow) {
          return __query()(stdexec::get_env(__rcvr));
        }});
        return static_cast<__result &&>(*__state.__result_);
      };
      stdexec::__set_value_invoke(static_cast<_Receiver &&>(__rcvr),
                                  __query_fn);
    }
  };

  static constexpr auto submit =
      []<class _Sender, class _Receiver>(const _Sender &__sndr,
                                         _Receiver __rcvr) noexcept
    requires std::is_reference_v<
        __call_result_t<__data_of<_Sender>, env_of_t<_Receiver>>>
  {
    static_assert(sender_expr_for<_Sender, __read_env_t>);
    using __query = __data_of<_Sender>;
    stdexec::__set_value_invoke(static_cast<_Receiver &&>(__rcvr), __query(),
                                stdexec::get_env(__rcvr));
  };
};
} // namespace __read

[[deprecated("read has been renamed to read_env")]]
inline constexpr __read::__read_env_t read{};
inline constexpr __read::__read_env_t read_env{};

template <>
struct __sexpr_impl<__read::__read_env_t> : __read::__read_env_impl {};

namespace __queries {
template <class _Tag> inline auto get_scheduler_t::operator()() const noexcept {
  return read_env(get_scheduler);
}

template <class _Tag>
inline auto get_delegation_scheduler_t::operator()() const noexcept {
  return read_env(get_delegation_scheduler);
}

template <class _Tag> inline auto get_allocator_t::operator()() const noexcept {
  return read_env(get_allocator);
}

template <class _Tag>
inline auto get_stop_token_t::operator()() const noexcept {
  return read_env(get_stop_token);
}
} // namespace __queries
} // namespace stdexec
# 44 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__receiver_adaptor.hpp" 1
# 25 "./../stdexec/include/stdexec/__detail/__receiver_adaptor.hpp"
namespace stdexec {
namespace __adaptors {
namespace __no {
struct __nope {};

struct __receiver : __nope {
  using receiver_concept = receiver_t;

  void set_error(std::exception_ptr) noexcept;
  void set_stopped() noexcept;
  [[nodiscard]]
  auto get_env() const noexcept -> env<>;
};
} // namespace __no

using __not_a_receiver = __no::__receiver;

template <class _Base> struct __adaptor_base {
  template <class _T1>
    requires constructible_from<_Base, _T1>
  explicit __adaptor_base(_T1 &&__base)
      : __base_(static_cast<_T1 &&>(__base)) {}

private:
  [[no_unique_address]] _Base __base_;

protected:
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  base() & noexcept -> _Base & {
    return __base_;
  }

  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline

      auto
      base() const & noexcept -> const _Base & {
    return __base_;
  }

  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  base() && noexcept -> _Base && {
    return static_cast<_Base &&>(__base_);
  }
};

template <derived_from<__no::__nope> _Base> struct __adaptor_base<_Base> {};
# 101 "./../stdexec/include/stdexec/__detail/__receiver_adaptor.hpp"
template <__class _Derived, class _Base = __not_a_receiver>
struct receiver_adaptor : __adaptor_base<_Base>, receiver_t {

  static constexpr bool __has_base = !derived_from<_Base, __no::__nope>;

  template <class _Self>
  using __base_from_derived_t = decltype(__declval<_Self>().base());

  using __get_base_fn =
      __if_c<__has_base, __mbind_back_q<__copy_cvref_t, _Base>,
             __q<__base_from_derived_t>>;

  template <class _Self> using __base_t = __minvoke<__get_base_fn, _Self &&>;

  template <class _Self>

  static auto __get_base(_Self &&__self) noexcept -> __base_t<_Self> {
    if constexpr (__has_base) {
      return __c_upcast<receiver_adaptor>(static_cast<_Self &&>(__self)).base();
    } else {
      return static_cast<_Self &&>(__self).base();
    }
  }

public:
  using receiver_concept = receiver_t;

  receiver_adaptor() = default;
  using __adaptor_base<_Base>::__adaptor_base;

  template <class... _As, class _Self = _Derived>
    requires __callable<set_value_t, __base_t<_Self>, _As...>

  void set_value(_As &&...__as) && noexcept {
    return stdexec::set_value(__get_base(static_cast<_Self &&>(*this)),
                              static_cast<_As &&>(__as)...);
  }

  template <class _Error, class _Self = _Derived>
    requires __callable<set_error_t, __base_t<_Self>, _Error>

  void set_error(_Error &&__err) && noexcept {
    return stdexec::set_error(__get_base(static_cast<_Self &&>(*this)),
                              static_cast<_Error &&>(__err));
  }

  template <class _Self = _Derived>
    requires __callable<set_stopped_t, __base_t<_Self>>

  void set_stopped() && noexcept {
    return stdexec::set_stopped(__get_base(static_cast<_Self &&>(*this)));
  }

  template <class _Self = _Derived>

  auto get_env() const noexcept -> env_of_t<__base_t<const _Self &>> {
    return stdexec::get_env(__get_base(static_cast<const _Self &>(*this)));
  }
};
} // namespace __adaptors

template <__class _Derived, receiver _Base = __adaptors::__not_a_receiver>
using receiver_adaptor = __adaptors::receiver_adaptor<_Derived, _Base>;
} // namespace stdexec
# 46 "./../stdexec/include/stdexec/execution.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__receiver_ref.hpp" 1
# 26 "./../stdexec/include/stdexec/__detail/__receiver_ref.hpp"
namespace stdexec {
template <class _Rcvr, class _Env = env_of_t<_Rcvr>> struct __rcvr_ref {
  using receiver_concept = receiver_t;

  explicit constexpr __rcvr_ref(_Rcvr &__rcvr) noexcept
      : __rcvr_{std::addressof(__rcvr)} {}

  template <class... _As>

  void set_value(_As &&...__as) noexcept {
    stdexec::set_value(static_cast<_Rcvr &&>(*__rcvr_),
                       static_cast<_As &&>(__as)...);
  }

  template <class _Error>

  void set_error(_Error &&__err) noexcept {
    stdexec::set_error(static_cast<_Rcvr &&>(*__rcvr_),
                       static_cast<_Error &&>(__err));
  }

  void set_stopped() noexcept {
    stdexec::set_stopped(static_cast<_Rcvr &&>(*__rcvr_));
  }

  [[nodiscard]]
  auto get_env() const noexcept -> _Env {
    static_assert(std::is_same_v<_Env, env_of_t<_Rcvr>>,
                  "get_env() must return the same type as env_of_t<_Rcvr>");
    return stdexec::get_env(*__rcvr_);
  }

private:
  _Rcvr *__rcvr_;
};

namespace __detail {
template <class _Rcvr, size_t = sizeof(_Rcvr)>

constexpr auto __is_type_complete(int) noexcept {
  return true;
}

template <class _Rcvr>

constexpr auto __is_type_complete(long) noexcept {
  return false;
}
} // namespace __detail
# 87 "./../stdexec/include/stdexec/__detail/__receiver_ref.hpp"
template <class _Env = void, class _Rcvr>
[[nodiscard]]
constexpr auto __ref_rcvr(_Rcvr &__rcvr) noexcept {
  if constexpr (std::is_same_v<_Env, void>) {
    return stdexec::__ref_rcvr<env_of_t<_Rcvr>>(__rcvr);
  } else if constexpr (__is_instance_of<_Rcvr, __rcvr_ref>) {
    return __rcvr;
  } else if constexpr (!__detail::__is_type_complete<_Rcvr>(0)) {
    return __rcvr_ref<_Rcvr, _Env>{__rcvr};
  } else if constexpr (operation_state<_Rcvr>) {
    return __rcvr_ref<_Rcvr, _Env>{__rcvr};
  } else if constexpr (__nothrow_constructible_from<_Rcvr, const _Rcvr &>) {
    return const_cast<const _Rcvr &>(__rcvr);
  } else {
    return __rcvr_ref{__rcvr};
  }
  __builtin_unreachable();
}

template <class _Rcvr, class _Env = env_of_t<_Rcvr>>
using __rcvr_ref_t =
    decltype(stdexec::__ref_rcvr<_Env>(stdexec::__declval<_Rcvr &>()));
} // namespace stdexec
# 47 "./../stdexec/include/stdexec/execution.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__run_loop.hpp" 1
# 27 "./../stdexec/include/stdexec/__detail/__run_loop.hpp"
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/condition_variable" 1 3
# 33 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/condition_variable" 3
# 54 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/condition_variable" 3
namespace std __attribute__((__visibility__("default"))) {
# 67 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/condition_variable" 3
  enum class cv_status { no_timeout, timeout };

  class condition_variable {
    using steady_clock = chrono::steady_clock;
    using system_clock = chrono::system_clock;

    using __clock_t = steady_clock;

    __condvar _M_cond;

  public:
    typedef __gthread_cond_t *native_handle_type;

    condition_variable() noexcept;
    ~condition_variable() noexcept;

    condition_variable(const condition_variable &) = delete;
    condition_variable &operator=(const condition_variable &) = delete;

    void notify_one() noexcept;

    void notify_all() noexcept;

    void wait(unique_lock<mutex> &__lock);

    template <typename _Predicate>
    void wait(unique_lock<mutex> &__lock, _Predicate __p) {
      while (!__p())
        wait(__lock);
    }

    template <typename _Duration>
    cv_status
    wait_until(unique_lock<mutex> &__lock,
               const chrono::time_point<steady_clock, _Duration> &__atime) {
      return __wait_until_impl(__lock, __atime);
    }

    template <typename _Duration>
    cv_status
    wait_until(unique_lock<mutex> &__lock,
               const chrono::time_point<system_clock, _Duration> &__atime) {
      return __wait_until_impl(__lock, __atime);
    }

    template <typename _Clock, typename _Duration>
    cv_status wait_until(unique_lock<mutex> &__lock,
                         const chrono::time_point<_Clock, _Duration> &__atime) {

      static_assert(chrono::is_clock_v<_Clock>);

      using __s_dur = typename __clock_t::duration;
      const typename _Clock::time_point __c_entry = _Clock::now();
      const __clock_t::time_point __s_entry = __clock_t::now();
      const auto __delta = __atime - __c_entry;
      const auto __s_atime =
          __s_entry + chrono::__detail::ceil<__s_dur>(__delta);

      if (__wait_until_impl(__lock, __s_atime) == cv_status::no_timeout)
        return cv_status::no_timeout;

      if (_Clock::now() < __atime)
        return cv_status::no_timeout;
      return cv_status::timeout;
    }

    template <typename _Clock, typename _Duration, typename _Predicate>
    bool wait_until(unique_lock<mutex> &__lock,
                    const chrono::time_point<_Clock, _Duration> &__atime,
                    _Predicate __p) {
      while (!__p())
        if (wait_until(__lock, __atime) == cv_status::timeout)
          return __p();
      return true;
    }

    template <typename _Rep, typename _Period>
    cv_status wait_for(unique_lock<mutex> &__lock,
                       const chrono::duration<_Rep, _Period> &__rtime) {
      using __dur = typename steady_clock::duration;
      return wait_until(__lock, steady_clock::now() +
                                    chrono::__detail::ceil<__dur>(__rtime));
    }

    template <typename _Rep, typename _Period, typename _Predicate>
    bool wait_for(unique_lock<mutex> &__lock,
                  const chrono::duration<_Rep, _Period> &__rtime,
                  _Predicate __p) {
      using __dur = typename steady_clock::duration;
      return wait_until(
          __lock, steady_clock::now() + chrono::__detail::ceil<__dur>(__rtime),
          std::move(__p));
    }

    native_handle_type native_handle() { return _M_cond.native_handle(); }

  private:
    template <typename _Dur>
    cv_status
    __wait_until_impl(unique_lock<mutex> &__lock,
                      const chrono::time_point<steady_clock, _Dur> &__atime) {
      auto __s = chrono::time_point_cast<chrono::seconds>(__atime);
      auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);

      __gthread_time_t __ts = {
          static_cast<std::time_t>(__s.time_since_epoch().count()),
          static_cast<long>(__ns.count())};

      _M_cond.wait_until(*__lock.mutex(), 1, __ts);

      return (steady_clock::now() < __atime ? cv_status::no_timeout
                                            : cv_status::timeout);
    }

    template <typename _Dur>
    cv_status
    __wait_until_impl(unique_lock<mutex> &__lock,
                      const chrono::time_point<system_clock, _Dur> &__atime) {
      auto __s = chrono::time_point_cast<chrono::seconds>(__atime);
      auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);

      __gthread_time_t __ts = {
          static_cast<std::time_t>(__s.time_since_epoch().count()),
          static_cast<long>(__ns.count())};

      _M_cond.wait_until(*__lock.mutex(), __ts);

      return (system_clock::now() < __atime ? cv_status::no_timeout
                                            : cv_status::timeout);
    }
  };

  void notify_all_at_thread_exit(condition_variable &, unique_lock<mutex>);

  struct __at_thread_exit_elt {
    __at_thread_exit_elt *_M_next;
    void (*_M_cb)(void *);
  };

  inline namespace _V2 {

  class condition_variable_any {

    using __clock_t = chrono::steady_clock;

    condition_variable _M_cond;
    shared_ptr<mutex> _M_mutex;

    template <typename _Lock> struct _Unlock {
      explicit _Unlock(_Lock &__lk) : _M_lock(__lk) { __lk.unlock(); }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      ~_Unlock() noexcept(false) {
        if (uncaught_exception()) {
          try {
            _M_lock.lock();
          } catch (const __cxxabiv1::__forced_unwind &) {
            throw;
          } catch (...) {
          }
        } else
          _M_lock.lock();
      }
#pragma GCC diagnostic pop

      _Unlock(const _Unlock &) = delete;
      _Unlock &operator=(const _Unlock &) = delete;

      _Lock &_M_lock;
    };

  public:
    condition_variable_any() : _M_mutex(std::make_shared<mutex>()) {}
    ~condition_variable_any() = default;

    condition_variable_any(const condition_variable_any &) = delete;
    condition_variable_any &operator=(const condition_variable_any &) = delete;

    void notify_one() noexcept {
      lock_guard<mutex> __lock(*_M_mutex);
      _M_cond.notify_one();
    }

    void notify_all() noexcept {
      lock_guard<mutex> __lock(*_M_mutex);
      _M_cond.notify_all();
    }

    template <typename _Lock> void wait(_Lock &__lock) {
      shared_ptr<mutex> __mutex = _M_mutex;
      unique_lock<mutex> __my_lock(*__mutex);
      _Unlock<_Lock> __unlock(__lock);

      unique_lock<mutex> __my_lock2(std::move(__my_lock));
      _M_cond.wait(__my_lock2);
    }

    template <typename _Lock, typename _Predicate>
    void wait(_Lock &__lock, _Predicate __p) {
      while (!__p())
        wait(__lock);
    }

    template <typename _Lock, typename _Clock, typename _Duration>
    cv_status wait_until(_Lock &__lock,
                         const chrono::time_point<_Clock, _Duration> &__atime) {
      shared_ptr<mutex> __mutex = _M_mutex;
      unique_lock<mutex> __my_lock(*__mutex);
      _Unlock<_Lock> __unlock(__lock);

      unique_lock<mutex> __my_lock2(std::move(__my_lock));
      return _M_cond.wait_until(__my_lock2, __atime);
    }

    template <typename _Lock, typename _Clock, typename _Duration,
              typename _Predicate>
    bool wait_until(_Lock &__lock,
                    const chrono::time_point<_Clock, _Duration> &__atime,
                    _Predicate __p) {
      while (!__p())
        if (wait_until(__lock, __atime) == cv_status::timeout)
          return __p();
      return true;
    }

    template <typename _Lock, typename _Rep, typename _Period>
    cv_status wait_for(_Lock &__lock,
                       const chrono::duration<_Rep, _Period> &__rtime) {
      return wait_until(__lock, __clock_t::now() + __rtime);
    }

    template <typename _Lock, typename _Rep, typename _Period,
              typename _Predicate>
    bool wait_for(_Lock &__lock, const chrono::duration<_Rep, _Period> &__rtime,
                  _Predicate __p) {
      return wait_until(__lock, __clock_t::now() + __rtime, std::move(__p));
    }

    template <class _Lock, class _Predicate>
    bool wait(_Lock &__lock, stop_token __stoken, _Predicate __p) {
      if (__stoken.stop_requested()) {
        return __p();
      }

      std::stop_callback __cb(__stoken, [this] { notify_all(); });
      shared_ptr<mutex> __mutex = _M_mutex;
      while (!__p()) {
        unique_lock<mutex> __my_lock(*__mutex);
        if (__stoken.stop_requested()) {
          return false;
        }

        _Unlock<_Lock> __unlock(__lock);
        unique_lock<mutex> __my_lock2(std::move(__my_lock));
        _M_cond.wait(__my_lock2);
      }
      return true;
    }

    template <class _Lock, class _Clock, class _Duration, class _Predicate>
    bool wait_until(_Lock &__lock, stop_token __stoken,
                    const chrono::time_point<_Clock, _Duration> &__abs_time,
                    _Predicate __p) {
      if (__stoken.stop_requested()) {
        return __p();
      }

      std::stop_callback __cb(__stoken, [this] { notify_all(); });
      shared_ptr<mutex> __mutex = _M_mutex;
      while (!__p()) {
        bool __stop;
        {
          unique_lock<mutex> __my_lock(*__mutex);
          if (__stoken.stop_requested()) {
            return false;
          }
          _Unlock<_Lock> __u(__lock);
          unique_lock<mutex> __my_lock2(std::move(__my_lock));
          const auto __status = _M_cond.wait_until(__my_lock2, __abs_time);
          __stop = (__status == std::cv_status::timeout) ||
                   __stoken.stop_requested();
        }
        if (__stop) {
          return __p();
        }
      }
      return true;
    }

    template <class _Lock, class _Rep, class _Period, class _Predicate>
    bool wait_for(_Lock &__lock, stop_token __stoken,
                  const chrono::duration<_Rep, _Period> &__rel_time,
                  _Predicate __p) {
      auto __abst = std::chrono::steady_clock::now() + __rel_time;
      return wait_until(__lock, std::move(__stoken), __abst, std::move(__p));
    }
  };

  } // namespace _V2

} // namespace std
# 28 "./../stdexec/include/stdexec/__detail/__run_loop.hpp" 2

namespace stdexec {

namespace __loop {
class run_loop;

struct __task : __immovable {
  __task *__next_ = this;

  union {
    __task *__tail_ = nullptr;
    void (*__execute_)(__task *) noexcept;
  };

  void __execute() noexcept { (*__execute_)(this); }
};

template <class _ReceiverId> struct __operation {
  using _Receiver = stdexec::__t<_ReceiverId>;

  struct __t : __task {
    using __id = __operation;

    run_loop *__loop_;
    [[no_unique_address]] _Receiver __rcvr_;

    static void __execute_impl(__task *__p) noexcept {
      auto &__rcvr = static_cast<__t *>(__p)->__rcvr_;
      try {
        if (stdexec::get_stop_token(stdexec::get_env(__rcvr))
                .stop_requested()) {
          stdexec::set_stopped(static_cast<_Receiver &&>(__rcvr));
        } else {
          stdexec::set_value(static_cast<_Receiver &&>(__rcvr));
        }
      } catch (...) {
        stdexec::set_error(static_cast<_Receiver &&>(__rcvr),
                           std::current_exception());
      }
    }

    explicit __t(__task *__tail) noexcept : __task{{}, this, __tail} {}

    __t(__task *__next, run_loop *__loop, _Receiver __rcvr)
        : __task{{}, __next, {}}, __loop_{__loop},
          __rcvr_{static_cast<_Receiver &&>(__rcvr)} {
      __execute_ = &__execute_impl;
    }

    void start() & noexcept;
  };
};

class run_loop {
  template <class> friend struct __operation;

public:
  struct __scheduler {
  private:
    struct __schedule_task {
      using __t = __schedule_task;
      using __id = __schedule_task;
      using sender_concept = sender_t;
      using completion_signatures = stdexec::completion_signatures<
          set_value_t(), set_error_t(std::exception_ptr), set_stopped_t()>;

      template <class _Receiver>
      using __operation = stdexec::__t<__operation<stdexec::__id<_Receiver>>>;

      template <class _Receiver>
      auto connect(_Receiver __rcvr) const -> __operation<_Receiver> {
        return {&__loop_->__head_, __loop_, static_cast<_Receiver &&>(__rcvr)};
      }

    private:
      friend __scheduler;

      struct __env {
        using __t = __env;
        using __id = __env;

        run_loop *__loop_;

        template <class _CPO>
        auto
        query(get_completion_scheduler_t<_CPO>) const noexcept -> __scheduler {
          return __loop_->get_scheduler();
        }
      };

      explicit __schedule_task(run_loop *__loop) noexcept : __loop_(__loop) {}

      run_loop *const __loop_;

    public:
      [[nodiscard]]
      auto get_env() const noexcept -> __env {
        return __env{__loop_};
      }
    };

    friend run_loop;

    explicit __scheduler(run_loop *__loop) noexcept : __loop_(__loop) {}

    run_loop *__loop_;

  public:
    using __t = __scheduler;
    using __id = __scheduler;
    auto operator==(const __scheduler &) const noexcept -> bool = default;

    [[nodiscard]]
    auto schedule() const noexcept -> __schedule_task {
      return __schedule_task{__loop_};
    }

    [[nodiscard]]
    auto query(get_forward_progress_guarantee_t) const noexcept
        -> stdexec::forward_progress_guarantee {
      return stdexec::forward_progress_guarantee::parallel;
    }

    [[nodiscard]]
    auto query(execute_may_block_caller_t) const noexcept -> bool {
      return false;
    }
  };

  auto get_scheduler() noexcept -> __scheduler { return __scheduler{this}; }

  void run();

  void finish();

private:
  void __push_back_(__task *__task);
  auto __pop_front_() -> __task *;

  std::mutex __mutex_;
  std::condition_variable __cv_;
  __task __head_{{}, &__head_, {&__head_}};
  bool __stop_ = false;
};

template <class _ReceiverId>
inline void __operation<_ReceiverId>::__t::start() & noexcept {
  try {
    __loop_->__push_back_(this);
  } catch (...) {
    stdexec::set_error(static_cast<_Receiver &&>(__rcvr_),
                       std::current_exception());
  }
}

inline void run_loop::run() {
  for (__task *__task; (__task = __pop_front_()) != &__head_;) {
    __task->__execute();
  }
}

inline void run_loop::finish() {
  std::unique_lock __lock{__mutex_};
  __stop_ = true;
  __cv_.notify_all();
}

inline void run_loop::__push_back_(__task *__task) {
  std::unique_lock __lock{__mutex_};
  __task->__next_ = &__head_;
  __head_.__tail_ = __head_.__tail_->__next_ = __task;
  __cv_.notify_one();
}

inline auto run_loop::__pop_front_() -> __task * {
  std::unique_lock __lock{__mutex_};
  __cv_.wait(__lock, [this] { return __head_.__next_ != &__head_ || __stop_; });
  if (__head_.__tail_ == __head_.__next_)
    __head_.__tail_ = &__head_;
  return std::exchange(__head_.__next_, __head_.__next_->__next_);
}
} // namespace __loop

using run_loop = __loop::run_loop;
} // namespace stdexec
# 48 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__split.hpp" 1
# 30 "./../stdexec/include/stdexec/__detail/__split.hpp"
namespace stdexec {

namespace __split {
using namespace __shared;

struct __split_t {};

struct split_t {
  template <sender _Sender, class _Env = env<>>
    requires sender_in<_Sender, _Env> && __decay_copyable<env_of_t<_Sender>>
  auto operator()(_Sender &&__sndr,
                  _Env &&__env = {}) const -> __well_formed_sender auto {
    auto __domain =
        __get_late_domain(__sndr, __env, __get_early_domain(__sndr));
    return stdexec::transform_sender(
        __domain, __make_sexpr<split_t>(static_cast<_Env &&>(__env),
                                        static_cast<_Sender &&>(__sndr)));
  }

  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline

      auto
      operator()() const noexcept -> __binder_back<split_t> {
    return {{}, {}, {}};
  }

  template <class _CvrefSender, class _Env>
  using __receiver_t =
      __t<__meval<__receiver, __cvref_id<_CvrefSender>, __id<_Env>>>;

  template <class _Sender> static auto transform_sender(_Sender &&__sndr) {
    using _Receiver =
        __receiver_t<__child_of<_Sender>, __decay_t<__data_of<_Sender>>>;
    static_assert(sender_to<__child_of<_Sender>, _Receiver>);

    return __sexpr_apply(
        static_cast<_Sender &&>(__sndr),
        [&]<class _Env, class _Child>(__ignore, _Env &&__env,
                                      _Child &&__child) {
          auto *__sh_state = new __shared_state{static_cast<_Child &&>(__child),
                                                static_cast<_Env &&>(__env)};

          return __make_sexpr<__split_t>(__box{__split_t(), __sh_state});
        });
  }
};
} // namespace __split

using __split::split_t;
inline constexpr split_t split{};

template <>
struct __sexpr_impl<__split::__split_t>
    : __shared::__shared_impl<__split::__split_t> {};

template <> struct __sexpr_impl<split_t> : __sexpr_defaults {
  static constexpr auto get_completion_signatures =
      []<class _Sender>(_Sender &&) noexcept
      -> __completion_signatures_of_t<
          transform_sender_result_t<default_domain, _Sender, env<>>> {};
};
} // namespace stdexec
# 53 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__starts_on.hpp" 1
# 31 "./../stdexec/include/stdexec/__detail/__starts_on.hpp"
namespace stdexec {
namespace __detail {

template <class _Ty, class = __name_of<__decay_t<_Ty>>> struct __always {
  _Ty __val_;

  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline

      constexpr auto
      operator()() noexcept(__nothrow_constructible_from<_Ty, _Ty>) -> _Ty {
    return static_cast<_Ty &&>(__val_);
  }
};

template <class _Ty> __always(_Ty) -> __always<_Ty>;
} // namespace __detail

namespace __starts_on_ns {
struct starts_on_t {
  template <scheduler _Scheduler, sender _Sender>
  auto operator()(_Scheduler &&__sched,
                  _Sender &&__sndr) const -> __well_formed_sender auto {
    auto __domain = query_or(get_domain, __sched, default_domain());
    return stdexec::transform_sender(
        __domain, __make_sexpr<starts_on_t>(static_cast<_Scheduler &&>(__sched),
                                            static_cast<_Sender &&>(__sndr)));
  }

  template <class _Env>
  __attribute__((__always_inline__, __artificial__,
                 __nodebug__)) inline static auto
  __transform_env_fn(_Env &&__env) noexcept {
    return [&](__ignore, auto __sched, __ignore) noexcept {
      return __env::__join(__sched_env{__sched}, static_cast<_Env &&>(__env));
    };
  }

  template <class _Sender, class _Env>
  static auto transform_env(const _Sender &__sndr, _Env &&__env) noexcept {
    return __sexpr_apply(__sndr,
                         __transform_env_fn(static_cast<_Env &&>(__env)));
  }

  template <class _Sender, class _Env>
  static auto transform_sender(_Sender &&__sndr, const _Env &) {
    return __sexpr_apply(
        static_cast<_Sender &&>(__sndr),
        []<class _Data, class _Child>(__ignore, _Data &&__data,
                                      _Child &&__child) {
          return let_value(schedule(__data),
                           __detail::__always{static_cast<_Child &&>(__child)});
        });
  }
};
} // namespace __starts_on_ns

using __starts_on_ns::starts_on_t;
inline constexpr starts_on_t starts_on{};

using on_t = starts_on_t;
inline constexpr starts_on_t on{};

using start_on_t = starts_on_t;
inline constexpr starts_on_t start_on{};

template <> struct __sexpr_impl<starts_on_t> : __sexpr_defaults {
  static constexpr auto get_completion_signatures =
      []<class _Sender>(_Sender &&) noexcept
      -> __completion_signatures_of_t<
          transform_sender_result_t<default_domain, _Sender, env<>>> {
    return {};
  };
};
} // namespace stdexec
# 55 "./../stdexec/include/stdexec/execution.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__stopped_as_error.hpp" 1
# 26 "./../stdexec/include/stdexec/__detail/__stopped_as_error.hpp"
namespace stdexec {

namespace __sae {
struct stopped_as_error_t {
  template <sender _Sender, __movable_value _Error>
  auto operator()(_Sender &&__sndr, _Error __err) const {
    return let_stopped(
        static_cast<_Sender &&>(__sndr),
        [__err2 = static_cast<_Error &&>(__err)]() mutable noexcept(
            __nothrow_move_constructible<_Error>) {
          return just_error(static_cast<_Error &&>(__err2));
        });
  }

  template <__movable_value _Error>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Error __err) const -> __binder_back<stopped_as_error_t, _Error> {
    return {{static_cast<_Error &&>(__err)}, {}, {}};
  }
};
} // namespace __sae

using __sae::stopped_as_error_t;
inline constexpr stopped_as_error_t stopped_as_error{};
} // namespace stdexec
# 56 "./../stdexec/include/stdexec/execution.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__stopped_as_optional.hpp" 1
# 32 "./../stdexec/include/stdexec/__detail/__stopped_as_optional.hpp"
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/optional" 1 3
# 34 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/optional" 3
# 54 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/optional" 3
namespace std __attribute__((__visibility__("default"))) {
# 71 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/optional" 3
  template <typename _Tp> class optional;

  struct nullopt_t {

    enum class _Construct { _Token };

    explicit constexpr nullopt_t(_Construct) noexcept {}
  };

  inline constexpr nullopt_t nullopt{nullopt_t::_Construct::_Token};

  template <typename _Fn> struct _Optional_func {
    _Fn &_M_f;
  };

  class bad_optional_access : public exception {
  public:
    bad_optional_access() = default;
    virtual ~bad_optional_access() = default;

    const char *what() const noexcept override { return "bad optional access"; }
  };

  [[__noreturn__]] inline void __throw_bad_optional_access() {
    (throw(bad_optional_access()));
  }

  template <typename _Tp> struct _Optional_payload_base {
    using _Stored_type = remove_const_t<_Tp>;

    _Optional_payload_base() = default;
    ~_Optional_payload_base() = default;

    template <typename... _Args>
    constexpr _Optional_payload_base(in_place_t __tag, _Args &&...__args)
        : _M_payload(__tag, std::forward<_Args>(__args)...), _M_engaged(true) {}

    template <typename _Up, typename... _Args>
    constexpr _Optional_payload_base(std::initializer_list<_Up> __il,
                                     _Args &&...__args)
        : _M_payload(__il, std::forward<_Args>(__args)...), _M_engaged(true) {}

    constexpr _Optional_payload_base(bool,
                                     const _Optional_payload_base &__other) {
      if (__other._M_engaged)
        this->_M_construct(__other._M_get());
    }

    constexpr _Optional_payload_base(bool, _Optional_payload_base &&__other) {
      if (__other._M_engaged)
        this->_M_construct(std::move(__other._M_get()));
    }

    _Optional_payload_base(const _Optional_payload_base &) = default;

    _Optional_payload_base(_Optional_payload_base &&) = default;

    _Optional_payload_base &operator=(const _Optional_payload_base &) = default;

    _Optional_payload_base &operator=(_Optional_payload_base &&) = default;

    constexpr void _M_copy_assign(const _Optional_payload_base &__other) {
      if (this->_M_engaged && __other._M_engaged)
        this->_M_get() = __other._M_get();
      else {
        if (__other._M_engaged)
          this->_M_construct(__other._M_get());
        else
          this->_M_reset();
      }
    }

    constexpr void _M_move_assign(_Optional_payload_base &&__other) noexcept(
        __and_v<is_nothrow_move_constructible<_Tp>,
                is_nothrow_move_assignable<_Tp>>) {
      if (this->_M_engaged && __other._M_engaged)
        this->_M_get() = std::move(__other._M_get());
      else {
        if (__other._M_engaged)
          this->_M_construct(std::move(__other._M_get()));
        else
          this->_M_reset();
      }
    }

    struct _Empty_byte {};

    template <typename _Up, bool = is_trivially_destructible_v<_Up>>
    union _Storage {
      constexpr _Storage() noexcept : _M_empty() {}

      template <typename... _Args>
      constexpr _Storage(in_place_t, _Args &&...__args)
          : _M_value(std::forward<_Args>(__args)...) {}

      template <typename _Vp, typename... _Args>
      constexpr _Storage(std::initializer_list<_Vp> __il, _Args &&...__args)
          : _M_value(__il, std::forward<_Args>(__args)...) {}

      template <typename _Fn, typename _Arg>
      constexpr _Storage(_Optional_func<_Fn> __f, _Arg &&__arg)
          : _M_value(std::__invoke(std::forward<_Fn>(__f._M_f),
                                   std::forward<_Arg>(__arg))) {}

      _Empty_byte _M_empty;
      _Up _M_value;
    };

    template <typename _Up> union _Storage<_Up, false> {
      constexpr _Storage() noexcept : _M_empty() {}

      template <typename... _Args>
      constexpr _Storage(in_place_t, _Args &&...__args)
          : _M_value(std::forward<_Args>(__args)...) {}

      template <typename _Vp, typename... _Args>
      constexpr _Storage(std::initializer_list<_Vp> __il, _Args &&...__args)
          : _M_value(__il, std::forward<_Args>(__args)...) {}

      template <typename _Fn, typename _Arg>
      constexpr _Storage(_Optional_func<_Fn> __f, _Arg &&__arg)
          : _M_value(std::__invoke(std::forward<_Fn>(__f._M_f),
                                   std::forward<_Arg>(__arg))) {}

      constexpr ~_Storage() {}

      _Empty_byte _M_empty;
      _Up _M_value;
    };

    _Storage<_Stored_type> _M_payload;

    bool _M_engaged = false;

    template <typename... _Args>
    constexpr void _M_construct(_Args &&...__args) noexcept(
        is_nothrow_constructible_v<_Stored_type, _Args...>) {
      std::_Construct(std::__addressof(this->_M_payload._M_value),
                      std::forward<_Args>(__args)...);
      this->_M_engaged = true;
    }

    constexpr void _M_destroy() noexcept {
      _M_engaged = false;
      _M_payload._M_value.~_Stored_type();
    }

    template <typename _Fn, typename _Up>
    constexpr void _M_apply(_Optional_func<_Fn> __f, _Up &&__x) {
      std::construct_at(std::__addressof(this->_M_payload), __f,
                        std::forward<_Up>(__x));
      _M_engaged = true;
    }

    constexpr _Tp &_M_get() noexcept { return this->_M_payload._M_value; }

    constexpr const _Tp &_M_get() const noexcept {
      return this->_M_payload._M_value;
    }

    constexpr void _M_reset() noexcept {
      if (this->_M_engaged)
        _M_destroy();
      else
        this->_M_engaged = false;
    }
  };

  template <typename _Tp, bool = is_trivially_destructible_v<_Tp>,
            bool = is_trivially_copy_assignable_v<_Tp> &&
                   is_trivially_copy_constructible_v<_Tp>,
            bool = is_trivially_move_assignable_v<_Tp> &&
                   is_trivially_move_constructible_v<_Tp>>
  struct _Optional_payload;

  template <typename _Tp>
  struct _Optional_payload<_Tp, true, true, true>
      : _Optional_payload_base<_Tp> {
    using _Optional_payload_base<_Tp>::_Optional_payload_base;

    _Optional_payload() = default;
  };

  template <typename _Tp>
  struct _Optional_payload<_Tp, true, false, true>
      : _Optional_payload_base<_Tp> {
    using _Optional_payload_base<_Tp>::_Optional_payload_base;

    _Optional_payload() = default;
    ~_Optional_payload() = default;
    _Optional_payload(const _Optional_payload &) = default;
    _Optional_payload(_Optional_payload &&) = default;
    _Optional_payload &operator=(_Optional_payload &&) = default;

    constexpr _Optional_payload &operator=(const _Optional_payload &__other) {
      this->_M_copy_assign(__other);
      return *this;
    }
  };

  template <typename _Tp>
  struct _Optional_payload<_Tp, true, true, false>
      : _Optional_payload_base<_Tp> {
    using _Optional_payload_base<_Tp>::_Optional_payload_base;

    _Optional_payload() = default;
    ~_Optional_payload() = default;
    _Optional_payload(const _Optional_payload &) = default;
    _Optional_payload(_Optional_payload &&) = default;
    _Optional_payload &operator=(const _Optional_payload &) = default;

    constexpr _Optional_payload &
    operator=(_Optional_payload &&__other) noexcept(
        __and_v<is_nothrow_move_constructible<_Tp>,
                is_nothrow_move_assignable<_Tp>>) {
      this->_M_move_assign(std::move(__other));
      return *this;
    }
  };

  template <typename _Tp>
  struct _Optional_payload<_Tp, true, false, false>
      : _Optional_payload_base<_Tp> {
    using _Optional_payload_base<_Tp>::_Optional_payload_base;

    _Optional_payload() = default;
    ~_Optional_payload() = default;
    _Optional_payload(const _Optional_payload &) = default;
    _Optional_payload(_Optional_payload &&) = default;

    constexpr _Optional_payload &operator=(const _Optional_payload &__other) {
      this->_M_copy_assign(__other);
      return *this;
    }

    constexpr _Optional_payload &
    operator=(_Optional_payload &&__other) noexcept(
        __and_v<is_nothrow_move_constructible<_Tp>,
                is_nothrow_move_assignable<_Tp>>) {
      this->_M_move_assign(std::move(__other));
      return *this;
    }
  };

  template <typename _Tp, bool _Copy, bool _Move>
  struct _Optional_payload<_Tp, false, _Copy, _Move>
      : _Optional_payload<_Tp, true, false, false> {

    using _Optional_payload<_Tp, true, false, false>::_Optional_payload;
    _Optional_payload() = default;
    _Optional_payload(const _Optional_payload &) = default;
    _Optional_payload(_Optional_payload &&) = default;
    _Optional_payload &operator=(const _Optional_payload &) = default;
    _Optional_payload &operator=(_Optional_payload &&) = default;

    constexpr ~_Optional_payload() { this->_M_reset(); }
  };

  template <typename _Tp, typename _Dp> class _Optional_base_impl {
  protected:
    using _Stored_type = remove_const_t<_Tp>;

    template <typename... _Args>
    constexpr void _M_construct(_Args &&...__args) noexcept(
        is_nothrow_constructible_v<_Stored_type, _Args...>) {
      static_cast<_Dp *>(this)->_M_payload._M_construct(
          std::forward<_Args>(__args)...);
    }

    constexpr void _M_destruct() noexcept {
      static_cast<_Dp *>(this)->_M_payload._M_destroy();
    }

    constexpr void _M_reset() noexcept {
      static_cast<_Dp *>(this)->_M_payload._M_reset();
    }

    constexpr bool _M_is_engaged() const noexcept {
      return static_cast<const _Dp *>(this)->_M_payload._M_engaged;
    }

    constexpr _Tp &_M_get() noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(this->_M_is_engaged()))
          __builtin_unreachable();
      } while (false);
      return static_cast<_Dp *>(this)->_M_payload._M_get();
    }

    constexpr const _Tp &_M_get() const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(this->_M_is_engaged()))
          __builtin_unreachable();
      } while (false);
      return static_cast<const _Dp *>(this)->_M_payload._M_get();
    }
  };
# 509 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/optional" 3
  template <typename _Tp, bool = is_trivially_copy_constructible_v<_Tp>,
            bool = is_trivially_move_constructible_v<_Tp>>
  struct _Optional_base : _Optional_base_impl<_Tp, _Optional_base<_Tp>> {

    constexpr _Optional_base() = default;

    template <typename... _Args,
              enable_if_t<is_constructible_v<_Tp, _Args...>, bool> = false>
    constexpr explicit _Optional_base(in_place_t, _Args &&...__args)
        : _M_payload(in_place, std::forward<_Args>(__args)...) {}

    template <
        typename _Up, typename... _Args,
        enable_if_t<is_constructible_v<_Tp, initializer_list<_Up> &, _Args...>,
                    bool> = false>
    constexpr explicit _Optional_base(in_place_t, initializer_list<_Up> __il,
                                      _Args &&...__args)
        : _M_payload(in_place, __il, std::forward<_Args>(__args)...) {}

    constexpr _Optional_base(const _Optional_base &__other)
        : _M_payload(__other._M_payload._M_engaged, __other._M_payload) {}

    constexpr _Optional_base(_Optional_base &&__other) noexcept(
        is_nothrow_move_constructible_v<_Tp>)
        : _M_payload(__other._M_payload._M_engaged,
                     std::move(__other._M_payload)) {}

    _Optional_base &operator=(const _Optional_base &) = default;
    _Optional_base &operator=(_Optional_base &&) = default;

    _Optional_payload<_Tp> _M_payload;
  };

  template <typename _Tp>
  struct _Optional_base<_Tp, false, true>
      : _Optional_base_impl<_Tp, _Optional_base<_Tp>> {

    constexpr _Optional_base() = default;

    template <typename... _Args,
              enable_if_t<is_constructible_v<_Tp, _Args...>, bool> = false>
    constexpr explicit _Optional_base(in_place_t, _Args &&...__args)
        : _M_payload(in_place, std::forward<_Args>(__args)...) {}

    template <
        typename _Up, typename... _Args,
        enable_if_t<is_constructible_v<_Tp, initializer_list<_Up> &, _Args...>,
                    bool> = false>
    constexpr explicit _Optional_base(in_place_t, initializer_list<_Up> __il,
                                      _Args... __args)
        : _M_payload(in_place, __il, std::forward<_Args>(__args)...) {}

    constexpr _Optional_base(const _Optional_base &__other)
        : _M_payload(__other._M_payload._M_engaged, __other._M_payload) {}

    constexpr _Optional_base(_Optional_base &&__other) = default;

    _Optional_base &operator=(const _Optional_base &) = default;
    _Optional_base &operator=(_Optional_base &&) = default;

    _Optional_payload<_Tp> _M_payload;
  };

  template <typename _Tp>
  struct _Optional_base<_Tp, true, false>
      : _Optional_base_impl<_Tp, _Optional_base<_Tp>> {

    constexpr _Optional_base() = default;

    template <typename... _Args,
              enable_if_t<is_constructible_v<_Tp, _Args...>, bool> = false>
    constexpr explicit _Optional_base(in_place_t, _Args &&...__args)
        : _M_payload(in_place, std::forward<_Args>(__args)...) {}

    template <
        typename _Up, typename... _Args,
        enable_if_t<is_constructible_v<_Tp, initializer_list<_Up> &, _Args...>,
                    bool> = false>
    constexpr explicit _Optional_base(in_place_t, initializer_list<_Up> __il,
                                      _Args &&...__args)
        : _M_payload(in_place, __il, std::forward<_Args>(__args)...) {}

    constexpr _Optional_base(const _Optional_base &__other) = default;

    constexpr _Optional_base(_Optional_base &&__other) noexcept(
        is_nothrow_move_constructible_v<_Tp>)
        : _M_payload(__other._M_payload._M_engaged,
                     std::move(__other._M_payload)) {}

    _Optional_base &operator=(const _Optional_base &) = default;
    _Optional_base &operator=(_Optional_base &&) = default;

    _Optional_payload<_Tp> _M_payload;
  };

  template <typename _Tp>
  struct _Optional_base<_Tp, true, true>
      : _Optional_base_impl<_Tp, _Optional_base<_Tp>> {

    constexpr _Optional_base() = default;

    template <typename... _Args,
              enable_if_t<is_constructible_v<_Tp, _Args...>, bool> = false>
    constexpr explicit _Optional_base(in_place_t, _Args &&...__args)
        : _M_payload(in_place, std::forward<_Args>(__args)...) {}

    template <
        typename _Up, typename... _Args,
        enable_if_t<is_constructible_v<_Tp, initializer_list<_Up> &, _Args...>,
                    bool> = false>
    constexpr explicit _Optional_base(in_place_t, initializer_list<_Up> __il,
                                      _Args &&...__args)
        : _M_payload(in_place, __il, std::forward<_Args>(__args)...) {}

    constexpr _Optional_base(const _Optional_base &__other) = default;
    constexpr _Optional_base(_Optional_base &&__other) = default;

    _Optional_base &operator=(const _Optional_base &) = default;
    _Optional_base &operator=(_Optional_base &&) = default;

    _Optional_payload<_Tp> _M_payload;
  };

  template <typename _Tp> class optional;

  template <typename _Tp> inline constexpr bool __is_optional_v = false;
  template <typename _Tp>
  inline constexpr bool __is_optional_v<optional<_Tp>> = true;

  template <typename _Tp, typename _Up>
  using __converts_from_optional =
      __or_<is_constructible<_Tp, const optional<_Up> &>,
            is_constructible<_Tp, optional<_Up> &>,
            is_constructible<_Tp, const optional<_Up> &&>,
            is_constructible<_Tp, optional<_Up> &&>,
            is_convertible<const optional<_Up> &, _Tp>,
            is_convertible<optional<_Up> &, _Tp>,
            is_convertible<const optional<_Up> &&, _Tp>,
            is_convertible<optional<_Up> &&, _Tp>>;

  template <typename _Tp, typename _Up>
  using __assigns_from_optional =
      __or_<is_assignable<_Tp &, const optional<_Up> &>,
            is_assignable<_Tp &, optional<_Up> &>,
            is_assignable<_Tp &, const optional<_Up> &&>,
            is_assignable<_Tp &, optional<_Up> &&>>;

  template <typename _Tp>
  class optional
      : private _Optional_base<_Tp>,
        private _Enable_copy_move<

            is_copy_constructible_v<_Tp>,

            __and_v<is_copy_constructible<_Tp>, is_copy_assignable<_Tp>>,

            is_move_constructible_v<_Tp>,

            __and_v<is_move_constructible<_Tp>, is_move_assignable<_Tp>>,

            optional<_Tp>> {
    static_assert(!is_same_v<remove_cv_t<_Tp>, nullopt_t>);
    static_assert(!is_same_v<remove_cv_t<_Tp>, in_place_t>);
    static_assert(is_object_v<_Tp> && !is_array_v<_Tp>);

  private:
    using _Base = _Optional_base<_Tp>;

    template <typename _Up>
    using __not_self = __not_<is_same<optional, __remove_cvref_t<_Up>>>;
    template <typename _Up>
    using __not_tag = __not_<is_same<in_place_t, __remove_cvref_t<_Up>>>;
    template <typename... _Cond>
    using _Requires = enable_if_t<__and_v<_Cond...>, bool>;

  public:
    using value_type = _Tp;

    constexpr optional() noexcept {}

    constexpr optional(nullopt_t) noexcept {}

    template <typename _Up = _Tp, _Requires<__not_self<_Up>, __not_tag<_Up>,
                                            is_constructible<_Tp, _Up>,
                                            is_convertible<_Up, _Tp>> = true>
    constexpr optional(_Up &&__t) noexcept(is_nothrow_constructible_v<_Tp, _Up>)
        : _Base(std::in_place, std::forward<_Up>(__t)) {}

    template <
        typename _Up = _Tp,
        _Requires<__not_self<_Up>, __not_tag<_Up>, is_constructible<_Tp, _Up>,
                  __not_<is_convertible<_Up, _Tp>>> = false>
    explicit constexpr optional(_Up &&__t) noexcept(
        is_nothrow_constructible_v<_Tp, _Up>)
        : _Base(std::in_place, std::forward<_Up>(__t)) {}

    template <
        typename _Up,
        _Requires<__not_<is_same<_Tp, _Up>>, is_constructible<_Tp, const _Up &>,
                  is_convertible<const _Up &, _Tp>,
                  __not_<__converts_from_optional<_Tp, _Up>>> = true>
    constexpr optional(const optional<_Up> &__t) noexcept(
        is_nothrow_constructible_v<_Tp, const _Up &>) {
      if (__t)
        emplace(*__t);
    }

    template <
        typename _Up,
        _Requires<__not_<is_same<_Tp, _Up>>, is_constructible<_Tp, const _Up &>,
                  __not_<is_convertible<const _Up &, _Tp>>,
                  __not_<__converts_from_optional<_Tp, _Up>>> = false>
    explicit constexpr optional(const optional<_Up> &__t) noexcept(
        is_nothrow_constructible_v<_Tp, const _Up &>) {
      if (__t)
        emplace(*__t);
    }

    template <typename _Up,
              _Requires<__not_<is_same<_Tp, _Up>>, is_constructible<_Tp, _Up>,
                        is_convertible<_Up, _Tp>,
                        __not_<__converts_from_optional<_Tp, _Up>>> = true>
    constexpr optional(optional<_Up> &&__t) noexcept(
        is_nothrow_constructible_v<_Tp, _Up>) {
      if (__t)
        emplace(std::move(*__t));
    }

    template <typename _Up,
              _Requires<__not_<is_same<_Tp, _Up>>, is_constructible<_Tp, _Up>,
                        __not_<is_convertible<_Up, _Tp>>,
                        __not_<__converts_from_optional<_Tp, _Up>>> = false>
    explicit constexpr optional(optional<_Up> &&__t) noexcept(
        is_nothrow_constructible_v<_Tp, _Up>) {
      if (__t)
        emplace(std::move(*__t));
    }

    template <typename... _Args,
              _Requires<is_constructible<_Tp, _Args...>> = false>
    explicit constexpr optional(in_place_t, _Args &&...__args) noexcept(
        is_nothrow_constructible_v<_Tp, _Args...>)
        : _Base(std::in_place, std::forward<_Args>(__args)...) {}

    template <typename _Up, typename... _Args,
              _Requires<is_constructible<_Tp, initializer_list<_Up> &,
                                         _Args...>> = false>
    explicit constexpr optional(
        in_place_t, initializer_list<_Up> __il,
        _Args &&...__args) noexcept(is_nothrow_constructible_v<_Tp,
                                                               initializer_list<
                                                                   _Up> &,
                                                               _Args...>)
        : _Base(std::in_place, __il, std::forward<_Args>(__args)...) {}

    constexpr optional &operator=(nullopt_t) noexcept {
      this->_M_reset();
      return *this;
    }

    template <typename _Up = _Tp>
    constexpr enable_if_t<
        __and_v<__not_self<_Up>,
                __not_<__and_<is_scalar<_Tp>, is_same<_Tp, decay_t<_Up>>>>,
                is_constructible<_Tp, _Up>, is_assignable<_Tp &, _Up>>,
        optional &>
    operator=(_Up &&__u) noexcept(__and_v<is_nothrow_constructible<_Tp, _Up>,
                                          is_nothrow_assignable<_Tp &, _Up>>) {
      if (this->_M_is_engaged())
        this->_M_get() = std::forward<_Up>(__u);
      else
        this->_M_construct(std::forward<_Up>(__u));

      return *this;
    }

    template <typename _Up>
    constexpr enable_if_t<
        __and_v<__not_<is_same<_Tp, _Up>>, is_constructible<_Tp, const _Up &>,
                is_assignable<_Tp &, const _Up &>,
                __not_<__converts_from_optional<_Tp, _Up>>,
                __not_<__assigns_from_optional<_Tp, _Up>>>,
        optional &>
    operator=(const optional<_Up> &__u) noexcept(
        __and_v<is_nothrow_constructible<_Tp, const _Up &>,
                is_nothrow_assignable<_Tp &, const _Up &>>) {
      if (__u) {
        if (this->_M_is_engaged())
          this->_M_get() = *__u;
        else
          this->_M_construct(*__u);
      } else {
        this->_M_reset();
      }
      return *this;
    }

    template <typename _Up>
    constexpr enable_if_t<
        __and_v<__not_<is_same<_Tp, _Up>>, is_constructible<_Tp, _Up>,
                is_assignable<_Tp &, _Up>,
                __not_<__converts_from_optional<_Tp, _Up>>,
                __not_<__assigns_from_optional<_Tp, _Up>>>,
        optional &>
    operator=(optional<_Up> &&__u) noexcept(
        __and_v<is_nothrow_constructible<_Tp, _Up>,
                is_nothrow_assignable<_Tp &, _Up>>) {
      if (__u) {
        if (this->_M_is_engaged())
          this->_M_get() = std::move(*__u);
        else
          this->_M_construct(std::move(*__u));
      } else {
        this->_M_reset();
      }

      return *this;
    }

    template <typename... _Args>
    constexpr enable_if_t<is_constructible_v<_Tp, _Args...>, _Tp &> emplace(
        _Args &&...__args) noexcept(is_nothrow_constructible_v<_Tp, _Args...>) {
      this->_M_reset();
      this->_M_construct(std::forward<_Args>(__args)...);
      return this->_M_get();
    }

    template <typename _Up, typename... _Args>
    constexpr enable_if_t<
        is_constructible_v<_Tp, initializer_list<_Up> &, _Args...>, _Tp &>
    emplace(initializer_list<_Up> __il, _Args &&...__args) noexcept(
        is_nothrow_constructible_v<_Tp, initializer_list<_Up> &, _Args...>) {
      this->_M_reset();
      this->_M_construct(__il, std::forward<_Args>(__args)...);
      return this->_M_get();
    }

    constexpr void
    swap(optional &__other) noexcept(is_nothrow_move_constructible_v<_Tp> &&
                                     is_nothrow_swappable_v<_Tp>) {
      using std::swap;

      if (this->_M_is_engaged() && __other._M_is_engaged())
        swap(this->_M_get(), __other._M_get());
      else if (this->_M_is_engaged()) {
        __other._M_construct(std::move(this->_M_get()));
        this->_M_destruct();
      } else if (__other._M_is_engaged()) {
        this->_M_construct(std::move(__other._M_get()));
        __other._M_destruct();
      }
    }

    constexpr const _Tp *operator->() const noexcept {
      return std::__addressof(this->_M_get());
    }

    constexpr _Tp *operator->() noexcept {
      return std::__addressof(this->_M_get());
    }

    constexpr const _Tp &operator*() const & noexcept { return this->_M_get(); }

    constexpr _Tp &operator*() & noexcept { return this->_M_get(); }

    constexpr _Tp &&operator*() && noexcept {
      return std::move(this->_M_get());
    }

    constexpr const _Tp &&operator*() const && noexcept {
      return std::move(this->_M_get());
    }

    constexpr explicit operator bool() const noexcept {
      return this->_M_is_engaged();
    }

    constexpr bool has_value() const noexcept { return this->_M_is_engaged(); }

    constexpr const _Tp &value() const & {
      if (this->_M_is_engaged())
        return this->_M_get();
      __throw_bad_optional_access();
    }

    constexpr _Tp &value() & {
      if (this->_M_is_engaged())
        return this->_M_get();
      __throw_bad_optional_access();
    }

    constexpr _Tp &&value() && {
      if (this->_M_is_engaged())
        return std::move(this->_M_get());
      __throw_bad_optional_access();
    }

    constexpr const _Tp &&value() const && {
      if (this->_M_is_engaged())
        return std::move(this->_M_get());
      __throw_bad_optional_access();
    }

    template <typename _Up> constexpr _Tp value_or(_Up &&__u) const & {
      static_assert(is_copy_constructible_v<_Tp>);
      static_assert(is_convertible_v<_Up &&, _Tp>);

      if (this->_M_is_engaged())
        return this->_M_get();
      else
        return static_cast<_Tp>(std::forward<_Up>(__u));
    }

    template <typename _Up> constexpr _Tp value_or(_Up &&__u) && {
      static_assert(is_move_constructible_v<_Tp>);
      static_assert(is_convertible_v<_Up &&, _Tp>);

      if (this->_M_is_engaged())
        return std::move(this->_M_get());
      else
        return static_cast<_Tp>(std::forward<_Up>(__u));
    }
# 1184 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/optional" 3
    constexpr void reset() noexcept { this->_M_reset(); }

  private:
    template <typename _Up> friend class optional;

    template <typename _Fn, typename _Value>
    explicit constexpr optional(_Optional_func<_Fn> __f, _Value &&__v) {
      this->_M_payload._M_apply(__f, std::forward<_Value>(__v));
    }
  };

  template <typename _Tp>
  using __optional_relop_t =
      enable_if_t<is_convertible<_Tp, bool>::value, bool>;

  template <typename _Tp, typename _Up>
  using __optional_eq_t =
      __optional_relop_t<decltype(std::declval<const _Tp &>() ==
                                  std::declval<const _Up &>())>;

  template <typename _Tp, typename _Up>
  using __optional_ne_t =
      __optional_relop_t<decltype(std::declval<const _Tp &>() !=
                                  std::declval<const _Up &>())>;

  template <typename _Tp, typename _Up>
  using __optional_lt_t =
      __optional_relop_t<decltype(std::declval<const _Tp &>() <
                                  std::declval<const _Up &>())>;

  template <typename _Tp, typename _Up>
  using __optional_gt_t =
      __optional_relop_t<decltype(std::declval<const _Tp &>() >
                                  std::declval<const _Up &>())>;

  template <typename _Tp, typename _Up>
  using __optional_le_t =
      __optional_relop_t<decltype(std::declval<const _Tp &>() <=
                                  std::declval<const _Up &>())>;

  template <typename _Tp, typename _Up>
  using __optional_ge_t =
      __optional_relop_t<decltype(std::declval<const _Tp &>() >=
                                  std::declval<const _Up &>())>;

  template <typename _Tp, typename _Up>
  constexpr auto operator==(const optional<_Tp> &__lhs,
                            const optional<_Up> &__rhs)
      ->__optional_eq_t<_Tp, _Up> {
    return static_cast<bool>(__lhs) == static_cast<bool>(__rhs) &&
           (!__lhs || *__lhs == *__rhs);
  }

  template <typename _Tp, typename _Up>
  constexpr auto operator!=(const optional<_Tp> &__lhs,
                            const optional<_Up> &__rhs)
      ->__optional_ne_t<_Tp, _Up> {
    return static_cast<bool>(__lhs) != static_cast<bool>(__rhs) ||
           (static_cast<bool>(__lhs) && *__lhs != *__rhs);
  }

  template <typename _Tp, typename _Up>
  constexpr auto operator<(const optional<_Tp> &__lhs,
                           const optional<_Up> &__rhs)
      ->__optional_lt_t<_Tp, _Up> {
    return static_cast<bool>(__rhs) && (!__lhs || *__lhs < *__rhs);
  }

  template <typename _Tp, typename _Up>
  constexpr auto operator>(const optional<_Tp> &__lhs,
                           const optional<_Up> &__rhs)
      ->__optional_gt_t<_Tp, _Up> {
    return static_cast<bool>(__lhs) && (!__rhs || *__lhs > *__rhs);
  }

  template <typename _Tp, typename _Up>
  constexpr auto operator<=(const optional<_Tp> &__lhs,
                            const optional<_Up> &__rhs)
      ->__optional_le_t<_Tp, _Up> {
    return !__lhs || (static_cast<bool>(__rhs) && *__lhs <= *__rhs);
  }

  template <typename _Tp, typename _Up>
  constexpr auto operator>=(const optional<_Tp> &__lhs,
                            const optional<_Up> &__rhs)
      ->__optional_ge_t<_Tp, _Up> {
    return !__rhs || (static_cast<bool>(__lhs) && *__lhs >= *__rhs);
  }

  template <typename _Tp, three_way_comparable_with<_Tp> _Up>
  constexpr compare_three_way_result_t<_Tp, _Up> operator<=>(
      const optional<_Tp> &__x, const optional<_Up> &__y) {
    return __x && __y ? *__x <=> *__y : bool(__x) <=> bool(__y);
  }

  template <typename _Tp>
  constexpr bool operator==(const optional<_Tp> &__lhs, nullopt_t) noexcept {
    return !__lhs;
  }

  template <typename _Tp>
  constexpr strong_ordering operator<=>(const optional<_Tp> &__x,
                                        nullopt_t) noexcept {
    return bool(__x) <=> false;
  }
# 1362 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/optional" 3
  template <typename _Tp, typename _Up>
  constexpr auto operator==(const optional<_Tp> &__lhs, const _Up &__rhs)
      ->__optional_eq_t<_Tp, _Up> {
    return __lhs && *__lhs == __rhs;
  }

  template <typename _Tp, typename _Up>
  constexpr auto operator==(const _Up &__lhs, const optional<_Tp> &__rhs)
      ->__optional_eq_t<_Up, _Tp> {
    return __rhs && __lhs == *__rhs;
  }

  template <typename _Tp, typename _Up>
  constexpr auto operator!=(const optional<_Tp> &__lhs, const _Up &__rhs)
      ->__optional_ne_t<_Tp, _Up> {
    return !__lhs || *__lhs != __rhs;
  }

  template <typename _Tp, typename _Up>
  constexpr auto operator!=(const _Up &__lhs, const optional<_Tp> &__rhs)
      ->__optional_ne_t<_Up, _Tp> {
    return !__rhs || __lhs != *__rhs;
  }

  template <typename _Tp, typename _Up>
  constexpr auto operator<(const optional<_Tp> &__lhs, const _Up &__rhs)
      ->__optional_lt_t<_Tp, _Up> {
    return !__lhs || *__lhs < __rhs;
  }

  template <typename _Tp, typename _Up>
  constexpr auto operator<(const _Up &__lhs, const optional<_Tp> &__rhs)
      ->__optional_lt_t<_Up, _Tp> {
    return __rhs && __lhs < *__rhs;
  }

  template <typename _Tp, typename _Up>
  constexpr auto operator>(const optional<_Tp> &__lhs, const _Up &__rhs)
      ->__optional_gt_t<_Tp, _Up> {
    return __lhs && *__lhs > __rhs;
  }

  template <typename _Tp, typename _Up>
  constexpr auto operator>(const _Up &__lhs, const optional<_Tp> &__rhs)
      ->__optional_gt_t<_Up, _Tp> {
    return !__rhs || __lhs > *__rhs;
  }

  template <typename _Tp, typename _Up>
  constexpr auto operator<=(const optional<_Tp> &__lhs, const _Up &__rhs)
      ->__optional_le_t<_Tp, _Up> {
    return !__lhs || *__lhs <= __rhs;
  }

  template <typename _Tp, typename _Up>
  constexpr auto operator<=(const _Up &__lhs, const optional<_Tp> &__rhs)
      ->__optional_le_t<_Up, _Tp> {
    return __rhs && __lhs <= *__rhs;
  }

  template <typename _Tp, typename _Up>
  constexpr auto operator>=(const optional<_Tp> &__lhs, const _Up &__rhs)
      ->__optional_ge_t<_Tp, _Up> {
    return __lhs && *__lhs >= __rhs;
  }

  template <typename _Tp, typename _Up>
  constexpr auto operator>=(const _Up &__lhs, const optional<_Tp> &__rhs)
      ->__optional_ge_t<_Up, _Tp> {
    return !__rhs || __lhs >= *__rhs;
  }

  template <typename _Tp, typename _Up>
    requires(!__is_optional_v<_Up>) && three_way_comparable_with<_Up, _Tp>
  constexpr compare_three_way_result_t<_Tp, _Up> operator<=>(
      const optional<_Tp> &__x, const _Up &__v) {
    return bool(__x) ? *__x <=> __v : strong_ordering::less;
  }

  template <typename _Tp>
  constexpr inline enable_if_t<is_move_constructible_v<_Tp> &&
                               is_swappable_v<_Tp>>
  swap(optional<_Tp> & __lhs,
       optional<_Tp> & __rhs) noexcept(noexcept(__lhs.swap(__rhs))) {
    __lhs.swap(__rhs);
  }

  template <typename _Tp>
  enable_if_t<!(is_move_constructible_v<_Tp> && is_swappable_v<_Tp>)> swap(
      optional<_Tp> &, optional<_Tp> &) = delete;

  template <typename _Tp>
  constexpr enable_if_t<is_constructible_v<decay_t<_Tp>, _Tp>,
                        optional<decay_t<_Tp>>>
  make_optional(_Tp && __t) noexcept(
      is_nothrow_constructible_v<optional<decay_t<_Tp>>, _Tp>) {
    return optional<decay_t<_Tp>>{std::forward<_Tp>(__t)};
  }

  template <typename _Tp, typename... _Args>
  constexpr enable_if_t<is_constructible_v<_Tp, _Args...>, optional<_Tp>>
  make_optional(_Args &&
                ...__args) noexcept(is_nothrow_constructible_v<_Tp, _Args...>) {
    return optional<_Tp>{in_place, std::forward<_Args>(__args)...};
  }

  template <typename _Tp, typename _Up, typename... _Args>
  constexpr enable_if_t<
      is_constructible_v<_Tp, initializer_list<_Up> &, _Args...>, optional<_Tp>>
  make_optional(initializer_list<_Up> __il, _Args && ...__args) noexcept(
      is_nothrow_constructible_v<_Tp, initializer_list<_Up> &, _Args...>) {
    return optional<_Tp>{in_place, __il, std::forward<_Args>(__args)...};
  }

  template <typename _Tp, typename _Up = remove_const_t<_Tp>,
            bool = __poison_hash<_Up>::__enable_hash_call>
  struct __optional_hash_call_base {
    size_t operator()(const optional<_Tp> &__t) const
        noexcept(noexcept(hash<_Up>{}(*__t))) {

      constexpr size_t __magic_disengaged_hash = static_cast<size_t>(-3333);
      return __t ? hash<_Up>{}(*__t) : __magic_disengaged_hash;
    }
  };

  template <typename _Tp, typename _Up>
  struct __optional_hash_call_base<_Tp, _Up, false> {};

  template <typename _Tp>
  struct hash<optional<_Tp>> : private __poison_hash<remove_const_t<_Tp>>,
                               public __optional_hash_call_base<_Tp> {
    using result_type [[__deprecated__]] = size_t;
    using argument_type [[__deprecated__]] = optional<_Tp>;
  };

  template <typename _Tp>
  struct __is_fast_hash<hash<optional<_Tp>>> : __is_fast_hash<hash<_Tp>> {};

  template <typename _Tp> optional(_Tp) -> optional<_Tp>;

} // namespace std
# 33 "./../stdexec/include/stdexec/__detail/__stopped_as_optional.hpp" 2

namespace stdexec {

namespace __sao {
struct _SENDER_MUST_HAVE_EXACTLY_ONE_VALUE_COMPLETION_WITH_ONE_ARGUMENT_;

struct stopped_as_optional_t {
  template <sender _Sender> auto operator()(_Sender &&__sndr) const {
    return __make_sexpr<stopped_as_optional_t>(__(),
                                               static_cast<_Sender &&>(__sndr));
  }

  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline

      auto
      operator()() const noexcept -> __binder_back<stopped_as_optional_t> {
    return {{}, {}, {}};
  }
};

struct __stopped_as_optional_impl : __sexpr_defaults {
  template <class... _Tys>
    requires(sizeof...(_Tys) == 1)
  using __set_value_t =
      completion_signatures<set_value_t(std::optional<__decay_t<_Tys>>...)>;

  template <class _Ty>
  using __set_error_t = completion_signatures<set_error_t(_Ty)>;

  static constexpr auto get_completion_signatures =
      []<class _Self, class... _Env>(_Self &&, _Env &&...) noexcept
    requires __mvalid<__completion_signatures_of_t, __child_of<_Self>, _Env...>
  {
    static_assert(sender_expr_for<_Self, stopped_as_optional_t>);
    using _Completions =
        __completion_signatures_of_t<__child_of<_Self>, _Env...>;
    if constexpr (!__valid_completion_signatures<_Completions>) {
      return _Completions();
    } else if constexpr (__single_value_sender<__child_of<_Self>, _Env...>) {
      return transform_completion_signatures<
          _Completions, completion_signatures<set_error_t(std::exception_ptr)>,
          __set_value_t, __set_error_t, completion_signatures<>>();
    } else {
      return _ERROR_<
          _WHAT_<>(
              _SENDER_MUST_HAVE_EXACTLY_ONE_VALUE_COMPLETION_WITH_ONE_ARGUMENT_),
          _IN_ALGORITHM_(stopped_as_optional_t),
          _WITH_SENDER_<__child_of<_Self>>>();
    }
  };

  static constexpr auto get_state =
      []<class _Self, class _Receiver>(_Self &&, _Receiver &) noexcept {
        static_assert(sender_expr_for<_Self, stopped_as_optional_t>);
        using _Value = __decay_t<
            __single_sender_value_t<__child_of<_Self>, env_of_t<_Receiver>>>;
        return __mtype<_Value>();
      };

  static constexpr auto complete =
      []<class _State, class _Receiver, class _Tag, class... _Args>(
          __ignore, _State &, _Receiver &__rcvr, _Tag,
          _Args &&...__args) noexcept -> void {
    if constexpr (__same_as<_Tag, set_value_t>) {
      try {
        static_assert(constructible_from<__t<_State>, _Args...>);
        stdexec::set_value(
            static_cast<_Receiver &&>(__rcvr),
            std::optional<__t<_State>>{static_cast<_Args &&>(__args)...});
      } catch (...) {
        stdexec::set_error(static_cast<_Receiver &&>(__rcvr),
                           std::current_exception());
      }
    } else if constexpr (__same_as<_Tag, set_error_t>) {
      stdexec::set_error(static_cast<_Receiver &&>(__rcvr),
                         static_cast<_Args &&>(__args)...);
    } else {
      stdexec::set_value(static_cast<_Receiver &&>(__rcvr),
                         std::optional<__t<_State>>{std::nullopt});
    }
  };
};
} // namespace __sao

using __sao::stopped_as_optional_t;
inline constexpr stopped_as_optional_t stopped_as_optional{};

template <>
struct __sexpr_impl<stopped_as_optional_t> : __sao::__stopped_as_optional_impl {
};
} // namespace stdexec
# 57 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__sync_wait.hpp" 1
# 41 "./../stdexec/include/stdexec/__detail/__sync_wait.hpp"
namespace stdexec {

namespace __sync_wait {
struct __env {
  using __t = __env;
  using __id = __env;

  run_loop *__loop_ = nullptr;

  [[nodiscard]]
  auto query(get_scheduler_t) const noexcept -> run_loop::__scheduler {
    return __loop_->get_scheduler();
  }

  [[nodiscard]]
  auto
  query(get_delegation_scheduler_t) const noexcept -> run_loop::__scheduler {
    return __loop_->get_scheduler();
  }
};

template <class _Sender, class _Continuation>
using __sync_wait_result_impl =
    __value_types_of_t<_Sender, __env,
                       __mtransform<__q<__decay_t>, _Continuation>,
                       __q<__msingle>>;

template <class _Sender>
using __sync_wait_result_t =
    __mtry_eval<__sync_wait_result_impl, _Sender, __qq<std::tuple>>;

template <class _Sender>
using __sync_wait_with_variant_result_t =
    __mtry_eval<__sync_wait_result_impl, __result_of<into_variant, _Sender>,
                __q<__midentity>>;

struct __state {
  std::exception_ptr __eptr_;
  run_loop __loop_;
};

template <class... _Values> struct __receiver {
  struct __t {
    using receiver_concept = receiver_t;
    using __id = __receiver;
    __state *__state_;
    std::optional<std::tuple<_Values...>> *__values_;

    template <class... _As>
      requires constructible_from<std::tuple<_Values...>, _As...>
    void set_value(_As &&...__as) noexcept {
      try {
        __values_->emplace(static_cast<_As &&>(__as)...);
      } catch (...) {
        __state_->__eptr_ = std::current_exception();
      }
      __state_->__loop_.finish();
    }

    template <class _Error> void set_error(_Error __err) noexcept {
      if constexpr (__same_as<_Error, std::exception_ptr>) {
        do {
          static_assert(noexcept(__err != nullptr));
          (static_cast<bool>(__err != nullptr)
               ? void(0)
               : __assert_fail("__err != nullptr", __builtin_FILE(),
                               __builtin_LINE(),
                               __extension__ __PRETTY_FUNCTION__));
        } while (false);
        __state_->__eptr_ = static_cast<_Error &&>(__err);
      } else if constexpr (__same_as<_Error, std::error_code>) {
        __state_->__eptr_ = std::make_exception_ptr(std::system_error(__err));
      } else {
        __state_->__eptr_ =
            std::make_exception_ptr(static_cast<_Error &&>(__err));
      }
      __state_->__loop_.finish();
    }

    void set_stopped() noexcept { __state_->__loop_.finish(); }

    [[nodiscard]]
    auto get_env() const noexcept -> __env {
      return __env{&__state_->__loop_};
    }
  };
};

template <class _Sender>
using __receiver_t = __t<__sync_wait_result_impl<_Sender, __q<__receiver>>>;

template <class _Sender> struct __sync_receiver_for {
  using __t = __receiver_t<_Sender>;
};
template <class _Sender>
using __sync_receiver_for_t = __t<__sync_receiver_for<_Sender>>;

template <class _Sender> struct __value_tuple_for {
  using __t = __sync_wait_result_t<_Sender>;
};
template <class _Sender>
using __value_tuple_for_t = __t<__value_tuple_for<_Sender>>;

template <class _Sender> struct __variant_for {
  using __t = __sync_wait_with_variant_result_t<_Sender>;
};
template <class _Sender> using __variant_for_t = __t<__variant_for<_Sender>>;

inline constexpr __mstring __sync_wait_context_diag =
    "In stdexec::sync_wait()..."_mstr;
inline constexpr __mstring __too_many_successful_completions_diag =
    "The argument to stdexec::sync_wait() is a sender that can complete "
    "successfully in more "
    "than one way. Use stdexec::sync_wait_with_variant() instead."_mstr;

template <__mstring _Context, __mstring _Diagnostic>
struct _INVALID_ARGUMENT_TO_SYNC_WAIT_;

template <__mstring _Diagnostic>
using __invalid_argument_to_sync_wait =
    _INVALID_ARGUMENT_TO_SYNC_WAIT_<__sync_wait_context_diag, _Diagnostic>;

template <__mstring _Diagnostic, class _Sender, class _Env = __env>
using __sync_wait_error =
    __mexception<__invalid_argument_to_sync_wait<_Diagnostic>,
                 _WITH_SENDER_<_Sender>, _WITH_ENVIRONMENT_<_Env>>;

template <class _Sender, class>
using __too_many_successful_completions_error =
    __sync_wait_error<__too_many_successful_completions_diag, _Sender>;

template <class _Sender>
concept __valid_sync_wait_argument =
    __ok<__minvoke<__mtry_catch_q<__single_value_variant_sender_t,
                                  __q<__too_many_successful_completions_error>>,
                   _Sender, __env>>;

struct sync_wait_t {
  template <class _Sender> auto operator()(_Sender &&__sndr) const {
    if constexpr (!sender_in<_Sender, __env>) {
      stdexec::__diagnose_sender_concept_failure<_Sender, __env>();
    } else {
      using __early_domain_t = __early_domain_of_t<_Sender>;
      using __domain_t = __late_domain_of_t<_Sender, __env, __early_domain_t>;
      constexpr auto __success_completion_count =
          __v<value_types_of_t<_Sender, __env, __types, __msize::__f>>;
      static_assert(__success_completion_count != 0,
                    "The argument to stdexec::sync_wait() is a sender that "
                    "cannot complete successfully. "
                    "stdexec::sync_wait() requires a sender that can complete "
                    "successfully in exactly one "
                    "way. In other words, the sender's completion signatures "
                    "must include exactly one "
                    "signature of the form `set_value_t(value-types...)`.");
      static_assert(
          __success_completion_count <= 1,
          "The sender passed to stdexec::sync_wait() can complete successfully "
          "in "
          "more than one way. Use stdexec::sync_wait_with_variant() instead.");
      if constexpr (1 == __success_completion_count) {
        using __sync_wait_receiver = __receiver_t<_Sender>;
        constexpr bool __no_custom_sync_wait =
            __same_as<__domain_t, default_domain>;
        if constexpr (__no_custom_sync_wait &&
                      sender_to<_Sender, __sync_wait_receiver>) {
# 220 "./../stdexec/include/stdexec/__detail/__sync_wait.hpp"
          {

            return default_domain().apply_sender(
                *this, static_cast<_Sender &&>(__sndr));
          }
        } else if constexpr (__no_custom_sync_wait) {
          static_assert(sender_to<_Sender, __sync_wait_receiver>,
                        "The sender passed to stdexec::sync_wait() does not "
                        "have a .connect(<receiver>) "
                        "member function that accepts sync_wait's receiver.");
        } else if constexpr (!__has_implementation_for<sync_wait_t, __domain_t,
                                                       _Sender>) {
          static_assert(
              __has_implementation_for<sync_wait_t, __domain_t, _Sender>,
              "The sender passed to stdexec::sync_wait() has a domain that "
              "does not provide a "
              "usable implementation for sync_wait().");
        } else {

          return stdexec::apply_sender(__domain_t(), *this,
                                       static_cast<_Sender &&>(__sndr));
        }
      }
    }
  }
# 268 "./../stdexec/include/stdexec/__detail/__sync_wait.hpp"
  template <sender_in<__env> _Sender>
  auto apply_sender(_Sender &&__sndr) const
      -> std::optional<__sync_wait_result_t<_Sender>> {
    __state __local_state{};
    std::optional<__sync_wait_result_t<_Sender>> __result{};

    [[maybe_unused]]
    auto __op =
        stdexec::connect(static_cast<_Sender &&>(__sndr),
                         __receiver_t<_Sender>{&__local_state, &__result});
    stdexec::start(__op);

    __local_state.__loop_.run();

    if (__local_state.__eptr_) {
      std::rethrow_exception(
          static_cast<std::exception_ptr &&>(__local_state.__eptr_));
    }

    return __result;
  }
};

struct sync_wait_with_variant_t {
  struct __impl;

  template <sender_in<__env> _Sender>
    requires __callable<apply_sender_t, __early_domain_of_t<_Sender>,
                        sync_wait_with_variant_t, _Sender>
  auto operator()(_Sender &&__sndr) const -> decltype(auto) {
    using __result_t =
        __call_result_t<apply_sender_t, __early_domain_of_t<_Sender>,
                        sync_wait_with_variant_t, _Sender>;
    static_assert(__is_instance_of<__result_t, std::optional>);
    using __variant_t = typename __result_t::value_type;
    static_assert(__is_instance_of<__variant_t, std::variant>);

    using _Domain = __late_domain_of_t<_Sender, __env>;
    return stdexec::apply_sender(_Domain(), *this,
                                 static_cast<_Sender &&>(__sndr));
  }

  template <class _Sender>
    requires __callable<sync_wait_t, __result_of<into_variant, _Sender>>
  auto apply_sender(_Sender &&__sndr) const
      -> std::optional<__variant_for_t<_Sender>> {
    if (auto __opt_values =
            sync_wait_t()(into_variant(static_cast<_Sender &&>(__sndr)))) {
      return std::move(std::get<0>(*__opt_values));
    }
    return std::nullopt;
  }
};
} // namespace __sync_wait

using __sync_wait::sync_wait_t;
inline constexpr sync_wait_t sync_wait{};

using __sync_wait::sync_wait_with_variant_t;
inline constexpr sync_wait_with_variant_t sync_wait_with_variant{};
} // namespace stdexec
# 59 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__transfer_just.hpp" 1
# 33 "./../stdexec/include/stdexec/__detail/__transfer_just.hpp"
#pragma GCC diagnostic push
# 33 "./../stdexec/include/stdexec/__detail/__transfer_just.hpp"
#pragma GCC diagnostic ignored "-Wpragmas"
# 33 "./../stdexec/include/stdexec/__detail/__transfer_just.hpp"
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
# 33 "./../stdexec/include/stdexec/__detail/__transfer_just.hpp"
#pragma GCC diagnostic ignored "-Wunknown-warning-option"
# 33 "./../stdexec/include/stdexec/__detail/__transfer_just.hpp"
#pragma GCC diagnostic ignored "-Wunknown-attributes"
# 33 "./../stdexec/include/stdexec/__detail/__transfer_just.hpp"
#pragma GCC diagnostic ignored "-Wattributes"
#pragma GCC diagnostic ignored "-Wmissing-braces"

namespace stdexec {

namespace __transfer_just {
template <class _Env> auto __make_transform_fn(const _Env &) {
  return [&]<class _Scheduler, class... _Values>(_Scheduler &&__sched,
                                                 _Values &&...__vals) {
    return continues_on(just(static_cast<_Values &&>(__vals)...),
                        static_cast<_Scheduler &&>(__sched));
  };
}

template <class _Env> auto __transform_sender_fn(const _Env &__env) {
  return [&]<class _Data>(__ignore, _Data &&__data) {
    return __data.apply(__make_transform_fn(__env),
                        static_cast<_Data &&>(__data));
  };
}

struct transfer_just_t {
  template <scheduler _Scheduler, __movable_value... _Values>
  auto operator()(_Scheduler &&__sched,
                  _Values &&...__vals) const -> __well_formed_sender auto {
    auto __domain = query_or(get_domain, __sched, default_domain());
    return stdexec::transform_sender(
        __domain, __make_sexpr<transfer_just_t>(
                      __tuple{static_cast<_Scheduler &&>(__sched),
                              static_cast<_Values &&>(__vals)...}));
  }

  template <class _Sender, class _Env>
  static auto transform_sender(_Sender &&__sndr, const _Env &__env) {
    return __sexpr_apply(static_cast<_Sender &&>(__sndr),
                         __transform_sender_fn(__env));
  }
};

inline auto __make_attrs_fn() noexcept {
  return []<class _Scheduler>(const _Scheduler &__sched,
                              const auto &...) noexcept {
    static_assert(scheduler<_Scheduler>, "transfer_just requires a scheduler");
    return __sched_attrs{std::cref(__sched)};
  };
}

struct __transfer_just_impl : __sexpr_defaults {
  static constexpr auto get_attrs =
      []<class _Data>(const _Data &__data) noexcept {
        return __data.apply(__make_attrs_fn(), __data);
      };

  static constexpr auto get_completion_signatures =
      []<class _Sender>(_Sender &&) noexcept
      -> __completion_signatures_of_t<
          transform_sender_result_t<default_domain, _Sender, env<>>> {};
};
} // namespace __transfer_just

using __transfer_just::transfer_just_t;
inline constexpr transfer_just_t transfer_just{};

template <>
struct __sexpr_impl<transfer_just_t> : __transfer_just::__transfer_just_impl {};
} // namespace stdexec

#pragma GCC diagnostic pop
# 61 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__upon_error.hpp" 1
# 31 "./../stdexec/include/stdexec/__detail/__upon_error.hpp"
namespace stdexec {

namespace __upon_error {
inline constexpr __mstring __upon_error_context =
    "In stdexec::upon_error(Sender, Function)..."_mstr;
using __on_not_callable = __callable_error<__upon_error_context>;

template <class _Fun, class _CvrefSender, class... _Env>
using __completion_signatures_t = transform_completion_signatures<
    __completion_signatures_of_t<_CvrefSender, _Env...>,
    __with_error_invoke_t<__on_not_callable, set_error_t, _Fun, _CvrefSender,
                          _Env...>,
    __sigs::__default_set_value,
    __mbind_front<__mtry_catch_q<__set_value_invoke_t, __on_not_callable>,
                  _Fun>::template __f>;

struct upon_error_t {
  template <sender _Sender, __movable_value _Fun>
  auto operator()(_Sender &&__sndr, _Fun __fun) const -> __well_formed_sender
      auto {
    auto __domain = __get_early_domain(__sndr);
    return stdexec::transform_sender(
        __domain, __make_sexpr<upon_error_t>(static_cast<_Fun &&>(__fun),
                                             static_cast<_Sender &&>(__sndr)));
  }

  template <__movable_value _Fun>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Fun __fun) const -> __binder_back<upon_error_t, _Fun> {
    return {{static_cast<_Fun &&>(__fun)}, {}, {}};
  }
};

struct __upon_error_impl : __sexpr_defaults {
  static constexpr auto get_completion_signatures =
      []<class _Sender, class... _Env>(_Sender &&, _Env &&...) noexcept
      -> __completion_signatures_t<__decay_t<__data_of<_Sender>>,
                                   __child_of<_Sender>, _Env...> {
    static_assert(sender_expr_for<_Sender, upon_error_t>);
    return {};
  };

  static constexpr auto complete =
      []<class _Tag, class _State, class _Receiver, class... _Args>(
          __ignore, _State &__state, _Receiver &__rcvr, _Tag,
          _Args &&...__args) noexcept -> void {
    if constexpr (__same_as<_Tag, set_error_t>) {
      stdexec::__set_value_invoke(static_cast<_Receiver &&>(__rcvr),
                                  static_cast<_State &&>(__state),
                                  static_cast<_Args &&>(__args)...);
    } else {
      _Tag()(static_cast<_Receiver &&>(__rcvr),
             static_cast<_Args &&>(__args)...);
    }
  };
};
} // namespace __upon_error

using __upon_error::upon_error_t;
inline constexpr upon_error_t upon_error{};

template <>
struct __sexpr_impl<upon_error_t> : __upon_error::__upon_error_impl {};
} // namespace stdexec
# 65 "./../stdexec/include/stdexec/execution.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__upon_stopped.hpp" 1
# 31 "./../stdexec/include/stdexec/__detail/__upon_stopped.hpp"
namespace stdexec {

namespace __upon_stopped {
inline constexpr __mstring __upon_stopped_context =
    "In stdexec::upon_stopped(Sender, Function)..."_mstr;
using __on_not_callable = __callable_error<__upon_stopped_context>;

template <class _Fun, class _CvrefSender, class... _Env>
using __completion_signatures_t = transform_completion_signatures<
    __completion_signatures_of_t<_CvrefSender, _Env...>,
    __with_error_invoke_t<__on_not_callable, set_stopped_t, _Fun, _CvrefSender,
                          _Env...>,
    __sigs::__default_set_value, __sigs::__default_set_error,
    __set_value_invoke_t<_Fun>>;

struct upon_stopped_t {
  template <sender _Sender, __movable_value _Fun>
    requires __callable<_Fun>
  auto operator()(_Sender &&__sndr, _Fun __fun) const -> __well_formed_sender
      auto {
    auto __domain = __get_early_domain(__sndr);
    return stdexec::transform_sender(
        __domain,
        __make_sexpr<upon_stopped_t>(static_cast<_Fun &&>(__fun),
                                     static_cast<_Sender &&>(__sndr)));
  }

  template <__movable_value _Fun>
    requires __callable<_Fun>
  __attribute__((__always_inline__, __artificial__, __nodebug__)) inline auto
  operator()(_Fun __fun) const -> __binder_back<upon_stopped_t, _Fun> {
    return {{static_cast<_Fun &&>(__fun)}, {}, {}};
  }
};

struct __upon_stopped_impl : __sexpr_defaults {
  static constexpr auto get_completion_signatures =
      []<class _Sender, class... _Env>(_Sender &&, _Env &&...) noexcept
      -> __completion_signatures_t<__decay_t<__data_of<_Sender>>,
                                   __child_of<_Sender>, _Env...> {
    static_assert(sender_expr_for<_Sender, upon_stopped_t>);
    return {};
  };

  static constexpr auto complete =
      []<class _Tag, class _State, class _Receiver, class... _Args>(
          __ignore, _State &__state, _Receiver &__rcvr, _Tag,
          _Args &&...__args) noexcept -> void {
    if constexpr (__same_as<_Tag, set_stopped_t>) {
      stdexec::__set_value_invoke(static_cast<_Receiver &&>(__rcvr),
                                  static_cast<_State &&>(__state),
                                  static_cast<_Args &&>(__args)...);
    } else {
      _Tag()(static_cast<_Receiver &&>(__rcvr),
             static_cast<_Args &&>(__args)...);
    }
  };
};
} // namespace __upon_stopped

using __upon_stopped::upon_stopped_t;
inline constexpr upon_stopped_t upon_stopped{};

template <>
struct __sexpr_impl<upon_stopped_t> : __upon_stopped::__upon_stopped_impl {};

} // namespace stdexec
# 66 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/__detail/__when_all.hpp" 1
# 44 "./../stdexec/include/stdexec/__detail/__when_all.hpp"
namespace stdexec {

namespace __when_all {
enum __state_t { __started, __error, __stopped };

struct __on_stop_request {
  inplace_stop_source &__stop_source_;

  void operator()() noexcept { __stop_source_.request_stop(); }
};

template <class _Env>
auto __mkenv(_Env &&__env, const inplace_stop_source &__stop_source) noexcept {
  return __env::__join(prop{get_stop_token, __stop_source.get_token()},
                       static_cast<_Env &&>(__env));
}

template <class _Env>
using __env_t = decltype(__when_all::__mkenv(
    __declval<_Env>(), __declval<inplace_stop_source &>()));

template <class _Sender, class _Env>
concept __max1_sender =
    sender_in<_Sender, _Env> && __mvalid<__value_types_of_t, _Sender, _Env,
                                         __mconst<int>, __msingle_or<void>>;

template <
    __mstring _Context = "In stdexec::when_all()..."_mstr,
    __mstring _Diagnostic =
        "The given sender can complete successfully in more that one way. "
        "Use stdexec::when_all_with_variant() instead."_mstr>
struct _INVALID_WHEN_ALL_ARGUMENT_;

template <class _Sender, class... _Env>
using __too_many_value_completions_error =
    __mexception<_INVALID_WHEN_ALL_ARGUMENT_<>, _WITH_SENDER_<_Sender>,
                 _WITH_ENVIRONMENT_<_Env>...>;

template <class... _Args>
using __all_nothrow_decay_copyable =
    __mbool<(__nothrow_decay_copyable<_Args> && ...)>;

template <class _Error>
using __set_error_t = completion_signatures<set_error_t(__decay_t<_Error>)>;

template <class _Sender, class... _Env>
using __nothrow_decay_copyable_results = __for_each_completion_signature<
    __completion_signatures_of_t<_Sender, _Env...>,
    __all_nothrow_decay_copyable, __mand_t>;

template <class... _Env> struct __completions_t {
  template <class... _Senders>
  using __all_nothrow_decay_copyable_results =
      __mand<__nothrow_decay_copyable_results<_Senders, _Env...>...>;

  template <class _Sender, class _ValueTuple, class... _Rest>
  using __value_tuple_t =
      __minvoke<__if_c<(0 == sizeof...(_Rest)), __mconst<_ValueTuple>,
                       __q<__too_many_value_completions_error>>,
                _Sender, _Env...>;

  template <class _Sender>
  using __single_values_of_t =
      __value_types_t<__completion_signatures_of_t<_Sender, _Env...>,
                      __mtransform<__q<__decay_t>, __q<__types>>,
                      __mbind_front_q<__value_tuple_t, _Sender>>;

  template <class... _Senders>
  using __set_values_sig_t =
      __meval<completion_signatures,
              __minvoke<__mconcat<__qf<set_value_t>>,
                        __single_values_of_t<_Senders>...>>;

  template <class... _Senders>
  using __f =
      __meval<__concat_completion_signatures,
              __meval<__eptr_completion_if_t,
                      __all_nothrow_decay_copyable_results<_Senders...>>,
              completion_signatures<set_stopped_t()>,
              __minvoke<__with_default<__qq<__set_values_sig_t>,
                                       completion_signatures<>>,
                        _Senders...>,
              __transform_completion_signatures<
                  __completion_signatures_of_t<_Senders, _Env...>,
                  __mconst<completion_signatures<>>::__f, __set_error_t,
                  completion_signatures<>, __concat_completion_signatures>...>;
};

template <class _Receiver, class _ValuesTuple>
void __set_values(_Receiver &__rcvr, _ValuesTuple &__values) noexcept {
  __values.apply(
      [&]<class... OptTuples>(OptTuples &&...__opt_vals) noexcept -> void {
        __tup::__cat_apply(__mk_completion_fn(set_value, __rcvr),
                           *static_cast<OptTuples &&>(__opt_vals)...);
      },
      static_cast<_ValuesTuple &&>(__values));
}

template <class _Env, class _Sender>
using __values_opt_tuple_t =
    value_types_of_t<_Sender, __env_t<_Env>, __decayed_tuple, __optional>;

template <class _Env, __max1_sender<__env_t<_Env>>... _Senders>
struct __traits {

  using __values_tuple = __minvoke<
      __with_default<__mtransform<__mbind_front_q<__values_opt_tuple_t, _Env>,
                                  __q<__tuple_for>>,
                     __ignore>,
      _Senders...>;

  using __collect_errors = __mbind_front_q<__mset_insert, __mset<>>;

  using __errors_list = __minvoke<
      __mconcat<>,
      __if<__mand<__nothrow_decay_copyable_results<_Senders, _Env>...>,
           __types<>, __types<std::exception_ptr>>,
      __error_types_of_t<_Senders, __env_t<_Env>, __q<__types>>...>;

  using __errors_variant = __mapply<__q<__uniqued_variant_for>, __errors_list>;
};

struct _INVALID_ARGUMENTS_TO_WHEN_ALL_ {};

template <class _ErrorsVariant, class _ValuesTuple, class _StopToken>
struct __when_all_state {
  using __stop_callback_t = stop_callback_for_t<_StopToken, __on_stop_request>;

  template <class _Receiver> void __arrive(_Receiver &__rcvr) noexcept {
    if (1 == __count_.fetch_sub(1)) {
      __complete(__rcvr);
    }
  }

  template <class _Receiver> void __complete(_Receiver &__rcvr) noexcept {

    __on_stop_.reset();

    switch (__state_.load(std::memory_order_relaxed)) {
    case __started:
      if constexpr (!same_as<_ValuesTuple, __ignore>) {

        __when_all::__set_values(__rcvr, __values_);
      }
      break;
    case __error:
      if constexpr (!__same_as<_ErrorsVariant, __variant_for<>>) {

        __errors_.visit(__mk_completion_fn(set_error, __rcvr),
                        static_cast<_ErrorsVariant &&>(__errors_));
      }
      break;
    case __stopped:
      stdexec::set_stopped(static_cast<_Receiver &&>(__rcvr));
      break;
    default:;
    }
  }

  std::atomic<std::size_t> __count_;
  inplace_stop_source __stop_source_{};

  std::atomic<__state_t> __state_{__started};
  _ErrorsVariant __errors_{};
  [[no_unique_address]] _ValuesTuple __values_{};
  __optional<__stop_callback_t> __on_stop_{};
};

template <class _Env> static auto __mk_state_fn(const _Env &) noexcept {
  return []<__max1_sender<__env_t<_Env>>... _Child>(__ignore, __ignore,
                                                    _Child &&...) {
    using _Traits = __traits<_Env, _Child...>;
    using _ErrorsVariant = typename _Traits::__errors_variant;
    using _ValuesTuple = typename _Traits::__values_tuple;
    using _State =
        __when_all_state<_ErrorsVariant, _ValuesTuple, stop_token_of_t<_Env>>;
    return _State{sizeof...(_Child)};
  };
}

template <class _Env>
using __mk_state_fn_t = decltype(__when_all::__mk_state_fn(__declval<_Env>()));

struct when_all_t {
  template <sender... _Senders>
    requires __has_common_domain<_Senders...>
  auto operator()(_Senders &&...__sndrs) const -> __well_formed_sender auto {
    auto __domain = __common_domain_t<_Senders...>();
    return stdexec::transform_sender(
        __domain,
        __make_sexpr<when_all_t>(__(), static_cast<_Senders &&>(__sndrs)...));
  }
};

struct __when_all_impl : __sexpr_defaults {
  template <class _Self, class _Env>
  using __error_t = __mexception<_INVALID_ARGUMENTS_TO_WHEN_ALL_,
                                 __children_of<_Self, __q<_WITH_SENDERS_>>,
                                 _WITH_ENVIRONMENT_<_Env>>;

  template <class _Self, class... _Env>
  using __completions = __children_of<_Self, __completions_t<__env_t<_Env>...>>;

  static constexpr auto get_attrs =
      []<class... _Child>(__ignore, const _Child &...) noexcept {
        using _Domain = __common_domain_t<_Child...>;
        if constexpr (__same_as<_Domain, default_domain>) {
          return env();
        } else {
          return prop{get_domain, _Domain()};
        }
      };

  static constexpr auto get_completion_signatures =
      []<class _Self, class... _Env>(_Self &&, _Env &&...) noexcept {
        static_assert(sender_expr_for<_Self, when_all_t>);
        return __minvoke<__mtry_catch<__q<__completions>, __q<__error_t>>,
                         _Self, _Env...>();
      };

  static constexpr auto get_env =
      []<class _State, class _Receiver>(__ignore, _State &__state,
                                        const _Receiver &__rcvr) noexcept
      -> __env_t<env_of_t<const _Receiver &>> {
    return __mkenv(stdexec::get_env(__rcvr), __state.__stop_source_);
  };

  static constexpr auto get_state =
      []<class _Self, class _Receiver>(_Self &&__self, _Receiver &__rcvr)
      -> __sexpr_apply_result_t<_Self, __mk_state_fn_t<env_of_t<_Receiver>>> {
    return __sexpr_apply(static_cast<_Self &&>(__self),
                         __when_all::__mk_state_fn(stdexec::get_env(__rcvr)));
  };

  static constexpr auto start =
      []<class _State, class _Receiver, class... _Operations>(
          _State &__state, _Receiver &__rcvr,
          _Operations &...__child_ops) noexcept -> void {
    __state.__on_stop_.emplace(get_stop_token(stdexec::get_env(__rcvr)),
                               __on_stop_request{__state.__stop_source_});
    if (__state.__stop_source_.stop_requested()) {

      stdexec::set_stopped(static_cast<_Receiver &&>(__rcvr));
    } else {
      (stdexec::start(__child_ops), ...);
      if constexpr (sizeof...(__child_ops) == 0) {
        __state.__complete(__rcvr);
      }
    }
  };

  template <class _State, class _Receiver, class _Error>
  static void __set_error(_State &__state, _Receiver &,
                          _Error &&__err) noexcept {

    switch (__state.__state_.exchange(__error)) {
    case __started:

      __state.__stop_source_.request_stop();
      [[fallthrough]];
    case __stopped:

      if constexpr (__nothrow_decay_copyable<_Error>) {
        __state.__errors_.template emplace<__decay_t<_Error>>(
            static_cast<_Error &&>(__err));
      } else {
        try {
          __state.__errors_.template emplace<__decay_t<_Error>>(
              static_cast<_Error &&>(__err));
        } catch (...) {
          __state.__errors_.template emplace<std::exception_ptr>(
              std::current_exception());
        }
      }
      break;
    case __error:;
    }
  }

  static constexpr auto complete =
      []<class _Index, class _State, class _Receiver, class _Set,
         class... _Args>(_Index, _State &__state, _Receiver &__rcvr, _Set,
                         _Args &&...__args) noexcept -> void {
    using _ValuesTuple = decltype(_State::__values_);
    if constexpr (__same_as<_Set, set_error_t>) {
      __set_error(__state, __rcvr, static_cast<_Args &&>(__args)...);
    } else if constexpr (__same_as<_Set, set_stopped_t>) {
      __state_t __expected = __started;

      if (__state.__state_.compare_exchange_strong(__expected, __stopped)) {
        __state.__stop_source_.request_stop();
      }
    } else if constexpr (!__same_as<_ValuesTuple, __ignore>) {

      if (__state.__state_.load() == __started) {
        auto &__opt_values =
            _ValuesTuple::template __get<__v<_Index>>(__state.__values_);
        using _Tuple = __decayed_tuple<_Args...>;
        static_assert(__same_as<decltype(*__opt_values), _Tuple &>,
                      "One of the senders in this when_all() is fibbing about "
                      "what types it sends");
        if constexpr ((__nothrow_decay_copyable<_Args> && ...)) {
          __opt_values.emplace(_Tuple{static_cast<_Args &&>(__args)...});
        } else {
          try {
            __opt_values.emplace(_Tuple{static_cast<_Args &&>(__args)...});
          } catch (...) {
            __set_error(__state, __rcvr, std::current_exception());
          }
        }
      }
    }

    __state.__arrive(__rcvr);
  };
};

struct when_all_with_variant_t {
  template <sender... _Senders>
    requires __has_common_domain<_Senders...>
  auto operator()(_Senders &&...__sndrs) const -> __well_formed_sender auto {
    auto __domain = __common_domain_t<_Senders...>();
    return stdexec::transform_sender(
        __domain, __make_sexpr<when_all_with_variant_t>(
                      __(), static_cast<_Senders &&>(__sndrs)...));
  }

  template <class _Sender, class _Env>
  static auto transform_sender(_Sender &&__sndr, const _Env &) {

    return __sexpr_apply(
        static_cast<_Sender &&>(__sndr),
        [&]<class... _Child>(__ignore, __ignore, _Child &&...__child) {
          return when_all_t()(into_variant(static_cast<_Child &&>(__child))...);
        });
  }
};

struct __when_all_with_variant_impl : __sexpr_defaults {
  static constexpr auto get_attrs =
      []<class... _Child>(__ignore, const _Child &...) noexcept {
        using _Domain = __common_domain_t<_Child...>;
        if constexpr (same_as<_Domain, default_domain>) {
          return env();
        } else {
          return prop{get_domain, _Domain()};
        }
      };

  static constexpr auto get_completion_signatures =
      []<class _Sender>(_Sender &&) noexcept
      -> __completion_signatures_of_t<
          transform_sender_result_t<default_domain, _Sender, env<>>> {
    return {};
  };
};

struct transfer_when_all_t {
  template <scheduler _Scheduler, sender... _Senders>
    requires __has_common_domain<_Senders...>
  auto operator()(_Scheduler __sched,
                  _Senders &&...__sndrs) const -> __well_formed_sender auto {
    auto __domain = query_or(get_domain, __sched, default_domain());
    return stdexec::transform_sender(__domain,
                                     __make_sexpr<transfer_when_all_t>(
                                         static_cast<_Scheduler &&>(__sched),
                                         static_cast<_Senders &&>(__sndrs)...));
  }

  template <class _Sender, class _Env>
  static auto transform_sender(_Sender &&__sndr, const _Env &) {

    return __sexpr_apply(
        static_cast<_Sender &&>(__sndr),
        [&]<class _Data, class... _Child>(__ignore, _Data &&__data,
                                          _Child &&...__child) {
          return continues_on(when_all_t()(static_cast<_Child &&>(__child)...),
                              static_cast<_Data &&>(__data));
        });
  }
};

struct __transfer_when_all_impl : __sexpr_defaults {
  static constexpr auto get_attrs =
      []<class _Scheduler, class... _Child>(const _Scheduler &__sched,
                                            const _Child &...) noexcept {
        using __sndr_t = __call_result_t<when_all_t, _Child...>;
        using __domain_t = __detail::__early_domain_of_t<__sndr_t, __none_such>;
        return __sched_attrs{std::cref(__sched), __domain_t{}};
      };

  static constexpr auto get_completion_signatures =
      []<class _Sender>(_Sender &&) noexcept
      -> __completion_signatures_of_t<
          transform_sender_result_t<default_domain, _Sender, env<>>> {
    return {};
  };
};

struct transfer_when_all_with_variant_t {
  template <scheduler _Scheduler, sender... _Senders>
    requires __has_common_domain<_Senders...>
  auto operator()(_Scheduler &&__sched,
                  _Senders &&...__sndrs) const -> __well_formed_sender auto {
    auto __domain = query_or(get_domain, __sched, default_domain());
    return stdexec::transform_sender(
        __domain, __make_sexpr<transfer_when_all_with_variant_t>(
                      static_cast<_Scheduler &&>(__sched),
                      static_cast<_Senders &&>(__sndrs)...));
  }

  template <class _Sender, class _Env>
  static auto transform_sender(_Sender &&__sndr, const _Env &) {

    return __sexpr_apply(
        static_cast<_Sender &&>(__sndr),
        [&]<class _Data, class... _Child>(__ignore, _Data &&__data,
                                          _Child &&...__child) {
          return transfer_when_all_t()(
              static_cast<_Data &&>(__data),
              into_variant(static_cast<_Child &&>(__child))...);
        });
  }
};

struct __transfer_when_all_with_variant_impl : __sexpr_defaults {
  static constexpr auto get_attrs =
      []<class _Scheduler, class... _Child>(const _Scheduler &__sched,
                                            const _Child &...) noexcept {
        using __sndr_t = __call_result_t<when_all_with_variant_t, _Child...>;
        using __domain_t = __detail::__early_domain_of_t<__sndr_t, __none_such>;
        return __sched_attrs{std::cref(__sched), __domain_t{}};
      };

  static constexpr auto get_completion_signatures =
      []<class _Sender>(_Sender &&) noexcept
      -> __completion_signatures_of_t<
          transform_sender_result_t<default_domain, _Sender, env<>>> {
    return {};
  };
};
} // namespace __when_all

using __when_all::when_all_t;
inline constexpr when_all_t when_all{};

using __when_all::when_all_with_variant_t;
inline constexpr when_all_with_variant_t when_all_with_variant{};

using __when_all::transfer_when_all_t;
inline constexpr transfer_when_all_t transfer_when_all{};

using __when_all::transfer_when_all_with_variant_t;
inline constexpr transfer_when_all_with_variant_t
    transfer_when_all_with_variant{};

template <> struct __sexpr_impl<when_all_t> : __when_all::__when_all_impl {};

template <>
struct __sexpr_impl<when_all_with_variant_t>
    : __when_all::__when_all_with_variant_impl {};

template <>
struct __sexpr_impl<transfer_when_all_t>
    : __when_all::__transfer_when_all_impl {};

template <>
struct __sexpr_impl<transfer_when_all_with_variant_t>
    : __when_all::__transfer_when_all_with_variant_impl {};
} // namespace stdexec
# 68 "./../stdexec/include/stdexec/execution.hpp" 2
# 1 "./../stdexec/include/stdexec/__detail/__with_awaitable_senders.hpp" 1
# 25 "./../stdexec/include/stdexec/__detail/__with_awaitable_senders.hpp"
namespace stdexec {

namespace __was {
template <class _Promise = void> class __continuation_handle;

template <> class __continuation_handle<void> {
public:
  __continuation_handle() = default;

  template <class _Promise>
  __continuation_handle(__coro::coroutine_handle<_Promise> __coro) noexcept
      : __coro_(__coro) {
    if constexpr (requires(_Promise &__promise) {
                    __promise.unhandled_stopped();
                  }) {
      __stopped_callback_ =
          [](void *__address) noexcept -> __coro::coroutine_handle<> {
        return __coro::coroutine_handle<_Promise>::from_address(__address)
            .promise()
            .unhandled_stopped();
      };
    }
  }

  [[nodiscard]]
  auto handle() const noexcept -> __coro::coroutine_handle<> {
    return __coro_;
  }

  [[nodiscard]]
  auto unhandled_stopped() const noexcept -> __coro::coroutine_handle<> {
    return __stopped_callback_(__coro_.address());
  }

private:
  using __stopped_callback_t = __coro::coroutine_handle<> (*)(void *) noexcept;

  __coro::coroutine_handle<> __coro_{};
  __stopped_callback_t __stopped_callback_ =
      [](void *) noexcept -> __coro::coroutine_handle<> { std::terminate(); };
};

template <class _Promise> class __continuation_handle {
public:
  __continuation_handle() = default;

  __continuation_handle(__coro::coroutine_handle<_Promise> __coro) noexcept
      : __continuation_{__coro} {}

  auto handle() const noexcept -> __coro::coroutine_handle<_Promise> {
    return __coro::coroutine_handle<_Promise>::from_address(
        __continuation_.handle().address());
  }

  [[nodiscard]]
  auto unhandled_stopped() const noexcept -> __coro::coroutine_handle<> {
    return __continuation_.unhandled_stopped();
  }

private:
  __continuation_handle<> __continuation_{};
};

struct __with_awaitable_senders_base {
  template <class _OtherPromise>
  void
  set_continuation(__coro::coroutine_handle<_OtherPromise> __hcoro) noexcept {
    static_assert(!__same_as<_OtherPromise, void>);
    __continuation_ = __hcoro;
  }

  void set_continuation(__continuation_handle<> __continuation) noexcept {
    __continuation_ = __continuation;
  }

  [[nodiscard]]
  auto continuation() const noexcept -> __continuation_handle<> {
    return __continuation_;
  }

  auto unhandled_stopped() noexcept -> __coro::coroutine_handle<> {
    return __continuation_.unhandled_stopped();
  }

private:
  __continuation_handle<> __continuation_{};
};

template <class _Promise>
struct with_awaitable_senders : __with_awaitable_senders_base {
  template <class _Value>
  auto await_transform(_Value &&__val)
      -> __call_result_t<as_awaitable_t, _Value, _Promise &> {
    static_assert(derived_from<_Promise, with_awaitable_senders>);
    return as_awaitable(static_cast<_Value &&>(__val),
                        static_cast<_Promise &>(*this));
  }
};
} // namespace __was

using __was::__continuation_handle;
using __was::with_awaitable_senders;

} // namespace stdexec
# 69 "./../stdexec/include/stdexec/execution.hpp" 2

# 1 "./../stdexec/include/stdexec/coroutine.hpp" 1
# 74 "./../stdexec/include/stdexec/execution.hpp" 2

template <stdexec::sender _Ignore, stdexec::sender _Sender>
  requires stdexec::__ok<stdexec::__bad_pipe_sink_t<_Sender>>
auto operator|(_Ignore &&, _Sender &&) noexcept;
# 9 "./ComputeSYMGS_stdexec.hpp" 2
# 24 "./ComputeSYMGS_stdexec.hpp"
# 1 "./mytimer.hpp" 1
# 17 "./mytimer.hpp"
double mytimer(void);
# 25 "./ComputeSYMGS_stdexec.hpp" 2

# 1 "./ComputeSYMGS_ref.hpp" 1
# 20 "./ComputeSYMGS_ref.hpp"
int ComputeSYMGS_ref(const SparseMatrix &A, const Vector &r, Vector &x);
# 28 "./ComputeSYMGS_stdexec.hpp" 2

auto ComputeSYMGS_stdexec(double *time, const SparseMatrix &A, const Vector &r,
                          Vector &x) {

  return stdexec::then([&, time]() {
    if (time != __null)
      *time -= mytimer();
    ComputeSYMGS_ref(A, r, x);
# 79 "./ComputeSYMGS_stdexec.hpp"
    if (time != __null)
      *time += mytimer();
  });
}
# 7 "./ComputeMG_stdexec.hpp" 2
# 1 "./ComputeSPMV_stdexec.hpp" 1
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 1 3
# 59 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_numeric.h" 1 3
# 64 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_numeric.h" 3
namespace std __attribute__((__visibility__("default"))) {
# 85 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_numeric.h" 3
  template <typename _ForwardIterator, typename _Tp>
  constexpr void iota(_ForwardIterator __first, _ForwardIterator __last,
                      _Tp __value) {

    ;

    for (; __first != __last; ++__first) {
      *__first = __value;
      ++__value;
    }
  }
# 131 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_numeric.h" 3
  template <typename _InputIterator, typename _Tp>
  constexpr inline _Tp accumulate(_InputIterator __first, _InputIterator __last,
                                  _Tp __init) {

    ;

    for (; __first != __last; ++__first)
      __init = std::move(__init) + *__first;
    return __init;
  }
# 158 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_numeric.h" 3
  template <typename _InputIterator, typename _Tp, typename _BinaryOperation>
  constexpr inline _Tp accumulate(_InputIterator __first, _InputIterator __last,
                                  _Tp __init, _BinaryOperation __binary_op) {

    ;

    for (; __first != __last; ++__first)
      __init = __binary_op(std::move(__init), *__first);
    return __init;
  }
# 187 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_numeric.h" 3
  template <typename _InputIterator1, typename _InputIterator2, typename _Tp>
  constexpr inline _Tp inner_product(_InputIterator1 __first1,
                                     _InputIterator1 __last1,
                                     _InputIterator2 __first2, _Tp __init) {

    ;

    for (; __first1 != __last1; ++__first1, (void)++__first2)
      __init = std::move(__init) + (*__first1 * *__first2);
    return __init;
  }
# 219 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_numeric.h" 3
  template <typename _InputIterator1, typename _InputIterator2, typename _Tp,
            typename _BinaryOperation1, typename _BinaryOperation2>
  constexpr inline _Tp inner_product(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _Tp __init, _BinaryOperation1 __binary_op1,
      _BinaryOperation2 __binary_op2) {

    ;

    for (; __first1 != __last1; ++__first1, (void)++__first2)
      __init =
          __binary_op1(std::move(__init), __binary_op2(*__first1, *__first2));
    return __init;
  }
# 253 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_numeric.h" 3
  template <typename _InputIterator, typename _OutputIterator>
  constexpr _OutputIterator partial_sum(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result) {
    typedef typename iterator_traits<_InputIterator>::value_type _ValueType;

    ;

    if (__first == __last)
      return __result;
    _ValueType __value = *__first;
    *__result = __value;
    while (++__first != __last) {
      __value = std::move(__value) + *__first;
      *++__result = __value;
    }
    return ++__result;
  }
# 294 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_numeric.h" 3
  template <typename _InputIterator, typename _OutputIterator,
            typename _BinaryOperation>
  constexpr _OutputIterator partial_sum(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _BinaryOperation __binary_op) {
    typedef typename iterator_traits<_InputIterator>::value_type _ValueType;

    ;

    if (__first == __last)
      return __result;
    _ValueType __value = *__first;
    *__result = __value;
    while (++__first != __last) {
      __value = __binary_op(std::move(__value), *__first);
      *++__result = __value;
    }
    return ++__result;
  }
# 334 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_numeric.h" 3
  template <typename _InputIterator, typename _OutputIterator>
  constexpr _OutputIterator adjacent_difference(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result) {
    typedef typename iterator_traits<_InputIterator>::value_type _ValueType;

    ;

    if (__first == __last)
      return __result;
    _ValueType __value = *__first;
    *__result = __value;
    while (++__first != __last) {
      _ValueType __tmp = *__first;
      *++__result = __tmp - std::move(__value);
      __value = std::move(__tmp);
    }
    return ++__result;
  }
# 376 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/stl_numeric.h" 3
  template <typename _InputIterator, typename _OutputIterator,
            typename _BinaryOperation>
  constexpr _OutputIterator adjacent_difference(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _BinaryOperation __binary_op) {
    typedef typename iterator_traits<_InputIterator>::value_type _ValueType;

    ;

    if (__first == __last)
      return __result;
    _ValueType __value = *__first;
    *__result = __value;
    while (++__first != __last) {
      _ValueType __tmp = *__first;
      *++__result = __binary_op(__tmp, std::move(__value));
      __value = std::move(__tmp);
    }
    return ++__result;
  }

} // namespace std
# 63 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 2 3
# 90 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
namespace std __attribute__((__visibility__("default"))) {

  namespace __detail {

  template <typename _Res, typename _Tp> constexpr _Res __abs_r(_Tp __val) {
    static_assert(sizeof(_Res) >= sizeof(_Tp),
                  "result type must be at least as wide as the input type");

    if (__val >= 0)
      return __val;

    return -static_cast<_Res>(__val);
  }

  template <typename> void __abs_r(bool) = delete;

  template <typename _Tp> constexpr _Tp __gcd(_Tp __m, _Tp __n) {
    static_assert(is_unsigned<_Tp>::value, "type must be unsigned");

    if (__m == 0)
      return __n;
    if (__n == 0)
      return __m;

    const int __i = std::__countr_zero(__m);
    __m >>= __i;
    const int __j = std::__countr_zero(__n);
    __n >>= __j;
    const int __k = __i < __j ? __i : __j;

    while (true) {
      if (__m > __n) {
        _Tp __tmp = __m;
        __m = __n;
        __n = __tmp;
      }

      __n -= __m;

      if (__n == 0)
        return __m << __k;

      __n >>= std::__countr_zero(__n);
    }
  }
  } // namespace __detail
# 162 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
  template <typename _Mn, typename _Nn>
  constexpr common_type_t<_Mn, _Nn> gcd(_Mn __m, _Nn __n) noexcept {
    static_assert(is_integral_v<_Mn> && is_integral_v<_Nn>,
                  "std::gcd arguments must be integers");
    static_assert(_Mn(2) == 2 && _Nn(2) == 2,
                  "std::gcd arguments must not be bool");
    using _Ct = common_type_t<_Mn, _Nn>;
    const _Ct __m2 = __detail::__abs_r<_Ct>(__m);
    const _Ct __n2 = __detail::__abs_r<_Ct>(__n);
    return __detail::__gcd<make_unsigned_t<_Ct>>(__m2, __n2);
  }

  template <typename _Mn, typename _Nn>
  constexpr common_type_t<_Mn, _Nn> lcm(_Mn __m, _Nn __n) noexcept {
    static_assert(is_integral_v<_Mn> && is_integral_v<_Nn>,
                  "std::lcm arguments must be integers");
    static_assert(_Mn(2) == 2 && _Nn(2) == 2,
                  "std::lcm arguments must not be bool");
    using _Ct = common_type_t<_Mn, _Nn>;
    const _Ct __m2 = __detail::__abs_r<_Ct>(__m);
    const _Ct __n2 = __detail::__abs_r<_Ct>(__n);
    if (__m2 == 0 || __n2 == 0)
      return 0;
    _Ct __r = __m2 / __detail::__gcd<make_unsigned_t<_Ct>>(__m2, __n2);

    if constexpr (is_signed_v<_Ct>)
      if (__is_constant_evaluated())
        return __r * __n2;

    bool __overflow = __builtin_mul_overflow(__r, __n2, &__r);
    do {
      if (std::__is_constant_evaluated() && !bool(!__overflow))
        __builtin_unreachable();
    } while (false);
    return __r;
  }
# 209 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
  template <typename _Tp>
  constexpr enable_if_t<
      __and_v<is_arithmetic<_Tp>, is_same<remove_cv_t<_Tp>, _Tp>,
              __not_<is_same<_Tp, bool>>>,
      _Tp>
  midpoint(_Tp __a, _Tp __b) noexcept {
    if constexpr (is_integral_v<_Tp>) {
      using _Up = make_unsigned_t<_Tp>;

      int __k = 1;
      _Up __m = __a;
      _Up __M = __b;
      if (__a > __b) {
        __k = -1;
        __m = __b;
        __M = __a;
      }
      return __a + __k * _Tp(_Up(__M - __m) / 2);
    } else {
      constexpr _Tp __lo = numeric_limits<_Tp>::min() * 2;
      constexpr _Tp __hi = numeric_limits<_Tp>::max() / 2;
      const _Tp __abs_a = __a < 0 ? -__a : __a;
      const _Tp __abs_b = __b < 0 ? -__b : __b;
      if (__abs_a <= __hi && __abs_b <= __hi) [[likely]]
        return (__a + __b) / 2;
      if (__abs_a < __lo)
        return __a + __b / 2;
      if (__abs_b < __lo)
        return __a / 2 + __b;
      return __a / 2 + __b / 2;
    }
  }

  template <typename _Tp>
  constexpr enable_if_t<is_object_v<_Tp>, _Tp *> midpoint(_Tp * __a,
                                                          _Tp * __b) noexcept {
    static_assert(sizeof(_Tp) != 0, "type must be complete");
    return __a + (__b - __a) / 2;
  }
# 284 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
  template <typename _InputIterator, typename _Tp, typename _BinaryOperation>
  constexpr _Tp reduce(_InputIterator __first, _InputIterator __last,
                       _Tp __init, _BinaryOperation __binary_op) {
    using __ref = typename iterator_traits<_InputIterator>::reference;
    static_assert(is_invocable_r_v<_Tp, _BinaryOperation &, _Tp &, __ref>);
    static_assert(is_invocable_r_v<_Tp, _BinaryOperation &, __ref, _Tp &>);
    static_assert(is_invocable_r_v<_Tp, _BinaryOperation &, _Tp &, _Tp &>);
    static_assert(is_invocable_r_v<_Tp, _BinaryOperation &, __ref, __ref>);
    if constexpr (__is_random_access_iter<_InputIterator>::value) {
      while ((__last - __first) >= 4) {
        _Tp __v1 = __binary_op(__first[0], __first[1]);
        _Tp __v2 = __binary_op(__first[2], __first[3]);
        _Tp __v3 = __binary_op(__v1, __v2);
        __init = __binary_op(__init, __v3);
        __first += 4;
      }
    }
    for (; __first != __last; ++__first)
      __init = __binary_op(__init, *__first);
    return __init;
  }
# 322 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
  template <typename _InputIterator, typename _Tp>
  constexpr inline _Tp reduce(_InputIterator __first, _InputIterator __last,
                              _Tp __init) {
    return std::reduce(__first, __last, std::move(__init), plus<>());
  }
# 339 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
  template <typename _InputIterator>
  constexpr inline typename iterator_traits<_InputIterator>::value_type reduce(
      _InputIterator __first, _InputIterator __last) {
    using value_type = typename iterator_traits<_InputIterator>::value_type;
    return std::reduce(__first, __last, value_type{}, plus<>());
  }
# 366 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
  template <typename _InputIterator1, typename _InputIterator2, typename _Tp,
            typename _BinaryOperation1, typename _BinaryOperation2>
  constexpr _Tp transform_reduce(
      _InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _Tp __init, _BinaryOperation1 __binary_op1,
      _BinaryOperation2 __binary_op2) {
    if constexpr (__and_v<__is_random_access_iter<_InputIterator1>,
                          __is_random_access_iter<_InputIterator2>>) {
      while ((__last1 - __first1) >= 4) {
        _Tp __v1 = __binary_op1(__binary_op2(__first1[0], __first2[0]),
                                __binary_op2(__first1[1], __first2[1]));
        _Tp __v2 = __binary_op1(__binary_op2(__first1[2], __first2[2]),
                                __binary_op2(__first1[3], __first2[3]));
        _Tp __v3 = __binary_op1(__v1, __v2);
        __init = __binary_op1(__init, __v3);
        __first1 += 4;
        __first2 += 4;
      }
    }
    for (; __first1 != __last1; ++__first1, (void)++__first2)
      __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
    return __init;
  }
# 410 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
  template <typename _InputIterator1, typename _InputIterator2, typename _Tp>
  constexpr inline _Tp transform_reduce(_InputIterator1 __first1,
                                        _InputIterator1 __last1,
                                        _InputIterator2 __first2, _Tp __init) {
    return std::transform_reduce(__first1, __last1, __first2, std::move(__init),
                                 plus<>(), multiplies<>());
  }
# 435 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
  template <typename _InputIterator, typename _Tp, typename _BinaryOperation,
            typename _UnaryOperation>
  constexpr _Tp transform_reduce(_InputIterator __first, _InputIterator __last,
                                 _Tp __init, _BinaryOperation __binary_op,
                                 _UnaryOperation __unary_op) {
    if constexpr (__is_random_access_iter<_InputIterator>::value) {
      while ((__last - __first) >= 4) {
        _Tp __v1 = __binary_op(__unary_op(__first[0]), __unary_op(__first[1]));
        _Tp __v2 = __binary_op(__unary_op(__first[2]), __unary_op(__first[3]));
        _Tp __v3 = __binary_op(__v1, __v2);
        __init = __binary_op(__init, __v3);
        __first += 4;
      }
    }
    for (; __first != __last; ++__first)
      __init = __binary_op(__init, __unary_op(*__first));
    return __init;
  }
# 478 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
  template <typename _InputIterator, typename _OutputIterator, typename _Tp,
            typename _BinaryOperation>
  constexpr _OutputIterator exclusive_scan(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _Tp __init, _BinaryOperation __binary_op) {
    while (__first != __last) {
      auto __v = __init;
      __init = __binary_op(__init, *__first);
      ++__first;
      *__result++ = std::move(__v);
    }
    return __result;
  }
# 513 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
  template <typename _InputIterator, typename _OutputIterator, typename _Tp>
  constexpr inline _OutputIterator exclusive_scan(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _Tp __init) {
    return std::exclusive_scan(__first, __last, __result, std::move(__init),
                               plus<>());
  }
# 541 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
  template <typename _InputIterator, typename _OutputIterator,
            typename _BinaryOperation, typename _Tp>
  constexpr _OutputIterator inclusive_scan(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _BinaryOperation __binary_op, _Tp __init) {
    for (; __first != __last; ++__first)
      *__result++ = __init = __binary_op(__init, *__first);
    return __result;
  }
# 570 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
  template <typename _InputIterator, typename _OutputIterator,
            typename _BinaryOperation>
  constexpr _OutputIterator inclusive_scan(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _BinaryOperation __binary_op) {
    if (__first != __last) {
      auto __init = *__first;
      *__result++ = __init;
      ++__first;
      if (__first != __last)
        __result = std::inclusive_scan(__first, __last, __result, __binary_op,
                                       std::move(__init));
    }
    return __result;
  }
# 604 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
  template <typename _InputIterator, typename _OutputIterator>
  constexpr inline _OutputIterator inclusive_scan(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result) {
    return std::inclusive_scan(__first, __last, __result, plus<>());
  }
# 631 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
  template <typename _InputIterator, typename _OutputIterator, typename _Tp,
            typename _BinaryOperation, typename _UnaryOperation>
  constexpr _OutputIterator transform_exclusive_scan(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _Tp __init, _BinaryOperation __binary_op, _UnaryOperation __unary_op) {
    while (__first != __last) {
      auto __v = __init;
      __init = __binary_op(__init, __unary_op(*__first));
      ++__first;
      *__result++ = std::move(__v);
    }
    return __result;
  }
# 670 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
  template <typename _InputIterator, typename _OutputIterator,
            typename _BinaryOperation, typename _UnaryOperation, typename _Tp>
  constexpr _OutputIterator transform_inclusive_scan(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _BinaryOperation __binary_op, _UnaryOperation __unary_op, _Tp __init) {
    for (; __first != __last; ++__first)
      *__result++ = __init = __binary_op(__init, __unary_op(*__first));
    return __result;
  }
# 704 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
  template <typename _InputIterator, typename _OutputIterator,
            typename _BinaryOperation, typename _UnaryOperation>
  constexpr _OutputIterator transform_inclusive_scan(
      _InputIterator __first, _InputIterator __last, _OutputIterator __result,
      _BinaryOperation __binary_op, _UnaryOperation __unary_op) {
    if (__first != __last) {
      auto __init = __unary_op(*__first);
      *__result++ = __init;
      ++__first;
      if (__first != __last)
        __result = std::transform_inclusive_scan(__first, __last, __result,
                                                 __binary_op, __unary_op,
                                                 std::move(__init));
    }
    return __result;
  }

} // namespace std
# 739 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_numeric_defs.h" 1 3
# 15 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_numeric_defs.h" 3
namespace std {

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp,
          class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>
reduce(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __last, _Tp __init, _BinaryOperation __binary_op);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>
reduce(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __last, _Tp __init);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy, typename iterator_traits<_ForwardIterator>::value_type>
reduce(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>
transform_reduce(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                 _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                 _Tp __init);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp, class _BinaryOperation1,
          class _BinaryOperation2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>
transform_reduce(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                 _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                 _Tp __init, _BinaryOperation1 __binary_op1,
                 _BinaryOperation2 __binary_op2);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp,
          class _BinaryOperation, class _UnaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>
transform_reduce(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                 _ForwardIterator __last, _Tp __init,
                 _BinaryOperation __binary_op, _UnaryOperation __unary_op);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
exclusive_scan(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
               _ForwardIterator1 __last, _ForwardIterator2 __result,
               _Tp __init);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp, class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
exclusive_scan(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
               _ForwardIterator1 __last, _ForwardIterator2 __result, _Tp __init,
               _BinaryOperation __binary_op);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
inclusive_scan(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
               _ForwardIterator1 __last, _ForwardIterator2 __result);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
inclusive_scan(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
               _ForwardIterator1 __last, _ForwardIterator2 __result,
               _BinaryOperation __binary_op);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp, class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
inclusive_scan(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
               _ForwardIterator1 __last, _ForwardIterator2 __result,
               _BinaryOperation __binary_op, _Tp __init);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp, class _BinaryOperation,
          class _UnaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
transform_exclusive_scan(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
                         _ForwardIterator1 __last, _ForwardIterator2 __result,
                         _Tp __init, _BinaryOperation __binary_op,
                         _UnaryOperation __unary_op);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryOperation,
          class _UnaryOperation, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
transform_inclusive_scan(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
                         _ForwardIterator1 __last, _ForwardIterator2 __result,
                         _BinaryOperation __binary_op,
                         _UnaryOperation __unary_op, _Tp __init);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _UnaryOperation,
          class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
transform_inclusive_scan(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
                         _ForwardIterator1 __last, _ForwardIterator2 __result,
                         _BinaryOperation __binary_op,
                         _UnaryOperation __unary_op);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
adjacent_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
                    _ForwardIterator1 __last, _ForwardIterator2 __d_first,
                    _BinaryOperation __op);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
adjacent_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
                    _ForwardIterator1 __last, _ForwardIterator2 __d_first);

} // namespace std
# 740 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/numeric" 2 3
# 2 "./ComputeSPMV_stdexec.hpp" 2
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/span" 1 3
# 38 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/span" 3
# 47 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/span" 3
namespace std __attribute__((__visibility__("default"))) {

  inline constexpr size_t dynamic_extent = static_cast<size_t>(-1);

  template <typename _Type, size_t _Extent> class span;

  namespace __detail {
  template <typename _Tp> inline constexpr bool __is_span = false;

  template <typename _Tp, size_t _Num>
  inline constexpr bool __is_span<span<_Tp, _Num>> = true;

  template <typename _Tp> inline constexpr bool __is_std_array = false;

  template <typename _Tp, size_t _Num>
  inline constexpr bool __is_std_array<std::array<_Tp, _Num>> = true;

  template <size_t _Extent> class __extent_storage {
  public:
    constexpr __extent_storage(size_t) noexcept {}

    static constexpr size_t _M_extent() noexcept { return _Extent; }
  };

  template <> class __extent_storage<dynamic_extent> {
  public:
    constexpr __extent_storage(size_t __extent) noexcept
        : _M_extent_value(__extent) {}

    constexpr size_t _M_extent() const noexcept {
      return this->_M_extent_value;
    }

  private:
    size_t _M_extent_value;
  };
  } // namespace __detail

  template <typename _Type, size_t _Extent = dynamic_extent> class span {
    template <size_t _Offset, size_t _Count>
    static constexpr size_t _S_subspan_extent() {
      if constexpr (_Count != dynamic_extent)
        return _Count;
      else if constexpr (extent != dynamic_extent)
        return _Extent - _Offset;
      else
        return dynamic_extent;
    }

    template <typename _Tp, size_t _ArrayExtent>
      requires(_Extent == dynamic_extent || _ArrayExtent == _Extent)
    using __is_compatible_array = __is_array_convertible<_Type, _Tp>;

    template <typename _Ref>
    using __is_compatible_ref =
        __is_array_convertible<_Type, remove_reference_t<_Ref>>;

  public:
    using element_type = _Type;
    using value_type = remove_cv_t<_Type>;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    using pointer = _Type *;
    using const_pointer = const _Type *;
    using reference = element_type &;
    using const_reference = const element_type &;
    using iterator = __gnu_cxx::__normal_iterator<pointer, span>;
    using reverse_iterator = std::reverse_iterator<iterator>;

    static constexpr size_t extent = _Extent;

    constexpr span() noexcept
      requires(_Extent == dynamic_extent || _Extent == 0)
        : _M_ptr(nullptr), _M_extent(0) {}

    template <contiguous_iterator _It>
      requires __is_compatible_ref<iter_reference_t<_It>>::value
    constexpr explicit(extent != dynamic_extent)
        span(_It __first, size_type __count) noexcept
        : _M_ptr(std::to_address(__first)), _M_extent(__count) {
      if constexpr (_Extent != dynamic_extent) {
        do {
          if (std::__is_constant_evaluated() && !bool(__count == _Extent))
            __builtin_unreachable();
        } while (false);
      };
    }

    template <contiguous_iterator _It, sized_sentinel_for<_It> _End>
      requires __is_compatible_ref<iter_reference_t<_It>>::value &&
                   (!is_convertible_v<_End, size_type>)
    constexpr explicit(extent != dynamic_extent)
        span(_It __first, _End __last) noexcept(noexcept(__last - __first))
        : _M_ptr(std::to_address(__first)),
          _M_extent(static_cast<size_type>(__last - __first)) {
      if constexpr (_Extent != dynamic_extent) {
        do {
          if (std::__is_constant_evaluated() &&
              !bool((__last - __first) == _Extent))
            __builtin_unreachable();
        } while (false);
      };
    }

    template <size_t _ArrayExtent>
      requires(_Extent == dynamic_extent || _ArrayExtent == _Extent)
    constexpr span(
        type_identity_t<element_type> (&__arr)[_ArrayExtent]) noexcept
        : span(static_cast<pointer>(__arr), _ArrayExtent) {}

    template <typename _Tp, size_t _ArrayExtent>
      requires __is_compatible_array<_Tp, _ArrayExtent>::value
    constexpr span(array<_Tp, _ArrayExtent> &__arr) noexcept
        : span(static_cast<pointer>(__arr.data()), _ArrayExtent) {}

    template <typename _Tp, size_t _ArrayExtent>
      requires __is_compatible_array<const _Tp, _ArrayExtent>::value
    constexpr span(const array<_Tp, _ArrayExtent> &__arr) noexcept
        : span(static_cast<pointer>(__arr.data()), _ArrayExtent) {}

    template <typename _Range>
      requires(!__detail::__is_span<remove_cvref_t<_Range>>) &&
              (!__detail::__is_std_array<remove_cvref_t<_Range>>) &&
              (!is_array_v<remove_cvref_t<_Range>>) &&
              ranges::contiguous_range<_Range> && ranges::sized_range<_Range> &&
              (ranges::borrowed_range<_Range> || is_const_v<element_type>) &&
              __is_compatible_ref<ranges::range_reference_t<_Range>>::value
    constexpr explicit(extent != dynamic_extent)
        span(_Range &&__range) noexcept(noexcept(ranges::data(__range)) &&
                                        noexcept(ranges::size(__range)))
        : span(ranges::data(__range), ranges::size(__range)) {
      if constexpr (extent != dynamic_extent) {
        do {
          if (std::__is_constant_evaluated() &&
              !bool(ranges::size(__range) == extent))
            __builtin_unreachable();
        } while (false);
      }
    }

    constexpr span(const span &) noexcept = default;

    template <typename _OType, size_t _OExtent>
      requires(_Extent == dynamic_extent || _OExtent == dynamic_extent ||
               _Extent == _OExtent) &&
                  (__is_array_convertible<_Type, _OType>::value)
    constexpr explicit(extent != dynamic_extent && _OExtent == dynamic_extent)
        span(const span<_OType, _OExtent> &__s) noexcept
        : _M_extent(__s.size()), _M_ptr(__s.data()) {
      if constexpr (extent != dynamic_extent) {
        do {
          if (std::__is_constant_evaluated() && !bool(__s.size() == extent))
            __builtin_unreachable();
        } while (false);
      }
    }

    ~span() noexcept = default;

    constexpr span &operator=(const span &) noexcept = default;

    [[nodiscard]]
    constexpr size_type size() const noexcept {
      return this->_M_extent._M_extent();
    }

    [[nodiscard]]
    constexpr size_type size_bytes() const noexcept {
      return this->_M_extent._M_extent() * sizeof(element_type);
    }

    [[nodiscard]]
    constexpr bool empty() const noexcept {
      return size() == 0;
    }

    [[nodiscard]]
    constexpr reference front() const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(!empty()))
          __builtin_unreachable();
      } while (false);
      return *this->_M_ptr;
    }

    [[nodiscard]]
    constexpr reference back() const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(!empty()))
          __builtin_unreachable();
      } while (false);
      return *(this->_M_ptr + (size() - 1));
    }

    [[nodiscard]]
    constexpr reference operator[](size_type __idx) const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(__idx < size()))
          __builtin_unreachable();
      } while (false);
      return *(this->_M_ptr + __idx);
    }

    [[nodiscard]]
    constexpr pointer data() const noexcept {
      return this->_M_ptr;
    }

    [[nodiscard]]
    constexpr iterator begin() const noexcept {
      return iterator(this->_M_ptr);
    }

    [[nodiscard]]
    constexpr iterator end() const noexcept {
      return iterator(this->_M_ptr + this->size());
    }

    [[nodiscard]]
    constexpr reverse_iterator rbegin() const noexcept {
      return reverse_iterator(this->end());
    }

    [[nodiscard]]
    constexpr reverse_iterator rend() const noexcept {
      return reverse_iterator(this->begin());
    }
# 343 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/span" 3
    template <size_t _Count>
    [[nodiscard]]
    constexpr span<element_type, _Count> first() const noexcept {
      if constexpr (_Extent == dynamic_extent)
        do {
          if (std::__is_constant_evaluated() && !bool(_Count <= size()))
            __builtin_unreachable();
        } while (false);
      else
        static_assert(_Count <= extent);
      using _Sp = span<element_type, _Count>;
      return _Sp{this->data(), _Count};
    }

    [[nodiscard]]
    constexpr span<element_type, dynamic_extent>
    first(size_type __count) const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(__count <= size()))
          __builtin_unreachable();
      } while (false);
      return {this->data(), __count};
    }

    template <size_t _Count>
    [[nodiscard]]
    constexpr span<element_type, _Count> last() const noexcept {
      if constexpr (_Extent == dynamic_extent)
        do {
          if (std::__is_constant_evaluated() && !bool(_Count <= size()))
            __builtin_unreachable();
        } while (false);
      else
        static_assert(_Count <= extent);
      using _Sp = span<element_type, _Count>;
      return _Sp{this->data() + (this->size() - _Count), _Count};
    }

    [[nodiscard]]
    constexpr span<element_type, dynamic_extent>
    last(size_type __count) const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(__count <= size()))
          __builtin_unreachable();
      } while (false);
      return {this->data() + (this->size() - __count), __count};
    }

    template <size_t _Offset, size_t _Count = dynamic_extent>
    [[nodiscard]]
    constexpr auto subspan() const noexcept
        -> span<element_type, _S_subspan_extent<_Offset, _Count>()> {
      if constexpr (_Extent == dynamic_extent) {
        do {
          if (std::__is_constant_evaluated() && !bool(_Offset <= size()))
            __builtin_unreachable();
        } while (false);
      } else
        static_assert(_Offset <= extent);

      using _Sp = span<element_type, _S_subspan_extent<_Offset, _Count>()>;

      if constexpr (_Count == dynamic_extent)
        return _Sp{this->data() + _Offset, this->size() - _Offset};
      else {
        if constexpr (_Extent == dynamic_extent) {
          do {
            if (std::__is_constant_evaluated() && !bool(_Count <= size()))
              __builtin_unreachable();
          } while (false);
          do {
            if (std::__is_constant_evaluated() &&
                !bool(_Count <= (size() - _Offset)))
              __builtin_unreachable();
          } while (false);
        } else {
          static_assert(_Count <= extent);
          static_assert(_Count <= (extent - _Offset));
        }
        return _Sp{this->data() + _Offset, _Count};
      }
    }

    [[nodiscard]]
    constexpr span<element_type, dynamic_extent>
    subspan(size_type __offset,
            size_type __count = dynamic_extent) const noexcept {
      do {
        if (std::__is_constant_evaluated() && !bool(__offset <= size()))
          __builtin_unreachable();
      } while (false);
      if (__count == dynamic_extent)
        __count = this->size() - __offset;
      else {
        do {
          if (std::__is_constant_evaluated() && !bool(__count <= size()))
            __builtin_unreachable();
        } while (false);
        do {
          if (std::__is_constant_evaluated() &&
              !bool(__offset + __count <= size()))
            __builtin_unreachable();
        } while (false);
      }
      return {this->data() + __offset, __count};
    }

  private:
    pointer _M_ptr;
    [[no_unique_address]] __detail::__extent_storage<extent> _M_extent;
  };

  template <typename _Type, size_t _ArrayExtent>
  span(_Type(&)[_ArrayExtent]) -> span<_Type, _ArrayExtent>;

  template <typename _Type, size_t _ArrayExtent>
  span(array<_Type, _ArrayExtent> &) -> span<_Type, _ArrayExtent>;

  template <typename _Type, size_t _ArrayExtent>
  span(const array<_Type, _ArrayExtent> &) -> span<const _Type, _ArrayExtent>;

  template <contiguous_iterator _Iter, typename _End>
  span(_Iter, _End) -> span<remove_reference_t<iter_reference_t<_Iter>>>;

  template <ranges::contiguous_range _Range>
  span(_Range &&)
      -> span<remove_reference_t<ranges::range_reference_t<_Range &>>>;

  template <typename _Type, size_t _Extent>
  [[nodiscard]]
  inline span<const byte, _Extent == dynamic_extent ? dynamic_extent
                                                    : _Extent * sizeof(_Type)>
  as_bytes(span<_Type, _Extent> __sp) noexcept {
    auto data = reinterpret_cast<const byte *>(__sp.data());
    auto size = __sp.size_bytes();
    constexpr auto extent =
        _Extent == dynamic_extent ? dynamic_extent : _Extent * sizeof(_Type);
    return span<const byte, extent>{data, size};
  }

  template <typename _Type, size_t _Extent>
    requires(!is_const_v<_Type>)
  inline span<byte, _Extent == dynamic_extent ? dynamic_extent
                                              : _Extent * sizeof(_Type)>
  as_writable_bytes [[nodiscard]] (span<_Type, _Extent> __sp) noexcept {
    auto data = reinterpret_cast<byte *>(__sp.data());
    auto size = __sp.size_bytes();
    constexpr auto extent =
        _Extent == dynamic_extent ? dynamic_extent : _Extent * sizeof(_Type);
    return span<byte, extent>{data, size};
  }

  namespace ranges {

  template <typename _ElementType, size_t _Extent>
  inline constexpr bool enable_borrowed_range<span<_ElementType, _Extent>> =
      true;

  template <typename _ElementType, size_t _Extent>
  inline constexpr bool enable_view<span<_ElementType, _Extent>> = true;
  } // namespace ranges

} // namespace std
# 3 "./ComputeSPMV_stdexec.hpp" 2
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ranges" 1 3
# 36 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ranges" 3
# 60 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ranges" 3
namespace std __attribute__((__visibility__("default"))) {

  namespace ranges {
# 77 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ranges" 3
  template <typename _Tp>
    requires is_object_v<_Tp>
  class empty_view : public view_interface<empty_view<_Tp>> {
  public:
    static constexpr _Tp *begin() noexcept { return nullptr; }
    static constexpr _Tp *end() noexcept { return nullptr; }
    static constexpr _Tp *data() noexcept { return nullptr; }
    static constexpr size_t size() noexcept { return 0; }
    static constexpr bool empty() noexcept { return true; }
  };

  template <typename _Tp>
  inline constexpr bool enable_borrowed_range<empty_view<_Tp>> = true;

  namespace __detail {
  template <typename _Tp>
  concept __boxable = copy_constructible<_Tp> && is_object_v<_Tp>;

  template <__boxable _Tp> struct __box : std::optional<_Tp> {
    using std::optional<_Tp>::optional;

    constexpr __box() noexcept(is_nothrow_default_constructible_v<_Tp>)
      requires default_initializable<_Tp>
        : std::optional<_Tp>{std::in_place} {}

    __box(const __box &) = default;
    __box(__box &&) = default;

    using std::optional<_Tp>::operator=;

    constexpr __box &operator=(const __box &__that) noexcept(
        is_nothrow_copy_constructible_v<_Tp>)
      requires(!copyable<_Tp>)
    {
      if (this != std::__addressof(__that)) {
        if ((bool)__that)
          this->emplace(*__that);
        else
          this->reset();
      }
      return *this;
    }

    constexpr __box &
    operator=(__box &&__that) noexcept(is_nothrow_move_constructible_v<_Tp>)
      requires(!movable<_Tp>)
    {
      if (this != std::__addressof(__that)) {
        if ((bool)__that)
          this->emplace(std::move(*__that));
        else
          this->reset();
      }
      return *this;
    }
  };

  template <__boxable _Tp>
    requires copyable<_Tp> || (is_nothrow_move_constructible_v<_Tp> &&
                               is_nothrow_copy_constructible_v<_Tp>)
  struct __box<_Tp> {
  private:
    [[no_unique_address]] _Tp _M_value = _Tp();

  public:
    __box()
      requires default_initializable<_Tp>
    = default;

    constexpr explicit __box(const _Tp &__t) noexcept(
        is_nothrow_copy_constructible_v<_Tp>)
        : _M_value(__t) {}

    constexpr explicit __box(_Tp &&__t) noexcept(
        is_nothrow_move_constructible_v<_Tp>)
        : _M_value(std::move(__t)) {}

    template <typename... _Args>
      requires constructible_from<_Tp, _Args...>
    constexpr explicit __box(in_place_t, _Args &&...__args) noexcept(
        is_nothrow_constructible_v<_Tp, _Args...>)
        : _M_value(std::forward<_Args>(__args)...) {}

    __box(const __box &) = default;
    __box(__box &&) = default;
    __box &operator=(const __box &)
      requires copyable<_Tp>
    = default;
    __box &operator=(__box &&)
      requires copyable<_Tp>
    = default;

    constexpr __box &operator=(const __box &__that) noexcept {
      static_assert(is_nothrow_copy_constructible_v<_Tp>);
      if (this != std::__addressof(__that)) {
        _M_value.~_Tp();
        std::construct_at(std::__addressof(_M_value), *__that);
      }
      return *this;
    }

    constexpr __box &operator=(__box &&__that) noexcept {
      static_assert(is_nothrow_move_constructible_v<_Tp>);
      if (this != std::__addressof(__that)) {
        _M_value.~_Tp();
        std::construct_at(std::__addressof(_M_value), std::move(*__that));
      }
      return *this;
    }

    constexpr bool has_value() const noexcept { return true; };

    constexpr _Tp &operator*() noexcept { return _M_value; }

    constexpr const _Tp &operator*() const noexcept { return _M_value; }

    constexpr _Tp *operator->() noexcept { return std::__addressof(_M_value); }

    constexpr const _Tp *operator->() const noexcept {
      return std::__addressof(_M_value);
    }
  };
  } // namespace __detail

  template <copy_constructible _Tp>
    requires is_object_v<_Tp>
  class single_view : public view_interface<single_view<_Tp>> {
  public:
    single_view()
      requires default_initializable<_Tp>
    = default;

    constexpr explicit single_view(const _Tp &__t) noexcept(
        is_nothrow_copy_constructible_v<_Tp>)
        : _M_value(__t) {}

    constexpr explicit single_view(_Tp &&__t) noexcept(
        is_nothrow_move_constructible_v<_Tp>)
        : _M_value(std::move(__t)) {}

    template <typename... _Args>
      requires constructible_from<_Tp, _Args...>
    constexpr explicit single_view(in_place_t, _Args &&...__args) noexcept(
        is_nothrow_constructible_v<_Tp, _Args...>)
        : _M_value{in_place, std::forward<_Args>(__args)...} {}

    constexpr _Tp *begin() noexcept { return data(); }

    constexpr const _Tp *begin() const noexcept { return data(); }

    constexpr _Tp *end() noexcept { return data() + 1; }

    constexpr const _Tp *end() const noexcept { return data() + 1; }

    static constexpr size_t size() noexcept { return 1; }

    constexpr _Tp *data() noexcept { return _M_value.operator->(); }

    constexpr const _Tp *data() const noexcept { return _M_value.operator->(); }

  private:
    [[no_unique_address]] __detail::__box<_Tp> _M_value;
  };

  template <typename _Tp> single_view(_Tp) -> single_view<_Tp>;

  namespace __detail {
  template <typename _Wp> constexpr auto __to_signed_like(_Wp __w) noexcept {
    if constexpr (!integral<_Wp>)
      return iter_difference_t<_Wp>();
    else if constexpr (sizeof(iter_difference_t<_Wp>) > sizeof(_Wp))
      return iter_difference_t<_Wp>(__w);
    else if constexpr (sizeof(ptrdiff_t) > sizeof(_Wp))
      return ptrdiff_t(__w);
    else if constexpr (sizeof(long long) > sizeof(_Wp))
      return (long long)(__w);

    else if constexpr (16 > sizeof(_Wp))
      return __int128(__w);

    else
      return __max_diff_type(__w);
  }

  template <typename _Wp>
  using __iota_diff_t = decltype(__to_signed_like(std::declval<_Wp>()));

  template <typename _It>
  concept __decrementable = incrementable<_It> && requires(_It __i) {
    { --__i } -> same_as<_It &>;
    { __i-- } -> same_as<_It>;
  };

  template <typename _It>
  concept __advanceable =
      __decrementable<_It> && totally_ordered<_It> &&
      requires(_It __i, const _It __j, const __iota_diff_t<_It> __n) {
        { __i += __n } -> same_as<_It &>;
        { __i -= __n } -> same_as<_It &>;
        _It(__j + __n);
        _It(__n + __j);
        _It(__j - __n);
        { __j - __j } -> convertible_to<__iota_diff_t<_It>>;
      };

  template <typename _Winc> struct __iota_view_iter_cat {};

  template <incrementable _Winc> struct __iota_view_iter_cat<_Winc> {
    using iterator_category = input_iterator_tag;
  };
  } // namespace __detail

  template <weakly_incrementable _Winc,
            semiregular _Bound = unreachable_sentinel_t>
    requires std::__detail::__weakly_eq_cmp_with<_Winc, _Bound> &&
             copyable<_Winc>
  class iota_view : public view_interface<iota_view<_Winc, _Bound>> {
  private:
    struct _Sentinel;

    struct _Iterator : __detail::__iota_view_iter_cat<_Winc> {
    private:
      static auto _S_iter_concept() {
        using namespace __detail;
        if constexpr (__advanceable<_Winc>)
          return random_access_iterator_tag{};
        else if constexpr (__decrementable<_Winc>)
          return bidirectional_iterator_tag{};
        else if constexpr (incrementable<_Winc>)
          return forward_iterator_tag{};
        else
          return input_iterator_tag{};
      }

    public:
      using iterator_concept = decltype(_S_iter_concept());

      using value_type = _Winc;
      using difference_type = __detail::__iota_diff_t<_Winc>;

      _Iterator()
        requires default_initializable<_Winc>
      = default;

      constexpr explicit _Iterator(_Winc __value) : _M_value(__value) {}

      constexpr _Winc operator*() const
          noexcept(is_nothrow_copy_constructible_v<_Winc>) {
        return _M_value;
      }

      constexpr _Iterator &operator++() {
        ++_M_value;
        return *this;
      }

      constexpr void operator++(int) { ++*this; }

      constexpr _Iterator operator++(int)
        requires incrementable<_Winc>
      {
        auto __tmp = *this;
        ++*this;
        return __tmp;
      }

      constexpr _Iterator &operator--()
        requires __detail::__decrementable<_Winc>
      {
        --_M_value;
        return *this;
      }

      constexpr _Iterator operator--(int)
        requires __detail::__decrementable<_Winc>
      {
        auto __tmp = *this;
        --*this;
        return __tmp;
      }

      constexpr _Iterator &operator+=(difference_type __n)
        requires __detail::__advanceable<_Winc>
      {
        using __detail::__is_integer_like;
        using __detail::__is_signed_integer_like;
        if constexpr (__is_integer_like<_Winc> &&
                      !__is_signed_integer_like<_Winc>) {
          if (__n >= difference_type(0))
            _M_value += static_cast<_Winc>(__n);
          else
            _M_value -= static_cast<_Winc>(-__n);
        } else
          _M_value += __n;
        return *this;
      }

      constexpr _Iterator &operator-=(difference_type __n)
        requires __detail::__advanceable<_Winc>
      {
        using __detail::__is_integer_like;
        using __detail::__is_signed_integer_like;
        if constexpr (__is_integer_like<_Winc> &&
                      !__is_signed_integer_like<_Winc>) {
          if (__n >= difference_type(0))
            _M_value -= static_cast<_Winc>(__n);
          else
            _M_value += static_cast<_Winc>(-__n);
        } else
          _M_value -= __n;
        return *this;
      }

      constexpr _Winc operator[](difference_type __n) const
        requires __detail::__advanceable<_Winc>
      {
        return _Winc(_M_value + __n);
      }

      friend constexpr bool operator==(const _Iterator &__x,
                                       const _Iterator &__y)
        requires equality_comparable<_Winc>
      {
        return __x._M_value == __y._M_value;
      }

      friend constexpr bool operator<(const _Iterator &__x,
                                      const _Iterator &__y)
        requires totally_ordered<_Winc>
      {
        return __x._M_value < __y._M_value;
      }

      friend constexpr bool operator>(const _Iterator &__x,
                                      const _Iterator &__y)
        requires totally_ordered<_Winc>
      {
        return __y < __x;
      }

      friend constexpr bool operator<=(const _Iterator &__x,
                                       const _Iterator &__y)
        requires totally_ordered<_Winc>
      {
        return !(__y < __x);
      }

      friend constexpr bool operator>=(const _Iterator &__x,
                                       const _Iterator &__y)
        requires totally_ordered<_Winc>
      {
        return !(__x < __y);
      }

      friend constexpr auto operator<=>(const _Iterator &__x,
                                        const _Iterator &__y)
        requires totally_ordered<_Winc> && three_way_comparable<_Winc>
      {
        return __x._M_value <=> __y._M_value;
      }

      friend constexpr _Iterator operator+(_Iterator __i, difference_type __n)
        requires __detail::__advanceable<_Winc>
      {
        __i += __n;
        return __i;
      }

      friend constexpr _Iterator operator+(difference_type __n, _Iterator __i)
        requires __detail::__advanceable<_Winc>
      {
        return __i += __n;
      }

      friend constexpr _Iterator operator-(_Iterator __i, difference_type __n)
        requires __detail::__advanceable<_Winc>
      {
        __i -= __n;
        return __i;
      }

      friend constexpr difference_type operator-(const _Iterator &__x,
                                                 const _Iterator &__y)
        requires __detail::__advanceable<_Winc>
      {
        using __detail::__is_integer_like;
        using __detail::__is_signed_integer_like;
        using _Dt = difference_type;
        if constexpr (__is_integer_like<_Winc>) {
          if constexpr (__is_signed_integer_like<_Winc>)
            return _Dt(_Dt(__x._M_value) - _Dt(__y._M_value));
          else
            return (__y._M_value > __x._M_value)
                       ? _Dt(-_Dt(__y._M_value - __x._M_value))
                       : _Dt(__x._M_value - __y._M_value);
        } else
          return __x._M_value - __y._M_value;
      }

    private:
      _Winc _M_value = _Winc();

      friend iota_view;
      friend _Sentinel;
    };

    struct _Sentinel {
    private:
      constexpr bool _M_equal(const _Iterator &__x) const {
        return __x._M_value == _M_bound;
      }

      constexpr auto _M_distance_from(const _Iterator &__x) const {
        return _M_bound - __x._M_value;
      }

      _Bound _M_bound = _Bound();

    public:
      _Sentinel() = default;

      constexpr explicit _Sentinel(_Bound __bound) : _M_bound(__bound) {}

      friend constexpr bool operator==(const _Iterator &__x,
                                       const _Sentinel &__y) {
        return __y._M_equal(__x);
      }

      friend constexpr iter_difference_t<_Winc> operator-(const _Iterator &__x,
                                                          const _Sentinel &__y)
        requires sized_sentinel_for<_Bound, _Winc>
      {
        return -__y._M_distance_from(__x);
      }

      friend constexpr iter_difference_t<_Winc> operator-(const _Sentinel &__x,
                                                          const _Iterator &__y)
        requires sized_sentinel_for<_Bound, _Winc>
      {
        return __x._M_distance_from(__y);
      }

      friend iota_view;
    };

    _Winc _M_value = _Winc();
    [[no_unique_address]] _Bound _M_bound = _Bound();

  public:
    iota_view()
      requires default_initializable<_Winc>
    = default;

    constexpr explicit iota_view(_Winc __value) : _M_value(__value) {}

    constexpr iota_view(type_identity_t<_Winc> __value,
                        type_identity_t<_Bound> __bound)
        : _M_value(__value), _M_bound(__bound) {
      if constexpr (totally_ordered_with<_Winc, _Bound>)
        do {
          if (std::__is_constant_evaluated() && !bool(bool(__value <= __bound)))
            __builtin_unreachable();
        } while (false);
    }

    constexpr iota_view(_Iterator __first, _Iterator __last)
      requires same_as<_Winc, _Bound>
        : iota_view(__first._M_value, __last._M_value) {}

    constexpr iota_view(_Iterator __first, unreachable_sentinel_t __last)
      requires same_as<_Bound, unreachable_sentinel_t>
        : iota_view(__first._M_value, __last) {}

    constexpr iota_view(_Iterator __first, _Sentinel __last)
      requires(!same_as<_Winc, _Bound>) &&
              (!same_as<_Bound, unreachable_sentinel_t>)
        : iota_view(__first._M_value, __last._M_bound) {}

    constexpr _Iterator begin() const { return _Iterator{_M_value}; }

    constexpr auto end() const {
      if constexpr (same_as<_Bound, unreachable_sentinel_t>)
        return unreachable_sentinel;
      else
        return _Sentinel{_M_bound};
    }

    constexpr _Iterator end() const
      requires same_as<_Winc, _Bound>
    {
      return _Iterator{_M_bound};
    }

    constexpr auto size() const
      requires(same_as<_Winc, _Bound> && __detail::__advanceable<_Winc>) ||
              (integral<_Winc> && integral<_Bound>) ||
              sized_sentinel_for<_Bound, _Winc>
    {
      using __detail::__is_integer_like;
      using __detail::__to_unsigned_like;
      if constexpr (integral<_Winc> && integral<_Bound>) {
        using _Up = make_unsigned_t<decltype(_M_bound - _M_value)>;
        return _Up(_M_bound) - _Up(_M_value);
      } else if constexpr (__is_integer_like<_Winc>)
        return __to_unsigned_like(_M_bound) - __to_unsigned_like(_M_value);
      else
        return __to_unsigned_like(_M_bound - _M_value);
    }
  };

  template <typename _Winc, typename _Bound>
    requires(!__detail::__is_integer_like<_Winc> ||
             !__detail::__is_integer_like<_Bound> ||
             (__detail::__is_signed_integer_like<_Winc> ==
              __detail::__is_signed_integer_like<_Bound>))
  iota_view(_Winc, _Bound) -> iota_view<_Winc, _Bound>;

  template <typename _Winc, typename _Bound>
  inline constexpr bool enable_borrowed_range<iota_view<_Winc, _Bound>> = true;

  namespace views {
  template <typename _Tp> inline constexpr empty_view<_Tp> empty{};

  namespace __detail {
  template <typename _Tp>
  concept __can_single_view =
      requires { single_view<decay_t<_Tp>>(std::declval<_Tp>()); };
  } // namespace __detail

  struct _Single {
    template <__detail::__can_single_view _Tp>
    constexpr auto operator() [[nodiscard]] (_Tp &&__e) const
        noexcept(noexcept(single_view<decay_t<_Tp>>(std::forward<_Tp>(__e)))) {
      return single_view<decay_t<_Tp>>(std::forward<_Tp>(__e));
    }
  };

  inline constexpr _Single single{};

  namespace __detail {
  template <typename... _Args>
  concept __can_iota_view = requires { iota_view(std::declval<_Args>()...); };
  } // namespace __detail

  struct _Iota {
    template <__detail::__can_iota_view _Tp>
    constexpr auto operator() [[nodiscard]] (_Tp &&__e) const {
      return iota_view(std::forward<_Tp>(__e));
    }

    template <typename _Tp, typename _Up>
      requires __detail::__can_iota_view<_Tp, _Up>
    constexpr auto operator() [[nodiscard]] (_Tp &&__e, _Up &&__f) const {
      return iota_view(std::forward<_Tp>(__e), std::forward<_Up>(__f));
    }
  };

  inline constexpr _Iota iota{};
  } // namespace views

  namespace __detail {
  template <typename _Val, typename _CharT, typename _Traits>
  concept __stream_extractable =
      requires(basic_istream<_CharT, _Traits> &is, _Val &t) { is >> t; };
  } // namespace __detail

  template <movable _Val, typename _CharT,
            typename _Traits = char_traits<_CharT>>
    requires default_initializable<_Val> &&
             __detail::__stream_extractable<_Val, _CharT, _Traits>
  class basic_istream_view
      : public view_interface<basic_istream_view<_Val, _CharT, _Traits>> {
  public:
    constexpr explicit basic_istream_view(
        basic_istream<_CharT, _Traits> &__stream)
        : _M_stream(std::__addressof(__stream)) {}

    constexpr auto begin() {
      *_M_stream >> _M_object;
      return _Iterator{this};
    }

    constexpr default_sentinel_t end() const noexcept {
      return default_sentinel;
    }

  private:
    basic_istream<_CharT, _Traits> *_M_stream;
    _Val _M_object = _Val();

    struct _Iterator {
    public:
      using iterator_concept = input_iterator_tag;
      using difference_type = ptrdiff_t;
      using value_type = _Val;

      constexpr explicit _Iterator(basic_istream_view *__parent) noexcept
          : _M_parent(__parent) {}

      _Iterator(const _Iterator &) = delete;
      _Iterator(_Iterator &&) = default;
      _Iterator &operator=(const _Iterator &) = delete;
      _Iterator &operator=(_Iterator &&) = default;

      _Iterator &operator++() {
        *_M_parent->_M_stream >> _M_parent->_M_object;
        return *this;
      }

      void operator++(int) { ++*this; }

      _Val &operator*() const { return _M_parent->_M_object; }

      friend bool operator==(const _Iterator &__x, default_sentinel_t) {
        return __x._M_at_end();
      }

    private:
      basic_istream_view *_M_parent;

      bool _M_at_end() const { return !*_M_parent->_M_stream; }
    };

    friend _Iterator;
  };

  template <typename _Val> using istream_view = basic_istream_view<_Val, char>;

  template <typename _Val>
  using wistream_view = basic_istream_view<_Val, wchar_t>;

  namespace views {
  namespace __detail {
  template <typename _Tp, typename _Up>
  concept __can_istream_view = requires(_Up __e) {
    basic_istream_view<_Tp, typename _Up::char_type, typename _Up::traits_type>(
        __e);
  };
  } // namespace __detail

  template <typename _Tp> struct _Istream {
    template <typename _CharT, typename _Traits>
    constexpr auto operator()
        [[nodiscard]] (basic_istream<_CharT, _Traits> &__e) const
      requires __detail::__can_istream_view<_Tp,
                                            remove_reference_t<decltype(__e)>>
    {
      return basic_istream_view<_Tp, _CharT, _Traits>(__e);
    }
  };

  template <typename _Tp> inline constexpr _Istream<_Tp> istream;
  } // namespace views

  namespace __detail {
  struct _Empty {};

  template <bool _Present, typename _Tp>
  using __maybe_present_t = __conditional_t<_Present, _Tp, _Empty>;

  template <bool _Const, typename _Tp>
  using __maybe_const_t = __conditional_t<_Const, const _Tp, _Tp>;

  } // namespace __detail

  using __detail::__maybe_const_t;

  namespace views::__adaptor {

  template <typename _Adaptor, typename... _Args>
  concept __adaptor_invocable =
      requires { std::declval<_Adaptor>()(declval<_Args>()...); };

  template <typename _Adaptor, typename... _Args>
  concept __adaptor_partial_app_viable =
      (_Adaptor::_S_arity > 1) &&
      (sizeof...(_Args) == _Adaptor::_S_arity - 1) &&
      (constructible_from<decay_t<_Args>, _Args> && ...);

  template <typename _Adaptor, typename... _Args> struct _Partial;

  template <typename _Lhs, typename _Rhs> struct _Pipe;

  struct _RangeAdaptorClosure {

    template <typename _Self, typename _Range>
      requires derived_from<remove_cvref_t<_Self>, _RangeAdaptorClosure> &&
               __adaptor_invocable<_Self, _Range>
    friend constexpr auto operator|(_Range &&__r, _Self &&__self) {
      return std::forward<_Self>(__self)(std::forward<_Range>(__r));
    }

    template <typename _Lhs, typename _Rhs>
      requires derived_from<_Lhs, _RangeAdaptorClosure> &&
               derived_from<_Rhs, _RangeAdaptorClosure>
    friend constexpr auto operator|(_Lhs __lhs, _Rhs __rhs) {
      return _Pipe<_Lhs, _Rhs>{std::move(__lhs), std::move(__rhs)};
    }
  };
# 911 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ranges" 3
  template <typename _Derived> struct _RangeAdaptor {

    template <typename... _Args>
      requires __adaptor_partial_app_viable<_Derived, _Args...>
    constexpr auto operator()(_Args &&...__args) const {
      return _Partial<_Derived, decay_t<_Args>...>{
          std::forward<_Args>(__args)...};
    }
  };

  template <typename _Adaptor>
  concept __closure_has_simple_call_op = _Adaptor::_S_has_simple_call_op;

  template <typename _Adaptor, typename... _Args>
  concept __adaptor_has_simple_extra_args =
      _Adaptor::_S_has_simple_extra_args ||
      _Adaptor::template _S_has_simple_extra_args<_Args...>;

  template <typename _Adaptor, typename... _Args>
  struct _Partial : _RangeAdaptorClosure {
    tuple<_Args...> _M_args;

    constexpr _Partial(_Args... __args) : _M_args(std::move(__args)...) {}

    template <typename _Range>
      requires __adaptor_invocable<_Adaptor, _Range, const _Args &...>
    constexpr auto operator()(_Range &&__r) const & {
      auto __forwarder = [&__r](const auto &...__args) {
        return _Adaptor{}(std::forward<_Range>(__r), __args...);
      };
      return std::apply(__forwarder, _M_args);
    }

    template <typename _Range>
      requires __adaptor_invocable<_Adaptor, _Range, _Args...>
    constexpr auto operator()(_Range &&__r) && {
      auto __forwarder = [&__r](auto &...__args) {
        return _Adaptor{}(std::forward<_Range>(__r), std::move(__args)...);
      };
      return std::apply(__forwarder, _M_args);
    }

    template <typename _Range>
    constexpr auto operator()(_Range &&__r) const && = delete;
  };

  template <typename _Adaptor, typename _Arg>
  struct _Partial<_Adaptor, _Arg> : _RangeAdaptorClosure {
    _Arg _M_arg;

    constexpr _Partial(_Arg __arg) : _M_arg(std::move(__arg)) {}

    template <typename _Range>
      requires __adaptor_invocable<_Adaptor, _Range, const _Arg &>
    constexpr auto operator()(_Range &&__r) const & {
      return _Adaptor{}(std::forward<_Range>(__r), _M_arg);
    }

    template <typename _Range>
      requires __adaptor_invocable<_Adaptor, _Range, _Arg>
    constexpr auto operator()(_Range &&__r) && {
      return _Adaptor{}(std::forward<_Range>(__r), std::move(_M_arg));
    }

    template <typename _Range>
    constexpr auto operator()(_Range &&__r) const && = delete;
  };

  template <typename _Adaptor, typename... _Args>
    requires __adaptor_has_simple_extra_args<_Adaptor, _Args...> &&
             (is_trivially_copyable_v<_Args> && ...)
  struct _Partial<_Adaptor, _Args...> : _RangeAdaptorClosure {
    tuple<_Args...> _M_args;

    constexpr _Partial(_Args... __args) : _M_args(std::move(__args)...) {}

    template <typename _Range>
      requires __adaptor_invocable<_Adaptor, _Range, const _Args &...>
    constexpr auto operator()(_Range &&__r) const {
      auto __forwarder = [&__r](const auto &...__args) {
        return _Adaptor{}(std::forward<_Range>(__r), __args...);
      };
      return std::apply(__forwarder, _M_args);
    }

    static constexpr bool _S_has_simple_call_op = true;
  };

  template <typename _Adaptor, typename _Arg>
    requires __adaptor_has_simple_extra_args<_Adaptor, _Arg> &&
             is_trivially_copyable_v<_Arg>
  struct _Partial<_Adaptor, _Arg> : _RangeAdaptorClosure {
    _Arg _M_arg;

    constexpr _Partial(_Arg __arg) : _M_arg(std::move(__arg)) {}

    template <typename _Range>
      requires __adaptor_invocable<_Adaptor, _Range, const _Arg &>
    constexpr auto operator()(_Range &&__r) const {
      return _Adaptor{}(std::forward<_Range>(__r), _M_arg);
    }

    static constexpr bool _S_has_simple_call_op = true;
  };

  template <typename _Lhs, typename _Rhs, typename _Range>
  concept __pipe_invocable = requires {
    std::declval<_Rhs>()(std::declval<_Lhs>()(std::declval<_Range>()));
  };

  template <typename _Lhs, typename _Rhs> struct _Pipe : _RangeAdaptorClosure {
    [[no_unique_address]] _Lhs _M_lhs;
    [[no_unique_address]] _Rhs _M_rhs;

    constexpr _Pipe(_Lhs __lhs, _Rhs __rhs)
        : _M_lhs(std::move(__lhs)), _M_rhs(std::move(__rhs)) {}

    template <typename _Range>
      requires __pipe_invocable<const _Lhs &, const _Rhs &, _Range>
    constexpr auto operator()(_Range &&__r) const & {
      return _M_rhs(_M_lhs(std::forward<_Range>(__r)));
    }

    template <typename _Range>
      requires __pipe_invocable<_Lhs, _Rhs, _Range>
    constexpr auto operator()(_Range &&__r) && {
      return std::move(_M_rhs)(std::move(_M_lhs)(std::forward<_Range>(__r)));
    }

    template <typename _Range>
    constexpr auto operator()(_Range &&__r) const && = delete;
  };

  template <typename _Lhs, typename _Rhs>
    requires __closure_has_simple_call_op<_Lhs> &&
             __closure_has_simple_call_op<_Rhs>
  struct _Pipe<_Lhs, _Rhs> : _RangeAdaptorClosure {
    [[no_unique_address]] _Lhs _M_lhs;
    [[no_unique_address]] _Rhs _M_rhs;

    constexpr _Pipe(_Lhs __lhs, _Rhs __rhs)
        : _M_lhs(std::move(__lhs)), _M_rhs(std::move(__rhs)) {}

    template <typename _Range>
      requires __pipe_invocable<const _Lhs &, const _Rhs &, _Range>
    constexpr auto operator()(_Range &&__r) const {
      return _M_rhs(_M_lhs(std::forward<_Range>(__r)));
    }

    static constexpr bool _S_has_simple_call_op = true;
  };
  } // namespace views::__adaptor
# 1133 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ranges" 3
  template <range _Range>
    requires is_object_v<_Range>
  class ref_view : public view_interface<ref_view<_Range>> {
  private:
    _Range *_M_r;

    static void _S_fun(_Range &);
    static void _S_fun(_Range &&) = delete;

  public:
    template <__detail::__different_from<ref_view> _Tp>
      requires convertible_to<_Tp, _Range &> &&
               requires { _S_fun(declval<_Tp>()); }
    constexpr ref_view(_Tp &&__t) noexcept(
        noexcept(static_cast<_Range &>(std::declval<_Tp>())))
        : _M_r(
              std::__addressof(static_cast<_Range &>(std::forward<_Tp>(__t)))) {
    }

    constexpr _Range &base() const { return *_M_r; }

    constexpr iterator_t<_Range> begin() const { return ranges::begin(*_M_r); }

    constexpr sentinel_t<_Range> end() const { return ranges::end(*_M_r); }

    constexpr bool empty() const
      requires requires { ranges::empty(*_M_r); }
    {
      return ranges::empty(*_M_r);
    }

    constexpr auto size() const
      requires sized_range<_Range>
    {
      return ranges::size(*_M_r);
    }

    constexpr auto data() const
      requires contiguous_range<_Range>
    {
      return ranges::data(*_M_r);
    }
  };

  template <typename _Range> ref_view(_Range &) -> ref_view<_Range>;

  template <typename _Tp>
  inline constexpr bool enable_borrowed_range<ref_view<_Tp>> = true;

  template <range _Range>
    requires movable<_Range> &&
             (!__detail::__is_initializer_list<remove_cv_t<_Range>>)
  class owning_view : public view_interface<owning_view<_Range>> {
  private:
    _Range _M_r = _Range();

  public:
    owning_view()
      requires default_initializable<_Range>
    = default;

    constexpr owning_view(_Range &&__t) noexcept(
        is_nothrow_move_constructible_v<_Range>)
        : _M_r(std::move(__t)) {}

    owning_view(owning_view &&) = default;
    owning_view &operator=(owning_view &&) = default;

    constexpr _Range &base() & noexcept { return _M_r; }

    constexpr const _Range &base() const & noexcept { return _M_r; }

    constexpr _Range &&base() && noexcept { return std::move(_M_r); }

    constexpr const _Range &&base() const && noexcept {
      return std::move(_M_r);
    }

    constexpr iterator_t<_Range> begin() { return ranges::begin(_M_r); }

    constexpr sentinel_t<_Range> end() { return ranges::end(_M_r); }

    constexpr auto begin() const
      requires range<const _Range>
    {
      return ranges::begin(_M_r);
    }

    constexpr auto end() const
      requires range<const _Range>
    {
      return ranges::end(_M_r);
    }

    constexpr bool empty()
      requires requires { ranges::empty(_M_r); }
    {
      return ranges::empty(_M_r);
    }

    constexpr bool empty() const
      requires requires { ranges::empty(_M_r); }
    {
      return ranges::empty(_M_r);
    }

    constexpr auto size()
      requires sized_range<_Range>
    {
      return ranges::size(_M_r);
    }

    constexpr auto size() const
      requires sized_range<const _Range>
    {
      return ranges::size(_M_r);
    }

    constexpr auto data()
      requires contiguous_range<_Range>
    {
      return ranges::data(_M_r);
    }

    constexpr auto data() const
      requires contiguous_range<const _Range>
    {
      return ranges::data(_M_r);
    }
  };

  template <typename _Tp>
  inline constexpr bool enable_borrowed_range<owning_view<_Tp>> =
      enable_borrowed_range<_Tp>;

  namespace views {
  namespace __detail {
  template <typename _Range>
  concept __can_ref_view = requires { ref_view{std::declval<_Range>()}; };

  template <typename _Range>
  concept __can_owning_view = requires { owning_view{std::declval<_Range>()}; };
  } // namespace __detail

  struct _All : __adaptor::_RangeAdaptorClosure {
    template <typename _Range> static constexpr bool _S_noexcept() {
      if constexpr (view<decay_t<_Range>>)
        return is_nothrow_constructible_v<decay_t<_Range>, _Range>;
      else if constexpr (__detail::__can_ref_view<_Range>)
        return true;
      else
        return noexcept(owning_view{std::declval<_Range>()});
    }

    template <viewable_range _Range>
      requires view<decay_t<_Range>> || __detail::__can_ref_view<_Range> ||
               __detail::__can_owning_view<_Range>
    constexpr auto operator() [[nodiscard]] (_Range &&__r) const
        noexcept(_S_noexcept<_Range>()) {
      if constexpr (view<decay_t<_Range>>)
        return std::forward<_Range>(__r);
      else if constexpr (__detail::__can_ref_view<_Range>)
        return ref_view{std::forward<_Range>(__r)};
      else
        return owning_view{std::forward<_Range>(__r)};
    }

    static constexpr bool _S_has_simple_call_op = true;
  };

  inline constexpr _All all;

  template <viewable_range _Range>
  using all_t = decltype(all(std::declval<_Range>()));
  } // namespace views

  namespace __detail {
  template <typename _Tp> struct __non_propagating_cache {};

  template <typename _Tp>
    requires is_object_v<_Tp>
  struct __non_propagating_cache<_Tp> : protected _Optional_base<_Tp> {
    __non_propagating_cache() = default;

    constexpr __non_propagating_cache(
        const __non_propagating_cache &) noexcept {}

    constexpr __non_propagating_cache(
        __non_propagating_cache &&__other) noexcept {
      __other._M_reset();
    }

    constexpr __non_propagating_cache &
    operator=(const __non_propagating_cache &__other) noexcept {
      if (std::__addressof(__other) != this)
        this->_M_reset();
      return *this;
    }

    constexpr __non_propagating_cache &
    operator=(__non_propagating_cache &&__other) noexcept {
      this->_M_reset();
      __other._M_reset();
      return *this;
    }

    constexpr __non_propagating_cache &operator=(_Tp __val) {
      this->_M_reset();
      this->_M_payload._M_construct(std::move(__val));
      return *this;
    }

    constexpr explicit operator bool() const noexcept {
      return this->_M_is_engaged();
    }

    constexpr _Tp &operator*() noexcept { return this->_M_get(); }

    constexpr const _Tp &operator*() const noexcept { return this->_M_get(); }

    template <typename _Iter>
    constexpr _Tp &_M_emplace_deref(const _Iter &__i) {
      this->_M_reset();
      auto __f = [](auto &__x) { return *__x; };
      this->_M_payload._M_apply(_Optional_func{__f}, __i);
      return this->_M_get();
    }
  };

  template <range _Range> struct _CachedPosition {
    constexpr bool _M_has_value() const { return false; }

    constexpr iterator_t<_Range> _M_get(const _Range &) const {
      do {
        if (std::__is_constant_evaluated() && !bool(false))
          __builtin_unreachable();
      } while (false);
      __builtin_unreachable();
    }

    constexpr void _M_set(const _Range &, const iterator_t<_Range> &) const {}
  };

  template <forward_range _Range>
  struct _CachedPosition<_Range>
      : protected __non_propagating_cache<iterator_t<_Range>> {
    constexpr bool _M_has_value() const { return this->_M_is_engaged(); }

    constexpr iterator_t<_Range> _M_get(const _Range &) const {
      do {
        if (std::__is_constant_evaluated() && !bool(_M_has_value()))
          __builtin_unreachable();
      } while (false);
      return **this;
    }

    constexpr void _M_set(const _Range &, const iterator_t<_Range> &__it) {
      do {
        if (std::__is_constant_evaluated() && !bool(!_M_has_value()))
          __builtin_unreachable();
      } while (false);
      std::construct_at(std::__addressof(this->_M_payload._M_payload), in_place,
                        __it);
      this->_M_payload._M_engaged = true;
    }
  };

  template <random_access_range _Range>
    requires(sizeof(range_difference_t<_Range>) <= sizeof(iterator_t<_Range>))
  struct _CachedPosition<_Range> {
  private:
    range_difference_t<_Range> _M_offset = -1;

  public:
    _CachedPosition() = default;

    constexpr _CachedPosition(const _CachedPosition &) = default;

    constexpr _CachedPosition(_CachedPosition &&__other) noexcept {
      *this = std::move(__other);
    }

    constexpr _CachedPosition &operator=(const _CachedPosition &) = default;

    constexpr _CachedPosition &operator=(_CachedPosition &&__other) noexcept {

      _M_offset = __other._M_offset;
      __other._M_offset = -1;
      return *this;
    }

    constexpr bool _M_has_value() const { return _M_offset >= 0; }

    constexpr iterator_t<_Range> _M_get(_Range &__r) const {
      do {
        if (std::__is_constant_evaluated() && !bool(_M_has_value()))
          __builtin_unreachable();
      } while (false);
      return ranges::begin(__r) + _M_offset;
    }

    constexpr void _M_set(_Range &__r, const iterator_t<_Range> &__it) {
      do {
        if (std::__is_constant_evaluated() && !bool(!_M_has_value()))
          __builtin_unreachable();
      } while (false);
      _M_offset = __it - ranges::begin(__r);
    }
  };
  } // namespace __detail

  namespace __detail {
  template <typename _Base> struct __filter_view_iter_cat {};

  template <forward_range _Base> struct __filter_view_iter_cat<_Base> {
  private:
    static auto _S_iter_cat() {
      using _Cat =
          typename iterator_traits<iterator_t<_Base>>::iterator_category;
      if constexpr (derived_from<_Cat, bidirectional_iterator_tag>)
        return bidirectional_iterator_tag{};
      else if constexpr (derived_from<_Cat, forward_iterator_tag>)
        return forward_iterator_tag{};
      else
        return _Cat{};
    }

  public:
    using iterator_category = decltype(_S_iter_cat());
  };
  } // namespace __detail

  template <input_range _Vp, indirect_unary_predicate<iterator_t<_Vp>> _Pred>
    requires view<_Vp> && is_object_v<_Pred>
  class filter_view : public view_interface<filter_view<_Vp, _Pred>> {
  private:
    struct _Sentinel;

    struct _Iterator : __detail::__filter_view_iter_cat<_Vp> {
    private:
      static constexpr auto _S_iter_concept() {
        if constexpr (bidirectional_range<_Vp>)
          return bidirectional_iterator_tag{};
        else if constexpr (forward_range<_Vp>)
          return forward_iterator_tag{};
        else
          return input_iterator_tag{};
      }

      friend filter_view;

      using _Vp_iter = iterator_t<_Vp>;

      _Vp_iter _M_current = _Vp_iter();
      filter_view *_M_parent = nullptr;

    public:
      using iterator_concept = decltype(_S_iter_concept());

      using value_type = range_value_t<_Vp>;
      using difference_type = range_difference_t<_Vp>;

      _Iterator()
        requires default_initializable<_Vp_iter>
      = default;

      constexpr _Iterator(filter_view *__parent, _Vp_iter __current)
          : _M_current(std::move(__current)), _M_parent(__parent) {}

      constexpr const _Vp_iter &base() const & noexcept { return _M_current; }

      constexpr _Vp_iter base() && { return std::move(_M_current); }

      constexpr range_reference_t<_Vp> operator*() const { return *_M_current; }

      constexpr _Vp_iter operator->() const
        requires __detail::__has_arrow<_Vp_iter> && copyable<_Vp_iter>
      {
        return _M_current;
      }

      constexpr _Iterator &operator++() {
        _M_current = ranges::find_if(std::move(++_M_current),
                                     ranges::end(_M_parent->_M_base),
                                     std::ref(*_M_parent->_M_pred));
        return *this;
      }

      constexpr void operator++(int) { ++*this; }

      constexpr _Iterator operator++(int)
        requires forward_range<_Vp>
      {
        auto __tmp = *this;
        ++*this;
        return __tmp;
      }

      constexpr _Iterator &operator--()
        requires bidirectional_range<_Vp>
      {
        do
          --_M_current;
        while (!std::__invoke(*_M_parent->_M_pred, *_M_current));
        return *this;
      }

      constexpr _Iterator operator--(int)
        requires bidirectional_range<_Vp>
      {
        auto __tmp = *this;
        --*this;
        return __tmp;
      }

      friend constexpr bool operator==(const _Iterator &__x,
                                       const _Iterator &__y)
        requires equality_comparable<_Vp_iter>
      {
        return __x._M_current == __y._M_current;
      }

      friend constexpr range_rvalue_reference_t<_Vp>
      iter_move(const _Iterator &__i) noexcept(
          noexcept(ranges::iter_move(__i._M_current))) {
        return ranges::iter_move(__i._M_current);
      }

      friend constexpr void
      iter_swap(const _Iterator &__x, const _Iterator &__y) noexcept(
          noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
        requires indirectly_swappable<_Vp_iter>
      {
        ranges::iter_swap(__x._M_current, __y._M_current);
      }
    };

    struct _Sentinel {
    private:
      sentinel_t<_Vp> _M_end = sentinel_t<_Vp>();

      constexpr bool __equal(const _Iterator &__i) const {
        return __i._M_current == _M_end;
      }

    public:
      _Sentinel() = default;

      constexpr explicit _Sentinel(filter_view *__parent)
          : _M_end(ranges::end(__parent->_M_base)) {}

      constexpr sentinel_t<_Vp> base() const { return _M_end; }

      friend constexpr bool operator==(const _Iterator &__x,
                                       const _Sentinel &__y) {
        return __y.__equal(__x);
      }
    };

    _Vp _M_base = _Vp();
    [[no_unique_address]] __detail::__box<_Pred> _M_pred;
    [[no_unique_address]] __detail::_CachedPosition<_Vp> _M_cached_begin;

  public:
    filter_view()
      requires(default_initializable<_Vp> && default_initializable<_Pred>)
    = default;

    constexpr filter_view(_Vp __base, _Pred __pred)
        : _M_base(std::move(__base)), _M_pred(std::move(__pred)) {}

    constexpr _Vp base() const &
      requires copy_constructible<_Vp>
    {
      return _M_base;
    }

    constexpr _Vp base() && { return std::move(_M_base); }

    constexpr const _Pred &pred() const { return *_M_pred; }

    constexpr _Iterator begin() {
      if (_M_cached_begin._M_has_value())
        return {this, _M_cached_begin._M_get(_M_base)};

      do {
        if (std::__is_constant_evaluated() && !bool(_M_pred.has_value()))
          __builtin_unreachable();
      } while (false);
      auto __it = ranges::find_if(ranges::begin(_M_base), ranges::end(_M_base),
                                  std::ref(*_M_pred));
      _M_cached_begin._M_set(_M_base, __it);
      return {this, std::move(__it)};
    }

    constexpr auto end() {
      if constexpr (common_range<_Vp>)
        return _Iterator{this, ranges::end(_M_base)};
      else
        return _Sentinel{this};
    }
  };

  template <typename _Range, typename _Pred>
  filter_view(_Range &&, _Pred) -> filter_view<views::all_t<_Range>, _Pred>;

  namespace views {
  namespace __detail {
  template <typename _Range, typename _Pred>
  concept __can_filter_view =
      requires { filter_view(std::declval<_Range>(), std::declval<_Pred>()); };
  } // namespace __detail

  struct _Filter : __adaptor::_RangeAdaptor<_Filter> {
    template <viewable_range _Range, typename _Pred>
      requires __detail::__can_filter_view<_Range, _Pred>
    constexpr auto operator() [[nodiscard]] (_Range &&__r, _Pred &&__p) const {
      return filter_view(std::forward<_Range>(__r), std::forward<_Pred>(__p));
    }

    using _RangeAdaptor<_Filter>::operator();
    static constexpr int _S_arity = 2;
    static constexpr bool _S_has_simple_extra_args = true;
  };

  inline constexpr _Filter filter;
  } // namespace views

  template <input_range _Vp, copy_constructible _Fp>
    requires view<_Vp> && is_object_v<_Fp> &&
             regular_invocable<_Fp &, range_reference_t<_Vp>> &&
             std::__detail::__can_reference<
                 invoke_result_t<_Fp &, range_reference_t<_Vp>>>
  class transform_view : public view_interface<transform_view<_Vp, _Fp>> {
  private:
    template <bool _Const> using _Base = __detail::__maybe_const_t<_Const, _Vp>;

    template <bool _Const> struct __iter_cat {};

    template <bool _Const>
      requires forward_range<_Base<_Const>>
    struct __iter_cat<_Const> {
    private:
      static auto _S_iter_cat() {
        using _Base = transform_view::_Base<_Const>;
        using _Res = invoke_result_t<_Fp &, range_reference_t<_Base>>;
        if constexpr (is_lvalue_reference_v<_Res>) {
          using _Cat =
              typename iterator_traits<iterator_t<_Base>>::iterator_category;
          if constexpr (derived_from<_Cat, contiguous_iterator_tag>)
            return random_access_iterator_tag{};
          else
            return _Cat{};
        } else
          return input_iterator_tag{};
      }

    public:
      using iterator_category = decltype(_S_iter_cat());
    };

    template <bool _Const> struct _Sentinel;

    template <bool _Const> struct _Iterator : __iter_cat<_Const> {
    private:
      using _Parent = __detail::__maybe_const_t<_Const, transform_view>;
      using _Base = transform_view::_Base<_Const>;

      static auto _S_iter_concept() {
        if constexpr (random_access_range<_Base>)
          return random_access_iterator_tag{};
        else if constexpr (bidirectional_range<_Base>)
          return bidirectional_iterator_tag{};
        else if constexpr (forward_range<_Base>)
          return forward_iterator_tag{};
        else
          return input_iterator_tag{};
      }

      using _Base_iter = iterator_t<_Base>;

      _Base_iter _M_current = _Base_iter();
      _Parent *_M_parent = nullptr;

    public:
      using iterator_concept = decltype(_S_iter_concept());

      using value_type =
          remove_cvref_t<invoke_result_t<_Fp &, range_reference_t<_Base>>>;
      using difference_type = range_difference_t<_Base>;

      _Iterator()
        requires default_initializable<_Base_iter>
      = default;

      constexpr _Iterator(_Parent *__parent, _Base_iter __current)
          : _M_current(std::move(__current)), _M_parent(__parent) {}

      constexpr _Iterator(_Iterator<!_Const> __i)
        requires _Const && convertible_to<iterator_t<_Vp>, _Base_iter>
          : _M_current(std::move(__i._M_current)), _M_parent(__i._M_parent) {}

      constexpr const _Base_iter &base() const & noexcept { return _M_current; }

      constexpr _Base_iter base() && { return std::move(_M_current); }

      constexpr decltype(auto) operator*() const
          noexcept(noexcept(std::__invoke(*_M_parent->_M_fun, *_M_current))) {
        return std::__invoke(*_M_parent->_M_fun, *_M_current);
      }

      constexpr _Iterator &operator++() {
        ++_M_current;
        return *this;
      }

      constexpr void operator++(int) { ++_M_current; }

      constexpr _Iterator operator++(int)
        requires forward_range<_Base>
      {
        auto __tmp = *this;
        ++*this;
        return __tmp;
      }

      constexpr _Iterator &operator--()
        requires bidirectional_range<_Base>
      {
        --_M_current;
        return *this;
      }

      constexpr _Iterator operator--(int)
        requires bidirectional_range<_Base>
      {
        auto __tmp = *this;
        --*this;
        return __tmp;
      }

      constexpr _Iterator &operator+=(difference_type __n)
        requires random_access_range<_Base>
      {
        _M_current += __n;
        return *this;
      }

      constexpr _Iterator &operator-=(difference_type __n)
        requires random_access_range<_Base>
      {
        _M_current -= __n;
        return *this;
      }

      constexpr decltype(auto) operator[](difference_type __n) const
        requires random_access_range<_Base>
      {
        return std::__invoke(*_M_parent->_M_fun, _M_current[__n]);
      }

      friend constexpr bool operator==(const _Iterator &__x,
                                       const _Iterator &__y)
        requires equality_comparable<_Base_iter>
      {
        return __x._M_current == __y._M_current;
      }

      friend constexpr bool operator<(const _Iterator &__x,
                                      const _Iterator &__y)
        requires random_access_range<_Base>
      {
        return __x._M_current < __y._M_current;
      }

      friend constexpr bool operator>(const _Iterator &__x,
                                      const _Iterator &__y)
        requires random_access_range<_Base>
      {
        return __y < __x;
      }

      friend constexpr bool operator<=(const _Iterator &__x,
                                       const _Iterator &__y)
        requires random_access_range<_Base>
      {
        return !(__y < __x);
      }

      friend constexpr bool operator>=(const _Iterator &__x,
                                       const _Iterator &__y)
        requires random_access_range<_Base>
      {
        return !(__x < __y);
      }

      friend constexpr auto operator<=>(const _Iterator &__x,
                                        const _Iterator &__y)
        requires random_access_range<_Base> && three_way_comparable<_Base_iter>
      {
        return __x._M_current <=> __y._M_current;
      }

      friend constexpr _Iterator operator+(_Iterator __i, difference_type __n)
        requires random_access_range<_Base>
      {
        return {__i._M_parent, __i._M_current + __n};
      }

      friend constexpr _Iterator operator+(difference_type __n, _Iterator __i)
        requires random_access_range<_Base>
      {
        return {__i._M_parent, __i._M_current + __n};
      }

      friend constexpr _Iterator operator-(_Iterator __i, difference_type __n)
        requires random_access_range<_Base>
      {
        return {__i._M_parent, __i._M_current - __n};
      }

      friend constexpr difference_type operator-(const _Iterator &__x,
                                                 const _Iterator &__y)
        requires sized_sentinel_for<iterator_t<_Base>, iterator_t<_Base>>
      {
        return __x._M_current - __y._M_current;
      }

      friend constexpr decltype(auto)
      iter_move(const _Iterator &__i) noexcept(noexcept(*__i)) {
        if constexpr (is_lvalue_reference_v<decltype(*__i)>)
          return std::move(*__i);
        else
          return *__i;
      }

      friend _Iterator<!_Const>;
      template <bool> friend struct _Sentinel;
    };

    template <bool _Const> struct _Sentinel {
    private:
      using _Parent = __detail::__maybe_const_t<_Const, transform_view>;
      using _Base = transform_view::_Base<_Const>;

      template <bool _Const2>
      constexpr auto __distance_from(const _Iterator<_Const2> &__i) const {
        return _M_end - __i._M_current;
      }

      template <bool _Const2>
      constexpr bool __equal(const _Iterator<_Const2> &__i) const {
        return __i._M_current == _M_end;
      }

      sentinel_t<_Base> _M_end = sentinel_t<_Base>();

    public:
      _Sentinel() = default;

      constexpr explicit _Sentinel(sentinel_t<_Base> __end) : _M_end(__end) {}

      constexpr _Sentinel(_Sentinel<!_Const> __i)
        requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>
          : _M_end(std::move(__i._M_end)) {}

      constexpr sentinel_t<_Base> base() const { return _M_end; }

      template <bool _Const2>
        requires sentinel_for<
            sentinel_t<_Base>,
            iterator_t<__detail::__maybe_const_t<_Const2, _Vp>>>
      friend constexpr bool operator==(const _Iterator<_Const2> &__x,
                                       const _Sentinel &__y) {
        return __y.__equal(__x);
      }

      template <bool _Const2,
                typename _Base2 = __detail::__maybe_const_t<_Const2, _Vp>>
        requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base2>>
      friend constexpr range_difference_t<_Base2>
      operator-(const _Iterator<_Const2> &__x, const _Sentinel &__y) {
        return -__y.__distance_from(__x);
      }

      template <bool _Const2,
                typename _Base2 = __detail::__maybe_const_t<_Const2, _Vp>>
        requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base2>>
      friend constexpr range_difference_t<_Base2>
      operator-(const _Sentinel &__y, const _Iterator<_Const2> &__x) {
        return __y.__distance_from(__x);
      }

      friend _Sentinel<!_Const>;
    };

    _Vp _M_base = _Vp();
    [[no_unique_address]] __detail::__box<_Fp> _M_fun;

  public:
    transform_view()
      requires(default_initializable<_Vp> && default_initializable<_Fp>)
    = default;

    constexpr transform_view(_Vp __base, _Fp __fun)
        : _M_base(std::move(__base)), _M_fun(std::move(__fun)) {}

    constexpr _Vp base() const &
      requires copy_constructible<_Vp>
    {
      return _M_base;
    }

    constexpr _Vp base() && { return std::move(_M_base); }

    constexpr _Iterator<false> begin() {
      return _Iterator<false>{this, ranges::begin(_M_base)};
    }

    constexpr _Iterator<true> begin() const
      requires range<const _Vp> &&
               regular_invocable<const _Fp &, range_reference_t<const _Vp>>
    {
      return _Iterator<true>{this, ranges::begin(_M_base)};
    }

    constexpr _Sentinel<false> end() {
      return _Sentinel<false>{ranges::end(_M_base)};
    }

    constexpr _Iterator<false> end()
      requires common_range<_Vp>
    {
      return _Iterator<false>{this, ranges::end(_M_base)};
    }

    constexpr _Sentinel<true> end() const
      requires range<const _Vp> &&
               regular_invocable<const _Fp &, range_reference_t<const _Vp>>
    {
      return _Sentinel<true>{ranges::end(_M_base)};
    }

    constexpr _Iterator<true> end() const
      requires common_range<const _Vp> &&
               regular_invocable<const _Fp &, range_reference_t<const _Vp>>
    {
      return _Iterator<true>{this, ranges::end(_M_base)};
    }

    constexpr auto size()
      requires sized_range<_Vp>
    {
      return ranges::size(_M_base);
    }

    constexpr auto size() const
      requires sized_range<const _Vp>
    {
      return ranges::size(_M_base);
    }
  };

  template <typename _Range, typename _Fp>
  transform_view(_Range &&, _Fp) -> transform_view<views::all_t<_Range>, _Fp>;

  namespace views {
  namespace __detail {
  template <typename _Range, typename _Fp>
  concept __can_transform_view =
      requires { transform_view(std::declval<_Range>(), std::declval<_Fp>()); };
  } // namespace __detail

  struct _Transform : __adaptor::_RangeAdaptor<_Transform> {
    template <viewable_range _Range, typename _Fp>
      requires __detail::__can_transform_view<_Range, _Fp>
    constexpr auto operator() [[nodiscard]] (_Range &&__r, _Fp &&__f) const {
      return transform_view(std::forward<_Range>(__r), std::forward<_Fp>(__f));
    }

    using _RangeAdaptor<_Transform>::operator();
    static constexpr int _S_arity = 2;
    static constexpr bool _S_has_simple_extra_args = true;
  };

  inline constexpr _Transform transform;
  } // namespace views

  template <view _Vp> class take_view : public view_interface<take_view<_Vp>> {
  private:
    template <bool _Const>
    using _CI =
        counted_iterator<iterator_t<__detail::__maybe_const_t<_Const, _Vp>>>;

    template <bool _Const> struct _Sentinel {
    private:
      using _Base = __detail::__maybe_const_t<_Const, _Vp>;
      sentinel_t<_Base> _M_end = sentinel_t<_Base>();

    public:
      _Sentinel() = default;

      constexpr explicit _Sentinel(sentinel_t<_Base> __end) : _M_end(__end) {}

      constexpr _Sentinel(_Sentinel<!_Const> __s)
        requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>
          : _M_end(std::move(__s._M_end)) {}

      constexpr sentinel_t<_Base> base() const { return _M_end; }

      friend constexpr bool operator==(const _CI<_Const> &__y,
                                       const _Sentinel &__x) {
        return __y.count() == 0 || __y.base() == __x._M_end;
      }

      template <bool _OtherConst = !_Const,
                typename _Base2 = __detail::__maybe_const_t<_OtherConst, _Vp>>
        requires sentinel_for<sentinel_t<_Base>, iterator_t<_Base2>>
      friend constexpr bool operator==(const _CI<_OtherConst> &__y,
                                       const _Sentinel &__x) {
        return __y.count() == 0 || __y.base() == __x._M_end;
      }

      friend _Sentinel<!_Const>;
    };

    _Vp _M_base = _Vp();
    range_difference_t<_Vp> _M_count = 0;

  public:
    take_view()
      requires default_initializable<_Vp>
    = default;

    constexpr take_view(_Vp __base, range_difference_t<_Vp> __count)
        : _M_base(std::move(__base)), _M_count(std::move(__count)) {}

    constexpr _Vp base() const &
      requires copy_constructible<_Vp>
    {
      return _M_base;
    }

    constexpr _Vp base() && { return std::move(_M_base); }

    constexpr auto begin()
      requires(!__detail::__simple_view<_Vp>)
    {
      if constexpr (sized_range<_Vp>) {
        if constexpr (random_access_range<_Vp>)
          return ranges::begin(_M_base);
        else {
          auto __sz = size();
          return counted_iterator(ranges::begin(_M_base), __sz);
        }
      } else
        return counted_iterator(ranges::begin(_M_base), _M_count);
    }

    constexpr auto begin() const
      requires range<const _Vp>
    {
      if constexpr (sized_range<const _Vp>) {
        if constexpr (random_access_range<const _Vp>)
          return ranges::begin(_M_base);
        else {
          auto __sz = size();
          return counted_iterator(ranges::begin(_M_base), __sz);
        }
      } else
        return counted_iterator(ranges::begin(_M_base), _M_count);
    }

    constexpr auto end()
      requires(!__detail::__simple_view<_Vp>)
    {
      if constexpr (sized_range<_Vp>) {
        if constexpr (random_access_range<_Vp>)
          return ranges::begin(_M_base) + size();
        else
          return default_sentinel;
      } else
        return _Sentinel<false>{ranges::end(_M_base)};
    }

    constexpr auto end() const
      requires range<const _Vp>
    {
      if constexpr (sized_range<const _Vp>) {
        if constexpr (random_access_range<const _Vp>)
          return ranges::begin(_M_base) + size();
        else
          return default_sentinel;
      } else
        return _Sentinel<true>{ranges::end(_M_base)};
    }

    constexpr auto size()
      requires sized_range<_Vp>
    {
      auto __n = ranges::size(_M_base);
      return std::min(__n, static_cast<decltype(__n)>(_M_count));
    }

    constexpr auto size() const
      requires sized_range<const _Vp>
    {
      auto __n = ranges::size(_M_base);
      return std::min(__n, static_cast<decltype(__n)>(_M_count));
    }
  };

  template <typename _Range>
  take_view(_Range &&,
            range_difference_t<_Range>) -> take_view<views::all_t<_Range>>;

  template <typename _Tp>
  inline constexpr bool enable_borrowed_range<take_view<_Tp>> =
      enable_borrowed_range<_Tp>;

  namespace views {
  namespace __detail {
  template <typename _Range> inline constexpr bool __is_empty_view = false;

  template <typename _Tp>
  inline constexpr bool __is_empty_view<empty_view<_Tp>> = true;

  template <typename _Range>
  inline constexpr bool __is_basic_string_view = false;

  template <typename _CharT, typename _Traits>
  inline constexpr bool
      __is_basic_string_view<basic_string_view<_CharT, _Traits>> = true;

  template <typename _Range> inline constexpr bool __is_subrange = false;

  template <typename _Iter, typename _Sent, subrange_kind _Kind>
  inline constexpr bool __is_subrange<subrange<_Iter, _Sent, _Kind>> = true;

  template <typename _Range> inline constexpr bool __is_iota_view = false;

  template <typename _Winc, typename _Bound>
  inline constexpr bool __is_iota_view<iota_view<_Winc, _Bound>> = true;

  template <typename _Range> inline constexpr bool __is_repeat_view = false;

  template <typename _Range>
  constexpr auto __take_of_repeat_view(_Range &&, range_difference_t<_Range>);

  template <typename _Range, typename _Dp>
  concept __can_take_view =
      requires { take_view(std::declval<_Range>(), std::declval<_Dp>()); };
  } // namespace __detail

  struct _Take : __adaptor::_RangeAdaptor<_Take> {
    template <viewable_range _Range, typename _Dp = range_difference_t<_Range>>
      requires __detail::__can_take_view<_Range, _Dp>
    constexpr auto operator()
        [[nodiscard]] (_Range &&__r, type_identity_t<_Dp> __n) const {
      using _Tp = remove_cvref_t<_Range>;
      if constexpr (__detail::__is_empty_view<_Tp>)
        return _Tp();
      else if constexpr (random_access_range<_Tp> && sized_range<_Tp> &&
                         (std::__detail::__is_span<_Tp> ||
                          __detail::__is_basic_string_view<_Tp> ||
                          __detail::__is_subrange<_Tp> ||
                          __detail::__is_iota_view<_Tp>)) {
        __n = std::min<_Dp>(ranges::distance(__r), __n);
        auto __begin = ranges::begin(__r);
        auto __end = __begin + __n;
        if constexpr (std::__detail::__is_span<_Tp>)
          return span<typename _Tp::element_type>(__begin, __end);
        else if constexpr (__detail::__is_basic_string_view<_Tp>)
          return _Tp(__begin, __end);
        else if constexpr (__detail::__is_subrange<_Tp>)
          return subrange<iterator_t<_Tp>>(__begin, __end);
        else
          return iota_view(*__begin, *__end);
      } else if constexpr (__detail::__is_repeat_view<_Tp>)
        return __detail::__take_of_repeat_view(std::forward<_Range>(__r), __n);
      else
        return take_view(std::forward<_Range>(__r), __n);
    }

    using _RangeAdaptor<_Take>::operator();
    static constexpr int _S_arity = 2;

    template <typename _Tp>
    static constexpr bool _S_has_simple_extra_args =
        ranges::__detail::__is_integer_like<_Tp>;
  };

  inline constexpr _Take take;
  } // namespace views

  template <view _Vp, typename _Pred>
    requires input_range<_Vp> && is_object_v<_Pred> &&
             indirect_unary_predicate<const _Pred, iterator_t<_Vp>>
  class take_while_view : public view_interface<take_while_view<_Vp, _Pred>> {
    template <bool _Const> struct _Sentinel {
    private:
      using _Base = __detail::__maybe_const_t<_Const, _Vp>;

      sentinel_t<_Base> _M_end = sentinel_t<_Base>();
      const _Pred *_M_pred = nullptr;

    public:
      _Sentinel() = default;

      constexpr explicit _Sentinel(sentinel_t<_Base> __end, const _Pred *__pred)
          : _M_end(__end), _M_pred(__pred) {}

      constexpr _Sentinel(_Sentinel<!_Const> __s)
        requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>
          : _M_end(__s._M_end), _M_pred(__s._M_pred) {}

      constexpr sentinel_t<_Base> base() const { return _M_end; }

      friend constexpr bool operator==(const iterator_t<_Base> &__x,
                                       const _Sentinel &__y) {
        return __y._M_end == __x || !std::__invoke(*__y._M_pred, *__x);
      }

      template <bool _OtherConst = !_Const,
                typename _Base2 = __detail::__maybe_const_t<_OtherConst, _Vp>>
        requires sentinel_for<sentinel_t<_Base>, iterator_t<_Base2>>
      friend constexpr bool operator==(const iterator_t<_Base2> &__x,
                                       const _Sentinel &__y) {
        return __y._M_end == __x || !std::__invoke(*__y._M_pred, *__x);
      }

      friend _Sentinel<!_Const>;
    };

    _Vp _M_base = _Vp();
    [[no_unique_address]] __detail::__box<_Pred> _M_pred;

  public:
    take_while_view()
      requires(default_initializable<_Vp> && default_initializable<_Pred>)
    = default;

    constexpr take_while_view(_Vp __base, _Pred __pred)
        : _M_base(std::move(__base)), _M_pred(std::move(__pred)) {}

    constexpr _Vp base() const &
      requires copy_constructible<_Vp>
    {
      return _M_base;
    }

    constexpr _Vp base() && { return std::move(_M_base); }

    constexpr const _Pred &pred() const { return *_M_pred; }

    constexpr auto begin()
      requires(!__detail::__simple_view<_Vp>)
    {
      return ranges::begin(_M_base);
    }

    constexpr auto begin() const
      requires range<const _Vp> &&
               indirect_unary_predicate<const _Pred, iterator_t<const _Vp>>
    {
      return ranges::begin(_M_base);
    }

    constexpr auto end()
      requires(!__detail::__simple_view<_Vp>)
    {
      return _Sentinel<false>(ranges::end(_M_base), std::__addressof(*_M_pred));
    }

    constexpr auto end() const
      requires range<const _Vp> &&
               indirect_unary_predicate<const _Pred, iterator_t<const _Vp>>
    {
      return _Sentinel<true>(ranges::end(_M_base), std::__addressof(*_M_pred));
    }
  };

  template <typename _Range, typename _Pred>
  take_while_view(_Range &&,
                  _Pred) -> take_while_view<views::all_t<_Range>, _Pred>;

  namespace views {
  namespace __detail {
  template <typename _Range, typename _Pred>
  concept __can_take_while_view = requires {
    take_while_view(std::declval<_Range>(), std::declval<_Pred>());
  };
  } // namespace __detail

  struct _TakeWhile : __adaptor::_RangeAdaptor<_TakeWhile> {
    template <viewable_range _Range, typename _Pred>
      requires __detail::__can_take_while_view<_Range, _Pred>
    constexpr auto operator() [[nodiscard]] (_Range &&__r, _Pred &&__p) const {
      return take_while_view(std::forward<_Range>(__r),
                             std::forward<_Pred>(__p));
    }

    using _RangeAdaptor<_TakeWhile>::operator();
    static constexpr int _S_arity = 2;
    static constexpr bool _S_has_simple_extra_args = true;
  };

  inline constexpr _TakeWhile take_while;
  } // namespace views

  template <view _Vp> class drop_view : public view_interface<drop_view<_Vp>> {
  private:
    _Vp _M_base = _Vp();
    range_difference_t<_Vp> _M_count = 0;

    static constexpr bool _S_needs_cached_begin =
        !(random_access_range<const _Vp> && sized_range<const _Vp>);
    [[no_unique_address]]
    __detail::__maybe_present_t<_S_needs_cached_begin,
                                __detail::_CachedPosition<_Vp>> _M_cached_begin;

  public:
    drop_view()
      requires default_initializable<_Vp>
    = default;

    constexpr drop_view(_Vp __base, range_difference_t<_Vp> __count)
        : _M_base(std::move(__base)), _M_count(__count) {
      do {
        if (std::__is_constant_evaluated() && !bool(__count >= 0))
          __builtin_unreachable();
      } while (false);
    }

    constexpr _Vp base() const &
      requires copy_constructible<_Vp>
    {
      return _M_base;
    }

    constexpr _Vp base() && { return std::move(_M_base); }

    constexpr auto begin()
      requires(!(__detail::__simple_view<_Vp> &&
                 random_access_range<const _Vp> && sized_range<const _Vp>))
    {
      if constexpr (_S_needs_cached_begin)
        if (_M_cached_begin._M_has_value())
          return _M_cached_begin._M_get(_M_base);

      auto __it =
          ranges::next(ranges::begin(_M_base), _M_count, ranges::end(_M_base));
      if constexpr (_S_needs_cached_begin)
        _M_cached_begin._M_set(_M_base, __it);
      return __it;
    }

    constexpr auto begin() const
      requires random_access_range<const _Vp> && sized_range<const _Vp>
    {
      return ranges::next(ranges::begin(_M_base), _M_count,
                          ranges::end(_M_base));
    }

    constexpr auto end()
      requires(!__detail::__simple_view<_Vp>)
    {
      return ranges::end(_M_base);
    }

    constexpr auto end() const
      requires range<const _Vp>
    {
      return ranges::end(_M_base);
    }

    constexpr auto size()
      requires sized_range<_Vp>
    {
      const auto __s = ranges::size(_M_base);
      const auto __c = static_cast<decltype(__s)>(_M_count);
      return __s < __c ? 0 : __s - __c;
    }

    constexpr auto size() const
      requires sized_range<const _Vp>
    {
      const auto __s = ranges::size(_M_base);
      const auto __c = static_cast<decltype(__s)>(_M_count);
      return __s < __c ? 0 : __s - __c;
    }
  };

  template <typename _Range>
  drop_view(_Range &&,
            range_difference_t<_Range>) -> drop_view<views::all_t<_Range>>;

  template <typename _Tp>
  inline constexpr bool enable_borrowed_range<drop_view<_Tp>> =
      enable_borrowed_range<_Tp>;

  namespace views {
  namespace __detail {
  template <typename _Range>
  constexpr auto __drop_of_repeat_view(_Range &&, range_difference_t<_Range>);

  template <typename _Range, typename _Dp>
  concept __can_drop_view =
      requires { drop_view(std::declval<_Range>(), std::declval<_Dp>()); };
  } // namespace __detail

  struct _Drop : __adaptor::_RangeAdaptor<_Drop> {
    template <viewable_range _Range, typename _Dp = range_difference_t<_Range>>
      requires __detail::__can_drop_view<_Range, _Dp>
    constexpr auto operator()
        [[nodiscard]] (_Range &&__r, type_identity_t<_Dp> __n) const {
      using _Tp = remove_cvref_t<_Range>;
      if constexpr (__detail::__is_empty_view<_Tp>)
        return _Tp();
      else if constexpr (random_access_range<_Tp> && sized_range<_Tp> &&
                         (std::__detail::__is_span<_Tp> ||
                          __detail::__is_basic_string_view<_Tp> ||
                          __detail::__is_iota_view<_Tp> ||
                          __detail::__is_subrange<_Tp>)) {
        __n = std::min<_Dp>(ranges::distance(__r), __n);
        auto __begin = ranges::begin(__r) + __n;
        auto __end = ranges::end(__r);
        if constexpr (std::__detail::__is_span<_Tp>)
          return span<typename _Tp::element_type>(__begin, __end);
        else if constexpr (__detail::__is_subrange<_Tp>) {
          if constexpr (_Tp::_S_store_size) {
            using ranges::__detail::__to_unsigned_like;
            auto __m = ranges::distance(__r) - __n;
            return _Tp(__begin, __end, __to_unsigned_like(__m));
          } else
            return _Tp(__begin, __end);
        } else
          return _Tp(__begin, __end);
      } else if constexpr (__detail::__is_repeat_view<_Tp>)
        return __detail::__drop_of_repeat_view(std::forward<_Range>(__r), __n);
      else
        return drop_view(std::forward<_Range>(__r), __n);
    }

    using _RangeAdaptor<_Drop>::operator();
    static constexpr int _S_arity = 2;
    template <typename _Tp>
    static constexpr bool _S_has_simple_extra_args =
        _Take::_S_has_simple_extra_args<_Tp>;
  };

  inline constexpr _Drop drop;
  } // namespace views

  template <view _Vp, typename _Pred>
    requires input_range<_Vp> && is_object_v<_Pred> &&
             indirect_unary_predicate<const _Pred, iterator_t<_Vp>>
  class drop_while_view : public view_interface<drop_while_view<_Vp, _Pred>> {
  private:
    _Vp _M_base = _Vp();
    [[no_unique_address]] __detail::__box<_Pred> _M_pred;
    [[no_unique_address]] __detail::_CachedPosition<_Vp> _M_cached_begin;

  public:
    drop_while_view()
      requires(default_initializable<_Vp> && default_initializable<_Pred>)
    = default;

    constexpr drop_while_view(_Vp __base, _Pred __pred)
        : _M_base(std::move(__base)), _M_pred(std::move(__pred)) {}

    constexpr _Vp base() const &
      requires copy_constructible<_Vp>
    {
      return _M_base;
    }

    constexpr _Vp base() && { return std::move(_M_base); }

    constexpr const _Pred &pred() const { return *_M_pred; }

    constexpr auto begin() {
      if (_M_cached_begin._M_has_value())
        return _M_cached_begin._M_get(_M_base);

      do {
        if (std::__is_constant_evaluated() && !bool(_M_pred.has_value()))
          __builtin_unreachable();
      } while (false);
      auto __it = ranges::find_if_not(
          ranges::begin(_M_base), ranges::end(_M_base), std::cref(*_M_pred));
      _M_cached_begin._M_set(_M_base, __it);
      return __it;
    }

    constexpr auto end() { return ranges::end(_M_base); }
  };

  template <typename _Range, typename _Pred>
  drop_while_view(_Range &&,
                  _Pred) -> drop_while_view<views::all_t<_Range>, _Pred>;

  template <typename _Tp, typename _Pred>
  inline constexpr bool enable_borrowed_range<drop_while_view<_Tp, _Pred>> =
      enable_borrowed_range<_Tp>;

  namespace views {
  namespace __detail {
  template <typename _Range, typename _Pred>
  concept __can_drop_while_view = requires {
    drop_while_view(std::declval<_Range>(), std::declval<_Pred>());
  };
  } // namespace __detail

  struct _DropWhile : __adaptor::_RangeAdaptor<_DropWhile> {
    template <viewable_range _Range, typename _Pred>
      requires __detail::__can_drop_while_view<_Range, _Pred>
    constexpr auto operator() [[nodiscard]] (_Range &&__r, _Pred &&__p) const {
      return drop_while_view(std::forward<_Range>(__r),
                             std::forward<_Pred>(__p));
    }

    using _RangeAdaptor<_DropWhile>::operator();
    static constexpr int _S_arity = 2;
    static constexpr bool _S_has_simple_extra_args = true;
  };

  inline constexpr _DropWhile drop_while;
  } // namespace views

  template <input_range _Vp>
    requires view<_Vp> && input_range<range_reference_t<_Vp>>
  class join_view : public view_interface<join_view<_Vp>> {
  private:
    using _InnerRange = range_reference_t<_Vp>;

    template <bool _Const> using _Base = __detail::__maybe_const_t<_Const, _Vp>;

    template <bool _Const> using _Outer_iter = iterator_t<_Base<_Const>>;

    template <bool _Const>
    using _Inner_iter = iterator_t<range_reference_t<_Base<_Const>>>;

    template <bool _Const>
    static constexpr bool _S_ref_is_glvalue =
        is_reference_v<range_reference_t<_Base<_Const>>>;

    template <bool _Const> struct __iter_cat {};

    template <bool _Const>
      requires _S_ref_is_glvalue<_Const> && forward_range<_Base<_Const>> &&
               forward_range<range_reference_t<_Base<_Const>>>
    struct __iter_cat<_Const> {
    private:
      static constexpr auto _S_iter_cat() {
        using _Outer_iter = join_view::_Outer_iter<_Const>;
        using _Inner_iter = join_view::_Inner_iter<_Const>;
        using _OuterCat =
            typename iterator_traits<_Outer_iter>::iterator_category;
        using _InnerCat =
            typename iterator_traits<_Inner_iter>::iterator_category;
        if constexpr (derived_from<_OuterCat, bidirectional_iterator_tag> &&
                      derived_from<_InnerCat, bidirectional_iterator_tag> &&
                      common_range<range_reference_t<_Base<_Const>>>)
          return bidirectional_iterator_tag{};
        else if constexpr (derived_from<_OuterCat, forward_iterator_tag> &&
                           derived_from<_InnerCat, forward_iterator_tag>)
          return forward_iterator_tag{};
        else
          return input_iterator_tag{};
      }

    public:
      using iterator_category = decltype(_S_iter_cat());
    };

    template <bool _Const> struct _Sentinel;

    template <bool _Const> struct _Iterator : __iter_cat<_Const> {
    private:
      using _Parent = __detail::__maybe_const_t<_Const, join_view>;
      using _Base = join_view::_Base<_Const>;

      static constexpr bool _S_ref_is_glvalue =
          join_view::_S_ref_is_glvalue<_Const>;

      constexpr void _M_satisfy() {
        auto __update_inner = [this](const iterator_t<_Base> &__x) -> auto && {
          if constexpr (_S_ref_is_glvalue)
            return *__x;
          else
            return _M_parent->_M_inner._M_emplace_deref(__x);
        };

        for (; _M_outer != ranges::end(_M_parent->_M_base); ++_M_outer) {
          auto &&__inner = __update_inner(_M_outer);
          _M_inner = ranges::begin(__inner);
          if (_M_inner != ranges::end(__inner))
            return;
        }

        if constexpr (_S_ref_is_glvalue)
          _M_inner.reset();
      }

      static constexpr auto _S_iter_concept() {
        if constexpr (_S_ref_is_glvalue && bidirectional_range<_Base> &&
                      bidirectional_range<range_reference_t<_Base>> &&
                      common_range<range_reference_t<_Base>>)
          return bidirectional_iterator_tag{};
        else if constexpr (_S_ref_is_glvalue && forward_range<_Base> &&
                           forward_range<range_reference_t<_Base>>)
          return forward_iterator_tag{};
        else
          return input_iterator_tag{};
      }

      using _Outer_iter = join_view::_Outer_iter<_Const>;
      using _Inner_iter = join_view::_Inner_iter<_Const>;

      _Outer_iter _M_outer = _Outer_iter();
      optional<_Inner_iter> _M_inner;
      _Parent *_M_parent = nullptr;

    public:
      using iterator_concept = decltype(_S_iter_concept());

      using value_type = range_value_t<range_reference_t<_Base>>;
      using difference_type =
          common_type_t<range_difference_t<_Base>,
                        range_difference_t<range_reference_t<_Base>>>;

      _Iterator()
        requires default_initializable<_Outer_iter>
      = default;

      constexpr _Iterator(_Parent *__parent, _Outer_iter __outer)
          : _M_outer(std::move(__outer)), _M_parent(__parent) {
        _M_satisfy();
      }

      constexpr _Iterator(_Iterator<!_Const> __i)
        requires _Const && convertible_to<iterator_t<_Vp>, _Outer_iter> &&
                     convertible_to<iterator_t<_InnerRange>, _Inner_iter>
          : _M_outer(std::move(__i._M_outer)),
            _M_inner(std::move(__i._M_inner)), _M_parent(__i._M_parent) {}

      constexpr decltype(auto) operator*() const { return **_M_inner; }

      constexpr _Inner_iter operator->() const
        requires __detail::__has_arrow<_Inner_iter> && copyable<_Inner_iter>
      {
        return *_M_inner;
      }

      constexpr _Iterator &operator++() {
        auto &&__inner_range = [this]() -> auto && {
          if constexpr (_S_ref_is_glvalue)
            return *_M_outer;
          else
            return *_M_parent->_M_inner;
        }();
        if (++*_M_inner == ranges::end(__inner_range)) {
          ++_M_outer;
          _M_satisfy();
        }
        return *this;
      }

      constexpr void operator++(int) { ++*this; }

      constexpr _Iterator operator++(int)
        requires _S_ref_is_glvalue && forward_range<_Base> &&
                 forward_range<range_reference_t<_Base>>
      {
        auto __tmp = *this;
        ++*this;
        return __tmp;
      }

      constexpr _Iterator &operator--()
        requires _S_ref_is_glvalue && bidirectional_range<_Base> &&
                 bidirectional_range<range_reference_t<_Base>> &&
                 common_range<range_reference_t<_Base>>
      {
        if (_M_outer == ranges::end(_M_parent->_M_base))
          _M_inner = ranges::end(*--_M_outer);
        while (*_M_inner == ranges::begin(*_M_outer))
          *_M_inner = ranges::end(*--_M_outer);
        --*_M_inner;
        return *this;
      }

      constexpr _Iterator operator--(int)
        requires _S_ref_is_glvalue && bidirectional_range<_Base> &&
                 bidirectional_range<range_reference_t<_Base>> &&
                 common_range<range_reference_t<_Base>>
      {
        auto __tmp = *this;
        --*this;
        return __tmp;
      }

      friend constexpr bool operator==(const _Iterator &__x,
                                       const _Iterator &__y)
        requires _S_ref_is_glvalue && equality_comparable<_Outer_iter> &&
                 equality_comparable<_Inner_iter>
      {
        return (__x._M_outer == __y._M_outer && __x._M_inner == __y._M_inner);
      }

      friend constexpr decltype(auto) iter_move(const _Iterator &__i) noexcept(
          noexcept(ranges::iter_move(*__i._M_inner))) {
        return ranges::iter_move(*__i._M_inner);
      }

      friend constexpr void
      iter_swap(const _Iterator &__x, const _Iterator &__y) noexcept(
          noexcept(ranges::iter_swap(*__x._M_inner, *__y._M_inner)))
        requires indirectly_swappable<_Inner_iter>
      {
        return ranges::iter_swap(*__x._M_inner, *__y._M_inner);
      }

      friend _Iterator<!_Const>;
      template <bool> friend struct _Sentinel;
    };

    template <bool _Const> struct _Sentinel {
    private:
      using _Parent = __detail::__maybe_const_t<_Const, join_view>;
      using _Base = join_view::_Base<_Const>;

      template <bool _Const2>
      constexpr bool __equal(const _Iterator<_Const2> &__i) const {
        return __i._M_outer == _M_end;
      }

      sentinel_t<_Base> _M_end = sentinel_t<_Base>();

    public:
      _Sentinel() = default;

      constexpr explicit _Sentinel(_Parent *__parent)
          : _M_end(ranges::end(__parent->_M_base)) {}

      constexpr _Sentinel(_Sentinel<!_Const> __s)
        requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>
          : _M_end(std::move(__s._M_end)) {}

      template <bool _Const2>
        requires sentinel_for<
            sentinel_t<_Base>,
            iterator_t<__detail::__maybe_const_t<_Const2, _Vp>>>
      friend constexpr bool operator==(const _Iterator<_Const2> &__x,
                                       const _Sentinel &__y) {
        return __y.__equal(__x);
      }

      friend _Sentinel<!_Const>;
    };

    _Vp _M_base = _Vp();
    [[no_unique_address]]
    __detail::__non_propagating_cache<remove_cv_t<_InnerRange>> _M_inner;

  public:
    join_view()
      requires default_initializable<_Vp>
    = default;

    constexpr explicit join_view(_Vp __base) : _M_base(std::move(__base)) {}

    constexpr _Vp base() const &
      requires copy_constructible<_Vp>
    {
      return _M_base;
    }

    constexpr _Vp base() && { return std::move(_M_base); }

    constexpr auto begin() {
      constexpr bool __use_const = (__detail::__simple_view<_Vp> &&
                                    is_reference_v<range_reference_t<_Vp>>);
      return _Iterator<__use_const>{this, ranges::begin(_M_base)};
    }

    constexpr auto begin() const
      requires input_range<const _Vp> &&
               is_reference_v<range_reference_t<const _Vp>>
    {
      return _Iterator<true>{this, ranges::begin(_M_base)};
    }

    constexpr auto end() {
      if constexpr (forward_range<_Vp> && is_reference_v<_InnerRange> &&
                    forward_range<_InnerRange> && common_range<_Vp> &&
                    common_range<_InnerRange>)
        return _Iterator<__detail::__simple_view<_Vp>>{this,
                                                       ranges::end(_M_base)};
      else
        return _Sentinel<__detail::__simple_view<_Vp>>{this};
    }

    constexpr auto end() const
      requires input_range<const _Vp> &&
               is_reference_v<range_reference_t<const _Vp>>
    {
      if constexpr (forward_range<const _Vp> &&
                    is_reference_v<range_reference_t<const _Vp>> &&
                    forward_range<range_reference_t<const _Vp>> &&
                    common_range<const _Vp> &&
                    common_range<range_reference_t<const _Vp>>)
        return _Iterator<true>{this, ranges::end(_M_base)};
      else
        return _Sentinel<true>{this};
    }
  };

  template <typename _Range>
  explicit join_view(_Range &&) -> join_view<views::all_t<_Range>>;

  namespace views {
  namespace __detail {
  template <typename _Range>
  concept __can_join_view =
      requires { join_view<all_t<_Range>>{std::declval<_Range>()}; };
  } // namespace __detail

  struct _Join : __adaptor::_RangeAdaptorClosure {
    template <viewable_range _Range>
      requires __detail::__can_join_view<_Range>
    constexpr auto operator() [[nodiscard]] (_Range &&__r) const {

      return join_view<all_t<_Range>>{std::forward<_Range>(__r)};
    }

    static constexpr bool _S_has_simple_call_op = true;
  };

  inline constexpr _Join join;
  } // namespace views

  namespace __detail {
  template <auto> struct __require_constant;

  template <typename _Range>
  concept __tiny_range = sized_range<_Range> && requires {
    typename __require_constant<remove_reference_t<_Range>::size()>;
  } && (remove_reference_t<_Range>::size() <= 1);

  template <typename _Base> struct __lazy_split_view_outer_iter_cat {};

  template <forward_range _Base>
  struct __lazy_split_view_outer_iter_cat<_Base> {
    using iterator_category = input_iterator_tag;
  };

  template <typename _Base> struct __lazy_split_view_inner_iter_cat {};

  template <forward_range _Base>
  struct __lazy_split_view_inner_iter_cat<_Base> {
  private:
    static constexpr auto _S_iter_cat() {
      using _Cat =
          typename iterator_traits<iterator_t<_Base>>::iterator_category;
      if constexpr (derived_from<_Cat, forward_iterator_tag>)
        return forward_iterator_tag{};
      else
        return _Cat{};
    }

  public:
    using iterator_category = decltype(_S_iter_cat());
  };
  } // namespace __detail

  template <input_range _Vp, forward_range _Pattern>
    requires view<_Vp> && view<_Pattern> &&
             indirectly_comparable<iterator_t<_Vp>, iterator_t<_Pattern>,
                                   ranges::equal_to> &&
             (forward_range<_Vp> || __detail::__tiny_range<_Pattern>)
  class lazy_split_view
      : public view_interface<lazy_split_view<_Vp, _Pattern>> {
  private:
    template <bool _Const> using _Base = __detail::__maybe_const_t<_Const, _Vp>;

    template <bool _Const> struct _InnerIter;

    template <bool _Const>
    struct _OuterIter
        : __detail::__lazy_split_view_outer_iter_cat<_Base<_Const>> {
    private:
      using _Parent = __detail::__maybe_const_t<_Const, lazy_split_view>;
      using _Base = lazy_split_view::_Base<_Const>;

      constexpr bool __at_end() const {
        return __current() == ranges::end(_M_parent->_M_base) &&
               !_M_trailing_empty;
      }

      constexpr auto &__current() noexcept {
        if constexpr (forward_range<_Vp>)
          return _M_current;
        else
          return *_M_parent->_M_current;
      }

      constexpr auto &__current() const noexcept {
        if constexpr (forward_range<_Vp>)
          return _M_current;
        else
          return *_M_parent->_M_current;
      }

      _Parent *_M_parent = nullptr;

      [[no_unique_address]]
      __detail::__maybe_present_t<forward_range<_Vp>, iterator_t<_Base>>
          _M_current;
      bool _M_trailing_empty = false;

    public:
      using iterator_concept =
          __conditional_t<forward_range<_Base>, forward_iterator_tag,
                          input_iterator_tag>;

      using difference_type = range_difference_t<_Base>;

      struct value_type : view_interface<value_type> {
      private:
        _OuterIter _M_i = _OuterIter();

      public:
        value_type() = default;

        constexpr explicit value_type(_OuterIter __i) : _M_i(std::move(__i)) {}

        constexpr _InnerIter<_Const> begin() const {
          return _InnerIter<_Const>{_M_i};
        }

        constexpr default_sentinel_t end() const noexcept {
          return default_sentinel;
        }
      };

      _OuterIter() = default;

      constexpr explicit _OuterIter(_Parent *__parent)
        requires(!forward_range<_Base>)
          : _M_parent(__parent) {}

      constexpr _OuterIter(_Parent *__parent, iterator_t<_Base> __current)
        requires forward_range<_Base>
          : _M_parent(__parent), _M_current(std::move(__current)) {}

      constexpr _OuterIter(_OuterIter<!_Const> __i)
        requires _Const && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>
          : _M_parent(__i._M_parent), _M_current(std::move(__i._M_current)),
            _M_trailing_empty(__i._M_trailing_empty) {}

      constexpr value_type operator*() const { return value_type{*this}; }

      constexpr _OuterIter &operator++() {

        const auto __end = ranges::end(_M_parent->_M_base);
        if (__current() == __end) {
          _M_trailing_empty = false;
          return *this;
        }
        const auto [__pbegin, __pend] = subrange{_M_parent->_M_pattern};
        if (__pbegin == __pend)
          ++__current();
        else if constexpr (__detail::__tiny_range<_Pattern>) {
          __current() = ranges::find(std::move(__current()), __end, *__pbegin);
          if (__current() != __end) {
            ++__current();
            if (__current() == __end)
              _M_trailing_empty = true;
          }
        } else
          do {
            auto [__b, __p] =
                ranges::mismatch(__current(), __end, __pbegin, __pend);
            if (__p == __pend) {
              __current() = __b;
              if (__current() == __end)
                _M_trailing_empty = true;
              break;
            }
          } while (++__current() != __end);
        return *this;
      }

      constexpr decltype(auto) operator++(int) {
        if constexpr (forward_range<_Base>) {
          auto __tmp = *this;
          ++*this;
          return __tmp;
        } else
          ++*this;
      }

      friend constexpr bool operator==(const _OuterIter &__x,
                                       const _OuterIter &__y)
        requires forward_range<_Base>
      {
        return __x._M_current == __y._M_current &&
               __x._M_trailing_empty == __y._M_trailing_empty;
      }

      friend constexpr bool operator==(const _OuterIter &__x,
                                       default_sentinel_t) {
        return __x.__at_end();
      };

      friend _OuterIter<!_Const>;
      friend _InnerIter<_Const>;
    };

    template <bool _Const>
    struct _InnerIter
        : __detail::__lazy_split_view_inner_iter_cat<_Base<_Const>> {
    private:
      using _Base = lazy_split_view::_Base<_Const>;

      constexpr bool __at_end() const {
        auto [__pcur, __pend] = subrange{_M_i._M_parent->_M_pattern};
        auto __end = ranges::end(_M_i._M_parent->_M_base);
        if constexpr (__detail::__tiny_range<_Pattern>) {
          const auto &__cur = _M_i_current();
          if (__cur == __end)
            return true;
          if (__pcur == __pend)
            return _M_incremented;
          return *__cur == *__pcur;
        } else {
          auto __cur = _M_i_current();
          if (__cur == __end)
            return true;
          if (__pcur == __pend)
            return _M_incremented;
          do {
            if (*__cur != *__pcur)
              return false;
            if (++__pcur == __pend)
              return true;
          } while (++__cur != __end);
          return false;
        }
      }

      constexpr auto &_M_i_current() noexcept { return _M_i.__current(); }

      constexpr auto &_M_i_current() const noexcept { return _M_i.__current(); }

      _OuterIter<_Const> _M_i = _OuterIter<_Const>();
      bool _M_incremented = false;

    public:
      using iterator_concept = typename _OuterIter<_Const>::iterator_concept;

      using value_type = range_value_t<_Base>;
      using difference_type = range_difference_t<_Base>;

      _InnerIter() = default;

      constexpr explicit _InnerIter(_OuterIter<_Const> __i)
          : _M_i(std::move(__i)) {}

      constexpr const iterator_t<_Base> &base() const & noexcept {
        return _M_i_current();
      }

      constexpr iterator_t<_Base> base() &&
        requires forward_range<_Vp>
      {
        return std::move(_M_i_current());
      }

      constexpr decltype(auto) operator*() const { return *_M_i_current(); }

      constexpr _InnerIter &operator++() {
        _M_incremented = true;
        if constexpr (!forward_range<_Base>)
          if constexpr (_Pattern::size() == 0)
            return *this;
        ++_M_i_current();
        return *this;
      }

      constexpr decltype(auto) operator++(int) {
        if constexpr (forward_range<_Base>) {
          auto __tmp = *this;
          ++*this;
          return __tmp;
        } else
          ++*this;
      }

      friend constexpr bool operator==(const _InnerIter &__x,
                                       const _InnerIter &__y)
        requires forward_range<_Base>
      {
        return __x._M_i == __y._M_i;
      }

      friend constexpr bool operator==(const _InnerIter &__x,
                                       default_sentinel_t) {
        return __x.__at_end();
      }

      friend constexpr decltype(auto) iter_move(const _InnerIter &__i) noexcept(
          noexcept(ranges::iter_move(__i._M_i_current()))) {
        return ranges::iter_move(__i._M_i_current());
      }

      friend constexpr void
      iter_swap(const _InnerIter &__x, const _InnerIter &__y) noexcept(
          noexcept(ranges::iter_swap(__x._M_i_current(), __y._M_i_current())))
        requires indirectly_swappable<iterator_t<_Base>>
      {
        ranges::iter_swap(__x._M_i_current(), __y._M_i_current());
      }
    };

    _Vp _M_base = _Vp();
    _Pattern _M_pattern = _Pattern();
    [[no_unique_address]]
    __detail::__maybe_present_t<
        !forward_range<_Vp>, __detail::__non_propagating_cache<iterator_t<_Vp>>>
        _M_current;

  public:
    lazy_split_view()
      requires(default_initializable<_Vp> && default_initializable<_Pattern>)
    = default;

    constexpr lazy_split_view(_Vp __base, _Pattern __pattern)
        : _M_base(std::move(__base)), _M_pattern(std::move(__pattern)) {}

    template <input_range _Range>
      requires constructible_from<_Vp, views::all_t<_Range>> &&
                   constructible_from<_Pattern,
                                      single_view<range_value_t<_Range>>>
    constexpr lazy_split_view(_Range &&__r, range_value_t<_Range> __e)
        : _M_base(views::all(std::forward<_Range>(__r))),
          _M_pattern(views::single(std::move(__e))) {}

    constexpr _Vp base() const &
      requires copy_constructible<_Vp>
    {
      return _M_base;
    }

    constexpr _Vp base() && { return std::move(_M_base); }

    constexpr auto begin() {
      if constexpr (forward_range<_Vp>) {
        constexpr bool __simple =
            __detail::__simple_view<_Vp> && __detail::__simple_view<_Pattern>;
        return _OuterIter<__simple>{this, ranges::begin(_M_base)};
      } else {
        _M_current = ranges::begin(_M_base);
        return _OuterIter<false>{this};
      }
    }

    constexpr auto begin() const
      requires forward_range<_Vp> && forward_range<const _Vp>
    {
      return _OuterIter<true>{this, ranges::begin(_M_base)};
    }

    constexpr auto end()
      requires forward_range<_Vp> && common_range<_Vp>
    {
      constexpr bool __simple =
          __detail::__simple_view<_Vp> && __detail::__simple_view<_Pattern>;
      return _OuterIter<__simple>{this, ranges::end(_M_base)};
    }

    constexpr auto end() const {
      if constexpr (forward_range<_Vp> && forward_range<const _Vp> &&
                    common_range<const _Vp>)
        return _OuterIter<true>{this, ranges::end(_M_base)};
      else
        return default_sentinel;
    }
  };

  template <typename _Range, typename _Pattern>
  lazy_split_view(_Range &&, _Pattern &&)
      -> lazy_split_view<views::all_t<_Range>, views::all_t<_Pattern>>;

  template <input_range _Range>
  lazy_split_view(_Range &&, range_value_t<_Range>)
      -> lazy_split_view<views::all_t<_Range>,
                         single_view<range_value_t<_Range>>>;

  namespace views {
  namespace __detail {
  template <typename _Range, typename _Pattern>
  concept __can_lazy_split_view = requires {
    lazy_split_view(std::declval<_Range>(), std::declval<_Pattern>());
  };
  } // namespace __detail

  struct _LazySplit : __adaptor::_RangeAdaptor<_LazySplit> {
    template <viewable_range _Range, typename _Pattern>
      requires __detail::__can_lazy_split_view<_Range, _Pattern>
    constexpr auto operator()
        [[nodiscard]] (_Range &&__r, _Pattern &&__f) const {
      return lazy_split_view(std::forward<_Range>(__r),
                             std::forward<_Pattern>(__f));
    }

    using _RangeAdaptor<_LazySplit>::operator();
    static constexpr int _S_arity = 2;

    template <typename _Pattern>
    static constexpr bool _S_has_simple_extra_args =
        is_scalar_v<_Pattern> ||
        (view<_Pattern> && copy_constructible<_Pattern>);
  };

  inline constexpr _LazySplit lazy_split;
  } // namespace views

  template <forward_range _Vp, forward_range _Pattern>
    requires view<_Vp> && view<_Pattern> &&
             indirectly_comparable<iterator_t<_Vp>, iterator_t<_Pattern>,
                                   ranges::equal_to>
  class split_view : public view_interface<split_view<_Vp, _Pattern>> {
  private:
    _Vp _M_base = _Vp();
    _Pattern _M_pattern = _Pattern();
    __detail::__non_propagating_cache<subrange<iterator_t<_Vp>>>
        _M_cached_begin;

    struct _Iterator;
    struct _Sentinel;

  public:
    split_view()
      requires(default_initializable<_Vp> && default_initializable<_Pattern>)
    = default;

    constexpr split_view(_Vp __base, _Pattern __pattern)
        : _M_base(std::move(__base)), _M_pattern(std::move(__pattern)) {}

    template <forward_range _Range>
      requires constructible_from<_Vp, views::all_t<_Range>> &&
                   constructible_from<_Pattern,
                                      single_view<range_value_t<_Range>>>
    constexpr split_view(_Range &&__r, range_value_t<_Range> __e)
        : _M_base(views::all(std::forward<_Range>(__r))),
          _M_pattern(views::single(std::move(__e))) {}

    constexpr _Vp base() const &
      requires copy_constructible<_Vp>
    {
      return _M_base;
    }

    constexpr _Vp base() && { return std::move(_M_base); }

    constexpr _Iterator begin() {
      if (!_M_cached_begin)
        _M_cached_begin = _M_find_next(ranges::begin(_M_base));
      return {this, ranges::begin(_M_base), *_M_cached_begin};
    }

    constexpr auto end() {
      if constexpr (common_range<_Vp>)
        return _Iterator{this, ranges::end(_M_base), {}};
      else
        return _Sentinel{this};
    }

    constexpr subrange<iterator_t<_Vp>> _M_find_next(iterator_t<_Vp> __it) {
      auto [__b, __e] =
          ranges::search(subrange(__it, ranges::end(_M_base)), _M_pattern);
      if (__b != ranges::end(_M_base) && ranges::empty(_M_pattern)) {
        ++__b;
        ++__e;
      }
      return {__b, __e};
    }

  private:
    struct _Iterator {
    private:
      split_view *_M_parent = nullptr;
      iterator_t<_Vp> _M_cur = iterator_t<_Vp>();
      subrange<iterator_t<_Vp>> _M_next = subrange<iterator_t<_Vp>>();
      bool _M_trailing_empty = false;

      friend struct _Sentinel;

    public:
      using iterator_concept = forward_iterator_tag;
      using iterator_category = input_iterator_tag;
      using value_type = subrange<iterator_t<_Vp>>;
      using difference_type = range_difference_t<_Vp>;

      _Iterator() = default;

      constexpr _Iterator(split_view *__parent, iterator_t<_Vp> __current,
                          subrange<iterator_t<_Vp>> __next)
          : _M_parent(__parent), _M_cur(std::move(__current)),
            _M_next(std::move(__next)) {}

      constexpr iterator_t<_Vp> base() const { return _M_cur; }

      constexpr value_type operator*() const {
        return {_M_cur, _M_next.begin()};
      }

      constexpr _Iterator &operator++() {
        _M_cur = _M_next.begin();
        if (_M_cur != ranges::end(_M_parent->_M_base)) {
          _M_cur = _M_next.end();
          if (_M_cur == ranges::end(_M_parent->_M_base)) {
            _M_trailing_empty = true;
            _M_next = {_M_cur, _M_cur};
          } else
            _M_next = _M_parent->_M_find_next(_M_cur);
        } else
          _M_trailing_empty = false;
        return *this;
      }

      constexpr _Iterator operator++(int) {
        auto __tmp = *this;
        ++*this;
        return __tmp;
      }

      friend constexpr bool operator==(const _Iterator &__x,
                                       const _Iterator &__y) {
        return __x._M_cur == __y._M_cur &&
               __x._M_trailing_empty == __y._M_trailing_empty;
      }
    };

    struct _Sentinel {
    private:
      sentinel_t<_Vp> _M_end = sentinel_t<_Vp>();

      constexpr bool _M_equal(const _Iterator &__x) const {
        return __x._M_cur == _M_end && !__x._M_trailing_empty;
      }

    public:
      _Sentinel() = default;

      constexpr explicit _Sentinel(split_view *__parent)
          : _M_end(ranges::end(__parent->_M_base)) {}

      friend constexpr bool operator==(const _Iterator &__x,
                                       const _Sentinel &__y) {
        return __y._M_equal(__x);
      }
    };
  };

  template <typename _Range, typename _Pattern>
  split_view(_Range &&, _Pattern &&)
      -> split_view<views::all_t<_Range>, views::all_t<_Pattern>>;

  template <forward_range _Range>
  split_view(_Range &&, range_value_t<_Range>)
      -> split_view<views::all_t<_Range>, single_view<range_value_t<_Range>>>;

  namespace views {
  namespace __detail {
  template <typename _Range, typename _Pattern>
  concept __can_split_view = requires {
    split_view(std::declval<_Range>(), std::declval<_Pattern>());
  };
  } // namespace __detail

  struct _Split : __adaptor::_RangeAdaptor<_Split> {
    template <viewable_range _Range, typename _Pattern>
      requires __detail::__can_split_view<_Range, _Pattern>
    constexpr auto operator()
        [[nodiscard]] (_Range &&__r, _Pattern &&__f) const {
      return split_view(std::forward<_Range>(__r), std::forward<_Pattern>(__f));
    }

    using _RangeAdaptor<_Split>::operator();
    static constexpr int _S_arity = 2;
    template <typename _Pattern>
    static constexpr bool _S_has_simple_extra_args =
        _LazySplit::_S_has_simple_extra_args<_Pattern>;
  };

  inline constexpr _Split split;
  } // namespace views

  namespace views {
  struct _Counted {
    template <input_or_output_iterator _Iter>
    constexpr auto operator()
        [[nodiscard]] (_Iter __i, iter_difference_t<_Iter> __n) const {
      if constexpr (contiguous_iterator<_Iter>)
        return span(std::__to_address(__i), __n);
      else if constexpr (random_access_iterator<_Iter>)
        return subrange(__i, __i + __n);
      else
        return subrange(counted_iterator(std::move(__i), __n),
                        default_sentinel);
    }
  };

  inline constexpr _Counted counted{};
  } // namespace views

  template <view _Vp>
    requires(!common_range<_Vp>) && copyable<iterator_t<_Vp>>
  class common_view : public view_interface<common_view<_Vp>> {
  private:
    _Vp _M_base = _Vp();

  public:
    common_view()
      requires default_initializable<_Vp>
    = default;

    constexpr explicit common_view(_Vp __r) : _M_base(std::move(__r)) {}

    constexpr _Vp base() const &
      requires copy_constructible<_Vp>
    {
      return _M_base;
    }

    constexpr _Vp base() && { return std::move(_M_base); }

    constexpr auto begin() {
      if constexpr (random_access_range<_Vp> && sized_range<_Vp>)
        return ranges::begin(_M_base);
      else
        return common_iterator<iterator_t<_Vp>, sentinel_t<_Vp>>(
            ranges::begin(_M_base));
    }

    constexpr auto begin() const
      requires range<const _Vp>
    {
      if constexpr (random_access_range<const _Vp> && sized_range<const _Vp>)
        return ranges::begin(_M_base);
      else
        return common_iterator<iterator_t<const _Vp>, sentinel_t<const _Vp>>(
            ranges::begin(_M_base));
    }

    constexpr auto end() {
      if constexpr (random_access_range<_Vp> && sized_range<_Vp>)
        return ranges::begin(_M_base) + ranges::size(_M_base);
      else
        return common_iterator<iterator_t<_Vp>, sentinel_t<_Vp>>(
            ranges::end(_M_base));
    }

    constexpr auto end() const
      requires range<const _Vp>
    {
      if constexpr (random_access_range<const _Vp> && sized_range<const _Vp>)
        return ranges::begin(_M_base) + ranges::size(_M_base);
      else
        return common_iterator<iterator_t<const _Vp>, sentinel_t<const _Vp>>(
            ranges::end(_M_base));
    }

    constexpr auto size()
      requires sized_range<_Vp>
    {
      return ranges::size(_M_base);
    }

    constexpr auto size() const
      requires sized_range<const _Vp>
    {
      return ranges::size(_M_base);
    }
  };

  template <typename _Range>
  common_view(_Range &&) -> common_view<views::all_t<_Range>>;

  template <typename _Tp>
  inline constexpr bool enable_borrowed_range<common_view<_Tp>> =
      enable_borrowed_range<_Tp>;

  namespace views {
  namespace __detail {
  template <typename _Range>
  concept __already_common =
      common_range<_Range> && requires { views::all(std::declval<_Range>()); };

  template <typename _Range>
  concept __can_common_view = requires { common_view{std::declval<_Range>()}; };
  } // namespace __detail

  struct _Common : __adaptor::_RangeAdaptorClosure {
    template <viewable_range _Range>
      requires __detail::__already_common<_Range> ||
               __detail::__can_common_view<_Range>
    constexpr auto operator() [[nodiscard]] (_Range &&__r) const {
      if constexpr (__detail::__already_common<_Range>)
        return views::all(std::forward<_Range>(__r));
      else
        return common_view{std::forward<_Range>(__r)};
    }

    static constexpr bool _S_has_simple_call_op = true;
  };

  inline constexpr _Common common;
  } // namespace views

  template <view _Vp>
    requires bidirectional_range<_Vp>
  class reverse_view : public view_interface<reverse_view<_Vp>> {
  private:
    static constexpr bool _S_needs_cached_begin =
        !common_range<_Vp> &&
        !(random_access_range<_Vp> &&
          sized_sentinel_for<sentinel_t<_Vp>, iterator_t<_Vp>>);

    _Vp _M_base = _Vp();
    [[no_unique_address]]
    __detail::__maybe_present_t<_S_needs_cached_begin,
                                __detail::_CachedPosition<_Vp>> _M_cached_begin;

  public:
    reverse_view()
      requires default_initializable<_Vp>
    = default;

    constexpr explicit reverse_view(_Vp __r) : _M_base(std::move(__r)) {}

    constexpr _Vp base() const &
      requires copy_constructible<_Vp>
    {
      return _M_base;
    }

    constexpr _Vp base() && { return std::move(_M_base); }

    constexpr reverse_iterator<iterator_t<_Vp>> begin() {
      if constexpr (_S_needs_cached_begin)
        if (_M_cached_begin._M_has_value())
          return std::make_reverse_iterator(_M_cached_begin._M_get(_M_base));

      auto __it = ranges::next(ranges::begin(_M_base), ranges::end(_M_base));
      if constexpr (_S_needs_cached_begin)
        _M_cached_begin._M_set(_M_base, __it);
      return std::make_reverse_iterator(std::move(__it));
    }

    constexpr auto begin()
      requires common_range<_Vp>
    {
      return std::make_reverse_iterator(ranges::end(_M_base));
    }

    constexpr auto begin() const
      requires common_range<const _Vp>
    {
      return std::make_reverse_iterator(ranges::end(_M_base));
    }

    constexpr reverse_iterator<iterator_t<_Vp>> end() {
      return std::make_reverse_iterator(ranges::begin(_M_base));
    }

    constexpr auto end() const
      requires common_range<const _Vp>
    {
      return std::make_reverse_iterator(ranges::begin(_M_base));
    }

    constexpr auto size()
      requires sized_range<_Vp>
    {
      return ranges::size(_M_base);
    }

    constexpr auto size() const
      requires sized_range<const _Vp>
    {
      return ranges::size(_M_base);
    }
  };

  template <typename _Range>
  reverse_view(_Range &&) -> reverse_view<views::all_t<_Range>>;

  template <typename _Tp>
  inline constexpr bool enable_borrowed_range<reverse_view<_Tp>> =
      enable_borrowed_range<_Tp>;

  namespace views {
  namespace __detail {
  template <typename> inline constexpr bool __is_reversible_subrange = false;

  template <typename _Iter, subrange_kind _Kind>
  inline constexpr bool __is_reversible_subrange<
      subrange<reverse_iterator<_Iter>, reverse_iterator<_Iter>, _Kind>> = true;

  template <typename> inline constexpr bool __is_reverse_view = false;

  template <typename _Vp>
  inline constexpr bool __is_reverse_view<reverse_view<_Vp>> = true;

  template <typename _Range>
  concept __can_reverse_view =
      requires { reverse_view{std::declval<_Range>()}; };
  } // namespace __detail

  struct _Reverse : __adaptor::_RangeAdaptorClosure {
    template <viewable_range _Range>
      requires __detail::__is_reverse_view<remove_cvref_t<_Range>> ||
               __detail::__is_reversible_subrange<remove_cvref_t<_Range>> ||
               __detail::__can_reverse_view<_Range>
    constexpr auto operator() [[nodiscard]] (_Range &&__r) const {
      using _Tp = remove_cvref_t<_Range>;
      if constexpr (__detail::__is_reverse_view<_Tp>)
        return std::forward<_Range>(__r).base();
      else if constexpr (__detail::__is_reversible_subrange<_Tp>) {
        using _Iter = decltype(ranges::begin(__r).base());
        if constexpr (sized_range<_Tp>)
          return subrange<_Iter, _Iter, subrange_kind::sized>{
              __r.end().base(), __r.begin().base(), __r.size()};
        else
          return subrange<_Iter, _Iter, subrange_kind::unsized>{
              __r.end().base(), __r.begin().base()};
      } else
        return reverse_view{std::forward<_Range>(__r)};
    }

    static constexpr bool _S_has_simple_call_op = true;
  };

  inline constexpr _Reverse reverse;
  } // namespace views

  namespace __detail {
  template <typename _Tp, size_t _Nm>
  concept __has_tuple_element = requires(_Tp __t) {
    typename tuple_size<_Tp>::type;
    requires _Nm < tuple_size_v<_Tp>;
    typename tuple_element_t<_Nm, _Tp>;
    { std::get<_Nm>(__t) } -> convertible_to<const tuple_element_t<_Nm, _Tp> &>;
  };

  template <typename _Tp, size_t _Nm>
  concept __returnable_element =
      is_reference_v<_Tp> || move_constructible<tuple_element_t<_Nm, _Tp>>;
  } // namespace __detail

  template <input_range _Vp, size_t _Nm>
    requires view<_Vp> &&
             __detail::__has_tuple_element<range_value_t<_Vp>, _Nm> &&
             __detail::__has_tuple_element<
                 remove_reference_t<range_reference_t<_Vp>>, _Nm> &&
             __detail::__returnable_element<range_reference_t<_Vp>, _Nm>
  class elements_view : public view_interface<elements_view<_Vp, _Nm>> {
  public:
    elements_view()
      requires default_initializable<_Vp>
    = default;

    constexpr explicit elements_view(_Vp __base) : _M_base(std::move(__base)) {}

    constexpr _Vp base() const &
      requires copy_constructible<_Vp>
    {
      return _M_base;
    }

    constexpr _Vp base() && { return std::move(_M_base); }

    constexpr auto begin()
      requires(!__detail::__simple_view<_Vp>)
    {
      return _Iterator<false>(ranges::begin(_M_base));
    }

    constexpr auto begin() const
      requires range<const _Vp>
    {
      return _Iterator<true>(ranges::begin(_M_base));
    }

    constexpr auto end()
      requires(!__detail::__simple_view<_Vp> && !common_range<_Vp>)
    {
      return _Sentinel<false>{ranges::end(_M_base)};
    }

    constexpr auto end()
      requires(!__detail::__simple_view<_Vp> && common_range<_Vp>)
    {
      return _Iterator<false>{ranges::end(_M_base)};
    }

    constexpr auto end() const
      requires range<const _Vp>
    {
      return _Sentinel<true>{ranges::end(_M_base)};
    }

    constexpr auto end() const
      requires common_range<const _Vp>
    {
      return _Iterator<true>{ranges::end(_M_base)};
    }

    constexpr auto size()
      requires sized_range<_Vp>
    {
      return ranges::size(_M_base);
    }

    constexpr auto size() const
      requires sized_range<const _Vp>
    {
      return ranges::size(_M_base);
    }

  private:
    template <bool _Const> using _Base = __detail::__maybe_const_t<_Const, _Vp>;

    template <bool _Const> struct __iter_cat {};

    template <bool _Const>
      requires forward_range<_Base<_Const>>
    struct __iter_cat<_Const> {
    private:
      static auto _S_iter_cat() {
        using _Base = elements_view::_Base<_Const>;
        using _Cat =
            typename iterator_traits<iterator_t<_Base>>::iterator_category;
        using _Res =
            decltype((std::get<_Nm>(*std::declval<iterator_t<_Base>>())));
        if constexpr (!is_lvalue_reference_v<_Res>)
          return input_iterator_tag{};
        else if constexpr (derived_from<_Cat, random_access_iterator_tag>)
          return random_access_iterator_tag{};
        else
          return _Cat{};
      }

    public:
      using iterator_category = decltype(_S_iter_cat());
    };

    template <bool _Const> struct _Sentinel;

    template <bool _Const> struct _Iterator : __iter_cat<_Const> {
    private:
      using _Base = elements_view::_Base<_Const>;

      iterator_t<_Base> _M_current = iterator_t<_Base>();

      static constexpr decltype(auto)
      _S_get_element(const iterator_t<_Base> &__i) {
        if constexpr (is_reference_v<range_reference_t<_Base>>)
          return std::get<_Nm>(*__i);
        else {
          using _Et =
              remove_cv_t<tuple_element_t<_Nm, range_reference_t<_Base>>>;
          return static_cast<_Et>(std::get<_Nm>(*__i));
        }
      }

      static auto _S_iter_concept() {
        if constexpr (random_access_range<_Base>)
          return random_access_iterator_tag{};
        else if constexpr (bidirectional_range<_Base>)
          return bidirectional_iterator_tag{};
        else if constexpr (forward_range<_Base>)
          return forward_iterator_tag{};
        else
          return input_iterator_tag{};
      }

      friend _Iterator<!_Const>;

    public:
      using iterator_concept = decltype(_S_iter_concept());

      using value_type =
          remove_cvref_t<tuple_element_t<_Nm, range_value_t<_Base>>>;
      using difference_type = range_difference_t<_Base>;

      _Iterator()
        requires default_initializable<iterator_t<_Base>>
      = default;

      constexpr explicit _Iterator(iterator_t<_Base> __current)
          : _M_current(std::move(__current)) {}

      constexpr _Iterator(_Iterator<!_Const> __i)
        requires _Const && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>
          : _M_current(std::move(__i._M_current)) {}

      constexpr const iterator_t<_Base> &base() const & noexcept {
        return _M_current;
      }

      constexpr iterator_t<_Base> base() && { return std::move(_M_current); }

      constexpr decltype(auto) operator*() const {
        return _S_get_element(_M_current);
      }

      constexpr _Iterator &operator++() {
        ++_M_current;
        return *this;
      }

      constexpr void operator++(int) { ++_M_current; }

      constexpr _Iterator operator++(int)
        requires forward_range<_Base>
      {
        auto __tmp = *this;
        ++_M_current;
        return __tmp;
      }

      constexpr _Iterator &operator--()
        requires bidirectional_range<_Base>
      {
        --_M_current;
        return *this;
      }

      constexpr _Iterator operator--(int)
        requires bidirectional_range<_Base>
      {
        auto __tmp = *this;
        --_M_current;
        return __tmp;
      }

      constexpr _Iterator &operator+=(difference_type __n)
        requires random_access_range<_Base>
      {
        _M_current += __n;
        return *this;
      }

      constexpr _Iterator &operator-=(difference_type __n)
        requires random_access_range<_Base>
      {
        _M_current -= __n;
        return *this;
      }

      constexpr decltype(auto) operator[](difference_type __n) const
        requires random_access_range<_Base>
      {
        return _S_get_element(_M_current + __n);
      }

      friend constexpr bool operator==(const _Iterator &__x,
                                       const _Iterator &__y)
        requires equality_comparable<iterator_t<_Base>>
      {
        return __x._M_current == __y._M_current;
      }

      friend constexpr bool operator<(const _Iterator &__x,
                                      const _Iterator &__y)
        requires random_access_range<_Base>
      {
        return __x._M_current < __y._M_current;
      }

      friend constexpr bool operator>(const _Iterator &__x,
                                      const _Iterator &__y)
        requires random_access_range<_Base>
      {
        return __y._M_current < __x._M_current;
      }

      friend constexpr bool operator<=(const _Iterator &__x,
                                       const _Iterator &__y)
        requires random_access_range<_Base>
      {
        return !(__y._M_current > __x._M_current);
      }

      friend constexpr bool operator>=(const _Iterator &__x,
                                       const _Iterator &__y)
        requires random_access_range<_Base>
      {
        return !(__x._M_current > __y._M_current);
      }

      friend constexpr auto operator<=>(const _Iterator &__x,
                                        const _Iterator &__y)
        requires random_access_range<_Base> &&
                 three_way_comparable<iterator_t<_Base>>
      {
        return __x._M_current <=> __y._M_current;
      }

      friend constexpr _Iterator operator+(const _Iterator &__x,
                                           difference_type __y)
        requires random_access_range<_Base>
      {
        return _Iterator{__x} += __y;
      }

      friend constexpr _Iterator operator+(difference_type __x,
                                           const _Iterator &__y)
        requires random_access_range<_Base>
      {
        return __y + __x;
      }

      friend constexpr _Iterator operator-(const _Iterator &__x,
                                           difference_type __y)
        requires random_access_range<_Base>
      {
        return _Iterator{__x} -= __y;
      }

      friend constexpr difference_type operator-(const _Iterator &__x,
                                                 const _Iterator &__y)
        requires sized_sentinel_for<iterator_t<_Base>, iterator_t<_Base>>
      {
        return __x._M_current - __y._M_current;
      }

      template <bool> friend struct _Sentinel;
    };

    template <bool _Const> struct _Sentinel {
    private:
      template <bool _Const2>
      constexpr bool _M_equal(const _Iterator<_Const2> &__x) const {
        return __x._M_current == _M_end;
      }

      template <bool _Const2>
      constexpr auto _M_distance_from(const _Iterator<_Const2> &__i) const {
        return _M_end - __i._M_current;
      }

      using _Base = elements_view::_Base<_Const>;
      sentinel_t<_Base> _M_end = sentinel_t<_Base>();

    public:
      _Sentinel() = default;

      constexpr explicit _Sentinel(sentinel_t<_Base> __end)
          : _M_end(std::move(__end)) {}

      constexpr _Sentinel(_Sentinel<!_Const> __other)
        requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>
          : _M_end(std::move(__other._M_end)) {}

      constexpr sentinel_t<_Base> base() const { return _M_end; }

      template <bool _Const2>
        requires sentinel_for<
            sentinel_t<_Base>,
            iterator_t<__detail::__maybe_const_t<_Const2, _Vp>>>
      friend constexpr bool operator==(const _Iterator<_Const2> &__x,
                                       const _Sentinel &__y) {
        return __y._M_equal(__x);
      }

      template <bool _Const2,
                typename _Base2 = __detail::__maybe_const_t<_Const2, _Vp>>
        requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base2>>
      friend constexpr range_difference_t<_Base2>
      operator-(const _Iterator<_Const2> &__x, const _Sentinel &__y) {
        return -__y._M_distance_from(__x);
      }

      template <bool _Const2,
                typename _Base2 = __detail::__maybe_const_t<_Const2, _Vp>>
        requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base2>>
      friend constexpr range_difference_t<_Base2>
      operator-(const _Sentinel &__x, const _Iterator<_Const2> &__y) {
        return __x._M_distance_from(__y);
      }

      friend _Sentinel<!_Const>;
    };

    _Vp _M_base = _Vp();
  };

  template <typename _Tp, size_t _Nm>
  inline constexpr bool enable_borrowed_range<elements_view<_Tp, _Nm>> =
      enable_borrowed_range<_Tp>;

  template <typename _Range>
  using keys_view = elements_view<views::all_t<_Range>, 0>;

  template <typename _Range>
  using values_view = elements_view<views::all_t<_Range>, 1>;

  namespace views {
  namespace __detail {
  template <size_t _Nm, typename _Range>
  concept __can_elements_view =
      requires { elements_view<all_t<_Range>, _Nm>{std::declval<_Range>()}; };
  } // namespace __detail

  template <size_t _Nm> struct _Elements : __adaptor::_RangeAdaptorClosure {
    template <viewable_range _Range>
      requires __detail::__can_elements_view<_Nm, _Range>
    constexpr auto operator() [[nodiscard]] (_Range &&__r) const {
      return elements_view<all_t<_Range>, _Nm>{std::forward<_Range>(__r)};
    }

    static constexpr bool _S_has_simple_call_op = true;
  };

  template <size_t _Nm> inline constexpr _Elements<_Nm> elements;
  inline constexpr auto keys = elements<0>;
  inline constexpr auto values = elements<1>;
  } // namespace views
# 9057 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/ranges" 3
  } // namespace ranges

  namespace views = ranges::views;

} // namespace std
# 4 "./ComputeSPMV_stdexec.hpp" 2
# 35 "./ComputeSPMV_stdexec.hpp"
# 1 "./ComputeSPMV_ref.hpp" 1
# 20 "./ComputeSPMV_ref.hpp"
int ComputeSPMV_ref(const SparseMatrix &A, Vector &x, Vector &y);
# 36 "./ComputeSPMV_stdexec.hpp" 2

auto ComputeSPMV_stdexec(double *time, const SparseMatrix &A, Vector &x,
                         Vector &y) {

  return stdexec::then([&, time]() {
    if (time != __null)
      *time -= mytimer();
    (static_cast<bool>(x.localLength >= A.localNumberOfColumns)
         ? void(0)
         : __assert_fail("x.localLength >= A.localNumberOfColumns",
                         __builtin_FILE(), __builtin_LINE(),
                         __extension__ __PRETTY_FUNCTION__));
    (static_cast<bool>(y.localLength >= A.localNumberOfRows)
         ? void(0)
         : __assert_fail("y.localLength >= A.localNumberOfRows",
                         __builtin_FILE(), __builtin_LINE(),
                         __extension__ __PRETTY_FUNCTION__));

    ComputeSPMV_ref(A, x, y);
    if (time != __null)
      *time += mytimer();
  });
# 66 "./ComputeSPMV_stdexec.hpp"
}
# 8 "./ComputeMG_stdexec.hpp" 2
# 1 "./ComputeRestriction_stdexec.hpp" 1
# 23 "./ComputeRestriction_stdexec.hpp"
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/algorithm" 1 3
# 59 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/algorithm" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_algo.h" 1 3
# 43 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_algo.h" 3
namespace std __attribute__((__visibility__("default"))) {

  namespace ranges {
  namespace __detail {
  template <typename _Comp, typename _Proj>
  constexpr auto __make_comp_proj(_Comp &__comp, _Proj &__proj) {
    return [&](auto &&__lhs, auto &&__rhs) -> bool {
      using _TL = decltype(__lhs);
      using _TR = decltype(__rhs);
      return std::__invoke(__comp,
                           std::__invoke(__proj, std::forward<_TL>(__lhs)),
                           std::__invoke(__proj, std::forward<_TR>(__rhs)));
    };
  }

  template <typename _Pred, typename _Proj>
  constexpr auto __make_pred_proj(_Pred &__pred, _Proj &__proj) {
    return [&]<typename _Tp>(_Tp &&__arg) -> bool {
      return std::__invoke(__pred,
                           std::__invoke(__proj, std::forward<_Tp>(__arg)));
    };
  }
  } // namespace __detail

  struct __all_of_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    constexpr bool operator()(_Iter __first, _Sent __last, _Pred __pred,
                              _Proj __proj = {}) const {
      for (; __first != __last; ++__first)
        if (!(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
          return false;
      return true;
    }

    template <
        input_range _Range, typename _Proj = identity,
        indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    constexpr bool operator()(_Range &&__r, _Pred __pred,
                              _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred),
                     std::move(__proj));
    }
  };

  inline constexpr __all_of_fn all_of{};

  struct __any_of_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    constexpr bool operator()(_Iter __first, _Sent __last, _Pred __pred,
                              _Proj __proj = {}) const {
      for (; __first != __last; ++__first)
        if (std::__invoke(__pred, std::__invoke(__proj, *__first)))
          return true;
      return false;
    }

    template <
        input_range _Range, typename _Proj = identity,
        indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    constexpr bool operator()(_Range &&__r, _Pred __pred,
                              _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred),
                     std::move(__proj));
    }
  };

  inline constexpr __any_of_fn any_of{};

  struct __none_of_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    constexpr bool operator()(_Iter __first, _Sent __last, _Pred __pred,
                              _Proj __proj = {}) const {
      for (; __first != __last; ++__first)
        if (std::__invoke(__pred, std::__invoke(__proj, *__first)))
          return false;
      return true;
    }

    template <
        input_range _Range, typename _Proj = identity,
        indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    constexpr bool operator()(_Range &&__r, _Pred __pred,
                              _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred),
                     std::move(__proj));
    }
  };

  inline constexpr __none_of_fn none_of{};

  template <typename _Iter, typename _Fp> struct in_fun_result {
    [[no_unique_address]] _Iter in;
    [[no_unique_address]] _Fp fun;

    template <typename _Iter2, typename _F2p>
      requires convertible_to<const _Iter &, _Iter2> &&
               convertible_to<const _Fp &, _F2p>
    constexpr operator in_fun_result<_Iter2, _F2p>() const & {
      return {in, fun};
    }

    template <typename _Iter2, typename _F2p>
      requires convertible_to<_Iter, _Iter2> && convertible_to<_Fp, _F2p>
    constexpr operator in_fun_result<_Iter2, _F2p>() && {
      return {std::move(in), std::move(fun)};
    }
  };

  template <typename _Iter, typename _Fp>
  using for_each_result = in_fun_result<_Iter, _Fp>;

  struct __for_each_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirectly_unary_invocable<projected<_Iter, _Proj>> _Fun>
    constexpr for_each_result<_Iter, _Fun>
    operator()(_Iter __first, _Sent __last, _Fun __f, _Proj __proj = {}) const {
      for (; __first != __last; ++__first)
        std::__invoke(__f, std::__invoke(__proj, *__first));
      return {std::move(__first), std::move(__f)};
    }

    template <
        input_range _Range, typename _Proj = identity,
        indirectly_unary_invocable<projected<iterator_t<_Range>, _Proj>> _Fun>
    constexpr for_each_result<borrowed_iterator_t<_Range>, _Fun>
    operator()(_Range &&__r, _Fun __f, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__f),
                     std::move(__proj));
    }
  };

  inline constexpr __for_each_fn for_each{};

  template <typename _Iter, typename _Fp>
  using for_each_n_result = in_fun_result<_Iter, _Fp>;

  struct __for_each_n_fn {
    template <input_iterator _Iter, typename _Proj = identity,
              indirectly_unary_invocable<projected<_Iter, _Proj>> _Fun>
    constexpr for_each_n_result<_Iter, _Fun>
    operator()(_Iter __first, iter_difference_t<_Iter> __n, _Fun __f,
               _Proj __proj = {}) const {
      if constexpr (random_access_iterator<_Iter>) {
        if (__n <= 0)
          return {std::move(__first), std::move(__f)};
        auto __last = __first + __n;
        return ranges::for_each(std::move(__first), std::move(__last),
                                std::move(__f), std::move(__proj));
      } else {
        while (__n-- > 0) {
          std::__invoke(__f, std::__invoke(__proj, *__first));
          ++__first;
        }
        return {std::move(__first), std::move(__f)};
      }
    }
  };

  inline constexpr __for_each_n_fn for_each_n{};

  struct __find_first_of_fn {
    template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
              typename _Pred = ranges::equal_to, typename _Proj1 = identity,
              typename _Proj2 = identity>
      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
    constexpr _Iter1 operator()(_Iter1 __first1, _Sent1 __last1,
                                _Iter2 __first2, _Sent2 __last2,
                                _Pred __pred = {}, _Proj1 __proj1 = {},
                                _Proj2 __proj2 = {}) const {
      for (; __first1 != __last1; ++__first1)
        for (auto __iter = __first2; __iter != __last2; ++__iter)
          if (std::__invoke(__pred, std::__invoke(__proj1, *__first1),
                            std::__invoke(__proj2, *__iter)))
            return __first1;
      return __first1;
    }

    template <input_range _Range1, forward_range _Range2,
              typename _Pred = ranges::equal_to, typename _Proj1 = identity,
              typename _Proj2 = identity>
      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
                                     _Pred, _Proj1, _Proj2>
    constexpr borrowed_iterator_t<_Range1>
    operator()(_Range1 &&__r1, _Range2 &&__r2, _Pred __pred = {},
               _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      return (*this)(ranges::begin(__r1), ranges::end(__r1),
                     ranges::begin(__r2), ranges::end(__r2), std::move(__pred),
                     std::move(__proj1), std::move(__proj2));
    }
  };

  inline constexpr __find_first_of_fn find_first_of{};

  struct __count_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,
              typename _Proj = identity>
      requires indirect_binary_predicate<ranges::equal_to,
                                         projected<_Iter, _Proj>, const _Tp *>
    constexpr iter_difference_t<_Iter> operator()(_Iter __first, _Sent __last,
                                                  const _Tp &__value,
                                                  _Proj __proj = {}) const {
      iter_difference_t<_Iter> __n = 0;
      for (; __first != __last; ++__first)
        if (std::__invoke(__proj, *__first) == __value)
          ++__n;
      return __n;
    }

    template <input_range _Range, typename _Tp, typename _Proj = identity>
      requires indirect_binary_predicate<
          ranges::equal_to, projected<iterator_t<_Range>, _Proj>, const _Tp *>
    constexpr range_difference_t<_Range>
    operator()(_Range &&__r, const _Tp &__value, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), __value,
                     std::move(__proj));
    }
  };

  inline constexpr __count_fn count{};

  struct __count_if_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    constexpr iter_difference_t<_Iter> operator()(_Iter __first, _Sent __last,
                                                  _Pred __pred,
                                                  _Proj __proj = {}) const {
      iter_difference_t<_Iter> __n = 0;
      for (; __first != __last; ++__first)
        if (std::__invoke(__pred, std::__invoke(__proj, *__first)))
          ++__n;
      return __n;
    }

    template <
        input_range _Range, typename _Proj = identity,
        indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    constexpr range_difference_t<_Range> operator()(_Range &&__r, _Pred __pred,
                                                    _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred),
                     std::move(__proj));
    }
  };

  inline constexpr __count_if_fn count_if{};

  struct __search_n_fn {
    template <forward_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,
              typename _Pred = ranges::equal_to, typename _Proj = identity>
      requires indirectly_comparable<_Iter, const _Tp *, _Pred, _Proj>
    constexpr subrange<_Iter>
    operator()(_Iter __first, _Sent __last, iter_difference_t<_Iter> __count,
               const _Tp &__value, _Pred __pred = {}, _Proj __proj = {}) const {
      if (__count <= 0)
        return {__first, __first};

      auto __value_comp = [&]<typename _Rp>(_Rp &&__arg) -> bool {
        return std::__invoke(__pred, std::forward<_Rp>(__arg), __value);
      };
      if (__count == 1) {
        __first = ranges::find_if(std::move(__first), __last,
                                  std::move(__value_comp), std::move(__proj));
        if (__first == __last)
          return {__first, __first};
        else {
          auto __end = __first;
          return {__first, ++__end};
        }
      }

      if constexpr (sized_sentinel_for<_Sent, _Iter> &&
                    random_access_iterator<_Iter>) {
        auto __tail_size = __last - __first;
        auto __remainder = __count;

        while (__remainder <= __tail_size) {
          __first += __remainder;
          __tail_size -= __remainder;
          auto __backtrack = __first;
          while (__value_comp(std::__invoke(__proj, *--__backtrack))) {
            if (--__remainder == 0)
              return {__first - __count, __first};
          }
          __remainder = __count + 1 - (__first - __backtrack);
        }
        auto __i = __first + __tail_size;
        return {__i, __i};
      } else {
        __first = ranges::find_if(__first, __last, __value_comp, __proj);
        while (__first != __last) {
          auto __n = __count;
          auto __i = __first;
          ++__i;
          while (__i != __last && __n != 1 &&
                 __value_comp(std::__invoke(__proj, *__i))) {
            ++__i;
            --__n;
          }
          if (__n == 1)
            return {__first, __i};
          if (__i == __last)
            return {__i, __i};
          __first = ranges::find_if(++__i, __last, __value_comp, __proj);
        }
        return {__first, __first};
      }
    }

    template <forward_range _Range, typename _Tp,
              typename _Pred = ranges::equal_to, typename _Proj = identity>
      requires indirectly_comparable<iterator_t<_Range>, const _Tp *, _Pred,
                                     _Proj>
    constexpr borrowed_subrange_t<_Range>
    operator()(_Range &&__r, range_difference_t<_Range> __count,
               const _Tp &__value, _Pred __pred = {}, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__count),
                     __value, std::move(__pred), std::move(__proj));
    }
  };

  inline constexpr __search_n_fn search_n{};

  struct __find_end_fn {
    template <forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
              typename _Pred = ranges::equal_to, typename _Proj1 = identity,
              typename _Proj2 = identity>
      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
    constexpr subrange<_Iter1>
    operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
               _Pred __pred = {}, _Proj1 __proj1 = {},
               _Proj2 __proj2 = {}) const {
      if constexpr (bidirectional_iterator<_Iter1> &&
                    bidirectional_iterator<_Iter2>) {
        auto __i1 = ranges::next(__first1, __last1);
        auto __i2 = ranges::next(__first2, __last2);
        auto __rresult = ranges::search(
            reverse_iterator<_Iter1>{__i1}, reverse_iterator<_Iter1>{__first1},
            reverse_iterator<_Iter2>{__i2}, reverse_iterator<_Iter2>{__first2},
            std::move(__pred), std::move(__proj1), std::move(__proj2));
        auto __result_first = ranges::end(__rresult).base();
        auto __result_last = ranges::begin(__rresult).base();
        if (__result_last == __first1)
          return {__i1, __i1};
        else
          return {__result_first, __result_last};
      } else {
        auto __i = ranges::next(__first1, __last1);
        if (__first2 == __last2)
          return {__i, __i};

        auto __result_begin = __i;
        auto __result_end = __i;
        for (;;) {
          auto __new_range = ranges::search(__first1, __last1, __first2,
                                            __last2, __pred, __proj1, __proj2);
          auto __new_result_begin = ranges::begin(__new_range);
          auto __new_result_end = ranges::end(__new_range);
          if (__new_result_begin == __last1)
            return {__result_begin, __result_end};
          else {
            __result_begin = __new_result_begin;
            __result_end = __new_result_end;
            __first1 = __result_begin;
            ++__first1;
          }
        }
      }
    }

    template <forward_range _Range1, forward_range _Range2,
              typename _Pred = ranges::equal_to, typename _Proj1 = identity,
              typename _Proj2 = identity>
      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
                                     _Pred, _Proj1, _Proj2>
    constexpr borrowed_subrange_t<_Range1>
    operator()(_Range1 &&__r1, _Range2 &&__r2, _Pred __pred = {},
               _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      return (*this)(ranges::begin(__r1), ranges::end(__r1),
                     ranges::begin(__r2), ranges::end(__r2), std::move(__pred),
                     std::move(__proj1), std::move(__proj2));
    }
  };

  inline constexpr __find_end_fn find_end{};

  struct __is_permutation_fn {
    template <forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
              typename _Proj1 = identity, typename _Proj2 = identity,
              indirect_equivalence_relation<projected<_Iter1, _Proj1>,
                                            projected<_Iter2, _Proj2>>
                  _Pred = ranges::equal_to>
    constexpr bool operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2,
                              _Sent2 __last2, _Pred __pred = {},
                              _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      constexpr bool __sized_iters = (sized_sentinel_for<_Sent1, _Iter1> &&
                                      sized_sentinel_for<_Sent2, _Iter2>);
      if constexpr (__sized_iters) {
        auto __d1 = ranges::distance(__first1, __last1);
        auto __d2 = ranges::distance(__first2, __last2);
        if (__d1 != __d2)
          return false;
      }

      for (; __first1 != __last1 && __first2 != __last2;
           ++__first1, (void)++__first2)
        if (!(bool)std::__invoke(__pred, std::__invoke(__proj1, *__first1),
                                 std::__invoke(__proj2, *__first2)))
          break;

      if constexpr (__sized_iters) {
        if (__first1 == __last1)
          return true;
      } else {
        auto __d1 = ranges::distance(__first1, __last1);
        auto __d2 = ranges::distance(__first2, __last2);
        if (__d1 == 0 && __d2 == 0)
          return true;
        if (__d1 != __d2)
          return false;
      }

      for (auto __scan = __first1; __scan != __last1; ++__scan) {
        auto &&__proj_scan = std::__invoke(__proj1, *__scan);
        auto __comp_scan = [&]<typename _Tp>(_Tp &&__arg) -> bool {
          return std::__invoke(__pred, __proj_scan, std::forward<_Tp>(__arg));
        };
        if (__scan != ranges::find_if(__first1, __scan, __comp_scan, __proj1))
          continue;

        auto __matches =
            ranges::count_if(__first2, __last2, __comp_scan, __proj2);
        if (__matches == 0 || ranges::count_if(__scan, __last1, __comp_scan,
                                               __proj1) != __matches)
          return false;
      }
      return true;
    }

    template <
        forward_range _Range1, forward_range _Range2,
        typename _Proj1 = identity, typename _Proj2 = identity,
        indirect_equivalence_relation<projected<iterator_t<_Range1>, _Proj1>,
                                      projected<iterator_t<_Range2>, _Proj2>>
            _Pred = ranges::equal_to>
    constexpr bool operator()(_Range1 &&__r1, _Range2 &&__r2, _Pred __pred = {},
                              _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      return (*this)(ranges::begin(__r1), ranges::end(__r1),
                     ranges::begin(__r2), ranges::end(__r2), std::move(__pred),
                     std::move(__proj1), std::move(__proj2));
    }
  };

  inline constexpr __is_permutation_fn is_permutation{};

  template <typename _Iter, typename _Out>
  using copy_if_result = in_out_result<_Iter, _Out>;

  struct __copy_if_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              weakly_incrementable _Out, typename _Proj = identity,
              indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
      requires indirectly_copyable<_Iter, _Out>
    constexpr copy_if_result<_Iter, _Out>
    operator()(_Iter __first, _Sent __last, _Out __result, _Pred __pred,
               _Proj __proj = {}) const {
      for (; __first != __last; ++__first)
        if (std::__invoke(__pred, std::__invoke(__proj, *__first))) {
          *__result = *__first;
          ++__result;
        }
      return {std::move(__first), std::move(__result)};
    }

    template <
        input_range _Range, weakly_incrementable _Out,
        typename _Proj = identity,
        indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
      requires indirectly_copyable<iterator_t<_Range>, _Out>
    constexpr copy_if_result<borrowed_iterator_t<_Range>, _Out>
    operator()(_Range &&__r, _Out __result, _Pred __pred,
               _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__result),
                     std::move(__pred), std::move(__proj));
    }
  };

  inline constexpr __copy_if_fn copy_if{};

  template <typename _Iter1, typename _Iter2>
  using swap_ranges_result = in_in_result<_Iter1, _Iter2>;

  struct __swap_ranges_fn {
    template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              input_iterator _Iter2, sentinel_for<_Iter2> _Sent2>
      requires indirectly_swappable<_Iter1, _Iter2>
    constexpr swap_ranges_result<_Iter1, _Iter2>
    operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2,
               _Sent2 __last2) const {
      for (; __first1 != __last1 && __first2 != __last2;
           ++__first1, (void)++__first2)
        ranges::iter_swap(__first1, __first2);
      return {std::move(__first1), std::move(__first2)};
    }

    template <input_range _Range1, input_range _Range2>
      requires indirectly_swappable<iterator_t<_Range1>, iterator_t<_Range2>>
    constexpr swap_ranges_result<borrowed_iterator_t<_Range1>,
                                 borrowed_iterator_t<_Range2>>
    operator()(_Range1 &&__r1, _Range2 &&__r2) const {
      return (*this)(ranges::begin(__r1), ranges::end(__r1),
                     ranges::begin(__r2), ranges::end(__r2));
    }
  };

  inline constexpr __swap_ranges_fn swap_ranges{};

  template <typename _Iter, typename _Out>
  using unary_transform_result = in_out_result<_Iter, _Out>;

  template <typename _Iter1, typename _Iter2, typename _Out>
  struct in_in_out_result {
    [[no_unique_address]] _Iter1 in1;
    [[no_unique_address]] _Iter2 in2;
    [[no_unique_address]] _Out out;

    template <typename _IIter1, typename _IIter2, typename _OOut>
      requires convertible_to<const _Iter1 &, _IIter1> &&
               convertible_to<const _Iter2 &, _IIter2> &&
               convertible_to<const _Out &, _OOut>
    constexpr operator in_in_out_result<_IIter1, _IIter2, _OOut>() const & {
      return {in1, in2, out};
    }

    template <typename _IIter1, typename _IIter2, typename _OOut>
      requires convertible_to<_Iter1, _IIter1> &&
               convertible_to<_Iter2, _IIter2> && convertible_to<_Out, _OOut>
    constexpr operator in_in_out_result<_IIter1, _IIter2, _OOut>() && {
      return {std::move(in1), std::move(in2), std::move(out)};
    }
  };

  template <typename _Iter1, typename _Iter2, typename _Out>
  using binary_transform_result = in_in_out_result<_Iter1, _Iter2, _Out>;

  struct __transform_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              weakly_incrementable _Out, copy_constructible _Fp,
              typename _Proj = identity>
      requires indirectly_writable<
          _Out, indirect_result_t<_Fp &, projected<_Iter, _Proj>>>
    constexpr unary_transform_result<_Iter, _Out>
    operator()(_Iter __first1, _Sent __last1, _Out __result, _Fp __op,
               _Proj __proj = {}) const {
      for (; __first1 != __last1; ++__first1, (void)++__result)
        *__result = std::__invoke(__op, std::__invoke(__proj, *__first1));
      return {std::move(__first1), std::move(__result)};
    }

    template <input_range _Range, weakly_incrementable _Out,
              copy_constructible _Fp, typename _Proj = identity>
      requires indirectly_writable<
          _Out, indirect_result_t<_Fp &, projected<iterator_t<_Range>, _Proj>>>
    constexpr unary_transform_result<borrowed_iterator_t<_Range>, _Out>
    operator()(_Range &&__r, _Out __result, _Fp __op, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__result),
                     std::move(__op), std::move(__proj));
    }

    template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
              weakly_incrementable _Out, copy_constructible _Fp,
              typename _Proj1 = identity, typename _Proj2 = identity>
      requires indirectly_writable<
          _Out, indirect_result_t<_Fp &, projected<_Iter1, _Proj1>,
                                  projected<_Iter2, _Proj2>>>
    constexpr binary_transform_result<_Iter1, _Iter2, _Out>
    operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
               _Out __result, _Fp __binary_op, _Proj1 __proj1 = {},
               _Proj2 __proj2 = {}) const {
      for (; __first1 != __last1 && __first2 != __last2;
           ++__first1, (void)++__first2, ++__result)
        *__result =
            std::__invoke(__binary_op, std::__invoke(__proj1, *__first1),
                          std::__invoke(__proj2, *__first2));
      return {std::move(__first1), std::move(__first2), std::move(__result)};
    }

    template <input_range _Range1, input_range _Range2,
              weakly_incrementable _Out, copy_constructible _Fp,
              typename _Proj1 = identity, typename _Proj2 = identity>
      requires indirectly_writable<
          _Out, indirect_result_t<_Fp &, projected<iterator_t<_Range1>, _Proj1>,
                                  projected<iterator_t<_Range2>, _Proj2>>>
    constexpr binary_transform_result<borrowed_iterator_t<_Range1>,
                                      borrowed_iterator_t<_Range2>, _Out>
    operator()(_Range1 &&__r1, _Range2 &&__r2, _Out __result, _Fp __binary_op,
               _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      return (*this)(ranges::begin(__r1), ranges::end(__r1),
                     ranges::begin(__r2), ranges::end(__r2),
                     std::move(__result), std::move(__binary_op),
                     std::move(__proj1), std::move(__proj2));
    }
  };

  inline constexpr __transform_fn transform{};

  struct __replace_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp1,
              typename _Tp2, typename _Proj = identity>
      requires indirectly_writable<_Iter, const _Tp2 &> &&
               indirect_binary_predicate<ranges::equal_to,
                                         projected<_Iter, _Proj>, const _Tp1 *>
    constexpr _Iter operator()(_Iter __first, _Sent __last,
                               const _Tp1 &__old_value, const _Tp2 &__new_value,
                               _Proj __proj = {}) const {
      for (; __first != __last; ++__first)
        if (std::__invoke(__proj, *__first) == __old_value)
          *__first = __new_value;
      return __first;
    }

    template <input_range _Range, typename _Tp1, typename _Tp2,
              typename _Proj = identity>
      requires indirectly_writable<iterator_t<_Range>, const _Tp2 &> &&
               indirect_binary_predicate<ranges::equal_to,
                                         projected<iterator_t<_Range>, _Proj>,
                                         const _Tp1 *>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r, const _Tp1 &__old_value, const _Tp2 &__new_value,
               _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), __old_value,
                     __new_value, std::move(__proj));
    }
  };

  inline constexpr __replace_fn replace{};

  struct __replace_if_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,
              typename _Proj = identity,
              indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
      requires indirectly_writable<_Iter, const _Tp &>
    constexpr _Iter operator()(_Iter __first, _Sent __last, _Pred __pred,
                               const _Tp &__new_value,
                               _Proj __proj = {}) const {
      for (; __first != __last; ++__first)
        if (std::__invoke(__pred, std::__invoke(__proj, *__first)))
          *__first = __new_value;
      return std::move(__first);
    }

    template <
        input_range _Range, typename _Tp, typename _Proj = identity,
        indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
      requires indirectly_writable<iterator_t<_Range>, const _Tp &>
    constexpr borrowed_iterator_t<_Range> operator()(_Range &&__r, _Pred __pred,
                                                     const _Tp &__new_value,
                                                     _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred),
                     __new_value, std::move(__proj));
    }
  };

  inline constexpr __replace_if_fn replace_if{};

  template <typename _Iter, typename _Out>
  using replace_copy_result = in_out_result<_Iter, _Out>;

  struct __replace_copy_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp1,
              typename _Tp2, output_iterator<const _Tp2 &> _Out,
              typename _Proj = identity>
      requires indirectly_copyable<_Iter, _Out> &&
               indirect_binary_predicate<ranges::equal_to,
                                         projected<_Iter, _Proj>, const _Tp1 *>
    constexpr replace_copy_result<_Iter, _Out>
    operator()(_Iter __first, _Sent __last, _Out __result,
               const _Tp1 &__old_value, const _Tp2 &__new_value,
               _Proj __proj = {}) const {
      for (; __first != __last; ++__first, (void)++__result)
        if (std::__invoke(__proj, *__first) == __old_value)
          *__result = __new_value;
        else
          *__result = *__first;
      return {std::move(__first), std::move(__result)};
    }

    template <input_range _Range, typename _Tp1, typename _Tp2,
              output_iterator<const _Tp2 &> _Out, typename _Proj = identity>
      requires indirectly_copyable<iterator_t<_Range>, _Out> &&
               indirect_binary_predicate<ranges::equal_to,
                                         projected<iterator_t<_Range>, _Proj>,
                                         const _Tp1 *>
    constexpr replace_copy_result<borrowed_iterator_t<_Range>, _Out>
    operator()(_Range &&__r, _Out __result, const _Tp1 &__old_value,
               const _Tp2 &__new_value, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__result),
                     __old_value, __new_value, std::move(__proj));
    }
  };

  inline constexpr __replace_copy_fn replace_copy{};

  template <typename _Iter, typename _Out>
  using replace_copy_if_result = in_out_result<_Iter, _Out>;

  struct __replace_copy_if_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,
              output_iterator<const _Tp &> _Out, typename _Proj = identity,
              indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
      requires indirectly_copyable<_Iter, _Out>
    constexpr replace_copy_if_result<_Iter, _Out>
    operator()(_Iter __first, _Sent __last, _Out __result, _Pred __pred,
               const _Tp &__new_value, _Proj __proj = {}) const {
      for (; __first != __last; ++__first, (void)++__result)
        if (std::__invoke(__pred, std::__invoke(__proj, *__first)))
          *__result = __new_value;
        else
          *__result = *__first;
      return {std::move(__first), std::move(__result)};
    }

    template <
        input_range _Range, typename _Tp, output_iterator<const _Tp &> _Out,
        typename _Proj = identity,
        indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
      requires indirectly_copyable<iterator_t<_Range>, _Out>
    constexpr replace_copy_if_result<borrowed_iterator_t<_Range>, _Out>
    operator()(_Range &&__r, _Out __result, _Pred __pred,
               const _Tp &__new_value, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__result),
                     std::move(__pred), __new_value, std::move(__proj));
    }
  };

  inline constexpr __replace_copy_if_fn replace_copy_if{};

  struct __generate_n_fn {
    template <input_or_output_iterator _Out, copy_constructible _Fp>
      requires invocable<_Fp &> &&
               indirectly_writable<_Out, invoke_result_t<_Fp &>>
    constexpr _Out operator()(_Out __first, iter_difference_t<_Out> __n,
                              _Fp __gen) const {
      for (; __n > 0; --__n, (void)++__first)
        *__first = std::__invoke(__gen);
      return __first;
    }
  };

  inline constexpr __generate_n_fn generate_n{};

  struct __generate_fn {
    template <input_or_output_iterator _Out, sentinel_for<_Out> _Sent,
              copy_constructible _Fp>
      requires invocable<_Fp &> &&
               indirectly_writable<_Out, invoke_result_t<_Fp &>>
    constexpr _Out operator()(_Out __first, _Sent __last, _Fp __gen) const {
      for (; __first != __last; ++__first)
        *__first = std::__invoke(__gen);
      return __first;
    }

    template <typename _Range, copy_constructible _Fp>
      requires invocable<_Fp &> && output_range<_Range, invoke_result_t<_Fp &>>
    constexpr borrowed_iterator_t<_Range> operator()(_Range &&__r,
                                                     _Fp __gen) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__gen));
    }
  };

  inline constexpr __generate_fn generate{};

  struct __remove_if_fn {
    template <permutable _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    constexpr subrange<_Iter> operator()(_Iter __first, _Sent __last,
                                         _Pred __pred,
                                         _Proj __proj = {}) const {
      __first = ranges::find_if(__first, __last, __pred, __proj);
      if (__first == __last)
        return {__first, __first};

      auto __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
        if (!std::__invoke(__pred, std::__invoke(__proj, *__first))) {
          *__result = std::move(*__first);
          ++__result;
        }

      return {__result, __first};
    }

    template <
        forward_range _Range, typename _Proj = identity,
        indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
      requires permutable<iterator_t<_Range>>
    constexpr borrowed_subrange_t<_Range> operator()(_Range &&__r, _Pred __pred,
                                                     _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred),
                     std::move(__proj));
    }
  };

  inline constexpr __remove_if_fn remove_if{};

  struct __remove_fn {
    template <permutable _Iter, sentinel_for<_Iter> _Sent, typename _Tp,
              typename _Proj = identity>
      requires indirect_binary_predicate<ranges::equal_to,
                                         projected<_Iter, _Proj>, const _Tp *>
    constexpr subrange<_Iter> operator()(_Iter __first, _Sent __last,
                                         const _Tp &__value,
                                         _Proj __proj = {}) const {
      auto __pred = [&](auto &&__arg) -> bool {
        return std::forward<decltype(__arg)>(__arg) == __value;
      };
      return ranges::remove_if(__first, __last, std::move(__pred),
                               std::move(__proj));
    }

    template <forward_range _Range, typename _Tp, typename _Proj = identity>
      requires permutable<iterator_t<_Range>> &&
               indirect_binary_predicate<ranges::equal_to,
                                         projected<iterator_t<_Range>, _Proj>,
                                         const _Tp *>
    constexpr borrowed_subrange_t<_Range>
    operator()(_Range &&__r, const _Tp &__value, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), __value,
                     std::move(__proj));
    }
  };

  inline constexpr __remove_fn remove{};

  template <typename _Iter, typename _Out>
  using remove_copy_if_result = in_out_result<_Iter, _Out>;

  struct __remove_copy_if_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              weakly_incrementable _Out, typename _Proj = identity,
              indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
      requires indirectly_copyable<_Iter, _Out>
    constexpr remove_copy_if_result<_Iter, _Out>
    operator()(_Iter __first, _Sent __last, _Out __result, _Pred __pred,
               _Proj __proj = {}) const {
      for (; __first != __last; ++__first)
        if (!std::__invoke(__pred, std::__invoke(__proj, *__first))) {
          *__result = *__first;
          ++__result;
        }
      return {std::move(__first), std::move(__result)};
    }

    template <
        input_range _Range, weakly_incrementable _Out,
        typename _Proj = identity,
        indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
      requires indirectly_copyable<iterator_t<_Range>, _Out>
    constexpr remove_copy_if_result<borrowed_iterator_t<_Range>, _Out>
    operator()(_Range &&__r, _Out __result, _Pred __pred,
               _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__result),
                     std::move(__pred), std::move(__proj));
    }
  };

  inline constexpr __remove_copy_if_fn remove_copy_if{};

  template <typename _Iter, typename _Out>
  using remove_copy_result = in_out_result<_Iter, _Out>;

  struct __remove_copy_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              weakly_incrementable _Out, typename _Tp,
              typename _Proj = identity>
      requires indirectly_copyable<_Iter, _Out> &&
               indirect_binary_predicate<ranges::equal_to,
                                         projected<_Iter, _Proj>, const _Tp *>
    constexpr remove_copy_result<_Iter, _Out>
    operator()(_Iter __first, _Sent __last, _Out __result, const _Tp &__value,
               _Proj __proj = {}) const {
      for (; __first != __last; ++__first)
        if (!(std::__invoke(__proj, *__first) == __value)) {
          *__result = *__first;
          ++__result;
        }
      return {std::move(__first), std::move(__result)};
    }

    template <input_range _Range, weakly_incrementable _Out, typename _Tp,
              typename _Proj = identity>
      requires indirectly_copyable<iterator_t<_Range>, _Out> &&
               indirect_binary_predicate<ranges::equal_to,
                                         projected<iterator_t<_Range>, _Proj>,
                                         const _Tp *>
    constexpr remove_copy_result<borrowed_iterator_t<_Range>, _Out>
    operator()(_Range &&__r, _Out __result, const _Tp &__value,
               _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__result),
                     __value, std::move(__proj));
    }
  };

  inline constexpr __remove_copy_fn remove_copy{};

  struct __unique_fn {
    template <permutable _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_equivalence_relation<projected<_Iter, _Proj>> _Comp =
                  ranges::equal_to>
    constexpr subrange<_Iter> operator()(_Iter __first, _Sent __last,
                                         _Comp __comp = {},
                                         _Proj __proj = {}) const {
      __first = ranges::adjacent_find(__first, __last, __comp, __proj);
      if (__first == __last)
        return {__first, __first};

      auto __dest = __first;
      ++__first;
      while (++__first != __last)
        if (!std::__invoke(__comp, std::__invoke(__proj, *__dest),
                           std::__invoke(__proj, *__first)))
          *++__dest = std::move(*__first);
      return {++__dest, __first};
    }

    template <
        forward_range _Range, typename _Proj = identity,
        indirect_equivalence_relation<projected<iterator_t<_Range>, _Proj>>
            _Comp = ranges::equal_to>
      requires permutable<iterator_t<_Range>>
    constexpr borrowed_subrange_t<_Range>
    operator()(_Range &&__r, _Comp __comp = {}, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __unique_fn unique{};

  namespace __detail {
  template <typename _Out, typename _Tp>
  concept __can_reread_output =
      input_iterator<_Out> && same_as<_Tp, iter_value_t<_Out>>;
  }

  template <typename _Iter, typename _Out>
  using unique_copy_result = in_out_result<_Iter, _Out>;

  struct __unique_copy_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              weakly_incrementable _Out, typename _Proj = identity,
              indirect_equivalence_relation<projected<_Iter, _Proj>> _Comp =
                  ranges::equal_to>
      requires indirectly_copyable<_Iter, _Out> &&
               (forward_iterator<_Iter> ||
                __detail::__can_reread_output<_Out, iter_value_t<_Iter>> ||
                indirectly_copyable_storable<_Iter, _Out>)
    constexpr unique_copy_result<_Iter, _Out>
    operator()(_Iter __first, _Sent __last, _Out __result, _Comp __comp = {},
               _Proj __proj = {}) const {
      if (__first == __last)
        return {std::move(__first), std::move(__result)};

      if constexpr (forward_iterator<_Iter>) {
        auto __next = __first;
        *__result = *__next;
        while (++__next != __last)
          if (!std::__invoke(__comp, std::__invoke(__proj, *__first),
                             std::__invoke(__proj, *__next))) {
            __first = __next;
            *++__result = *__first;
          }
        return {__next, std::move(++__result)};
      } else if constexpr (__detail::__can_reread_output<_Out,
                                                         iter_value_t<_Iter>>) {
        *__result = *__first;
        while (++__first != __last)
          if (!std::__invoke(__comp, std::__invoke(__proj, *__result),
                             std::__invoke(__proj, *__first)))
            *++__result = *__first;
        return {std::move(__first), std::move(++__result)};
      } else {
        auto __value = *__first;
        *__result = __value;
        while (++__first != __last) {
          if (!(bool)std::__invoke(__comp, std::__invoke(__proj, *__first),
                                   std::__invoke(__proj, __value))) {
            __value = *__first;
            *++__result = __value;
          }
        }
        return {std::move(__first), std::move(++__result)};
      }
    }

    template <
        input_range _Range, weakly_incrementable _Out,
        typename _Proj = identity,
        indirect_equivalence_relation<projected<iterator_t<_Range>, _Proj>>
            _Comp = ranges::equal_to>
      requires indirectly_copyable<iterator_t<_Range>, _Out> &&
               (forward_iterator<iterator_t<_Range>> ||
                __detail::__can_reread_output<_Out, range_value_t<_Range>> ||
                indirectly_copyable_storable<iterator_t<_Range>, _Out>)
    constexpr unique_copy_result<borrowed_iterator_t<_Range>, _Out>
    operator()(_Range &&__r, _Out __result, _Comp __comp = {},
               _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__result),
                     std::move(__comp), std::move(__proj));
    }
  };

  inline constexpr __unique_copy_fn unique_copy{};

  struct __reverse_fn {
    template <bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent>
      requires permutable<_Iter>
    constexpr _Iter operator()(_Iter __first, _Sent __last) const {
      auto __i = ranges::next(__first, __last);
      auto __tail = __i;

      if constexpr (random_access_iterator<_Iter>) {
        if (__first != __last) {
          --__tail;
          while (__first < __tail) {
            ranges::iter_swap(__first, __tail);
            ++__first;
            --__tail;
          }
        }
        return __i;
      } else {
        for (;;)
          if (__first == __tail || __first == --__tail)
            break;
          else {
            ranges::iter_swap(__first, __tail);
            ++__first;
          }
        return __i;
      }
    }

    template <bidirectional_range _Range>
      requires permutable<iterator_t<_Range>>
    constexpr borrowed_iterator_t<_Range> operator()(_Range &&__r) const {
      return (*this)(ranges::begin(__r), ranges::end(__r));
    }
  };

  inline constexpr __reverse_fn reverse{};

  template <typename _Iter, typename _Out>
  using reverse_copy_result = in_out_result<_Iter, _Out>;

  struct __reverse_copy_fn {
    template <bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,
              weakly_incrementable _Out>
      requires indirectly_copyable<_Iter, _Out>
    constexpr reverse_copy_result<_Iter, _Out>
    operator()(_Iter __first, _Sent __last, _Out __result) const {
      auto __i = ranges::next(__first, __last);
      auto __tail = __i;
      while (__first != __tail) {
        --__tail;
        *__result = *__tail;
        ++__result;
      }
      return {__i, std::move(__result)};
    }

    template <bidirectional_range _Range, weakly_incrementable _Out>
      requires indirectly_copyable<iterator_t<_Range>, _Out>
    constexpr reverse_copy_result<borrowed_iterator_t<_Range>, _Out>
    operator()(_Range &&__r, _Out __result) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__result));
    }
  };

  inline constexpr __reverse_copy_fn reverse_copy{};

  struct __rotate_fn {
    template <permutable _Iter, sentinel_for<_Iter> _Sent>
    constexpr subrange<_Iter> operator()(_Iter __first, _Iter __middle,
                                         _Sent __last) const {
      auto __lasti = ranges::next(__first, __last);
      if (__first == __middle)
        return {__lasti, __lasti};
      if (__last == __middle)
        return {std::move(__first), std::move(__lasti)};

      if constexpr (random_access_iterator<_Iter>) {
        auto __n = __lasti - __first;
        auto __k = __middle - __first;

        if (__k == __n - __k) {
          ranges::swap_ranges(__first, __middle, __middle, __middle + __k);
          return {std::move(__middle), std::move(__lasti)};
        }

        auto __p = __first;
        auto __ret = __first + (__lasti - __middle);

        for (;;) {
          if (__k < __n - __k) {

            if constexpr (__is_pod(iter_value_t<_Iter>))
              if (__k == 1) {
                auto __t = std::move(*__p);
                ranges::move(__p + 1, __p + __n, __p);
                *(__p + __n - 1) = std::move(__t);
                return {std::move(__ret), std::move(__lasti)};
              }
            auto __q = __p + __k;
            for (decltype(__n) __i = 0; __i < __n - __k; ++__i) {
              ranges::iter_swap(__p, __q);
              ++__p;
              ++__q;
            }
            __n %= __k;
            if (__n == 0)
              return {std::move(__ret), std::move(__lasti)};
            ranges::swap(__n, __k);
            __k = __n - __k;
          } else {
            __k = __n - __k;

            if constexpr (__is_pod(iter_value_t<_Iter>))
              if (__k == 1) {
                auto __t = std::move(*(__p + __n - 1));
                ranges::move_backward(__p, __p + __n - 1, __p + __n);
                *__p = std::move(__t);
                return {std::move(__ret), std::move(__lasti)};
              }
            auto __q = __p + __n;
            __p = __q - __k;
            for (decltype(__n) __i = 0; __i < __n - __k; ++__i) {
              --__p;
              --__q;
              ranges::iter_swap(__p, __q);
            }
            __n %= __k;
            if (__n == 0)
              return {std::move(__ret), std::move(__lasti)};
            std::swap(__n, __k);
          }
        }
      } else if constexpr (bidirectional_iterator<_Iter>) {
        auto __tail = __lasti;

        ranges::reverse(__first, __middle);
        ranges::reverse(__middle, __tail);

        while (__first != __middle && __middle != __tail) {
          ranges::iter_swap(__first, --__tail);
          ++__first;
        }

        if (__first == __middle) {
          ranges::reverse(__middle, __tail);
          return {std::move(__tail), std::move(__lasti)};
        } else {
          ranges::reverse(__first, __middle);
          return {std::move(__first), std::move(__lasti)};
        }
      } else {
        auto __first2 = __middle;
        do {
          ranges::iter_swap(__first, __first2);
          ++__first;
          ++__first2;
          if (__first == __middle)
            __middle = __first2;
        } while (__first2 != __last);

        auto __ret = __first;

        __first2 = __middle;

        while (__first2 != __last) {
          ranges::iter_swap(__first, __first2);
          ++__first;
          ++__first2;
          if (__first == __middle)
            __middle = __first2;
          else if (__first2 == __last)
            __first2 = __middle;
        }
        return {std::move(__ret), std::move(__lasti)};
      }
    }

    template <forward_range _Range>
      requires permutable<iterator_t<_Range>>
    constexpr borrowed_subrange_t<_Range>
    operator()(_Range &&__r, iterator_t<_Range> __middle) const {
      return (*this)(ranges::begin(__r), std::move(__middle), ranges::end(__r));
    }
  };

  inline constexpr __rotate_fn rotate{};

  template <typename _Iter, typename _Out>
  using rotate_copy_result = in_out_result<_Iter, _Out>;

  struct __rotate_copy_fn {
    template <forward_iterator _Iter, sentinel_for<_Iter> _Sent,
              weakly_incrementable _Out>
      requires indirectly_copyable<_Iter, _Out>
    constexpr rotate_copy_result<_Iter, _Out>
    operator()(_Iter __first, _Iter __middle, _Sent __last,
               _Out __result) const {
      auto __copy1 =
          ranges::copy(__middle, std::move(__last), std::move(__result));
      auto __copy2 = ranges::copy(std::move(__first), std::move(__middle),
                                  std::move(__copy1.out));
      return {std::move(__copy1.in), std::move(__copy2.out)};
    }

    template <forward_range _Range, weakly_incrementable _Out>
      requires indirectly_copyable<iterator_t<_Range>, _Out>
    constexpr rotate_copy_result<borrowed_iterator_t<_Range>, _Out>
    operator()(_Range &&__r, iterator_t<_Range> __middle, _Out __result) const {
      return (*this)(ranges::begin(__r), std::move(__middle), ranges::end(__r),
                     std::move(__result));
    }
  };

  inline constexpr __rotate_copy_fn rotate_copy{};

  struct __sample_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              weakly_incrementable _Out, typename _Gen>
      requires(forward_iterator<_Iter> || random_access_iterator<_Out>) &&
              indirectly_copyable<_Iter, _Out> &&
              uniform_random_bit_generator<remove_reference_t<_Gen>>
    _Out operator()(_Iter __first, _Sent __last, _Out __out,
                    iter_difference_t<_Iter> __n, _Gen &&__g) const {
      if constexpr (forward_iterator<_Iter>) {

        auto __lasti = ranges::next(__first, __last);
        return std::sample(std::move(__first), std::move(__lasti),
                           std::move(__out), __n, std::forward<_Gen>(__g));
      } else {
        using __distrib_type =
            uniform_int_distribution<iter_difference_t<_Iter>>;
        using __param_type = typename __distrib_type::param_type;
        __distrib_type __d{};
        iter_difference_t<_Iter> __sample_sz = 0;
        while (__first != __last && __sample_sz != __n) {
          __out[__sample_sz++] = *__first;
          ++__first;
        }
        for (auto __pop_sz = __sample_sz; __first != __last;
             ++__first, (void)++__pop_sz) {
          const auto __k = __d(__g, __param_type{0, __pop_sz});
          if (__k < __n)
            __out[__k] = *__first;
        }
        return __out + __sample_sz;
      }
    }

    template <input_range _Range, weakly_incrementable _Out, typename _Gen>
      requires(forward_range<_Range> || random_access_iterator<_Out>) &&
              indirectly_copyable<iterator_t<_Range>, _Out> &&
              uniform_random_bit_generator<remove_reference_t<_Gen>>
    _Out operator()(_Range &&__r, _Out __out, range_difference_t<_Range> __n,
                    _Gen &&__g) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__out),
                     __n, std::forward<_Gen>(__g));
    }
  };

  inline constexpr __sample_fn sample{};

  struct __shuffle_fn {
    template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Gen>
      requires permutable<_Iter> &&
               uniform_random_bit_generator<remove_reference_t<_Gen>>
    _Iter operator()(_Iter __first, _Sent __last, _Gen &&__g) const {
      auto __lasti = ranges::next(__first, __last);
      std::shuffle(std::move(__first), __lasti, std::forward<_Gen>(__g));
      return __lasti;
    }

    template <random_access_range _Range, typename _Gen>
      requires permutable<iterator_t<_Range>> &&
               uniform_random_bit_generator<remove_reference_t<_Gen>>
    borrowed_iterator_t<_Range> operator()(_Range &&__r, _Gen &&__g) const {
      return (*this)(ranges::begin(__r), ranges::end(__r),
                     std::forward<_Gen>(__g));
    }
  };

  inline constexpr __shuffle_fn shuffle{};

  struct __push_heap_fn {
    template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Comp = ranges::less, typename _Proj = identity>
      requires sortable<_Iter, _Comp, _Proj>
    constexpr _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {},
                               _Proj __proj = {}) const {
      auto __lasti = ranges::next(__first, __last);
      std::push_heap(__first, __lasti,
                     __detail::__make_comp_proj(__comp, __proj));
      return __lasti;
    }

    template <random_access_range _Range, typename _Comp = ranges::less,
              typename _Proj = identity>
      requires sortable<iterator_t<_Range>, _Comp, _Proj>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r, _Comp __comp = {}, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __push_heap_fn push_heap{};

  struct __pop_heap_fn {
    template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Comp = ranges::less, typename _Proj = identity>
      requires sortable<_Iter, _Comp, _Proj>
    constexpr _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {},
                               _Proj __proj = {}) const {
      auto __lasti = ranges::next(__first, __last);
      std::pop_heap(__first, __lasti,
                    __detail::__make_comp_proj(__comp, __proj));
      return __lasti;
    }

    template <random_access_range _Range, typename _Comp = ranges::less,
              typename _Proj = identity>
      requires sortable<iterator_t<_Range>, _Comp, _Proj>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r, _Comp __comp = {}, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __pop_heap_fn pop_heap{};

  struct __make_heap_fn {
    template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Comp = ranges::less, typename _Proj = identity>
      requires sortable<_Iter, _Comp, _Proj>
    constexpr _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {},
                               _Proj __proj = {}) const {
      auto __lasti = ranges::next(__first, __last);
      std::make_heap(__first, __lasti,
                     __detail::__make_comp_proj(__comp, __proj));
      return __lasti;
    }

    template <random_access_range _Range, typename _Comp = ranges::less,
              typename _Proj = identity>
      requires sortable<iterator_t<_Range>, _Comp, _Proj>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r, _Comp __comp = {}, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __make_heap_fn make_heap{};

  struct __sort_heap_fn {
    template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Comp = ranges::less, typename _Proj = identity>
      requires sortable<_Iter, _Comp, _Proj>
    constexpr _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {},
                               _Proj __proj = {}) const {
      auto __lasti = ranges::next(__first, __last);
      std::sort_heap(__first, __lasti,
                     __detail::__make_comp_proj(__comp, __proj));
      return __lasti;
    }

    template <random_access_range _Range, typename _Comp = ranges::less,
              typename _Proj = identity>
      requires sortable<iterator_t<_Range>, _Comp, _Proj>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r, _Comp __comp = {}, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __sort_heap_fn sort_heap{};

  struct __is_heap_until_fn {
    template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_strict_weak_order<projected<_Iter, _Proj>> _Comp =
                  ranges::less>
    constexpr _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {},
                               _Proj __proj = {}) const {
      iter_difference_t<_Iter> __n = ranges::distance(__first, __last);
      iter_difference_t<_Iter> __parent = 0, __child = 1;
      for (; __child < __n; ++__child)
        if (std::__invoke(__comp, std::__invoke(__proj, *(__first + __parent)),
                          std::__invoke(__proj, *(__first + __child))))
          return __first + __child;
        else if ((__child & 1) == 0)
          ++__parent;

      return __first + __n;
    }

    template <random_access_range _Range, typename _Proj = identity,
              indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
                  _Comp = ranges::less>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r, _Comp __comp = {}, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __is_heap_until_fn is_heap_until{};

  struct __is_heap_fn {
    template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_strict_weak_order<projected<_Iter, _Proj>> _Comp =
                  ranges::less>
    constexpr bool operator()(_Iter __first, _Sent __last, _Comp __comp = {},
                              _Proj __proj = {}) const {
      return (__last == ranges::is_heap_until(__first, __last,
                                              std::move(__comp),
                                              std::move(__proj)));
    }

    template <random_access_range _Range, typename _Proj = identity,
              indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
                  _Comp = ranges::less>
    constexpr bool operator()(_Range &&__r, _Comp __comp = {},
                              _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __is_heap_fn is_heap{};

  struct __sort_fn {
    template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Comp = ranges::less, typename _Proj = identity>
      requires sortable<_Iter, _Comp, _Proj>
    constexpr _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {},
                               _Proj __proj = {}) const {
      auto __lasti = ranges::next(__first, __last);
      std::sort(std::move(__first), __lasti,
                __detail::__make_comp_proj(__comp, __proj));
      return __lasti;
    }

    template <random_access_range _Range, typename _Comp = ranges::less,
              typename _Proj = identity>
      requires sortable<iterator_t<_Range>, _Comp, _Proj>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r, _Comp __comp = {}, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __sort_fn sort{};

  struct __stable_sort_fn {
    template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Comp = ranges::less, typename _Proj = identity>
      requires sortable<_Iter, _Comp, _Proj>
    _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {},
                     _Proj __proj = {}) const {
      auto __lasti = ranges::next(__first, __last);
      std::stable_sort(std::move(__first), __lasti,
                       __detail::__make_comp_proj(__comp, __proj));
      return __lasti;
    }

    template <random_access_range _Range, typename _Comp = ranges::less,
              typename _Proj = identity>
      requires sortable<iterator_t<_Range>, _Comp, _Proj>
    borrowed_iterator_t<_Range> operator()(_Range &&__r, _Comp __comp = {},
                                           _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __stable_sort_fn stable_sort{};

  struct __partial_sort_fn {
    template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Comp = ranges::less, typename _Proj = identity>
      requires sortable<_Iter, _Comp, _Proj>
    constexpr _Iter operator()(_Iter __first, _Iter __middle, _Sent __last,
                               _Comp __comp = {}, _Proj __proj = {}) const {
      if (__first == __middle)
        return ranges::next(__first, __last);

      ranges::make_heap(__first, __middle, __comp, __proj);
      auto __i = __middle;
      for (; __i != __last; ++__i)
        if (std::__invoke(__comp, std::__invoke(__proj, *__i),
                          std::__invoke(__proj, *__first))) {
          ranges::pop_heap(__first, __middle, __comp, __proj);
          ranges::iter_swap(__middle - 1, __i);
          ranges::push_heap(__first, __middle, __comp, __proj);
        }
      ranges::sort_heap(__first, __middle, __comp, __proj);

      return __i;
    }

    template <random_access_range _Range, typename _Comp = ranges::less,
              typename _Proj = identity>
      requires sortable<iterator_t<_Range>, _Comp, _Proj>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r, iterator_t<_Range> __middle, _Comp __comp = {},
               _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), std::move(__middle), ranges::end(__r),
                     std::move(__comp), std::move(__proj));
    }
  };

  inline constexpr __partial_sort_fn partial_sort{};

  template <typename _Iter, typename _Out>
  using partial_sort_copy_result = in_out_result<_Iter, _Out>;

  struct __partial_sort_copy_fn {
    template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              random_access_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
              typename _Comp = ranges::less, typename _Proj1 = identity,
              typename _Proj2 = identity>
      requires indirectly_copyable<_Iter1, _Iter2> &&
               sortable<_Iter2, _Comp, _Proj2> &&
               indirect_strict_weak_order<_Comp, projected<_Iter1, _Proj1>,
                                          projected<_Iter2, _Proj2>>
    constexpr partial_sort_copy_result<_Iter1, _Iter2>
    operator()(_Iter1 __first, _Sent1 __last, _Iter2 __result_first,
               _Sent2 __result_last, _Comp __comp = {}, _Proj1 __proj1 = {},
               _Proj2 __proj2 = {}) const {
      if (__result_first == __result_last) {

        auto __lasti = ranges::next(std::move(__first), std::move(__last));
        return {std::move(__lasti), std::move(__result_first)};
      }

      auto __result_real_last = __result_first;
      while (__first != __last && __result_real_last != __result_last) {
        *__result_real_last = *__first;
        ++__result_real_last;
        ++__first;
      }

      ranges::make_heap(__result_first, __result_real_last, __comp, __proj2);
      for (; __first != __last; ++__first)
        if (std::__invoke(__comp, std::__invoke(__proj1, *__first),
                          std::__invoke(__proj2, *__result_first))) {
          ranges::pop_heap(__result_first, __result_real_last, __comp, __proj2);
          *(__result_real_last - 1) = *__first;
          ranges::push_heap(__result_first, __result_real_last, __comp,
                            __proj2);
        }
      ranges::sort_heap(__result_first, __result_real_last, __comp, __proj2);

      return {std::move(__first), std::move(__result_real_last)};
    }

    template <input_range _Range1, random_access_range _Range2,
              typename _Comp = ranges::less, typename _Proj1 = identity,
              typename _Proj2 = identity>
      requires indirectly_copyable<iterator_t<_Range1>, iterator_t<_Range2>> &&
               sortable<iterator_t<_Range2>, _Comp, _Proj2> &&
               indirect_strict_weak_order<
                   _Comp, projected<iterator_t<_Range1>, _Proj1>,
                   projected<iterator_t<_Range2>, _Proj2>>
    constexpr partial_sort_copy_result<borrowed_iterator_t<_Range1>,
                                       borrowed_iterator_t<_Range2>>
    operator()(_Range1 &&__r, _Range2 &&__out, _Comp __comp = {},
               _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), ranges::begin(__out),
                     ranges::end(__out), std::move(__comp), std::move(__proj1),
                     std::move(__proj2));
    }
  };

  inline constexpr __partial_sort_copy_fn partial_sort_copy{};

  struct __is_sorted_until_fn {
    template <forward_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_strict_weak_order<projected<_Iter, _Proj>> _Comp =
                  ranges::less>
    constexpr _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {},
                               _Proj __proj = {}) const {
      if (__first == __last)
        return __first;

      auto __next = __first;
      for (++__next; __next != __last; __first = __next, (void)++__next)
        if (std::__invoke(__comp, std::__invoke(__proj, *__next),
                          std::__invoke(__proj, *__first)))
          return __next;
      return __next;
    }

    template <forward_range _Range, typename _Proj = identity,
              indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
                  _Comp = ranges::less>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r, _Comp __comp = {}, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __is_sorted_until_fn is_sorted_until{};

  struct __is_sorted_fn {
    template <forward_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_strict_weak_order<projected<_Iter, _Proj>> _Comp =
                  ranges::less>
    constexpr bool operator()(_Iter __first, _Sent __last, _Comp __comp = {},
                              _Proj __proj = {}) const {
      if (__first == __last)
        return true;

      auto __next = __first;
      for (++__next; __next != __last; __first = __next, (void)++__next)
        if (std::__invoke(__comp, std::__invoke(__proj, *__next),
                          std::__invoke(__proj, *__first)))
          return false;
      return true;
    }

    template <forward_range _Range, typename _Proj = identity,
              indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
                  _Comp = ranges::less>
    constexpr bool operator()(_Range &&__r, _Comp __comp = {},
                              _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __is_sorted_fn is_sorted{};

  struct __nth_element_fn {
    template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Comp = ranges::less, typename _Proj = identity>
      requires sortable<_Iter, _Comp, _Proj>
    constexpr _Iter operator()(_Iter __first, _Iter __nth, _Sent __last,
                               _Comp __comp = {}, _Proj __proj = {}) const {
      auto __lasti = ranges::next(__first, __last);
      std::nth_element(std::move(__first), std::move(__nth), __lasti,
                       __detail::__make_comp_proj(__comp, __proj));
      return __lasti;
    }

    template <random_access_range _Range, typename _Comp = ranges::less,
              typename _Proj = identity>
      requires sortable<iterator_t<_Range>, _Comp, _Proj>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r, iterator_t<_Range> __nth, _Comp __comp = {},
               _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), std::move(__nth), ranges::end(__r),
                     std::move(__comp), std::move(__proj));
    }
  };

  inline constexpr __nth_element_fn nth_element{};

  struct __lower_bound_fn {
    template <forward_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,
              typename _Proj = identity,
              indirect_strict_weak_order<const _Tp *, projected<_Iter, _Proj>>
                  _Comp = ranges::less>
    constexpr _Iter operator()(_Iter __first, _Sent __last, const _Tp &__value,
                               _Comp __comp = {}, _Proj __proj = {}) const {
      auto __len = ranges::distance(__first, __last);

      while (__len > 0) {
        auto __half = __len / 2;
        auto __middle = __first;
        ranges::advance(__middle, __half);
        if (std::__invoke(__comp, std::__invoke(__proj, *__middle), __value)) {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        } else
          __len = __half;
      }
      return __first;
    }

    template <forward_range _Range, typename _Tp, typename _Proj = identity,
              indirect_strict_weak_order<const _Tp *,
                                         projected<iterator_t<_Range>, _Proj>>
                  _Comp = ranges::less>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r, const _Tp &__value, _Comp __comp = {},
               _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), __value,
                     std::move(__comp), std::move(__proj));
    }
  };

  inline constexpr __lower_bound_fn lower_bound{};

  struct __upper_bound_fn {
    template <forward_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,
              typename _Proj = identity,
              indirect_strict_weak_order<const _Tp *, projected<_Iter, _Proj>>
                  _Comp = ranges::less>
    constexpr _Iter operator()(_Iter __first, _Sent __last, const _Tp &__value,
                               _Comp __comp = {}, _Proj __proj = {}) const {
      auto __len = ranges::distance(__first, __last);

      while (__len > 0) {
        auto __half = __len / 2;
        auto __middle = __first;
        ranges::advance(__middle, __half);
        if (std::__invoke(__comp, __value, std::__invoke(__proj, *__middle)))
          __len = __half;
        else {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
      }
      return __first;
    }

    template <forward_range _Range, typename _Tp, typename _Proj = identity,
              indirect_strict_weak_order<const _Tp *,
                                         projected<iterator_t<_Range>, _Proj>>
                  _Comp = ranges::less>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r, const _Tp &__value, _Comp __comp = {},
               _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), __value,
                     std::move(__comp), std::move(__proj));
    }
  };

  inline constexpr __upper_bound_fn upper_bound{};

  struct __equal_range_fn {
    template <forward_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,
              typename _Proj = identity,
              indirect_strict_weak_order<const _Tp *, projected<_Iter, _Proj>>
                  _Comp = ranges::less>
    constexpr subrange<_Iter> operator()(_Iter __first, _Sent __last,
                                         const _Tp &__value, _Comp __comp = {},
                                         _Proj __proj = {}) const {
      auto __len = ranges::distance(__first, __last);

      while (__len > 0) {
        auto __half = __len / 2;
        auto __middle = __first;
        ranges::advance(__middle, __half);
        if (std::__invoke(__comp, std::__invoke(__proj, *__middle), __value)) {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        } else if (std::__invoke(__comp, __value,
                                 std::__invoke(__proj, *__middle)))
          __len = __half;
        else {
          auto __left =
              ranges::lower_bound(__first, __middle, __value, __comp, __proj);
          ranges::advance(__first, __len);
          auto __right =
              ranges::upper_bound(++__middle, __first, __value, __comp, __proj);
          return {__left, __right};
        }
      }
      return {__first, __first};
    }

    template <forward_range _Range, typename _Tp, typename _Proj = identity,
              indirect_strict_weak_order<const _Tp *,
                                         projected<iterator_t<_Range>, _Proj>>
                  _Comp = ranges::less>
    constexpr borrowed_subrange_t<_Range>
    operator()(_Range &&__r, const _Tp &__value, _Comp __comp = {},
               _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), __value,
                     std::move(__comp), std::move(__proj));
    }
  };

  inline constexpr __equal_range_fn equal_range{};

  struct __binary_search_fn {
    template <forward_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,
              typename _Proj = identity,
              indirect_strict_weak_order<const _Tp *, projected<_Iter, _Proj>>
                  _Comp = ranges::less>
    constexpr bool operator()(_Iter __first, _Sent __last, const _Tp &__value,
                              _Comp __comp = {}, _Proj __proj = {}) const {
      auto __i = ranges::lower_bound(__first, __last, __value, __comp, __proj);
      if (__i == __last)
        return false;
      return !(bool)std::__invoke(__comp, __value, std::__invoke(__proj, *__i));
    }

    template <forward_range _Range, typename _Tp, typename _Proj = identity,
              indirect_strict_weak_order<const _Tp *,
                                         projected<iterator_t<_Range>, _Proj>>
                  _Comp = ranges::less>
    constexpr bool operator()(_Range &&__r, const _Tp &__value,
                              _Comp __comp = {}, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), __value,
                     std::move(__comp), std::move(__proj));
    }
  };

  inline constexpr __binary_search_fn binary_search{};

  struct __is_partitioned_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    constexpr bool operator()(_Iter __first, _Sent __last, _Pred __pred,
                              _Proj __proj = {}) const {
      __first = ranges::find_if_not(std::move(__first), __last, __pred, __proj);
      if (__first == __last)
        return true;
      ++__first;
      return ranges::none_of(std::move(__first), std::move(__last),
                             std::move(__pred), std::move(__proj));
    }

    template <
        input_range _Range, typename _Proj = identity,
        indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    constexpr bool operator()(_Range &&__r, _Pred __pred,
                              _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred),
                     std::move(__proj));
    }
  };

  inline constexpr __is_partitioned_fn is_partitioned{};

  struct __partition_fn {
    template <permutable _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    constexpr subrange<_Iter> operator()(_Iter __first, _Sent __last,
                                         _Pred __pred,
                                         _Proj __proj = {}) const {
      if constexpr (bidirectional_iterator<_Iter>) {
        auto __lasti = ranges::next(__first, __last);
        auto __tail = __lasti;
        for (;;) {
          for (;;)
            if (__first == __tail)
              return {std::move(__first), std::move(__lasti)};
            else if (std::__invoke(__pred, std::__invoke(__proj, *__first)))
              ++__first;
            else
              break;
          --__tail;
          for (;;)
            if (__first == __tail)
              return {std::move(__first), std::move(__lasti)};
            else if (!(bool)std::__invoke(__pred,
                                          std::__invoke(__proj, *__tail)))
              --__tail;
            else
              break;
          ranges::iter_swap(__first, __tail);
          ++__first;
        }
      } else {
        if (__first == __last)
          return {__first, __first};

        while (std::__invoke(__pred, std::__invoke(__proj, *__first)))
          if (++__first == __last)
            return {__first, __first};

        auto __next = __first;
        while (++__next != __last)
          if (std::__invoke(__pred, std::__invoke(__proj, *__next))) {
            ranges::iter_swap(__first, __next);
            ++__first;
          }

        return {std::move(__first), std::move(__next)};
      }
    }

    template <
        forward_range _Range, typename _Proj = identity,
        indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
      requires permutable<iterator_t<_Range>>
    constexpr borrowed_subrange_t<_Range> operator()(_Range &&__r, _Pred __pred,
                                                     _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred),
                     std::move(__proj));
    }
  };

  inline constexpr __partition_fn partition{};

  struct __stable_partition_fn {
    template <bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
      requires permutable<_Iter>
    subrange<_Iter> operator()(_Iter __first, _Sent __last, _Pred __pred,
                               _Proj __proj = {}) const {
      auto __lasti = ranges::next(__first, __last);
      auto __middle =
          std::stable_partition(std::move(__first), __lasti,
                                __detail::__make_pred_proj(__pred, __proj));
      return {std::move(__middle), std::move(__lasti)};
    }

    template <
        bidirectional_range _Range, typename _Proj = identity,
        indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
      requires permutable<iterator_t<_Range>>
    borrowed_subrange_t<_Range> operator()(_Range &&__r, _Pred __pred,
                                           _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred),
                     std::move(__proj));
    }
  };

  inline constexpr __stable_partition_fn stable_partition{};

  template <typename _Iter, typename _Out1, typename _Out2>
  struct in_out_out_result {
    [[no_unique_address]] _Iter in;
    [[no_unique_address]] _Out1 out1;
    [[no_unique_address]] _Out2 out2;

    template <typename _IIter, typename _OOut1, typename _OOut2>
      requires convertible_to<const _Iter &, _IIter> &&
               convertible_to<const _Out1 &, _OOut1> &&
               convertible_to<const _Out2 &, _OOut2>
    constexpr operator in_out_out_result<_IIter, _OOut1, _OOut2>() const & {
      return {in, out1, out2};
    }

    template <typename _IIter, typename _OOut1, typename _OOut2>
      requires convertible_to<_Iter, _IIter> && convertible_to<_Out1, _OOut1> &&
               convertible_to<_Out2, _OOut2>
    constexpr operator in_out_out_result<_IIter, _OOut1, _OOut2>() && {
      return {std::move(in), std::move(out1), std::move(out2)};
    }
  };

  template <typename _Iter, typename _Out1, typename _Out2>
  using partition_copy_result = in_out_out_result<_Iter, _Out1, _Out2>;

  struct __partition_copy_fn {
    template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
              weakly_incrementable _Out1, weakly_incrementable _Out2,
              typename _Proj = identity,
              indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
      requires indirectly_copyable<_Iter, _Out1> &&
               indirectly_copyable<_Iter, _Out2>
    constexpr partition_copy_result<_Iter, _Out1, _Out2>
    operator()(_Iter __first, _Sent __last, _Out1 __out_true, _Out2 __out_false,
               _Pred __pred, _Proj __proj = {}) const {
      for (; __first != __last; ++__first)
        if (std::__invoke(__pred, std::__invoke(__proj, *__first))) {
          *__out_true = *__first;
          ++__out_true;
        } else {
          *__out_false = *__first;
          ++__out_false;
        }

      return {std::move(__first), std::move(__out_true),
              std::move(__out_false)};
    }

    template <
        input_range _Range, weakly_incrementable _Out1,
        weakly_incrementable _Out2, typename _Proj = identity,
        indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
      requires indirectly_copyable<iterator_t<_Range>, _Out1> &&
               indirectly_copyable<iterator_t<_Range>, _Out2>
    constexpr partition_copy_result<borrowed_iterator_t<_Range>, _Out1, _Out2>
    operator()(_Range &&__r, _Out1 __out_true, _Out2 __out_false, _Pred __pred,
               _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r),
                     std::move(__out_true), std::move(__out_false),
                     std::move(__pred), std::move(__proj));
    }
  };

  inline constexpr __partition_copy_fn partition_copy{};

  struct __partition_point_fn {
    template <forward_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    constexpr _Iter operator()(_Iter __first, _Sent __last, _Pred __pred,
                               _Proj __proj = {}) const {
      auto __len = ranges::distance(__first, __last);

      while (__len > 0) {
        auto __half = __len / 2;
        auto __middle = __first;
        ranges::advance(__middle, __half);
        if (std::__invoke(__pred, std::__invoke(__proj, *__middle))) {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        } else
          __len = __half;
      }
      return __first;
    }

    template <
        forward_range _Range, typename _Proj = identity,
        indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    constexpr borrowed_iterator_t<_Range> operator()(_Range &&__r, _Pred __pred,
                                                     _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__pred),
                     std::move(__proj));
    }
  };

  inline constexpr __partition_point_fn partition_point{};

  template <typename _Iter1, typename _Iter2, typename _Out>
  using merge_result = in_in_out_result<_Iter1, _Iter2, _Out>;

  struct __merge_fn {
    template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
              weakly_incrementable _Out, typename _Comp = ranges::less,
              typename _Proj1 = identity, typename _Proj2 = identity>
      requires mergeable<_Iter1, _Iter2, _Out, _Comp, _Proj1, _Proj2>
    constexpr merge_result<_Iter1, _Iter2, _Out>
    operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
               _Out __result, _Comp __comp = {}, _Proj1 __proj1 = {},
               _Proj2 __proj2 = {}) const {
      while (__first1 != __last1 && __first2 != __last2) {
        if (std::__invoke(__comp, std::__invoke(__proj2, *__first2),
                          std::__invoke(__proj1, *__first1))) {
          *__result = *__first2;
          ++__first2;
        } else {
          *__result = *__first1;
          ++__first1;
        }
        ++__result;
      }
      auto __copy1 = ranges::copy(std::move(__first1), std::move(__last1),
                                  std::move(__result));
      auto __copy2 = ranges::copy(std::move(__first2), std::move(__last2),
                                  std::move(__copy1.out));
      return {std::move(__copy1.in), std::move(__copy2.in),
              std::move(__copy2.out)};
    }

    template <input_range _Range1, input_range _Range2,
              weakly_incrementable _Out, typename _Comp = ranges::less,
              typename _Proj1 = identity, typename _Proj2 = identity>
      requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _Out, _Comp,
                         _Proj1, _Proj2>
    constexpr merge_result<borrowed_iterator_t<_Range1>,
                           borrowed_iterator_t<_Range2>, _Out>
    operator()(_Range1 &&__r1, _Range2 &&__r2, _Out __result, _Comp __comp = {},
               _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      return (*this)(ranges::begin(__r1), ranges::end(__r1),
                     ranges::begin(__r2), ranges::end(__r2),
                     std::move(__result), std::move(__comp), std::move(__proj1),
                     std::move(__proj2));
    }
  };

  inline constexpr __merge_fn merge{};

  struct __inplace_merge_fn {
    template <bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Comp = ranges::less, typename _Proj = identity>
      requires sortable<_Iter, _Comp, _Proj>
    _Iter operator()(_Iter __first, _Iter __middle, _Sent __last,
                     _Comp __comp = {}, _Proj __proj = {}) const {
      auto __lasti = ranges::next(__first, __last);
      std::inplace_merge(std::move(__first), std::move(__middle), __lasti,
                         __detail::__make_comp_proj(__comp, __proj));
      return __lasti;
    }

    template <bidirectional_range _Range, typename _Comp = ranges::less,
              typename _Proj = identity>
      requires sortable<iterator_t<_Range>, _Comp, _Proj>
    borrowed_iterator_t<_Range>
    operator()(_Range &&__r, iterator_t<_Range> __middle, _Comp __comp = {},
               _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), std::move(__middle), ranges::end(__r),
                     std::move(__comp), std::move(__proj));
    }
  };

  inline constexpr __inplace_merge_fn inplace_merge{};

  struct __includes_fn {
    template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
              typename _Proj1 = identity, typename _Proj2 = identity,
              indirect_strict_weak_order<projected<_Iter1, _Proj1>,
                                         projected<_Iter2, _Proj2>>
                  _Comp = ranges::less>
    constexpr bool operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2,
                              _Sent2 __last2, _Comp __comp = {},
                              _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      while (__first1 != __last1 && __first2 != __last2)
        if (std::__invoke(__comp, std::__invoke(__proj2, *__first2),
                          std::__invoke(__proj1, *__first1)))
          return false;
        else if (std::__invoke(__comp, std::__invoke(__proj1, *__first1),
                               std::__invoke(__proj2, *__first2)))
          ++__first1;
        else {
          ++__first1;
          ++__first2;
        }

      return __first2 == __last2;
    }

    template <input_range _Range1, input_range _Range2,
              typename _Proj1 = identity, typename _Proj2 = identity,
              indirect_strict_weak_order<projected<iterator_t<_Range1>, _Proj1>,
                                         projected<iterator_t<_Range2>, _Proj2>>
                  _Comp = ranges::less>
    constexpr bool operator()(_Range1 &&__r1, _Range2 &&__r2, _Comp __comp = {},
                              _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      return (*this)(ranges::begin(__r1), ranges::end(__r1),
                     ranges::begin(__r2), ranges::end(__r2), std::move(__comp),
                     std::move(__proj1), std::move(__proj2));
    }
  };

  inline constexpr __includes_fn includes{};

  template <typename _Iter1, typename _Iter2, typename _Out>
  using set_union_result = in_in_out_result<_Iter1, _Iter2, _Out>;

  struct __set_union_fn {
    template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
              weakly_incrementable _Out, typename _Comp = ranges::less,
              typename _Proj1 = identity, typename _Proj2 = identity>
      requires mergeable<_Iter1, _Iter2, _Out, _Comp, _Proj1, _Proj2>
    constexpr set_union_result<_Iter1, _Iter2, _Out>
    operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
               _Out __result, _Comp __comp = {}, _Proj1 __proj1 = {},
               _Proj2 __proj2 = {}) const {
      while (__first1 != __last1 && __first2 != __last2) {
        if (std::__invoke(__comp, std::__invoke(__proj1, *__first1),
                          std::__invoke(__proj2, *__first2))) {
          *__result = *__first1;
          ++__first1;
        } else if (std::__invoke(__comp, std::__invoke(__proj2, *__first2),
                                 std::__invoke(__proj1, *__first1))) {
          *__result = *__first2;
          ++__first2;
        } else {
          *__result = *__first1;
          ++__first1;
          ++__first2;
        }
        ++__result;
      }
      auto __copy1 = ranges::copy(std::move(__first1), std::move(__last1),
                                  std::move(__result));
      auto __copy2 = ranges::copy(std::move(__first2), std::move(__last2),
                                  std::move(__copy1.out));
      return {std::move(__copy1.in), std::move(__copy2.in),
              std::move(__copy2.out)};
    }

    template <input_range _Range1, input_range _Range2,
              weakly_incrementable _Out, typename _Comp = ranges::less,
              typename _Proj1 = identity, typename _Proj2 = identity>
      requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _Out, _Comp,
                         _Proj1, _Proj2>
    constexpr set_union_result<borrowed_iterator_t<_Range1>,
                               borrowed_iterator_t<_Range2>, _Out>
    operator()(_Range1 &&__r1, _Range2 &&__r2, _Out __result, _Comp __comp = {},
               _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      return (*this)(ranges::begin(__r1), ranges::end(__r1),
                     ranges::begin(__r2), ranges::end(__r2),
                     std::move(__result), std::move(__comp), std::move(__proj1),
                     std::move(__proj2));
    }
  };

  inline constexpr __set_union_fn set_union{};

  template <typename _Iter1, typename _Iter2, typename _Out>
  using set_intersection_result = in_in_out_result<_Iter1, _Iter2, _Out>;

  struct __set_intersection_fn {
    template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
              weakly_incrementable _Out, typename _Comp = ranges::less,
              typename _Proj1 = identity, typename _Proj2 = identity>
      requires mergeable<_Iter1, _Iter2, _Out, _Comp, _Proj1, _Proj2>
    constexpr set_intersection_result<_Iter1, _Iter2, _Out>
    operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
               _Out __result, _Comp __comp = {}, _Proj1 __proj1 = {},
               _Proj2 __proj2 = {}) const {
      while (__first1 != __last1 && __first2 != __last2)
        if (std::__invoke(__comp, std::__invoke(__proj1, *__first1),
                          std::__invoke(__proj2, *__first2)))
          ++__first1;
        else if (std::__invoke(__comp, std::__invoke(__proj2, *__first2),
                               std::__invoke(__proj1, *__first1)))
          ++__first2;
        else {
          *__result = *__first1;
          ++__first1;
          ++__first2;
          ++__result;
        }

      auto __last1i = ranges::next(std::move(__first1), std::move(__last1));
      auto __last2i = ranges::next(std::move(__first2), std::move(__last2));
      return {std::move(__last1i), std::move(__last2i), std::move(__result)};
    }

    template <input_range _Range1, input_range _Range2,
              weakly_incrementable _Out, typename _Comp = ranges::less,
              typename _Proj1 = identity, typename _Proj2 = identity>
      requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _Out, _Comp,
                         _Proj1, _Proj2>
    constexpr set_intersection_result<borrowed_iterator_t<_Range1>,
                                      borrowed_iterator_t<_Range2>, _Out>
    operator()(_Range1 &&__r1, _Range2 &&__r2, _Out __result, _Comp __comp = {},
               _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      return (*this)(ranges::begin(__r1), ranges::end(__r1),
                     ranges::begin(__r2), ranges::end(__r2),
                     std::move(__result), std::move(__comp), std::move(__proj1),
                     std::move(__proj2));
    }
  };

  inline constexpr __set_intersection_fn set_intersection{};

  template <typename _Iter, typename _Out>
  using set_difference_result = in_out_result<_Iter, _Out>;

  struct __set_difference_fn {
    template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
              weakly_incrementable _Out, typename _Comp = ranges::less,
              typename _Proj1 = identity, typename _Proj2 = identity>
      requires mergeable<_Iter1, _Iter2, _Out, _Comp, _Proj1, _Proj2>
    constexpr set_difference_result<_Iter1, _Out>
    operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
               _Out __result, _Comp __comp = {}, _Proj1 __proj1 = {},
               _Proj2 __proj2 = {}) const {
      while (__first1 != __last1 && __first2 != __last2)
        if (std::__invoke(__comp, std::__invoke(__proj1, *__first1),
                          std::__invoke(__proj2, *__first2))) {
          *__result = *__first1;
          ++__first1;
          ++__result;
        } else if (std::__invoke(__comp, std::__invoke(__proj2, *__first2),
                                 std::__invoke(__proj1, *__first1)))
          ++__first2;
        else {
          ++__first1;
          ++__first2;
        }
      return ranges::copy(std::move(__first1), std::move(__last1),
                          std::move(__result));
    }

    template <input_range _Range1, input_range _Range2,
              weakly_incrementable _Out, typename _Comp = ranges::less,
              typename _Proj1 = identity, typename _Proj2 = identity>
      requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _Out, _Comp,
                         _Proj1, _Proj2>
    constexpr set_difference_result<borrowed_iterator_t<_Range1>, _Out>
    operator()(_Range1 &&__r1, _Range2 &&__r2, _Out __result, _Comp __comp = {},
               _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      return (*this)(ranges::begin(__r1), ranges::end(__r1),
                     ranges::begin(__r2), ranges::end(__r2),
                     std::move(__result), std::move(__comp), std::move(__proj1),
                     std::move(__proj2));
    }
  };

  inline constexpr __set_difference_fn set_difference{};

  template <typename _Iter1, typename _Iter2, typename _Out>
  using set_symmetric_difference_result =
      in_in_out_result<_Iter1, _Iter2, _Out>;

  struct __set_symmetric_difference_fn {
    template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
              weakly_incrementable _Out, typename _Comp = ranges::less,
              typename _Proj1 = identity, typename _Proj2 = identity>
      requires mergeable<_Iter1, _Iter2, _Out, _Comp, _Proj1, _Proj2>
    constexpr set_symmetric_difference_result<_Iter1, _Iter2, _Out>
    operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
               _Out __result, _Comp __comp = {}, _Proj1 __proj1 = {},
               _Proj2 __proj2 = {}) const {
      while (__first1 != __last1 && __first2 != __last2)
        if (std::__invoke(__comp, std::__invoke(__proj1, *__first1),
                          std::__invoke(__proj2, *__first2))) {
          *__result = *__first1;
          ++__first1;
          ++__result;
        } else if (std::__invoke(__comp, std::__invoke(__proj2, *__first2),
                                 std::__invoke(__proj1, *__first1))) {
          *__result = *__first2;
          ++__first2;
          ++__result;
        } else {
          ++__first1;
          ++__first2;
        }
      auto __copy1 = ranges::copy(std::move(__first1), std::move(__last1),
                                  std::move(__result));
      auto __copy2 = ranges::copy(std::move(__first2), std::move(__last2),
                                  std::move(__copy1.out));
      return {std::move(__copy1.in), std::move(__copy2.in),
              std::move(__copy2.out)};
    }

    template <input_range _Range1, input_range _Range2,
              weakly_incrementable _Out, typename _Comp = ranges::less,
              typename _Proj1 = identity, typename _Proj2 = identity>
      requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _Out, _Comp,
                         _Proj1, _Proj2>
    constexpr set_symmetric_difference_result<
        borrowed_iterator_t<_Range1>, borrowed_iterator_t<_Range2>, _Out>
    operator()(_Range1 &&__r1, _Range2 &&__r2, _Out __result, _Comp __comp = {},
               _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      return (*this)(ranges::begin(__r1), ranges::end(__r1),
                     ranges::begin(__r2), ranges::end(__r2),
                     std::move(__result), std::move(__comp), std::move(__proj1),
                     std::move(__proj2));
    }
  };

  inline constexpr __set_symmetric_difference_fn set_symmetric_difference{};

  struct __max_fn {
    template <typename _Tp, typename _Proj = identity,
              indirect_strict_weak_order<projected<const _Tp *, _Proj>> _Comp =
                  ranges::less>
    constexpr const _Tp &operator()(const _Tp &__a, const _Tp &__b,
                                    _Comp __comp = {},
                                    _Proj __proj = {}) const {
      if (std::__invoke(__comp, std::__invoke(__proj, __a),
                        std::__invoke(__proj, __b)))
        return __b;
      else
        return __a;
    }

    template <input_range _Range, typename _Proj = identity,
              indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
                  _Comp = ranges::less>
      requires indirectly_copyable_storable<iterator_t<_Range>,
                                            range_value_t<_Range> *>
    constexpr range_value_t<_Range> operator()(_Range &&__r, _Comp __comp = {},
                                               _Proj __proj = {}) const {
      auto __first = ranges::begin(__r);
      auto __last = ranges::end(__r);
      do {
        if (std::__is_constant_evaluated() && !bool(__first != __last))
          __builtin_unreachable();
      } while (false);
      auto __result = *__first;
      while (++__first != __last) {
        auto __tmp = *__first;
        if (std::__invoke(__comp, std::__invoke(__proj, __result),
                          std::__invoke(__proj, __tmp)))
          __result = std::move(__tmp);
      }
      return __result;
    }

    template <copyable _Tp, typename _Proj = identity,
              indirect_strict_weak_order<projected<const _Tp *, _Proj>> _Comp =
                  ranges::less>
    constexpr _Tp operator()(initializer_list<_Tp> __r, _Comp __comp = {},
                             _Proj __proj = {}) const {
      return (*this)(ranges::subrange(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __max_fn max{};

  struct __clamp_fn {
    template <typename _Tp, typename _Proj = identity,
              indirect_strict_weak_order<projected<const _Tp *, _Proj>> _Comp =
                  ranges::less>
    constexpr const _Tp &operator()(const _Tp &__val, const _Tp &__lo,
                                    const _Tp &__hi, _Comp __comp = {},
                                    _Proj __proj = {}) const {
      do {
        if (std::__is_constant_evaluated() &&
            !bool(!(std::__invoke(__comp, std::__invoke(__proj, __hi),
                                  std::__invoke(__proj, __lo)))))
          __builtin_unreachable();
      } while (false);

      auto &&__proj_val = std::__invoke(__proj, __val);
      if (std::__invoke(__comp, __proj_val, std::__invoke(__proj, __lo)))
        return __lo;
      else if (std::__invoke(__comp, std::__invoke(__proj, __hi), __proj_val))
        return __hi;
      else
        return __val;
    }
  };

  inline constexpr __clamp_fn clamp{};

  template <typename _Tp> struct min_max_result {
    [[no_unique_address]] _Tp min;
    [[no_unique_address]] _Tp max;

    template <typename _Tp2>
      requires convertible_to<const _Tp &, _Tp2>
    constexpr operator min_max_result<_Tp2>() const & {
      return {min, max};
    }

    template <typename _Tp2>
      requires convertible_to<_Tp, _Tp2>
    constexpr operator min_max_result<_Tp2>() && {
      return {std::move(min), std::move(max)};
    }
  };

  template <typename _Tp> using minmax_result = min_max_result<_Tp>;

  struct __minmax_fn {
    template <typename _Tp, typename _Proj = identity,
              indirect_strict_weak_order<projected<const _Tp *, _Proj>> _Comp =
                  ranges::less>
    constexpr minmax_result<const _Tp &>
    operator()(const _Tp &__a, const _Tp &__b, _Comp __comp = {},
               _Proj __proj = {}) const {
      if (std::__invoke(__comp, std::__invoke(__proj, __b),
                        std::__invoke(__proj, __a)))
        return {__b, __a};
      else
        return {__a, __b};
    }

    template <input_range _Range, typename _Proj = identity,
              indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
                  _Comp = ranges::less>
      requires indirectly_copyable_storable<iterator_t<_Range>,
                                            range_value_t<_Range> *>
    constexpr minmax_result<range_value_t<_Range>>
    operator()(_Range &&__r, _Comp __comp = {}, _Proj __proj = {}) const {
      auto __first = ranges::begin(__r);
      auto __last = ranges::end(__r);
      do {
        if (std::__is_constant_evaluated() && !bool(__first != __last))
          __builtin_unreachable();
      } while (false);
      auto __comp_proj = __detail::__make_comp_proj(__comp, __proj);
      minmax_result<range_value_t<_Range>> __result = {*__first, __result.min};
      if (++__first == __last)
        return __result;
      else {

        auto &&__val = *__first;
        if (__comp_proj(__val, __result.min))
          __result.min = std::forward<decltype(__val)>(__val);
        else
          __result.max = std::forward<decltype(__val)>(__val);
      }
      while (++__first != __last) {

        range_value_t<_Range> __val1 = *__first;
        if (++__first == __last) {

          if (__comp_proj(__val1, __result.min))
            __result.min = std::move(__val1);
          else if (!__comp_proj(__val1, __result.max))
            __result.max = std::move(__val1);
          break;
        }
        auto &&__val2 = *__first;
        if (!__comp_proj(__val2, __val1)) {
          if (__comp_proj(__val1, __result.min))
            __result.min = std::move(__val1);
          if (!__comp_proj(__val2, __result.max))
            __result.max = std::forward<decltype(__val2)>(__val2);
        } else {
          if (__comp_proj(__val2, __result.min))
            __result.min = std::forward<decltype(__val2)>(__val2);
          if (!__comp_proj(__val1, __result.max))
            __result.max = std::move(__val1);
        }
      }
      return __result;
    }

    template <copyable _Tp, typename _Proj = identity,
              indirect_strict_weak_order<projected<const _Tp *, _Proj>> _Comp =
                  ranges::less>
    constexpr minmax_result<_Tp> operator()(initializer_list<_Tp> __r,
                                            _Comp __comp = {},
                                            _Proj __proj = {}) const {
      return (*this)(ranges::subrange(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __minmax_fn minmax{};

  struct __min_element_fn {
    template <forward_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_strict_weak_order<projected<_Iter, _Proj>> _Comp =
                  ranges::less>
    constexpr _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {},
                               _Proj __proj = {}) const {
      if (__first == __last)
        return __first;

      auto __i = __first;
      while (++__i != __last) {
        if (std::__invoke(__comp, std::__invoke(__proj, *__i),
                          std::__invoke(__proj, *__first)))
          __first = __i;
      }
      return __first;
    }

    template <forward_range _Range, typename _Proj = identity,
              indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
                  _Comp = ranges::less>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r, _Comp __comp = {}, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __min_element_fn min_element{};

  struct __max_element_fn {
    template <forward_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_strict_weak_order<projected<_Iter, _Proj>> _Comp =
                  ranges::less>
    constexpr _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {},
                               _Proj __proj = {}) const {
      if (__first == __last)
        return __first;

      auto __i = __first;
      while (++__i != __last) {
        if (std::__invoke(__comp, std::__invoke(__proj, *__first),
                          std::__invoke(__proj, *__i)))
          __first = __i;
      }
      return __first;
    }

    template <forward_range _Range, typename _Proj = identity,
              indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
                  _Comp = ranges::less>
    constexpr borrowed_iterator_t<_Range>
    operator()(_Range &&__r, _Comp __comp = {}, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __max_element_fn max_element{};

  template <typename _Iter> using minmax_element_result = min_max_result<_Iter>;

  struct __minmax_element_fn {
    template <forward_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Proj = identity,
              indirect_strict_weak_order<projected<_Iter, _Proj>> _Comp =
                  ranges::less>
    constexpr minmax_element_result<_Iter>
    operator()(_Iter __first, _Sent __last, _Comp __comp = {},
               _Proj __proj = {}) const {
      auto __comp_proj = __detail::__make_comp_proj(__comp, __proj);
      minmax_element_result<_Iter> __result = {__first, __first};
      if (__first == __last || ++__first == __last)
        return __result;
      else {

        if (__comp_proj(*__first, *__result.min))
          __result.min = __first;
        else
          __result.max = __first;
      }
      while (++__first != __last) {

        auto __prev = __first;
        if (++__first == __last) {

          if (__comp_proj(*__prev, *__result.min))
            __result.min = __prev;
          else if (!__comp_proj(*__prev, *__result.max))
            __result.max = __prev;
          break;
        }
        if (!__comp_proj(*__first, *__prev)) {
          if (__comp_proj(*__prev, *__result.min))
            __result.min = __prev;
          if (!__comp_proj(*__first, *__result.max))
            __result.max = __first;
        } else {
          if (__comp_proj(*__first, *__result.min))
            __result.min = __first;
          if (!__comp_proj(*__prev, *__result.max))
            __result.max = __prev;
        }
      }
      return __result;
    }

    template <forward_range _Range, typename _Proj = identity,
              indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
                  _Comp = ranges::less>
    constexpr minmax_element_result<borrowed_iterator_t<_Range>>
    operator()(_Range &&__r, _Comp __comp = {}, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __minmax_element_fn minmax_element{};

  struct __lexicographical_compare_fn {
    template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
              input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
              typename _Proj1 = identity, typename _Proj2 = identity,
              indirect_strict_weak_order<projected<_Iter1, _Proj1>,
                                         projected<_Iter2, _Proj2>>
                  _Comp = ranges::less>
    constexpr bool operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2,
                              _Sent2 __last2, _Comp __comp = {},
                              _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      if constexpr (__detail::__is_normal_iterator<_Iter1> &&
                    same_as<_Iter1, _Sent1>)
        return (*this)(__first1.base(), __last1.base(), std::move(__first2),
                       std::move(__last2), std::move(__comp),
                       std::move(__proj1), std::move(__proj2));
      else if constexpr (__detail::__is_normal_iterator<_Iter2> &&
                         same_as<_Iter2, _Sent2>)
        return (*this)(std::move(__first1), std::move(__last1), __first2.base(),
                       __last2.base(), std::move(__comp), std::move(__proj1),
                       std::move(__proj2));
      else {
        constexpr bool __sized_iters = (sized_sentinel_for<_Sent1, _Iter1> &&
                                        sized_sentinel_for<_Sent2, _Iter2>);
        if constexpr (__sized_iters) {
          using _ValueType1 = iter_value_t<_Iter1>;
          using _ValueType2 = iter_value_t<_Iter2>;

          constexpr bool __use_memcmp =
              (__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value &&
               __ptr_to_nonvolatile<_Iter1> && __ptr_to_nonvolatile<_Iter2> &&
               (is_same_v<_Comp, ranges::less> ||
                is_same_v<_Comp, ranges::greater>) &&
               is_same_v<_Proj1, identity> && is_same_v<_Proj2, identity>);
          if constexpr (__use_memcmp) {
            const auto __d1 = __last1 - __first1;
            const auto __d2 = __last2 - __first2;

            if (const auto __len = std::min(__d1, __d2)) {
              const auto __c = std::__memcmp(__first1, __first2, __len);
              if constexpr (is_same_v<_Comp, ranges::less>) {
                if (__c < 0)
                  return true;
                if (__c > 0)
                  return false;
              } else if constexpr (is_same_v<_Comp, ranges::greater>) {
                if (__c > 0)
                  return true;
                if (__c < 0)
                  return false;
              }
            }
            return __d1 < __d2;
          }
        }

        for (; __first1 != __last1 && __first2 != __last2;
             ++__first1, (void)++__first2) {
          if (std::__invoke(__comp, std::__invoke(__proj1, *__first1),
                            std::__invoke(__proj2, *__first2)))
            return true;
          if (std::__invoke(__comp, std::__invoke(__proj2, *__first2),
                            std::__invoke(__proj1, *__first1)))
            return false;
        }
        return __first1 == __last1 && __first2 != __last2;
      }
    }

    template <input_range _Range1, input_range _Range2,
              typename _Proj1 = identity, typename _Proj2 = identity,
              indirect_strict_weak_order<projected<iterator_t<_Range1>, _Proj1>,
                                         projected<iterator_t<_Range2>, _Proj2>>
                  _Comp = ranges::less>
    constexpr bool operator()(_Range1 &&__r1, _Range2 &&__r2, _Comp __comp = {},
                              _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
      return (*this)(ranges::begin(__r1), ranges::end(__r1),
                     ranges::begin(__r2), ranges::end(__r2), std::move(__comp),
                     std::move(__proj1), std::move(__proj2));
    }

  private:
    template <typename _Iter, typename _Ref = iter_reference_t<_Iter>>
    static constexpr bool __ptr_to_nonvolatile =
        is_pointer_v<_Iter> && !is_volatile_v<remove_reference_t<_Ref>>;
  };

  inline constexpr __lexicographical_compare_fn lexicographical_compare;

  template <typename _Iter> struct in_found_result {
    [[no_unique_address]] _Iter in;
    bool found;

    template <typename _Iter2>
      requires convertible_to<const _Iter &, _Iter2>
    constexpr operator in_found_result<_Iter2>() const & {
      return {in, found};
    }

    template <typename _Iter2>
      requires convertible_to<_Iter, _Iter2>
    constexpr operator in_found_result<_Iter2>() && {
      return {std::move(in), found};
    }
  };

  template <typename _Iter>
  using next_permutation_result = in_found_result<_Iter>;

  struct __next_permutation_fn {
    template <bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Comp = ranges::less, typename _Proj = identity>
      requires sortable<_Iter, _Comp, _Proj>
    constexpr next_permutation_result<_Iter>
    operator()(_Iter __first, _Sent __last, _Comp __comp = {},
               _Proj __proj = {}) const {
      if (__first == __last)
        return {std::move(__first), false};

      auto __i = __first;
      ++__i;
      if (__i == __last)
        return {std::move(__i), false};

      auto __lasti = ranges::next(__first, __last);
      __i = __lasti;
      --__i;

      for (;;) {
        auto __ii = __i;
        --__i;
        if (std::__invoke(__comp, std::__invoke(__proj, *__i),
                          std::__invoke(__proj, *__ii))) {
          auto __j = __lasti;
          while (!(bool)std::__invoke(__comp, std::__invoke(__proj, *__i),
                                      std::__invoke(__proj, *--__j)))
            ;
          ranges::iter_swap(__i, __j);
          ranges::reverse(__ii, __last);
          return {std::move(__lasti), true};
        }
        if (__i == __first) {
          ranges::reverse(__first, __last);
          return {std::move(__lasti), false};
        }
      }
    }

    template <bidirectional_range _Range, typename _Comp = ranges::less,
              typename _Proj = identity>
      requires sortable<iterator_t<_Range>, _Comp, _Proj>
    constexpr next_permutation_result<borrowed_iterator_t<_Range>>
    operator()(_Range &&__r, _Comp __comp = {}, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __next_permutation_fn next_permutation{};

  template <typename _Iter>
  using prev_permutation_result = in_found_result<_Iter>;

  struct __prev_permutation_fn {
    template <bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,
              typename _Comp = ranges::less, typename _Proj = identity>
      requires sortable<_Iter, _Comp, _Proj>
    constexpr prev_permutation_result<_Iter>
    operator()(_Iter __first, _Sent __last, _Comp __comp = {},
               _Proj __proj = {}) const {
      if (__first == __last)
        return {std::move(__first), false};

      auto __i = __first;
      ++__i;
      if (__i == __last)
        return {std::move(__i), false};

      auto __lasti = ranges::next(__first, __last);
      __i = __lasti;
      --__i;

      for (;;) {
        auto __ii = __i;
        --__i;
        if (std::__invoke(__comp, std::__invoke(__proj, *__ii),
                          std::__invoke(__proj, *__i))) {
          auto __j = __lasti;
          while (!(bool)std::__invoke(__comp, std::__invoke(__proj, *--__j),
                                      std::__invoke(__proj, *__i)))
            ;
          ranges::iter_swap(__i, __j);
          ranges::reverse(__ii, __last);
          return {std::move(__lasti), true};
        }
        if (__i == __first) {
          ranges::reverse(__first, __last);
          return {std::move(__lasti), false};
        }
      }
    }

    template <bidirectional_range _Range, typename _Comp = ranges::less,
              typename _Proj = identity>
      requires sortable<iterator_t<_Range>, _Comp, _Proj>
    constexpr prev_permutation_result<borrowed_iterator_t<_Range>>
    operator()(_Range &&__r, _Comp __comp = {}, _Proj __proj = {}) const {
      return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__comp),
                     std::move(__proj));
    }
  };

  inline constexpr __prev_permutation_fn prev_permutation{};
# 3953 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_algo.h" 3
  } // namespace ranges

  template <typename _ForwardIterator>
  constexpr _ForwardIterator shift_left(
      _ForwardIterator __first, _ForwardIterator __last,
      typename iterator_traits<_ForwardIterator>::difference_type __n) {
    do {
      if (std::__is_constant_evaluated() && !bool(__n >= 0))
        __builtin_unreachable();
    } while (false);
    if (__n == 0)
      return __last;

    auto __mid = ranges::next(__first, __n, __last);
    if (__mid == __last)
      return __first;
    return std::move(std::move(__mid), std::move(__last), std::move(__first));
  }

  template <typename _ForwardIterator>
  constexpr _ForwardIterator shift_right(
      _ForwardIterator __first, _ForwardIterator __last,
      typename iterator_traits<_ForwardIterator>::difference_type __n) {
    do {
      if (std::__is_constant_evaluated() && !bool(__n >= 0))
        __builtin_unreachable();
    } while (false);
    if (__n == 0)
      return __first;

    using _Cat = typename iterator_traits<_ForwardIterator>::iterator_category;
    if constexpr (derived_from<_Cat, bidirectional_iterator_tag>) {
      auto __mid = ranges::next(__last, -__n, __first);
      if (__mid == __first)
        return __last;

      return std::move_backward(std::move(__first), std::move(__mid),
                                std::move(__last));
    } else {
      auto __result = ranges::next(__first, __n, __last);
      if (__result == __last)
        return __last;

      auto __dest_head = __first, __dest_tail = __result;
      while (__dest_head != __result) {
        if (__dest_tail == __last) {

          std::move(std::move(__first), std::move(__dest_head), __result);
          return __result;
        }
        ++__dest_head;
        ++__dest_tail;
      }

      for (;;) {
# 4024 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/ranges_algo.h" 3
        auto __cursor = __first;
        while (__cursor != __result) {
          if (__dest_tail == __last) {

            __dest_head = std::move(__cursor, __result, std::move(__dest_head));
            std::move(std::move(__first), std::move(__cursor),
                      std::move(__dest_head));
            return __result;
          }
          std::iter_swap(__cursor, __dest_head);
          ++__dest_head;
          ++__dest_tail;
          ++__cursor;
        }
      }
    }
  }

} // namespace std
# 64 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/algorithm" 2 3
# 73 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/algorithm" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_algorithm_defs.h" 1 3
# 17 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_algorithm_defs.h" 3
namespace std {

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
any_of(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __last, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
all_of(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __last, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
none_of(_ExecutionPolicy &&__exec, _ForwardIterator __first,
        _ForwardIterator __last, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Function>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
for_each(_ExecutionPolicy &&__exec, _ForwardIterator __first,
         _ForwardIterator __last, _Function __f);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Function>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
for_each_n(_ExecutionPolicy &&__exec, _ForwardIterator __first, _Size __n,
           _Function __f);

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
find_if(_ExecutionPolicy &&__exec, _ForwardIterator __first,
        _ForwardIterator __last, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
find_if_not(_ExecutionPolicy &&__exec, _ForwardIterator __first,
            _ForwardIterator __last, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
find(_ExecutionPolicy &&__exec, _ForwardIterator __first,
     _ForwardIterator __last, const _Tp &__value);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator1>
find_end(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
         _ForwardIterator1 __last, _ForwardIterator2 __s_first,
         _ForwardIterator2 __s_last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator1>
find_end(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
         _ForwardIterator1 __last, _ForwardIterator2 __s_first,
         _ForwardIterator2 __s_last);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator1>
find_first_of(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
              _ForwardIterator1 __last, _ForwardIterator2 __s_first,
              _ForwardIterator2 __s_last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator1>
find_first_of(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
              _ForwardIterator1 __last, _ForwardIterator2 __s_first,
              _ForwardIterator2 __s_last);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
adjacent_find(_ExecutionPolicy &&__exec, _ForwardIterator __first,
              _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator,
          class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
adjacent_find(_ExecutionPolicy &&__exec, _ForwardIterator __first,
              _ForwardIterator __last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy,
    typename iterator_traits<_ForwardIterator>::difference_type>
count(_ExecutionPolicy &&__exec, _ForwardIterator __first,
      _ForwardIterator __last, const _Tp &__value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy,
    typename iterator_traits<_ForwardIterator>::difference_type>
count_if(_ExecutionPolicy &&__exec, _ForwardIterator __first,
         _ForwardIterator __last, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator1>
search(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
       _ForwardIterator1 __last, _ForwardIterator2 __s_first,
       _ForwardIterator2 __s_last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator1>
search(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
       _ForwardIterator1 __last, _ForwardIterator2 __s_first,
       _ForwardIterator2 __s_last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Tp, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
search_n(_ExecutionPolicy &&__exec, _ForwardIterator __first,
         _ForwardIterator __last, _Size __count, const _Tp &__value,
         _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
search_n(_ExecutionPolicy &&__exec, _ForwardIterator __first,
         _ForwardIterator __last, _Size __count, const _Tp &__value);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
     _ForwardIterator1 __last, _ForwardIterator2 __result);

template <class _ExecutionPolicy, class _ForwardIterator1, class _Size,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
copy_n(_ExecutionPolicy &&__exec, _ForwardIterator1 __first, _Size __n,
       _ForwardIterator2 __result);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
copy_if(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
        _ForwardIterator1 __last, _ForwardIterator2 result, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
swap_ranges(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
            _ForwardIterator1 __last1, _ForwardIterator2 __first2);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _UnaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
transform(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
          _ForwardIterator1 __last, _ForwardIterator2 __result,
          _UnaryOperation __op);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator,
          class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
transform(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
          _ForwardIterator1 __last1, _ForwardIterator2 __first2,
          _ForwardIterator __result, _BinaryOperation __op);

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate,
          class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
replace_if(_ExecutionPolicy &&__exec, _ForwardIterator __first,
           _ForwardIterator __last, _UnaryPredicate __pred,
           const _Tp &__new_value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
replace(_ExecutionPolicy &&__exec, _ForwardIterator __first,
        _ForwardIterator __last, const _Tp &__old_value,
        const _Tp &__new_value);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _UnaryPredicate, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
replace_copy_if(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
                _ForwardIterator1 __last, _ForwardIterator2 __result,
                _UnaryPredicate __pred, const _Tp &__new_value);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
replace_copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
             _ForwardIterator1 __last, _ForwardIterator2 __result,
             const _Tp &__old_value, const _Tp &__new_value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
fill(_ExecutionPolicy &&__exec, _ForwardIterator __first,
     _ForwardIterator __last, const _Tp &__value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
fill_n(_ExecutionPolicy &&__exec, _ForwardIterator __first, _Size __count,
       const _Tp &__value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Generator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
generate(_ExecutionPolicy &&__exec, _ForwardIterator __first,
         _ForwardIterator __last, _Generator __g);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Generator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
generate_n(_ExecutionPolicy &&__exec, _ForwardIterator __first, _Size count,
           _Generator __g);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
remove_copy_if(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
               _ForwardIterator1 __last, _ForwardIterator2 __result,
               _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
remove_copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
            _ForwardIterator1 __last, _ForwardIterator2 __result,
            const _Tp &__value);

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
remove_if(_ExecutionPolicy &&__exec, _ForwardIterator __first,
          _ForwardIterator __last, _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
remove(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __last, const _Tp &__value);

template <class _ExecutionPolicy, class _ForwardIterator,
          class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
unique(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
unique(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
unique_copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
            _ForwardIterator1 __last, _ForwardIterator2 __result,
            _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
unique_copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
            _ForwardIterator1 __last, _ForwardIterator2 __result);

template <class _ExecutionPolicy, class _BidirectionalIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
reverse(_ExecutionPolicy &&__exec, _BidirectionalIterator __first,
        _BidirectionalIterator __last);

template <class _ExecutionPolicy, class _BidirectionalIterator,
          class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
reverse_copy(_ExecutionPolicy &&__exec, _BidirectionalIterator __first,
             _BidirectionalIterator __last, _ForwardIterator __d_first);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
rotate(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __middle, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
rotate_copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
            _ForwardIterator1 __middle, _ForwardIterator1 __last,
            _ForwardIterator2 __result);

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_partitioned(_ExecutionPolicy &&__exec, _ForwardIterator __first,
               _ForwardIterator __last, _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
partition(_ExecutionPolicy &&__exec, _ForwardIterator __first,
          _ForwardIterator __last, _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _BidirectionalIterator,
          class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _BidirectionalIterator>
stable_partition(_ExecutionPolicy &&__exec, _BidirectionalIterator __first,
                 _BidirectionalIterator __last, _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator,
          class _ForwardIterator1, class _ForwardIterator2,
          class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
partition_copy(_ExecutionPolicy &&__exec, _ForwardIterator __first,
               _ForwardIterator __last, _ForwardIterator1 __out_true,
               _ForwardIterator2 __out_false, _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
     _RandomAccessIterator __last);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
stable_sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
            _RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
stable_sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
            _RandomAccessIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
         _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _ForwardIterator2 __last2, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
         _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
         _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _ForwardIterator2 __last2);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
         _ForwardIterator1 __last1, _ForwardIterator2 __first2);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
      _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _BinaryPredicate __p);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
      _ForwardIterator1 __last1, _ForwardIterator2 __first2);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
      _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _ForwardIterator2 __last2, _BinaryPredicate __p);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
      _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _ForwardIterator2 __last2);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
move(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
     _ForwardIterator1 __last, _ForwardIterator2 __d_first);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
partial_sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
             _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
partial_sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
             _RandomAccessIterator __middle, _RandomAccessIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator,
          class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _RandomAccessIterator>
partial_sort_copy(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                  _ForwardIterator __last, _RandomAccessIterator __d_first,
                  _RandomAccessIterator __d_last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator,
          class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _RandomAccessIterator>
partial_sort_copy(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                  _ForwardIterator __last, _RandomAccessIterator __d_first,
                  _RandomAccessIterator __d_last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
is_sorted_until(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                _ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
is_sorted_until(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_sorted(_ExecutionPolicy &&__exec, _ForwardIterator __first,
          _ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_sorted(_ExecutionPolicy &&__exec, _ForwardIterator __first,
          _ForwardIterator __last);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
nth_element(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
            _RandomAccessIterator __nth, _RandomAccessIterator __last,
            _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
nth_element(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
            _RandomAccessIterator __nth, _RandomAccessIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
merge(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
      _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _ForwardIterator2 __last2, _ForwardIterator __d_first, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
merge(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
      _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _ForwardIterator2 __last2, _ForwardIterator __d_first);

template <class _ExecutionPolicy, class _BidirectionalIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
inplace_merge(_ExecutionPolicy &&__exec, _BidirectionalIterator __first,
              _BidirectionalIterator __middle, _BidirectionalIterator __last,
              _Compare __comp);

template <class _ExecutionPolicy, class _BidirectionalIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
inplace_merge(_ExecutionPolicy &&__exec, _BidirectionalIterator __first,
              _BidirectionalIterator __middle, _BidirectionalIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
includes(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
         _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _ForwardIterator2 __last2, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
includes(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
         _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _ForwardIterator2 __last2);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
set_union(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
          _ForwardIterator1 __last1, _ForwardIterator2 __first2,
          _ForwardIterator2 __last2, _ForwardIterator __result,
          _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
set_union(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
          _ForwardIterator1 __last1, _ForwardIterator2 __first2,
          _ForwardIterator2 __last2, _ForwardIterator __result);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
set_intersection(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                 _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                 _ForwardIterator2 __last2, _ForwardIterator __result,
                 _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
set_intersection(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                 _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                 _ForwardIterator2 __last2, _ForwardIterator __result);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
set_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
               _ForwardIterator1 __last1, _ForwardIterator2 __first2,
               _ForwardIterator2 __last2, _ForwardIterator __result,
               _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
set_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
               _ForwardIterator1 __last1, _ForwardIterator2 __first2,
               _ForwardIterator2 __last2, _ForwardIterator __result);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
set_symmetric_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                         _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                         _ForwardIterator2 __last2, _ForwardIterator result,
                         _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
set_symmetric_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                         _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                         _ForwardIterator2 __last2, _ForwardIterator __result);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _RandomAccessIterator>
is_heap_until(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
              _RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _RandomAccessIterator>
is_heap_until(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
              _RandomAccessIterator __last);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_heap(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
        _RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_heap(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
        _RandomAccessIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
min_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
            _ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
min_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
            _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
max_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
            _ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
max_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
            _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy, std::pair<_ForwardIterator, _ForwardIterator>>
minmax_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
               _ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy, std::pair<_ForwardIterator, _ForwardIterator>>
minmax_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
               _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
lexicographical_compare(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                        _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                        _ForwardIterator2 __last2, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
lexicographical_compare(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                        _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                        _ForwardIterator2 __last2);

} // namespace std
# 74 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/algorithm" 2 3
# 24 "./ComputeRestriction_stdexec.hpp" 2
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/execution" 1 3
# 29 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/execution" 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_execution_defs.h" 1 3
# 17 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_execution_defs.h" 3
namespace std {

using __pstl::execution::is_execution_policy;

using __pstl::execution::is_execution_policy_v;

namespace execution {

using __pstl::execution::parallel_policy;
using __pstl::execution::parallel_unsequenced_policy;
using __pstl::execution::sequenced_policy;

using __pstl::execution::par;
using __pstl::execution::par_unseq;
using __pstl::execution::seq;

using __pstl::execution::unseq;
using __pstl::execution::unsequenced_policy;
} // namespace execution
} // namespace std

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/algorithm_impl.h" 1 3
# 19 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/algorithm_impl.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/execution_impl.h" 1 3
# 18 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/execution_impl.h" 3
namespace __pstl {
namespace __internal {

using namespace __pstl::execution;

template <typename _Tp> std::false_type __lazy_and(_Tp, std::false_type) {
  return std::false_type{};
}

template <typename _Tp> inline _Tp __lazy_and(_Tp __a, std::true_type) {
  return __a;
}

template <typename _Tp> std::true_type __lazy_or(_Tp, std::true_type) {
  return std::true_type{};
}

template <typename _Tp> inline _Tp __lazy_or(_Tp __a, std::false_type) {
  return __a;
}

template <typename _IteratorType, typename... _OtherIteratorTypes>
struct __is_random_access_iterator {
  static constexpr bool value =
      __internal::__is_random_access_iterator<_IteratorType>::value &&
      __internal::__is_random_access_iterator<_OtherIteratorTypes...>::value;
  typedef std::integral_constant<bool, value> type;
};

template <typename _IteratorType>
struct __is_random_access_iterator<_IteratorType>
    : std::is_same<
          typename std::iterator_traits<_IteratorType>::iterator_category,
          std::random_access_iterator_tag> {};

template <typename _Policy> struct __policy_traits {};

template <> struct __policy_traits<sequenced_policy> {
  typedef std::false_type allow_parallel;
  typedef std::false_type allow_unsequenced;
  typedef std::false_type allow_vector;
};

template <> struct __policy_traits<unsequenced_policy> {
  typedef std::false_type allow_parallel;
  typedef std::true_type allow_unsequenced;
  typedef std::true_type allow_vector;
};

template <> struct __policy_traits<parallel_policy> {
  typedef std::true_type allow_parallel;
  typedef std::false_type allow_unsequenced;
  typedef std::false_type allow_vector;
};

template <> struct __policy_traits<parallel_unsequenced_policy> {
  typedef std::true_type allow_parallel;
  typedef std::true_type allow_unsequenced;
  typedef std::true_type allow_vector;
};

template <typename _ExecutionPolicy>
using __collector_t = typename __internal::__policy_traits<
    typename std::decay<_ExecutionPolicy>::type>::__collector_type;

template <typename _ExecutionPolicy>
using __allow_vector = typename __internal::__policy_traits<
    typename std::decay<_ExecutionPolicy>::type>::__allow_vector;

template <typename _ExecutionPolicy>
using __allow_unsequenced = typename __internal::__policy_traits<
    typename std::decay<_ExecutionPolicy>::type>::__allow_unsequenced;

template <typename _ExecutionPolicy>
using __allow_parallel = typename __internal::__policy_traits<
    typename std::decay<_ExecutionPolicy>::type>::__allow_parallel;

template <typename _ExecutionPolicy, typename... _IteratorTypes>
auto __is_vectorization_preferred(_ExecutionPolicy &&__exec)
    -> decltype(__internal::__lazy_and(
        __exec.__allow_vector(),
        typename __internal::__is_random_access_iterator<
            _IteratorTypes...>::type())) {
  return __internal::__lazy_and(
      __exec.__allow_vector(), typename __internal::__is_random_access_iterator<
                                   _IteratorTypes...>::type());
}

template <typename _ExecutionPolicy, typename... _IteratorTypes>
auto __is_parallelization_preferred(_ExecutionPolicy &&__exec)
    -> decltype(__internal::__lazy_and(
        __exec.__allow_parallel(),
        typename __internal::__is_random_access_iterator<
            _IteratorTypes...>::type())) {
  return __internal::__lazy_and(
      __exec.__allow_parallel(),
      typename __internal::__is_random_access_iterator<
          _IteratorTypes...>::type());
}

template <typename __policy, typename... _IteratorTypes>
struct __prefer_unsequenced_tag {
  static constexpr bool value =
      __internal::__allow_unsequenced<__policy>::value &&
      __internal::__is_random_access_iterator<_IteratorTypes...>::value;
  typedef std::integral_constant<bool, value> type;
};

template <typename __policy, typename... _IteratorTypes>
struct __prefer_parallel_tag {
  static constexpr bool value =
      __internal::__allow_parallel<__policy>::value &&
      __internal::__is_random_access_iterator<_IteratorTypes...>::value;
  typedef std::integral_constant<bool, value> type;
};

} // namespace __internal
} // namespace __pstl
# 20 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/algorithm_impl.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/memory_impl.h" 1 3
# 15 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/memory_impl.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/unseq_backend_simd.h" 1 3
# 15 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/unseq_backend_simd.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/utils.h" 1 3
# 16 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/utils.h" 3
namespace __pstl {
namespace __internal {

template <typename _Fp>
typename std::result_of<_Fp()>::type __except_handler(_Fp __f) {
  try {
    return __f();
  } catch (const std::bad_alloc &) {
    throw;
  } catch (...) {
    std::__terminate();
  }
}

template <typename _Fp> void __invoke_if(std::true_type, _Fp __f) { __f(); }

template <typename _Fp> void __invoke_if(std::false_type, _Fp __f) {}

template <typename _Fp> void __invoke_if_not(std::false_type, _Fp __f) {
  __f();
}

template <typename _Fp> void __invoke_if_not(std::true_type, _Fp __f) {}

template <typename _F1, typename _F2>
typename std::result_of<_F1()>::type __invoke_if_else(std::true_type, _F1 __f1,
                                                      _F2 __f2) {
  return __f1();
}

template <typename _F1, typename _F2>
typename std::result_of<_F2()>::type __invoke_if_else(std::false_type, _F1 __f1,
                                                      _F2 __f2) {
  return __f2();
}

struct __no_op {
  template <typename _Tp> _Tp &&operator()(_Tp &&__a) const {
    return std::forward<_Tp>(__a);
  }
};

template <typename _Pred> class __not_pred {
  _Pred _M_pred;

public:
  explicit __not_pred(_Pred __pred) : _M_pred(__pred) {}

  template <typename... _Args> bool operator()(_Args &&...__args) {
    return !_M_pred(std::forward<_Args>(__args)...);
  }
};

template <typename _Pred> class __reorder_pred {
  _Pred _M_pred;

public:
  explicit __reorder_pred(_Pred __pred) : _M_pred(__pred) {}

  template <typename _FTp, typename _STp>
  bool operator()(_FTp &&__a, _STp &&__b) {
    return _M_pred(std::forward<_STp>(__b), std::forward<_FTp>(__a));
  }
};

class __pstl_equal {
public:
  explicit __pstl_equal() {}

  template <typename _Xp, typename _Yp>
  bool operator()(_Xp &&__x, _Yp &&__y) const {
    return std::forward<_Xp>(__x) == std::forward<_Yp>(__y);
  }
};

class __pstl_less {
public:
  explicit __pstl_less() {}

  template <typename _Xp, typename _Yp>
  bool operator()(_Xp &&__x, _Yp &&__y) const {
    return std::forward<_Xp>(__x) < std::forward<_Yp>(__y);
  }
};

template <typename _Tp, typename _Predicate> class __equal_value_by_pred {
  const _Tp &_M_value;
  _Predicate _M_pred;

public:
  __equal_value_by_pred(const _Tp &__value, _Predicate __pred)
      : _M_value(__value), _M_pred(__pred) {}

  template <typename _Arg> bool operator()(_Arg &&__arg) {
    return _M_pred(std::forward<_Arg>(__arg), _M_value);
  }
};

template <typename _Tp> class __equal_value {
  const _Tp &_M_value;

public:
  explicit __equal_value(const _Tp &__value) : _M_value(__value) {}

  template <typename _Arg> bool operator()(_Arg &&__arg) const {
    return std::forward<_Arg>(__arg) == _M_value;
  }
};

template <typename _Tp> class __not_equal_value {
  const _Tp &_M_value;

public:
  explicit __not_equal_value(const _Tp &__value) : _M_value(__value) {}

  template <typename _Arg> bool operator()(_Arg &&__arg) const {
    return !(std::forward<_Arg>(__arg) == _M_value);
  }
};

template <typename _ForwardIterator, typename _Compare>
_ForwardIterator __cmp_iterators_by_values(_ForwardIterator __a,
                                           _ForwardIterator __b,
                                           _Compare __comp) {
  if (__a < __b) {
    return __comp(*__b, *__a) ? __b : __a;
  } else {
    return __comp(*__a, *__b) ? __a : __b;
  }
}

} // namespace __internal
} // namespace __pstl
# 16 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/unseq_backend_simd.h" 2 3

namespace __pstl {
namespace __unseq_backend {

const std::size_t __lane_size = 64;

template <class _Iterator, class _DifferenceType, class _Function>
_Iterator __simd_walk_1(_Iterator __first, _DifferenceType __n,
                        _Function __f) noexcept {
#pragma omp simd
  for (_DifferenceType __i = 0; __i < __n; ++__i)
    __f(__first[__i]);

  return __first + __n;
}

template <class _Iterator1, class _DifferenceType, class _Iterator2,
          class _Function>
_Iterator2 __simd_walk_2(_Iterator1 __first1, _DifferenceType __n,
                         _Iterator2 __first2, _Function __f) noexcept {
#pragma omp simd
  for (_DifferenceType __i = 0; __i < __n; ++__i)
    __f(__first1[__i], __first2[__i]);
  return __first2 + __n;
}

template <class _Iterator1, class _DifferenceType, class _Iterator2,
          class _Iterator3, class _Function>
_Iterator3 __simd_walk_3(_Iterator1 __first1, _DifferenceType __n,
                         _Iterator2 __first2, _Iterator3 __first3,
                         _Function __f) noexcept {
#pragma omp simd
  for (_DifferenceType __i = 0; __i < __n; ++__i)
    __f(__first1[__i], __first2[__i], __first3[__i]);
  return __first3 + __n;
}

template <class _Index, class _DifferenceType, class _Pred>
bool __simd_or(_Index __first, _DifferenceType __n, _Pred __pred) noexcept {
# 73 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/unseq_backend_simd.h" 3
  _DifferenceType __block_size = 4 < __n ? 4 : __n;
  const _Index __last = __first + __n;
  while (__last != __first) {
    int __flag = 1;
#pragma omp simd reduction(& : __flag)
    for (_DifferenceType __i = 0; __i < __block_size; ++__i)
      if (__pred(*(__first + __i)))
        __flag = 0;
    if (!__flag)
      return true;

    __first += __block_size;
    if (__last - __first >= __block_size << 1) {

      __block_size <<= 1;
    } else {
      __block_size = __last - __first;
    }
  }
  return false;
}

template <class _Index, class _DifferenceType, class _Compare>
_Index __simd_first(_Index __first, _DifferenceType __begin,
                    _DifferenceType __end, _Compare __comp) noexcept {
# 117 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/unseq_backend_simd.h" 3
  const _DifferenceType __block_size = 8;
  alignas(__lane_size) _DifferenceType __lane[__block_size] = {0};
  while (__end - __begin >= __block_size) {
    _DifferenceType __found = 0;

#pragma omp simd reduction(| : __found)
    for (_DifferenceType __i = __begin; __i < __begin + __block_size; ++__i) {
      const _DifferenceType __t = __comp(__first, __i);
      __lane[__i - __begin] = __t;
      __found |= __t;
    }
    if (__found) {
      _DifferenceType __i;

      for (__i = 0; __i < __block_size; ++__i) {
        if (__lane[__i]) {
          break;
        }
      }
      return __first + __begin + __i;
    }
    __begin += __block_size;
  }

  while (__begin != __end) {
    if (__comp(__first, __begin)) {
      return __first + __begin;
    }
    ++__begin;
  }
  return __first + __end;
}

template <class _Index1, class _DifferenceType, class _Index2, class _Pred>
std::pair<_Index1, _Index2> __simd_first(_Index1 __first1, _DifferenceType __n,
                                         _Index2 __first2,
                                         _Pred __pred) noexcept {
# 173 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/unseq_backend_simd.h" 3
  const _Index1 __last1 = __first1 + __n;
  const _Index2 __last2 = __first2 + __n;

  const _DifferenceType __block_size = 8;
  alignas(__lane_size) _DifferenceType __lane[__block_size] = {0};
  while (__last1 - __first1 >= __block_size) {
    _DifferenceType __found = 0;
    _DifferenceType __i;

#pragma omp simd reduction(| : __found)
    for (__i = 0; __i < __block_size; ++__i) {
      const _DifferenceType __t = __pred(__first1[__i], __first2[__i]);
      __lane[__i] = __t;
      __found |= __t;
    }
    if (__found) {
      _DifferenceType __i2;

      for (__i2 = 0; __i2 < __block_size; ++__i2) {
        if (__lane[__i2])
          break;
      }
      return std::make_pair(__first1 + __i2, __first2 + __i2);
    }
    __first1 += __block_size;
    __first2 += __block_size;
  }

  for (; __last1 != __first1; ++__first1, ++__first2)
    if (__pred(*(__first1), *(__first2)))
      return std::make_pair(__first1, __first2);

  return std::make_pair(__last1, __last2);
}

template <class _Index, class _DifferenceType, class _Pred>
_DifferenceType __simd_count(_Index __index, _DifferenceType __n,
                             _Pred __pred) noexcept {
  _DifferenceType __count = 0;
#pragma omp simd reduction(+ : __count)
  for (_DifferenceType __i = 0; __i < __n; ++__i)
    if (__pred(*(__index + __i)))
      ++__count;

  return __count;
}

template <class _InputIterator, class _DifferenceType, class _OutputIterator,
          class _BinaryPredicate>
_OutputIterator __simd_unique_copy(_InputIterator __first, _DifferenceType __n,
                                   _OutputIterator __result,
                                   _BinaryPredicate __pred) noexcept {
  if (__n == 0)
    return __result;

  _DifferenceType __cnt = 1;
  __result[0] = __first[0];

#pragma omp simd
  for (_DifferenceType __i = 1; __i < __n; ++__i) {

    if (!__pred(__first[__i], __first[__i - 1])) {
      __result[__cnt] = __first[__i];
      ++__cnt;
    }
  }
  return __result + __cnt;
}

template <class _InputIterator, class _DifferenceType, class _OutputIterator,
          class _Assigner>
_OutputIterator __simd_assign(_InputIterator __first, _DifferenceType __n,
                              _OutputIterator __result,
                              _Assigner __assigner) noexcept {

#pragma omp simd
  for (_DifferenceType __i = 0; __i < __n; ++__i)
    __assigner(__first + __i, __result + __i);
  return __result + __n;
}

template <class _InputIterator, class _DifferenceType, class _OutputIterator,
          class _UnaryPredicate>
_OutputIterator __simd_copy_if(_InputIterator __first, _DifferenceType __n,
                               _OutputIterator __result,
                               _UnaryPredicate __pred) noexcept {
  _DifferenceType __cnt = 0;

#pragma omp simd
  for (_DifferenceType __i = 0; __i < __n; ++__i) {

    if (__pred(__first[__i])) {
      __result[__cnt] = __first[__i];
      ++__cnt;
    }
  }
  return __result + __cnt;
}

template <class _InputIterator, class _DifferenceType, class _BinaryPredicate>
_DifferenceType __simd_calc_mask_2(_InputIterator __first, _DifferenceType __n,
                                   bool *__mask,
                                   _BinaryPredicate __pred) noexcept {
  _DifferenceType __count = 0;

#pragma omp simd reduction(+ : __count)
  for (_DifferenceType __i = 0; __i < __n; ++__i) {
    __mask[__i] = !__pred(__first[__i], __first[__i - 1]);
    __count += __mask[__i];
  }
  return __count;
}

template <class _InputIterator, class _DifferenceType, class _UnaryPredicate>
_DifferenceType __simd_calc_mask_1(_InputIterator __first, _DifferenceType __n,
                                   bool *__mask,
                                   _UnaryPredicate __pred) noexcept {
  _DifferenceType __count = 0;

#pragma omp simd reduction(+ : __count)
  for (_DifferenceType __i = 0; __i < __n; ++__i) {
    __mask[__i] = __pred(__first[__i]);
    __count += __mask[__i];
  }
  return __count;
}

template <class _InputIterator, class _DifferenceType, class _OutputIterator,
          class _Assigner>
void __simd_copy_by_mask(_InputIterator __first, _DifferenceType __n,
                         _OutputIterator __result, bool *__mask,
                         _Assigner __assigner) noexcept {
  _DifferenceType __cnt = 0;
#pragma omp simd
  for (_DifferenceType __i = 0; __i < __n; ++__i) {
    if (__mask[__i]) {

      {
        __assigner(__first + __i, __result + __cnt);
        ++__cnt;
      }
    }
  }
}

template <class _InputIterator, class _DifferenceType, class _OutputIterator1,
          class _OutputIterator2>
void __simd_partition_by_mask(_InputIterator __first, _DifferenceType __n,
                              _OutputIterator1 __out_true,
                              _OutputIterator2 __out_false,
                              bool *__mask) noexcept {
  _DifferenceType __cnt_true = 0, __cnt_false = 0;
#pragma omp simd
  for (_DifferenceType __i = 0; __i < __n; ++__i) {

    if (__mask[__i]) {
      __out_true[__cnt_true] = __first[__i];
      ++__cnt_true;
    } else {
      __out_false[__cnt_false] = __first[__i];
      ++__cnt_false;
    }
  }
}

template <class _Index, class _DifferenceType, class _Tp>
_Index __simd_fill_n(_Index __first, _DifferenceType __n,
                     const _Tp &__value) noexcept {

#pragma omp simd
  for (_DifferenceType __i = 0; __i < __n; ++__i)
    __first[__i] = __value;
  return __first + __n;
}

template <class _Index, class _DifferenceType, class _Generator>
_Index __simd_generate_n(_Index __first, _DifferenceType __size,
                         _Generator __g) noexcept {

#pragma omp simd
  for (_DifferenceType __i = 0; __i < __size; ++__i)
    __first[__i] = __g();
  return __first + __size;
}

template <class _Index, class _BinaryPredicate>
_Index __simd_adjacent_find(_Index __first, _Index __last,
                            _BinaryPredicate __pred,
                            bool __or_semantic) noexcept {
  if (__last - __first < 2)
    return __last;

  typedef
      typename std::iterator_traits<_Index>::difference_type _DifferenceType;
  _DifferenceType __i = 0;
# 399 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/unseq_backend_simd.h" 3
  const _DifferenceType __block_size = 8;
  alignas(__lane_size) _DifferenceType __lane[__block_size] = {0};
  while (__last - __first >= __block_size) {
    _DifferenceType __found = 0;

#pragma omp simd reduction(| : __found)
    for (__i = 0; __i < __block_size - 1; ++__i) {

      const _DifferenceType __t =
          __pred(*(__first + __i), *(__first + __i + 1));
      __lane[__i] = __t;
      __found |= __t;
    }

    if (__first + __block_size < __last &&
        __pred(*(__first + __i), *(__first + __i + 1)))
      __lane[__i] = __found = 1;

    if (__found) {
      if (__or_semantic)
        return __first;

      for (__i = 0; __i < __block_size; ++__i)
        if (__lane[__i])
          break;
      return __first + __i;
    }
    __first += __block_size;
  }

  for (; __last - __first > 1; ++__first)
    if (__pred(*__first, *(__first + 1)))
      return __first;

  return __last;
}

template <typename _Tp, typename _BinaryOperation>
using is_arithmetic_plus = std::integral_constant<
    bool, std::is_arithmetic<_Tp>::value &&
              std::is_same<_BinaryOperation, std::plus<_Tp>>::value>;

template <typename _DifferenceType, typename _Tp, typename _BinaryOperation,
          typename _UnaryOperation>
typename std::enable_if<is_arithmetic_plus<_Tp, _BinaryOperation>::value,
                        _Tp>::type
__simd_transform_reduce(_DifferenceType __n, _Tp __init, _BinaryOperation,
                        _UnaryOperation __f) noexcept {
#pragma omp simd reduction(+ : __init)
  for (_DifferenceType __i = 0; __i < __n; ++__i)
    __init += __f(__i);
  return __init;
}

template <typename _Size, typename _Tp, typename _BinaryOperation,
          typename _UnaryOperation>
typename std::enable_if<!is_arithmetic_plus<_Tp, _BinaryOperation>::value,
                        _Tp>::type
__simd_transform_reduce(_Size __n, _Tp __init, _BinaryOperation __binary_op,
                        _UnaryOperation __f) noexcept {
  const _Size __block_size = __lane_size / sizeof(_Tp);
  if (__n > 2 * __block_size && __block_size > 1) {
    alignas(__lane_size) char __lane_[__lane_size];
    _Tp *__lane = reinterpret_cast<_Tp *>(__lane_);

#pragma omp simd
    for (_Size __i = 0; __i < __block_size; ++__i) {
      ::new (__lane + __i) _Tp(__binary_op(__f(__i), __f(__block_size + __i)));
    }

    _Size __i = 2 * __block_size;
    const _Size last_iteration = __block_size * (__n / __block_size);
    for (; __i < last_iteration; __i += __block_size) {
#pragma omp simd
      for (_Size __j = 0; __j < __block_size; ++__j) {
        __lane[__j] = __binary_op(__lane[__j], __f(__i + __j));
      }
    }

#pragma omp simd
    for (_Size __j = 0; __j < __n - last_iteration; ++__j) {
      __lane[__j] = __binary_op(__lane[__j], __f(last_iteration + __j));
    }

    for (_Size __j = 0; __j < __block_size; ++__j) {
      __init = __binary_op(__init, __lane[__j]);
    }

#pragma omp simd
    for (_Size __j = 0; __j < __block_size; ++__j) {
      __lane[__j].~_Tp();
    }
  } else {
    for (_Size __i = 0; __i < __n; ++__i) {
      __init = __binary_op(__init, __f(__i));
    }
  }
  return __init;
}

template <class _InputIterator, class _Size, class _OutputIterator,
          class _UnaryOperation, class _Tp, class _BinaryOperation>
typename std::enable_if<is_arithmetic_plus<_Tp, _BinaryOperation>::value,
                        std::pair<_OutputIterator, _Tp>>::type
__simd_scan(_InputIterator __first, _Size __n, _OutputIterator __result,
            _UnaryOperation __unary_op, _Tp __init, _BinaryOperation,
            std::false_type) {

  for (_Size __i = 0; __i < __n; ++__i) {
    __result[__i] = __init;

    __init += __unary_op(__first[__i]);
  }
  return std::make_pair(__result + __n, __init);
}

template <typename _Tp, typename _BinaryOp> struct _Combiner {
  _Tp __value;
  _BinaryOp *__bin_op;

  _Combiner() : __value{}, __bin_op(nullptr) {}
  _Combiner(const _Tp &value, const _BinaryOp *__bin_op)
      : __value(value), __bin_op(const_cast<_BinaryOp *>(__bin_op)) {}
  _Combiner(const _Combiner &__obj) : __value{}, __bin_op(__obj.__bin_op) {}

  void operator()(const _Combiner &__obj) {
    __value = (*__bin_op)(__value, __obj.__value);
  }
};

template <class _InputIterator, class _Size, class _OutputIterator,
          class _UnaryOperation, class _Tp, class _BinaryOperation>
typename std::enable_if<!is_arithmetic_plus<_Tp, _BinaryOperation>::value,
                        std::pair<_OutputIterator, _Tp>>::type
__simd_scan(_InputIterator __first, _Size __n, _OutputIterator __result,
            _UnaryOperation __unary_op, _Tp __init,
            _BinaryOperation __binary_op, std::false_type) {
  typedef _Combiner<_Tp, _BinaryOperation> _CombinerType;
  _CombinerType __init_{__init, &__binary_op};

#pragma omp declare reduction(__bin_op:_CombinerType : omp_out(omp_in))        \
    initializer(omp_priv = omp_orig)

  for (_Size __i = 0; __i < __n; ++__i) {
    __result[__i] = __init_.__value;

    __init_.__value = __binary_op(__init_.__value, __unary_op(__first[__i]));
  }
  return std::make_pair(__result + __n, __init_.__value);
}

template <class _InputIterator, class _Size, class _OutputIterator,
          class _UnaryOperation, class _Tp, class _BinaryOperation>
typename std::enable_if<is_arithmetic_plus<_Tp, _BinaryOperation>::value,
                        std::pair<_OutputIterator, _Tp>>::type
__simd_scan(_InputIterator __first, _Size __n, _OutputIterator __result,
            _UnaryOperation __unary_op, _Tp __init, _BinaryOperation,
            std::true_type) {

  for (_Size __i = 0; __i < __n; ++__i) {
    __init += __unary_op(__first[__i]);

    __result[__i] = __init;
  }
  return std::make_pair(__result + __n, __init);
}

template <class _InputIterator, class _Size, class _OutputIterator,
          class _UnaryOperation, class _Tp, class _BinaryOperation>
typename std::enable_if<!is_arithmetic_plus<_Tp, _BinaryOperation>::value,
                        std::pair<_OutputIterator, _Tp>>::type
__simd_scan(_InputIterator __first, _Size __n, _OutputIterator __result,
            _UnaryOperation __unary_op, _Tp __init,
            _BinaryOperation __binary_op, std::true_type) {
  typedef _Combiner<_Tp, _BinaryOperation> _CombinerType;
  _CombinerType __init_{__init, &__binary_op};

#pragma omp declare reduction(__bin_op:_CombinerType : omp_out(omp_in))        \
    initializer(omp_priv = omp_orig)

  for (_Size __i = 0; __i < __n; ++__i) {

    __init_.__value = __binary_op(__init_.__value, __unary_op(__first[__i]));

    __result[__i] = __init_.__value;
  }
  return std::make_pair(__result + __n, __init_.__value);
}

template <typename _ForwardIterator, typename _Size, typename _Compare>
_ForwardIterator __simd_min_element(_ForwardIterator __first, _Size __n,
                                    _Compare __comp) noexcept {
  if (__n == 0) {
    return __first;
  }

  typedef
      typename std::iterator_traits<_ForwardIterator>::value_type _ValueType;
  struct _ComplexType {
    _ValueType __min_val;
    _Size __min_ind;
    _Compare *__min_comp;

    _ComplexType() : __min_val{}, __min_ind{}, __min_comp(nullptr) {}
    _ComplexType(const _ValueType &__val, const _Compare *comp)
        : __min_val(__val), __min_ind(0),
          __min_comp(const_cast<_Compare *>(comp)) {}
    _ComplexType(const _ComplexType &__obj)
        : __min_val(__obj.__min_val), __min_ind(__obj.__min_ind),
          __min_comp(__obj.__min_comp) {}

#pragma omp declare simd
    void operator()(const _ComplexType &__obj) {
      if (!(*__min_comp)(__min_val, __obj.__min_val) &&
          ((*__min_comp)(__obj.__min_val, __min_val) ||
           __obj.__min_ind - __min_ind < 0)) {
        __min_val = __obj.__min_val;
        __min_ind = __obj.__min_ind;
      }
    }
  };

  _ComplexType __init{*__first, &__comp};

#pragma omp declare reduction(__min_func:_ComplexType : omp_out(omp_in))       \
    initializer(omp_priv = omp_orig)

#pragma omp simd reduction(__min_func : __init)
  for (_Size __i = 1; __i < __n; ++__i) {
    const _ValueType __min_val = __init.__min_val;
    const _ValueType __current = __first[__i];
    if (__comp(__current, __min_val)) {
      __init.__min_val = __current;
      __init.__min_ind = __i;
    }
  }
  return __first + __init.__min_ind;
}

template <typename _ForwardIterator, typename _Size, typename _Compare>
std::pair<_ForwardIterator, _ForwardIterator>
__simd_minmax_element(_ForwardIterator __first, _Size __n,
                      _Compare __comp) noexcept {
  if (__n == 0) {
    return std::make_pair(__first, __first);
  }
  typedef
      typename std::iterator_traits<_ForwardIterator>::value_type _ValueType;

  struct _ComplexType {
    _ValueType __min_val;
    _ValueType __max_val;
    _Size __min_ind;
    _Size __max_ind;
    _Compare *__minmax_comp;

    _ComplexType()
        : __min_val{}, __max_val{}, __min_ind{}, __max_ind{},
          __minmax_comp(nullptr) {}
    _ComplexType(const _ValueType &__min_val, const _ValueType &__max_val,
                 const _Compare *comp)
        : __min_val(__min_val), __max_val(__max_val), __min_ind(0),
          __max_ind(0), __minmax_comp(const_cast<_Compare *>(comp)) {}
    _ComplexType(const _ComplexType &__obj)
        : __min_val(__obj.__min_val), __max_val(__obj.__max_val),
          __min_ind(__obj.__min_ind), __max_ind(__obj.__max_ind),
          __minmax_comp(__obj.__minmax_comp) {}

    void operator()(const _ComplexType &__obj) {

      if ((*__minmax_comp)(__obj.__min_val, __min_val)) {
        __min_val = __obj.__min_val;
        __min_ind = __obj.__min_ind;
      } else if (!(*__minmax_comp)(__min_val, __obj.__min_val)) {
        __min_val = __obj.__min_val;
        __min_ind =
            (__min_ind - __obj.__min_ind < 0) ? __min_ind : __obj.__min_ind;
      }

      if ((*__minmax_comp)(__max_val, __obj.__max_val)) {
        __max_val = __obj.__max_val;
        __max_ind = __obj.__max_ind;
      } else if (!(*__minmax_comp)(__obj.__max_val, __max_val)) {
        __max_val = __obj.__max_val;
        __max_ind =
            (__max_ind - __obj.__max_ind < 0) ? __obj.__max_ind : __max_ind;
      }
    }
  };

  _ComplexType __init{*__first, *__first, &__comp};

#pragma omp declare reduction(__min_func:_ComplexType : omp_out(omp_in))       \
    initializer(omp_priv = omp_orig)
# 730 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/unseq_backend_simd.h" 3
  ;

#pragma omp simd reduction(__min_func : __init)
  for (_Size __i = 1; __i < __n; ++__i) {
    auto __min_val = __init.__min_val;
    auto __max_val = __init.__max_val;
    auto __current = __first + __i;
    if (__comp(*__current, __min_val)) {
      __init.__min_val = *__current;
      __init.__min_ind = __i;
    } else if (!__comp(*__current, __max_val)) {
      __init.__max_val = *__current;
      __init.__max_ind = __i;
    }
  }
  return std::make_pair(__first + __init.__min_ind, __first + __init.__max_ind);
}

template <class _InputIterator, class _DifferenceType, class _OutputIterator1,
          class _OutputIterator2, class _UnaryPredicate>
std::pair<_OutputIterator1, _OutputIterator2>
__simd_partition_copy(_InputIterator __first, _DifferenceType __n,
                      _OutputIterator1 __out_true, _OutputIterator2 __out_false,
                      _UnaryPredicate __pred) noexcept {
  _DifferenceType __cnt_true = 0, __cnt_false = 0;

#pragma omp simd
  for (_DifferenceType __i = 0; __i < __n; ++__i) {

    if (__pred(__first[__i])) {
      __out_true[__cnt_true] = __first[__i];
      ++__cnt_true;
    } else {
      __out_false[__cnt_false] = __first[__i];
      ++__cnt_false;
    }
  }
  return std::make_pair(__out_true + __cnt_true, __out_false + __cnt_false);
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
_ForwardIterator1
__simd_find_first_of(_ForwardIterator1 __first, _ForwardIterator1 __last,
                     _ForwardIterator2 __s_first, _ForwardIterator2 __s_last,
                     _BinaryPredicate __pred) noexcept {
  typedef typename std::iterator_traits<_ForwardIterator1>::difference_type
      _DifferencType;

  const _DifferencType __n1 = __last - __first;
  const _DifferencType __n2 = __s_last - __s_first;
  if (__n1 == 0 || __n2 == 0) {
    return __last;
  }

  if (__n1 < __n2) {
    for (; __first != __last; ++__first) {
      if (__unseq_backend::__simd_or(
              __s_first, __n2,
              __internal::__equal_value_by_pred<decltype(*__first),
                                                _BinaryPredicate>(*__first,
                                                                  __pred))) {
        return __first;
      }
    }
  } else {
    for (; __s_first != __s_last; ++__s_first) {
      const auto __result = __unseq_backend::__simd_first(
          __first, _DifferencType(0), __n1,
          [__s_first, &__pred](_ForwardIterator1 __it, _DifferencType __i) {
            return __pred(__it[__i], *__s_first);
          });
      if (__result != __last) {
        return __result;
      }
    }
  }
  return __last;
}

template <class _RandomAccessIterator, class _DifferenceType,
          class _UnaryPredicate>
_RandomAccessIterator __simd_remove_if(_RandomAccessIterator __first,
                                       _DifferenceType __n,
                                       _UnaryPredicate __pred) noexcept {

  auto __current = __unseq_backend::__simd_first(
      __first, _DifferenceType(0), __n,
      [&__pred](_RandomAccessIterator __it, _DifferenceType __i) {
        return __pred(__it[__i]);
      });
  __n -= __current - __first;

  if (__n < 2) {
    return __current;
  }

  _DifferenceType __cnt = 0;
#pragma omp simd
  for (_DifferenceType __i = 1; __i < __n; ++__i) {

    if (!__pred(__current[__i])) {
      __current[__cnt] = std::move(__current[__i]);
      ++__cnt;
    }
  }
  return __current + __cnt;
}
} // namespace __unseq_backend
} // namespace __pstl
# 16 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/memory_impl.h" 2 3

namespace __pstl {
namespace __internal {

template <typename _ForwardIterator, typename _OutputIterator>
_OutputIterator
__brick_uninitialized_move(_ForwardIterator __first, _ForwardIterator __last,
                           _OutputIterator __result, std::false_type) noexcept {
  using _ValueType = typename std::iterator_traits<_OutputIterator>::value_type;
  for (; __first != __last; ++__first, ++__result) {
    ::new (std::addressof(*__result)) _ValueType(std::move(*__first));
  }
  return __result;
}

template <typename _ForwardIterator, typename _OutputIterator>
_OutputIterator
__brick_uninitialized_move(_ForwardIterator __first, _ForwardIterator __last,
                           _OutputIterator __result, std::true_type) noexcept {
  using __ValueType =
      typename std::iterator_traits<_OutputIterator>::value_type;
  using _ReferenceType1 =
      typename std::iterator_traits<_ForwardIterator>::reference;
  using _ReferenceType2 =
      typename std::iterator_traits<_OutputIterator>::reference;

  return __unseq_backend::__simd_walk_2(
      __first, __last - __first, __result,
      [](_ReferenceType1 __x, _ReferenceType2 __y) {
        ::new (std::addressof(__y)) __ValueType(std::move(__x));
      });
}

template <typename _Iterator>
void __brick_destroy(_Iterator __first, _Iterator __last,
                     std::false_type) noexcept {
  using _ValueType = typename std::iterator_traits<_Iterator>::value_type;

  for (; __first != __last; ++__first)
    __first->~_ValueType();
}

template <typename _Iterator>
void __brick_destroy(_Iterator __first, _Iterator __last,
                     std::true_type) noexcept {
  using _ValueType = typename std::iterator_traits<_Iterator>::value_type;
  using _ReferenceType = typename std::iterator_traits<_Iterator>::reference;

  __unseq_backend::__simd_walk_1(__first, __last - __first,
                                 [](_ReferenceType __x) { __x.~_ValueType(); });
}

template <typename _ForwardIterator, typename _OutputIterator>
_OutputIterator
__brick_uninitialized_copy(_ForwardIterator __first, _ForwardIterator __last,
                           _OutputIterator __result, std::false_type) noexcept {
  using _ValueType = typename std::iterator_traits<_OutputIterator>::value_type;
  for (; __first != __last; ++__first, ++__result) {
    ::new (std::addressof(*__result)) _ValueType(*__first);
  }
  return __result;
}

template <typename _ForwardIterator, typename _OutputIterator>
_OutputIterator
__brick_uninitialized_copy(_ForwardIterator __first, _ForwardIterator __last,
                           _OutputIterator __result, std::true_type) noexcept {
  using __ValueType =
      typename std::iterator_traits<_OutputIterator>::value_type;
  using _ReferenceType1 =
      typename std::iterator_traits<_ForwardIterator>::reference;
  using _ReferenceType2 =
      typename std::iterator_traits<_OutputIterator>::reference;

  return __unseq_backend::__simd_walk_2(
      __first, __last - __first, __result,
      [](_ReferenceType1 __x, _ReferenceType2 __y) {
        ::new (std::addressof(__y)) __ValueType(__x);
      });
}

} // namespace __internal
} // namespace __pstl
# 21 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/algorithm_impl.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/parallel_backend_utils.h" 1 3
# 17 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/parallel_backend_utils.h" 3
namespace __pstl {

namespace __utils {

struct __serial_destroy {
  template <typename _RandomAccessIterator>
  void operator()(_RandomAccessIterator __zs, _RandomAccessIterator __ze) {
    typedef typename std::iterator_traits<_RandomAccessIterator>::value_type
        _ValueType;
    while (__zs != __ze) {
      --__ze;
      (*__ze).~_ValueType();
    }
  }
};

struct __serial_move_merge {
  const std::size_t _M_nmerge;

  explicit __serial_move_merge(std::size_t __nmerge) : _M_nmerge(__nmerge) {}
  template <class _RandomAccessIterator1, class _RandomAccessIterator2,
            class _RandomAccessIterator3, class _Compare, class _MoveValueX,
            class _MoveValueY, class _MoveSequenceX, class _MoveSequenceY>
  void operator()(_RandomAccessIterator1 __xs, _RandomAccessIterator1 __xe,
                  _RandomAccessIterator2 __ys, _RandomAccessIterator2 __ye,
                  _RandomAccessIterator3 __zs, _Compare __comp,
                  _MoveValueX __move_value_x, _MoveValueY __move_value_y,
                  _MoveSequenceX __move_sequence_x,
                  _MoveSequenceY __move_sequence_y) {
    constexpr bool __same_move_val =
        std::is_same<_MoveValueX, _MoveValueY>::value;
    constexpr bool __same_move_seq =
        std::is_same<_MoveSequenceX, _MoveSequenceY>::value;

    auto __n = _M_nmerge;
    do {
      if (std::__is_constant_evaluated() && !bool(__n > 0))
        __builtin_unreachable();
    } while (false);

    auto __nx = __xe - __xs;

    _RandomAccessIterator3 __zs_beg = __zs;

    if (__xs != __xe) {
      if (__ys != __ye) {
        for (;;) {
          if (__comp(*__ys, *__xs)) {
            const auto __i = __zs - __zs_beg;
            if (__i < __nx)
              __move_value_x(__ys, __zs);
            else
              __move_value_y(__ys, __zs);
            ++__zs, --__n;
            if (++__ys == __ye) {
              break;
            } else if (__n == 0) {
              const auto __j = __zs - __zs_beg;
              if (__same_move_seq || __j < __nx)
                __zs = __move_sequence_x(__ys, __ye, __zs);
              else
                __zs = __move_sequence_y(__ys, __ye, __zs);
              break;
            }
          } else {
            const auto __i = __zs - __zs_beg;
            if (__same_move_val || __i < __nx)
              __move_value_x(__xs, __zs);
            else
              __move_value_y(__xs, __zs);
            ++__zs, --__n;
            if (++__xs == __xe) {
              const auto __j = __zs - __zs_beg;
              if (__same_move_seq || __j < __nx)
                __move_sequence_x(__ys, __ye, __zs);
              else
                __move_sequence_y(__ys, __ye, __zs);
              return;
            } else if (__n == 0) {
              const auto __j = __zs - __zs_beg;
              if (__same_move_seq || __j < __nx) {
                __zs = __move_sequence_x(__xs, __xe, __zs);
                __move_sequence_x(__ys, __ye, __zs);
              } else {
                __zs = __move_sequence_y(__xs, __xe, __zs);
                __move_sequence_y(__ys, __ye, __zs);
              }
              return;
            }
          }
        }
      }
      __ys = __xs;
      __ye = __xe;
    }
    const auto __i = __zs - __zs_beg;
    if (__same_move_seq || __i < __nx)
      __move_sequence_x(__ys, __ye, __zs);
    else
      __move_sequence_y(__ys, __ye, __zs);
  }
};

template <typename _ForwardIterator1, typename _ForwardIterator2,
          typename _OutputIterator, typename _Compare,
          typename _CopyConstructRange>
_OutputIterator
__set_union_construct(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                      _OutputIterator __result, _Compare __comp,
                      _CopyConstructRange __cc_range) {
  using _Tp = typename std::iterator_traits<_OutputIterator>::value_type;

  for (; __first1 != __last1; ++__result) {
    if (__first2 == __last2)
      return __cc_range(__first1, __last1, __result);
    if (__comp(*__first2, *__first1)) {
      ::new (std::addressof(*__result)) _Tp(*__first2);
      ++__first2;
    } else {
      ::new (std::addressof(*__result)) _Tp(*__first1);
      if (!__comp(*__first1, *__first2))
        ++__first2;
      ++__first1;
    }
  }
  return __cc_range(__first2, __last2, __result);
}

template <typename _ForwardIterator1, typename _ForwardIterator2,
          typename _OutputIterator, typename _Compare>
_OutputIterator __set_intersection_construct(_ForwardIterator1 __first1,
                                             _ForwardIterator1 __last1,
                                             _ForwardIterator2 __first2,
                                             _ForwardIterator2 __last2,
                                             _OutputIterator __result,
                                             _Compare __comp) {
  using _Tp = typename std::iterator_traits<_OutputIterator>::value_type;

  for (; __first1 != __last1 && __first2 != __last2;) {
    if (__comp(*__first1, *__first2))
      ++__first1;
    else {
      if (!__comp(*__first2, *__first1)) {
        ::new (std::addressof(*__result)) _Tp(*__first1);
        ++__result;
        ++__first1;
      }
      ++__first2;
    }
  }
  return __result;
}

template <typename _ForwardIterator1, typename _ForwardIterator2,
          typename _OutputIterator, typename _Compare,
          typename _CopyConstructRange>
_OutputIterator __set_difference_construct(
    _ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _OutputIterator __result, _Compare __comp, _CopyConstructRange __cc_range) {
  using _Tp = typename std::iterator_traits<_OutputIterator>::value_type;

  for (; __first1 != __last1;) {
    if (__first2 == __last2)
      return __cc_range(__first1, __last1, __result);

    if (__comp(*__first1, *__first2)) {
      ::new (std::addressof(*__result)) _Tp(*__first1);
      ++__result;
      ++__first1;
    } else {
      if (!__comp(*__first2, *__first1))
        ++__first1;
      ++__first2;
    }
  }
  return __result;
}
template <typename _ForwardIterator1, typename _ForwardIterator2,
          typename _OutputIterator, typename _Compare,
          typename _CopyConstructRange>
_OutputIterator __set_symmetric_difference_construct(
    _ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _OutputIterator __result, _Compare __comp, _CopyConstructRange __cc_range) {
  using _Tp = typename std::iterator_traits<_OutputIterator>::value_type;

  for (; __first1 != __last1;) {
    if (__first2 == __last2)
      return __cc_range(__first1, __last1, __result);

    if (__comp(*__first1, *__first2)) {
      ::new (std::addressof(*__result)) _Tp(*__first1);
      ++__result;
      ++__first1;
    } else {
      if (__comp(*__first2, *__first1)) {
        ::new (std::addressof(*__result)) _Tp(*__first2);
        ++__result;
      } else
        ++__first1;
      ++__first2;
    }
  }
  return __cc_range(__first2, __last2, __result);
}

} // namespace __utils
} // namespace __pstl
# 22 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/algorithm_impl.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/parallel_backend.h" 1 3
# 14 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/parallel_backend.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/parallel_backend_serial.h" 1 3
# 19 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/parallel_backend_serial.h" 3
namespace __pstl {
namespace __serial_backend {

template <typename _Tp> class __buffer {
  std::allocator<_Tp> __allocator_;
  _Tp *__ptr_;
  const std::size_t __buf_size_;
  __buffer(const __buffer &) = delete;
  void operator=(const __buffer &) = delete;

public:
  __buffer(std::size_t __n)
      : __allocator_(), __ptr_(__allocator_.allocate(__n)), __buf_size_(__n) {}

  operator bool() const { return __ptr_ != nullptr; }
  _Tp *get() const { return __ptr_; }
  ~__buffer() { __allocator_.deallocate(__ptr_, __buf_size_); }
};

inline void __cancel_execution() {}

template <class _ExecutionPolicy, class _Index, class _Fp>
void __parallel_for(_ExecutionPolicy &&, _Index __first, _Index __last,
                    _Fp __f) {
  __f(__first, __last);
}

template <class _ExecutionPolicy, class _Value, class _Index,
          typename _RealBody, typename _Reduction>
_Value __parallel_reduce(_ExecutionPolicy &&, _Index __first, _Index __last,
                         const _Value &__identity, const _RealBody &__real_body,
                         const _Reduction &) {
  if (__first == __last) {
    return __identity;
  } else {
    return __real_body(__first, __last, __identity);
  }
}

template <class _ExecutionPolicy, class _Index, class _UnaryOp, class _Tp,
          class _BinaryOp, class _Reduce>
_Tp __parallel_transform_reduce(_ExecutionPolicy &&, _Index __first,
                                _Index __last, _UnaryOp, _Tp __init, _BinaryOp,
                                _Reduce __reduce) {
  return __reduce(__first, __last, __init);
}

template <class _ExecutionPolicy, typename _Index, typename _Tp, typename _Rp,
          typename _Cp, typename _Sp, typename _Ap>
void __parallel_strict_scan(_ExecutionPolicy &&, _Index __n, _Tp __initial,
                            _Rp __reduce, _Cp __combine, _Sp __scan,
                            _Ap __apex) {
  _Tp __sum = __initial;
  if (__n)
    __sum = __combine(__sum, __reduce(_Index(0), __n));
  __apex(__sum);
  if (__n)
    __scan(_Index(0), __n, __initial);
}

template <class _ExecutionPolicy, class _Index, class _UnaryOp, class _Tp,
          class _BinaryOp, class _Reduce, class _Scan>
_Tp __parallel_transform_scan(_ExecutionPolicy &&, _Index __n, _UnaryOp,
                              _Tp __init, _BinaryOp, _Reduce, _Scan __scan) {
  return __scan(_Index(0), __n, __init);
}

template <class _ExecutionPolicy, typename _RandomAccessIterator,
          typename _Compare, typename _LeafSort>
void __parallel_stable_sort(_ExecutionPolicy &&, _RandomAccessIterator __first,
                            _RandomAccessIterator __last, _Compare __comp,
                            _LeafSort __leaf_sort, std::size_t = 0) {
  __leaf_sort(__first, __last, __comp);
}

template <class _ExecutionPolicy, typename _RandomAccessIterator1,
          typename _RandomAccessIterator2, typename _RandomAccessIterator3,
          typename _Compare, typename _LeafMerge>
void __parallel_merge(_ExecutionPolicy &&, _RandomAccessIterator1 __first1,
                      _RandomAccessIterator1 __last1,
                      _RandomAccessIterator2 __first2,
                      _RandomAccessIterator2 __last2,
                      _RandomAccessIterator3 __outit, _Compare __comp,
                      _LeafMerge __leaf_merge) {
  __leaf_merge(__first1, __last1, __first2, __last2, __outit, __comp);
}

template <class _ExecutionPolicy, typename _F1, typename _F2>
void __parallel_invoke(_ExecutionPolicy &&, _F1 &&__f1, _F2 &&__f2) {
  std::forward<_F1>(__f1)();
  std::forward<_F2>(__f2)();
}

} // namespace __serial_backend
} // namespace __pstl
# 15 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/parallel_backend.h" 2 3
namespace __pstl {
namespace __par_backend = __serial_backend;
}
# 23 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/algorithm_impl.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/parallel_impl.h" 1 3
# 17 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/parallel_impl.h" 3
namespace __pstl {
namespace __internal {

template <class _ExecutionPolicy, class _Index, class _Brick, class _Compare>
_Index __parallel_find(_ExecutionPolicy &&__exec, _Index __first, _Index __last,
                       _Brick __f, _Compare __comp, bool __b_first) {
  typedef
      typename std::iterator_traits<_Index>::difference_type _DifferenceType;
  const _DifferenceType __n = __last - __first;
  _DifferenceType __initial_dist = __b_first ? __n : -1;
  std::atomic<_DifferenceType> __extremum(__initial_dist);

  __par_backend::__parallel_for(
      std::forward<_ExecutionPolicy>(__exec), __first, __last,
      [__comp, __f, __first, &__extremum](_Index __i, _Index __j) {
        if (__comp(__i - __first, __extremum)) {
          _Index __res = __f(__i, __j);

          if (__res != __j) {
            const _DifferenceType __k = __res - __first;
            for (_DifferenceType __old = __extremum; __comp(__k, __old);
                 __old = __extremum) {
              __extremum.compare_exchange_weak(__old, __k);
            }
          }
        }
      });
  return __extremum != __initial_dist ? __first + __extremum : __last;
}

template <class _ExecutionPolicy, class _Index, class _Brick>
bool __parallel_or(_ExecutionPolicy &&__exec, _Index __first, _Index __last,
                   _Brick __f) {
  std::atomic<bool> __found(false);
  __par_backend::__parallel_for(
      std::forward<_ExecutionPolicy>(__exec), __first, __last,
      [__f, &__found](_Index __i, _Index __j) {
        if (!__found.load(std::memory_order_relaxed) && __f(__i, __j)) {
          __found.store(true, std::memory_order_relaxed);
          __par_backend::__cancel_execution();
        }
      });
  return __found;
}

} // namespace __internal
} // namespace __pstl
# 24 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/algorithm_impl.h" 2 3

namespace __pstl {
namespace __internal {

template <class _ForwardIterator, class _Pred>
bool __brick_any_of(const _ForwardIterator __first,
                    const _ForwardIterator __last, _Pred __pred,
                    std::false_type) noexcept {
  return std::any_of(__first, __last, __pred);
};

template <class _ForwardIterator, class _Pred>
bool __brick_any_of(const _ForwardIterator __first,
                    const _ForwardIterator __last, _Pred __pred,
                    std::true_type) noexcept {
  return __unseq_backend::__simd_or(__first, __last - __first, __pred);
};

template <class _ExecutionPolicy, class _ForwardIterator, class _Pred,
          class _IsVector>
bool __pattern_any_of(_ExecutionPolicy &&, _ForwardIterator __first,
                      _ForwardIterator __last, _Pred __pred,
                      _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_any_of(__first, __last, __pred, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Pred,
          class _IsVector>
bool __pattern_any_of(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                      _ForwardIterator __last, _Pred __pred,
                      _IsVector __is_vector, std::true_type) {
  return __internal::__except_handler([&]() {
    return __internal::__parallel_or(
        std::forward<_ExecutionPolicy>(__exec), __first, __last,
        [__pred, __is_vector](_ForwardIterator __i, _ForwardIterator __j) {
          return __internal::__brick_any_of(__i, __j, __pred, __is_vector);
        });
  });
}

template <class _ForwardIterator, class _Size, class _Function>
_ForwardIterator __for_each_n_it_serial(_ForwardIterator __first, _Size __n,
                                        _Function __f) {
  for (; __n > 0; ++__first, --__n)
    __f(__first);
  return __first;
}

template <class _ForwardIterator, class _Function>
void __brick_walk1(_ForwardIterator __first, _ForwardIterator __last,
                   _Function __f, std::false_type) noexcept {
  std::for_each(__first, __last, __f);
}

template <class _RandomAccessIterator, class _Function>
void __brick_walk1(_RandomAccessIterator __first, _RandomAccessIterator __last,
                   _Function __f, std::true_type) noexcept {
  __unseq_backend::__simd_walk_1(__first, __last - __first, __f);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Function,
          class _IsVector>
void __pattern_walk1(_ExecutionPolicy &&, _ForwardIterator __first,
                     _ForwardIterator __last, _Function __f,
                     _IsVector __is_vector, std::false_type) noexcept {
  __internal::__brick_walk1(__first, __last, __f, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Function,
          class _IsVector>
void __pattern_walk1(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                     _ForwardIterator __last, _Function __f,
                     _IsVector __is_vector, std::true_type) {
  __internal::__except_handler([&]() {
    __par_backend::__parallel_for(
        std::forward<_ExecutionPolicy>(__exec), __first, __last,
        [__f, __is_vector](_ForwardIterator __i, _ForwardIterator __j) {
          __internal::__brick_walk1(__i, __j, __f, __is_vector);
        });
  });
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Brick>
void __pattern_walk_brick(_ExecutionPolicy &&, _ForwardIterator __first,
                          _ForwardIterator __last, _Brick __brick,
                          std::false_type) noexcept {
  __brick(__first, __last);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Brick>
void __pattern_walk_brick(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                          _ForwardIterator __last, _Brick __brick,
                          std::true_type) {
  __internal::__except_handler([&]() {
    __par_backend::__parallel_for(
        std::forward<_ExecutionPolicy>(__exec), __first, __last,
        [__brick](_ForwardIterator __i, _ForwardIterator __j) {
          __brick(__i, __j);
        });
  });
}

template <class _ForwardIterator, class _Size, class _Function>
_ForwardIterator __brick_walk1_n(_ForwardIterator __first, _Size __n,
                                 _Function __f, std::false_type) {
  return __internal::__for_each_n_it_serial(
      __first, __n, [&__f](_ForwardIterator __it) { __f(*__it); });
}

template <class _RandomAccessIterator, class _DifferenceType, class _Function>
_RandomAccessIterator __brick_walk1_n(_RandomAccessIterator __first,
                                      _DifferenceType __n, _Function __f,
                                      std::true_type) noexcept {
  return __unseq_backend::__simd_walk_1(__first, __n, __f);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Function, class _IsVector>
_ForwardIterator __pattern_walk1_n(_ExecutionPolicy &&,
                                   _ForwardIterator __first, _Size __n,
                                   _Function __f, _IsVector __is_vector,
                                   std::false_type) noexcept {
  return __internal::__brick_walk1_n(__first, __n, __f, __is_vector);
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Size,
          class _Function, class _IsVector>
_RandomAccessIterator __pattern_walk1_n(_ExecutionPolicy &&__exec,
                                        _RandomAccessIterator __first,
                                        _Size __n, _Function __f,
                                        _IsVector __is_vector, std::true_type) {
  __internal::__pattern_walk1(std::forward<_ExecutionPolicy>(__exec), __first,
                              __first + __n, __f, __is_vector,
                              std::true_type());
  return __first + __n;
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Brick>
_ForwardIterator
__pattern_walk_brick_n(_ExecutionPolicy &&, _ForwardIterator __first, _Size __n,
                       _Brick __brick, std::false_type) noexcept {
  return __brick(__first, __n);
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Size,
          class _Brick>
_RandomAccessIterator
__pattern_walk_brick_n(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
                       _Size __n, _Brick __brick, std::true_type) {
  return __internal::__except_handler([&]() {
    __par_backend::__parallel_for(
        std::forward<_ExecutionPolicy>(__exec), __first, __first + __n,
        [__brick](_RandomAccessIterator __i, _RandomAccessIterator __j) {
          __brick(__i, __j - __i);
        });
    return __first + __n;
  });
}

template <class _ForwardIterator1, class _ForwardIterator2, class _Function>
_ForwardIterator2 __brick_walk2(_ForwardIterator1 __first1,
                                _ForwardIterator1 __last1,
                                _ForwardIterator2 __first2, _Function __f,
                                std::false_type) noexcept {
  for (; __first1 != __last1; ++__first1, ++__first2)
    __f(*__first1, *__first2);
  return __first2;
}

template <class _ForwardIterator1, class _ForwardIterator2, class _Function>
_ForwardIterator2 __brick_walk2(_ForwardIterator1 __first1,
                                _ForwardIterator1 __last1,
                                _ForwardIterator2 __first2, _Function __f,
                                std::true_type) noexcept {
  return __unseq_backend::__simd_walk_2(__first1, __last1 - __first1, __first2,
                                        __f);
}

template <class _ForwardIterator1, class _Size, class _ForwardIterator2,
          class _Function>
_ForwardIterator2 __brick_walk2_n(_ForwardIterator1 __first1, _Size __n,
                                  _ForwardIterator2 __first2, _Function __f,
                                  std::false_type) noexcept {
  for (; __n > 0; --__n, ++__first1, ++__first2)
    __f(*__first1, *__first2);
  return __first2;
}

template <class _ForwardIterator1, class _Size, class _ForwardIterator2,
          class _Function>
_ForwardIterator2 __brick_walk2_n(_ForwardIterator1 __first1, _Size __n,
                                  _ForwardIterator2 __first2, _Function __f,
                                  std::true_type) noexcept {
  return __unseq_backend::__simd_walk_2(__first1, __n, __first2, __f);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Function, class _IsVector>
_ForwardIterator2
__pattern_walk2(_ExecutionPolicy &&, _ForwardIterator1 __first1,
                _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                _Function __f, _IsVector __is_vector,
                std::false_type) noexcept {
  return __internal::__brick_walk2(__first1, __last1, __first2, __f,
                                   __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Function, class _IsVector>
_ForwardIterator2
__pattern_walk2(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                _Function __f, _IsVector __is_vector, std::true_type) {
  return __internal::__except_handler([&]() {
    __par_backend::__parallel_for(
        std::forward<_ExecutionPolicy>(__exec), __first1, __last1,
        [__f, __first1, __first2, __is_vector](_ForwardIterator1 __i,
                                               _ForwardIterator1 __j) {
          __internal::__brick_walk2(__i, __j, __first2 + (__i - __first1), __f,
                                    __is_vector);
        });
    return __first2 + (__last1 - __first1);
  });
}

template <class _ExecutionPolicy, class _ForwardIterator1, class _Size,
          class _ForwardIterator2, class _Function, class _IsVector>
_ForwardIterator2
__pattern_walk2_n(_ExecutionPolicy &&, _ForwardIterator1 __first1, _Size __n,
                  _ForwardIterator2 __first2, _Function __f,
                  _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_walk2_n(__first1, __n, __first2, __f, __is_vector);
}

template <class _ExecutionPolicy, class _RandomAccessIterator1, class _Size,
          class _RandomAccessIterator2, class _Function, class _IsVector>
_RandomAccessIterator2
__pattern_walk2_n(_ExecutionPolicy &&__exec, _RandomAccessIterator1 __first1,
                  _Size __n, _RandomAccessIterator2 __first2, _Function __f,
                  _IsVector __is_vector, std::true_type) {
  return __internal::__pattern_walk2(std::forward<_ExecutionPolicy>(__exec),
                                     __first1, __first1 + __n, __first2, __f,
                                     __is_vector, std::true_type());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Brick>
_ForwardIterator2
__pattern_walk2_brick(_ExecutionPolicy &&, _ForwardIterator1 __first1,
                      _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                      _Brick __brick, std::false_type) noexcept {
  return __brick(__first1, __last1, __first2);
}

template <class _ExecutionPolicy, class _RandomAccessIterator1,
          class _RandomAccessIterator2, class _Brick>
_RandomAccessIterator2 __pattern_walk2_brick(_ExecutionPolicy &&__exec,
                                             _RandomAccessIterator1 __first1,
                                             _RandomAccessIterator1 __last1,
                                             _RandomAccessIterator2 __first2,
                                             _Brick __brick, std::true_type) {
  return __internal::__except_handler([&]() {
    __par_backend::__parallel_for(
        std::forward<_ExecutionPolicy>(__exec), __first1, __last1,
        [__first1, __first2, __brick](_RandomAccessIterator1 __i,
                                      _RandomAccessIterator1 __j) {
          __brick(__i, __j, __first2 + (__i - __first1));
        });
    return __first2 + (__last1 - __first1);
  });
}

template <class _ExecutionPolicy, class _RandomAccessIterator1, class _Size,
          class _RandomAccessIterator2, class _Brick>
_RandomAccessIterator2 __pattern_walk2_brick_n(_ExecutionPolicy &&__exec,
                                               _RandomAccessIterator1 __first1,
                                               _Size __n,
                                               _RandomAccessIterator2 __first2,
                                               _Brick __brick, std::true_type) {
  return __internal::__except_handler([&]() {
    __par_backend::__parallel_for(
        std::forward<_ExecutionPolicy>(__exec), __first1, __first1 + __n,
        [__first1, __first2, __brick](_RandomAccessIterator1 __i,
                                      _RandomAccessIterator1 __j) {
          __brick(__i, __j - __i, __first2 + (__i - __first1));
        });
    return __first2 + __n;
  });
}

template <class _ExecutionPolicy, class _ForwardIterator1, class _Size,
          class _ForwardIterator2, class _Brick>
_ForwardIterator2
__pattern_walk2_brick_n(_ExecutionPolicy &&, _ForwardIterator1 __first1,
                        _Size __n, _ForwardIterator2 __first2, _Brick __brick,
                        std::false_type) noexcept {
  return __brick(__first1, __n, __first2);
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _ForwardIterator3, class _Function>
_ForwardIterator3
__brick_walk3(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator3 __first3,
              _Function __f, std::false_type) noexcept {
  for (; __first1 != __last1; ++__first1, ++__first2, ++__first3)
    __f(*__first1, *__first2, *__first3);
  return __first3;
}

template <class _RandomAccessIterator1, class _RandomAccessIterator2,
          class _RandomAccessIterator3, class _Function>
_RandomAccessIterator3
__brick_walk3(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
              _RandomAccessIterator2 __first2, _RandomAccessIterator3 __first3,
              _Function __f, std::true_type) noexcept {
  return __unseq_backend::__simd_walk_3(__first1, __last1 - __first1, __first2,
                                        __first3, __f);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator3, class _Function,
          class _IsVector>
_ForwardIterator3
__pattern_walk3(_ExecutionPolicy &&, _ForwardIterator1 __first1,
                _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                _ForwardIterator3 __first3, _Function __f,
                _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_walk3(__first1, __last1, __first2, __first3, __f,
                                   __is_vector);
}

template <class _ExecutionPolicy, class _RandomAccessIterator1,
          class _RandomAccessIterator2, class _RandomAccessIterator3,
          class _Function, class _IsVector>
_RandomAccessIterator3
__pattern_walk3(_ExecutionPolicy &&__exec, _RandomAccessIterator1 __first1,
                _RandomAccessIterator1 __last1, _RandomAccessIterator2 __first2,
                _RandomAccessIterator3 __first3, _Function __f,
                _IsVector __is_vector, std::true_type) {
  return __internal::__except_handler([&]() {
    __par_backend::__parallel_for(
        std::forward<_ExecutionPolicy>(__exec), __first1, __last1,
        [__f, __first1, __first2, __first3,
         __is_vector](_RandomAccessIterator1 __i, _RandomAccessIterator1 __j) {
          __internal::__brick_walk3(__i, __j, __first2 + (__i - __first1),
                                    __first3 + (__i - __first1), __f,
                                    __is_vector);
        });
    return __first3 + (__last1 - __first1);
  });
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
bool __brick_equal(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                   _BinaryPredicate __p, std::false_type) noexcept {
  return std::equal(__first1, __last1, __first2, __last2, __p);
}

template <class _RandomAccessIterator1, class _RandomAccessIterator2,
          class _BinaryPredicate>
bool __brick_equal(_RandomAccessIterator1 __first1,
                   _RandomAccessIterator1 __last1,
                   _RandomAccessIterator2 __first2,
                   _RandomAccessIterator2 __last2, _BinaryPredicate __p,
                   std::true_type) noexcept {
  if (__last1 - __first1 != __last2 - __first2)
    return false;

  return __unseq_backend::__simd_first(__first1, __last1 - __first1, __first2,
                                       std::not_fn(__p))
             .first == __last1;
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate, class _IsVector>
bool __pattern_equal(_ExecutionPolicy &&, _ForwardIterator1 __first1,
                     _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                     _ForwardIterator2 __last2, _BinaryPredicate __p,
                     _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_equal(__first1, __last1, __first2, __last2, __p,
                                   __is_vector);
}

template <class _ExecutionPolicy, class _RandomAccessIterator1,
          class _RandomAccessIterator2, class _BinaryPredicate, class _IsVector>
bool __pattern_equal(_ExecutionPolicy &&__exec, _RandomAccessIterator1 __first1,
                     _RandomAccessIterator1 __last1,
                     _RandomAccessIterator2 __first2,
                     _RandomAccessIterator2 __last2, _BinaryPredicate __p,
                     _IsVector __is_vector, std::true_type) {
  if (__last1 - __first1 != __last2 - __first2)
    return false;

  return __internal::__except_handler([&]() {
    return !__internal::__parallel_or(
        std::forward<_ExecutionPolicy>(__exec), __first1, __last1,
        [__first1, __first2, __p, __is_vector](_RandomAccessIterator1 __i,
                                               _RandomAccessIterator1 __j) {
          return !__internal::__brick_equal(
              __i, __j, __first2 + (__i - __first1),
              __first2 + (__j - __first1), __p, __is_vector);
        });
  });
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
bool __brick_equal(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                   _ForwardIterator2 __first2, _BinaryPredicate __p,
                   std::false_type) noexcept {
  return std::equal(__first1, __last1, __first2, __p);
}

template <class _RandomAccessIterator1, class _RandomAccessIterator2,
          class _BinaryPredicate>
bool __brick_equal(_RandomAccessIterator1 __first1,
                   _RandomAccessIterator1 __last1,
                   _RandomAccessIterator2 __first2, _BinaryPredicate __p,
                   std::true_type) noexcept {
  return __unseq_backend::__simd_first(__first1, __last1 - __first1, __first2,
                                       std::not_fn(__p))
             .first == __last1;
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate, class _IsVector>
bool __pattern_equal(_ExecutionPolicy &&, _ForwardIterator1 __first1,
                     _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                     _BinaryPredicate __p, _IsVector __is_vector,
                     std::false_type) noexcept {
  return __internal::__brick_equal(__first1, __last1, __first2, __p,
                                   __is_vector);
}

template <class _ExecutionPolicy, class _RandomAccessIterator1,
          class _RandomAccessIterator2, class _BinaryPredicate, class _IsVector>
bool __pattern_equal(_ExecutionPolicy &&__exec, _RandomAccessIterator1 __first1,
                     _RandomAccessIterator1 __last1,
                     _RandomAccessIterator2 __first2, _BinaryPredicate __p,
                     _IsVector __is_vector, std::true_type) {
  return __internal::__except_handler([&]() {
    return !__internal::__parallel_or(
        std::forward<_ExecutionPolicy>(__exec), __first1, __last1,
        [__first1, __first2, __p, __is_vector](_RandomAccessIterator1 __i,
                                               _RandomAccessIterator1 __j) {
          return !__internal::__brick_equal(
              __i, __j, __first2 + (__i - __first1), __p, __is_vector);
        });
  });
}

template <class _ForwardIterator, class _Predicate>
_ForwardIterator __brick_find_if(_ForwardIterator __first,
                                 _ForwardIterator __last, _Predicate __pred,
                                 std::false_type) noexcept {
  return std::find_if(__first, __last, __pred);
}

template <class _RandomAccessIterator, class _Predicate>
_RandomAccessIterator
__brick_find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
                _Predicate __pred, std::true_type) noexcept {
  typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type
      _SizeType;
  return __unseq_backend::__simd_first(
      __first, _SizeType(0), __last - __first,
      [&__pred](_RandomAccessIterator __it, _SizeType __i) {
        return __pred(__it[__i]);
      });
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate,
          class _IsVector>
_ForwardIterator
__pattern_find_if(_ExecutionPolicy &&, _ForwardIterator __first,
                  _ForwardIterator __last, _Predicate __pred,
                  _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_find_if(__first, __last, __pred, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate,
          class _IsVector>
_ForwardIterator __pattern_find_if(_ExecutionPolicy &&__exec,
                                   _ForwardIterator __first,
                                   _ForwardIterator __last, _Predicate __pred,
                                   _IsVector __is_vector, std::true_type) {
  return __internal::__except_handler([&]() {
    return __internal::__parallel_find(
        std::forward<_ExecutionPolicy>(__exec), __first, __last,
        [__pred, __is_vector](_ForwardIterator __i, _ForwardIterator __j) {
          return __internal::__brick_find_if(__i, __j, __pred, __is_vector);
        },
        std::less<
            typename std::iterator_traits<_ForwardIterator>::difference_type>(),
        true);
  });
}
# 538 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/algorithm_impl.h" 3
template <class _RandomAccessIterator1, class _RandomAccessIterator2,
          class _BinaryPredicate, class _IsVector>
_RandomAccessIterator1
__find_subrange(_RandomAccessIterator1 __first, _RandomAccessIterator1 __last,
                _RandomAccessIterator1 __global_last,
                _RandomAccessIterator2 __s_first,
                _RandomAccessIterator2 __s_last, _BinaryPredicate __pred,
                bool __b_first, _IsVector __is_vector) noexcept {
  typedef typename std::iterator_traits<_RandomAccessIterator2>::value_type
      _ValueType;
  auto __n2 = __s_last - __s_first;
  if (__n2 < 1) {
    return __b_first ? __first : __last;
  }

  auto __n1 = __global_last - __first;
  if (__n1 < __n2) {
    return __last;
  }

  auto __cur = __last;
  while (__first != __last && (__global_last - __first >= __n2)) {

    __first = __internal::__brick_find_if(
        __first, __last,
        __equal_value_by_pred<_ValueType, _BinaryPredicate>(*__s_first, __pred),
        __is_vector);

    if (__first != __last && (__global_last - __first >= __n2) &&
        __internal::__brick_equal(__s_first + 1, __s_last, __first + 1, __pred,
                                  __is_vector)) {
      if (__b_first) {
        return __first;
      } else {
        __cur = __first;
      }
    } else if (__first == __last) {
      break;
    } else {
    }

    ++__first;
  }
  return __cur;
}

template <class _RandomAccessIterator, class _Size, class _Tp,
          class _BinaryPredicate, class _IsVector>
_RandomAccessIterator
__find_subrange(_RandomAccessIterator __first, _RandomAccessIterator __last,
                _RandomAccessIterator __global_last, _Size __count,
                const _Tp &__value, _BinaryPredicate __pred,
                _IsVector __is_vector) noexcept {
  if (static_cast<_Size>(__global_last - __first) < __count || __count < 1) {
    return __last;
  }

  auto __unary_pred =
      __equal_value_by_pred<_Tp, _BinaryPredicate>(__value, __pred);
  while (__first != __last &&
         (static_cast<_Size>(__global_last - __first) >= __count)) {
    __first =
        __internal::__brick_find_if(__first, __last, __unary_pred, __is_vector);

    if (__first != __last &&
        (static_cast<_Size>(__global_last - __first) >= __count) &&
        !__internal::__brick_any_of(__first + 1, __first + __count,
                                    std::not_fn(__unary_pred), __is_vector)) {
      return __first;
    } else if (__first == __last) {
      break;
    } else {
      ++__first;
    }
  }
  return __last;
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
_ForwardIterator1
__brick_find_end(_ForwardIterator1 __first, _ForwardIterator1 __last,
                 _ForwardIterator2 __s_first, _ForwardIterator2 __s_last,
                 _BinaryPredicate __pred, std::false_type) noexcept {
  return std::find_end(__first, __last, __s_first, __s_last, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
_ForwardIterator1
__brick_find_end(_ForwardIterator1 __first, _ForwardIterator1 __last,
                 _ForwardIterator2 __s_first, _ForwardIterator2 __s_last,
                 _BinaryPredicate __pred, std::true_type) noexcept {
  return __find_subrange(__first, __last, __last, __s_first, __s_last, __pred,
                         false, std::true_type());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate, class _IsVector>
_ForwardIterator1
__pattern_find_end(_ExecutionPolicy &&, _ForwardIterator1 __first,
                   _ForwardIterator1 __last, _ForwardIterator2 __s_first,
                   _ForwardIterator2 __s_last, _BinaryPredicate __pred,
                   _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_find_end(__first, __last, __s_first, __s_last,
                                      __pred, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate, class _IsVector>
_ForwardIterator1
__pattern_find_end(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
                   _ForwardIterator1 __last, _ForwardIterator2 __s_first,
                   _ForwardIterator2 __s_last, _BinaryPredicate __pred,
                   _IsVector __is_vector, std::true_type) noexcept {
  if (__last - __first == __s_last - __s_first) {
    const bool __res = __internal::__pattern_equal(
        std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first,
        __pred, __is_vector, std::true_type());
    return __res ? __first : __last;
  } else {
    return __internal::__except_handler([&]() {
      return __internal::__parallel_find(
          std::forward<_ExecutionPolicy>(__exec), __first, __last,
          [__last, __s_first, __s_last, __pred,
           __is_vector](_ForwardIterator1 __i, _ForwardIterator1 __j) {
            return __internal::__find_subrange(__i, __j, __last, __s_first,
                                               __s_last, __pred, false,
                                               __is_vector);
          },
          std::greater<typename std::iterator_traits<
              _ForwardIterator1>::difference_type>(),
          false);
    });
  }
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
_ForwardIterator1
__brick_find_first_of(_ForwardIterator1 __first, _ForwardIterator1 __last,
                      _ForwardIterator2 __s_first, _ForwardIterator2 __s_last,
                      _BinaryPredicate __pred, std::false_type) noexcept {
  return std::find_first_of(__first, __last, __s_first, __s_last, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
_ForwardIterator1
__brick_find_first_of(_ForwardIterator1 __first, _ForwardIterator1 __last,
                      _ForwardIterator2 __s_first, _ForwardIterator2 __s_last,
                      _BinaryPredicate __pred, std::true_type) noexcept {
  return __unseq_backend::__simd_find_first_of(__first, __last, __s_first,
                                               __s_last, __pred);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate, class _IsVector>
_ForwardIterator1
__pattern_find_first_of(_ExecutionPolicy &&, _ForwardIterator1 __first,
                        _ForwardIterator1 __last, _ForwardIterator2 __s_first,
                        _ForwardIterator2 __s_last, _BinaryPredicate __pred,
                        _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_find_first_of(__first, __last, __s_first, __s_last,
                                           __pred, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate, class _IsVector>
_ForwardIterator1
__pattern_find_first_of(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
                        _ForwardIterator1 __last, _ForwardIterator2 __s_first,
                        _ForwardIterator2 __s_last, _BinaryPredicate __pred,
                        _IsVector __is_vector, std::true_type) noexcept {
  return __internal::__except_handler([&]() {
    return __internal::__parallel_find(
        std::forward<_ExecutionPolicy>(__exec), __first, __last,
        [__s_first, __s_last, __pred, __is_vector](_ForwardIterator1 __i,
                                                   _ForwardIterator1 __j) {
          return __internal::__brick_find_first_of(
              __i, __j, __s_first, __s_last, __pred, __is_vector);
        },
        std::less<typename std::iterator_traits<
            _ForwardIterator1>::difference_type>(),
        true);
  });
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
_ForwardIterator1
__brick_search(_ForwardIterator1 __first, _ForwardIterator1 __last,
               _ForwardIterator2 __s_first, _ForwardIterator2 __s_last,
               _BinaryPredicate __pred, std::false_type) noexcept {
  return std::search(__first, __last, __s_first, __s_last, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
_ForwardIterator1
__brick_search(_ForwardIterator1 __first, _ForwardIterator1 __last,
               _ForwardIterator2 __s_first, _ForwardIterator2 __s_last,
               _BinaryPredicate __pred, std::true_type) noexcept {
  return __internal::__find_subrange(__first, __last, __last, __s_first,
                                     __s_last, __pred, true, std::true_type());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate, class _IsVector>
_ForwardIterator1
__pattern_search(_ExecutionPolicy &&, _ForwardIterator1 __first,
                 _ForwardIterator1 __last, _ForwardIterator2 __s_first,
                 _ForwardIterator2 __s_last, _BinaryPredicate __pred,
                 _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_search(__first, __last, __s_first, __s_last,
                                    __pred, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate, class _IsVector>
_ForwardIterator1
__pattern_search(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
                 _ForwardIterator1 __last, _ForwardIterator2 __s_first,
                 _ForwardIterator2 __s_last, _BinaryPredicate __pred,
                 _IsVector __is_vector, std::true_type) noexcept {
  if (__last - __first == __s_last - __s_first) {
    const bool __res = __internal::__pattern_equal(
        std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first,
        __pred, __is_vector, std::true_type());
    return __res ? __first : __last;
  } else {
    return __internal::__except_handler([&]() {
      return __internal::__parallel_find(
          std::forward<_ExecutionPolicy>(__exec), __first, __last,
          [__last, __s_first, __s_last, __pred,
           __is_vector](_ForwardIterator1 __i, _ForwardIterator1 __j) {
            return __internal::__find_subrange(__i, __j, __last, __s_first,
                                               __s_last, __pred, true,
                                               __is_vector);
          },
          std::less<typename std::iterator_traits<
              _ForwardIterator1>::difference_type>(),
          true);
    });
  }
}

template <class _ForwardIterator, class _Size, class _Tp,
          class _BinaryPredicate>
_ForwardIterator __brick_search_n(_ForwardIterator __first,
                                  _ForwardIterator __last, _Size __count,
                                  const _Tp &__value, _BinaryPredicate __pred,
                                  std::false_type) noexcept {
  return std::search_n(__first, __last, __count, __value, __pred);
}

template <class _ForwardIterator, class _Size, class _Tp,
          class _BinaryPredicate>
_ForwardIterator __brick_search_n(_ForwardIterator __first,
                                  _ForwardIterator __last, _Size __count,
                                  const _Tp &__value, _BinaryPredicate __pred,
                                  std::true_type) noexcept {
  return __internal::__find_subrange(__first, __last, __last, __count, __value,
                                     __pred, std::true_type());
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Tp, class _BinaryPredicate, class _IsVector>
_ForwardIterator
__pattern_search_n(_ExecutionPolicy &&, _ForwardIterator __first,
                   _ForwardIterator __last, _Size __count, const _Tp &__value,
                   _BinaryPredicate __pred, _IsVector __is_vector,
                   std::false_type) noexcept {
  return __internal::__brick_search_n(__first, __last, __count, __value, __pred,
                                      __is_vector);
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Size,
          class _Tp, class _BinaryPredicate, class _IsVector>
_RandomAccessIterator
__pattern_search_n(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
                   _RandomAccessIterator __last, _Size __count,
                   const _Tp &__value, _BinaryPredicate __pred,
                   _IsVector __is_vector, std::true_type) noexcept {
  if (static_cast<_Size>(__last - __first) == __count) {
    const bool __result = !__internal::__pattern_any_of(
        std::forward<_ExecutionPolicy>(__exec), __first, __last,
        [&__value, &__pred](const _Tp &__val) {
          return !__pred(__val, __value);
        },
        __is_vector, std::true_type());
    return __result ? __first : __last;
  } else {
    return __internal::__except_handler([&__exec, __first, __last, __count,
                                         &__value, __pred, __is_vector]() {
      return __internal::__parallel_find(
          std::forward<_ExecutionPolicy>(__exec), __first, __last,
          [__last, __count, &__value, __pred,
           __is_vector](_RandomAccessIterator __i, _RandomAccessIterator __j) {
            return __internal::__find_subrange(__i, __j, __last, __count,
                                               __value, __pred, __is_vector);
          },
          std::less<typename std::iterator_traits<
              _RandomAccessIterator>::difference_type>(),
          true);
    });
  }
}

template <class _ForwardIterator, class _Size, class _OutputIterator>
_OutputIterator __brick_copy_n(_ForwardIterator __first, _Size __n,
                               _OutputIterator __result,
                               std::false_type) noexcept {
  return std::copy_n(__first, __n, __result);
}

template <class _ForwardIterator, class _Size, class _OutputIterator>
_OutputIterator __brick_copy_n(_ForwardIterator __first, _Size __n,
                               _OutputIterator __result,
                               std::true_type) noexcept {
  return __unseq_backend::__simd_assign(
      __first, __n, __result,
      [](_ForwardIterator __first, _OutputIterator __result) {
        *__result = *__first;
      });
}

template <class _ForwardIterator, class _OutputIterator>
_OutputIterator __brick_copy(_ForwardIterator __first, _ForwardIterator __last,
                             _OutputIterator __result,
                             std::false_type) noexcept {
  return std::copy(__first, __last, __result);
}

template <class _RandomAccessIterator, class _OutputIterator>
_OutputIterator
__brick_copy(_RandomAccessIterator __first, _RandomAccessIterator __last,
             _OutputIterator __result, std::true_type) noexcept {
  return __unseq_backend::__simd_assign(
      __first, __last - __first, __result,
      [](_RandomAccessIterator __first, _OutputIterator __result) {
        *__result = *__first;
      });
}

template <class _ForwardIterator, class _OutputIterator>
_OutputIterator __brick_move(_ForwardIterator __first, _ForwardIterator __last,
                             _OutputIterator __result,
                             std::false_type) noexcept {
  return std::move(__first, __last, __result);
}

template <class _RandomAccessIterator, class _OutputIterator>
_OutputIterator
__brick_move(_RandomAccessIterator __first, _RandomAccessIterator __last,
             _OutputIterator __result, std::true_type) noexcept {
  return __unseq_backend::__simd_assign(
      __first, __last - __first, __result,
      [](_RandomAccessIterator __first, _OutputIterator __result) {
        *__result = std::move(*__first);
      });
}

struct __brick_move_destroy {
  template <typename _Iterator, typename _OutputIterator>
  _OutputIterator operator()(_Iterator __first, _Iterator __last,
                             _OutputIterator __result, std::true_type) const {
    using _IteratorValueType =
        typename std::iterator_traits<_Iterator>::value_type;

    return __unseq_backend::__simd_assign(
        __first, __last - __first, __result,
        [](_Iterator __first, _OutputIterator __result) {
          *__result = std::move(*__first);
          (*__first).~_IteratorValueType();
        });
  }

  template <typename _Iterator, typename _OutputIterator>
  _OutputIterator operator()(_Iterator __first, _Iterator __last,
                             _OutputIterator __result, std::false_type) const {
    using _IteratorValueType =
        typename std::iterator_traits<_Iterator>::value_type;

    for (; __first != __last; ++__first, ++__result) {
      *__result = std::move(*__first);
      (*__first).~_IteratorValueType();
    }
    return __result;
  }
};

template <class _ForwardIterator, class _OutputIterator>
_OutputIterator
__brick_swap_ranges(_ForwardIterator __first, _ForwardIterator __last,
                    _OutputIterator __result, std::false_type) noexcept {
  return std::swap_ranges(__first, __last, __result);
}

template <class _ForwardIterator, class _OutputIterator>
_OutputIterator
__brick_swap_ranges(_ForwardIterator __first, _ForwardIterator __last,
                    _OutputIterator __result, std::true_type) noexcept {
  using std::iter_swap;
  return __unseq_backend::__simd_assign(
      __first, __last - __first, __result,
      iter_swap<_ForwardIterator, _OutputIterator>);
}

template <class _ForwardIterator, class _OutputIterator, class _UnaryPredicate>
_OutputIterator
__brick_copy_if(_ForwardIterator __first, _ForwardIterator __last,
                _OutputIterator __result, _UnaryPredicate __pred,
                std::false_type) noexcept {
  return std::copy_if(__first, __last, __result, __pred);
}

template <class _ForwardIterator, class _OutputIterator, class _UnaryPredicate>
_OutputIterator
__brick_copy_if(_ForwardIterator __first, _ForwardIterator __last,
                _OutputIterator __result, _UnaryPredicate __pred,
                std::true_type) noexcept {

  return std::copy_if(__first, __last, __result, __pred);
}

template <class _DifferenceType, class _ForwardIterator, class _UnaryPredicate>
std::pair<_DifferenceType, _DifferenceType>
__brick_calc_mask_1(_ForwardIterator __first, _ForwardIterator __last,
                    bool *__restrict __mask, _UnaryPredicate __pred,
                    std::false_type) noexcept {
  auto __count_true = _DifferenceType(0);
  auto __size = __last - __first;

  static_assert(__is_random_access_iterator<_ForwardIterator>::value,
                "Pattern-brick error. Should be a random access iterator.");

  for (; __first != __last; ++__first, ++__mask) {
    *__mask = __pred(*__first);
    if (*__mask) {
      ++__count_true;
    }
  }
  return std::make_pair(__count_true, __size - __count_true);
}

template <class _DifferenceType, class _RandomAccessIterator,
          class _UnaryPredicate>
std::pair<_DifferenceType, _DifferenceType>
__brick_calc_mask_1(_RandomAccessIterator __first, _RandomAccessIterator __last,
                    bool *__mask, _UnaryPredicate __pred,
                    std::true_type) noexcept {
  auto __result = __unseq_backend::__simd_calc_mask_1(__first, __last - __first,
                                                      __mask, __pred);
  return std::make_pair(__result, (__last - __first) - __result);
}

template <class _ForwardIterator, class _OutputIterator, class _Assigner>
void __brick_copy_by_mask(_ForwardIterator __first, _ForwardIterator __last,
                          _OutputIterator __result, bool *__mask,
                          _Assigner __assigner, std::false_type) noexcept {
  for (; __first != __last; ++__first, ++__mask) {
    if (*__mask) {
      __assigner(__first, __result);
      ++__result;
    }
  }
}

template <class _ForwardIterator, class _OutputIterator, class _Assigner>
void __brick_copy_by_mask(_ForwardIterator __first, _ForwardIterator __last,
                          _OutputIterator __result, bool *__restrict __mask,
                          _Assigner __assigner, std::true_type) noexcept {

  __internal::__brick_copy_by_mask(__first, __last, __result, __mask,
                                   __assigner, std::false_type());
}

template <class _ForwardIterator, class _OutputIterator1,
          class _OutputIterator2>
void __brick_partition_by_mask(_ForwardIterator __first,
                               _ForwardIterator __last,
                               _OutputIterator1 __out_true,
                               _OutputIterator2 __out_false, bool *__mask,
                               std::false_type) noexcept {
  for (; __first != __last; ++__first, ++__mask) {
    if (*__mask) {
      *__out_true = *__first;
      ++__out_true;
    } else {
      *__out_false = *__first;
      ++__out_false;
    }
  }
}

template <class _RandomAccessIterator, class _OutputIterator1,
          class _OutputIterator2>
void __brick_partition_by_mask(_RandomAccessIterator __first,
                               _RandomAccessIterator __last,
                               _OutputIterator1 __out_true,
                               _OutputIterator2 __out_false, bool *__mask,
                               std::true_type) noexcept {

  __internal::__brick_partition_by_mask(__first, __last, __out_true,
                                        __out_false, __mask, std::false_type());
}

template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator,
          class _UnaryPredicate, class _IsVector>
_OutputIterator __pattern_copy_if(_ExecutionPolicy &&, _ForwardIterator __first,
                                  _ForwardIterator __last,
                                  _OutputIterator __result,
                                  _UnaryPredicate __pred, _IsVector __is_vector,
                                  std::false_type) noexcept {
  return __internal::__brick_copy_if(__first, __last, __result, __pred,
                                     __is_vector);
}

template <class _ExecutionPolicy, class _RandomAccessIterator,
          class _OutputIterator, class _UnaryPredicate, class _IsVector>
_OutputIterator
__pattern_copy_if(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
                  _RandomAccessIterator __last, _OutputIterator __result,
                  _UnaryPredicate __pred, _IsVector __is_vector,
                  std::true_type) {
  typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type
      _DifferenceType;
  const _DifferenceType __n = __last - __first;
  if (_DifferenceType(1) < __n) {
    __par_backend::__buffer<bool> __mask_buf(__n);
    return __internal::__except_handler(
        [&__exec, __n, __first, __result, __is_vector, __pred, &__mask_buf]() {
          bool *__mask = __mask_buf.get();
          _DifferenceType __m{};
          __par_backend::__parallel_strict_scan(
              std::forward<_ExecutionPolicy>(__exec), __n, _DifferenceType(0),
              [=](_DifferenceType __i, _DifferenceType __len) {
                return __internal::__brick_calc_mask_1<_DifferenceType>(
                           __first + __i, __first + (__i + __len), __mask + __i,
                           __pred, __is_vector)
                    .first;
              },
              std::plus<_DifferenceType>(),
              [=](_DifferenceType __i, _DifferenceType __len,
                  _DifferenceType __initial) {
                __internal::__brick_copy_by_mask(
                    __first + __i, __first + (__i + __len),
                    __result + __initial, __mask + __i,
                    [](_RandomAccessIterator __x, _OutputIterator __z) {
                      *__z = *__x;
                    },
                    __is_vector);
              },
              [&__m](_DifferenceType __total) { __m = __total; });
          return __result + __m;
        });
  }

  return __internal::__brick_copy_if(__first, __last, __result, __pred,
                                     __is_vector);
}

template <class _ForwardIterator, class _Predicate>
typename std::iterator_traits<_ForwardIterator>::difference_type
__brick_count(_ForwardIterator __first, _ForwardIterator __last,
              _Predicate __pred, std::true_type) noexcept {
  return __unseq_backend::__simd_count(__first, __last - __first, __pred);
}

template <class _ForwardIterator, class _Predicate>
typename std::iterator_traits<_ForwardIterator>::difference_type
__brick_count(_ForwardIterator __first, _ForwardIterator __last,
              _Predicate __pred, std::false_type) noexcept {
  return std::count_if(__first, __last, __pred);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate,
          class _IsVector>
typename std::iterator_traits<_ForwardIterator>::difference_type
__pattern_count(_ExecutionPolicy &&, _ForwardIterator __first,
                _ForwardIterator __last, _Predicate __pred, std::false_type,
                _IsVector __is_vector) noexcept {
  return __internal::__brick_count(__first, __last, __pred, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate,
          class _IsVector>
typename std::iterator_traits<_ForwardIterator>::difference_type
__pattern_count(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                _ForwardIterator __last, _Predicate __pred, std::true_type,
                _IsVector __is_vector) {
  typedef typename std::iterator_traits<_ForwardIterator>::difference_type
      _SizeType;
  return __internal::__except_handler([&]() {
    return __par_backend::__parallel_reduce(
        std::forward<_ExecutionPolicy>(__exec), __first, __last, _SizeType(0),
        [__pred, __is_vector](_ForwardIterator __begin, _ForwardIterator __end,
                              _SizeType __value) -> _SizeType {
          return __value +
                 __internal::__brick_count(__begin, __end, __pred, __is_vector);
        },
        std::plus<_SizeType>());
  });
}

template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator
__brick_unique(_ForwardIterator __first, _ForwardIterator __last,
               _BinaryPredicate __pred, std::false_type) noexcept {
  return std::unique(__first, __last, __pred);
}

template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator
__brick_unique(_ForwardIterator __first, _ForwardIterator __last,
               _BinaryPredicate __pred, std::true_type) noexcept {
  ;
  return std::unique(__first, __last, __pred);
}

template <class _ExecutionPolicy, class _ForwardIterator,
          class _BinaryPredicate, class _IsVector>
_ForwardIterator
__pattern_unique(_ExecutionPolicy &&, _ForwardIterator __first,
                 _ForwardIterator __last, _BinaryPredicate __pred,
                 _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_unique(__first, __last, __pred, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _CalcMask,
          class _IsVector>
_ForwardIterator
__remove_elements(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                  _ForwardIterator __last, _CalcMask __calc_mask,
                  _IsVector __is_vector) {
  typedef typename std::iterator_traits<_ForwardIterator>::difference_type
      _DifferenceType;
  typedef typename std::iterator_traits<_ForwardIterator>::value_type _Tp;
  _DifferenceType __n = __last - __first;
  __par_backend::__buffer<bool> __mask_buf(__n);

  return __internal::__except_handler([&]() {
    bool *__mask = __mask_buf.get();
    _DifferenceType __min = __par_backend::__parallel_reduce(
        std::forward<_ExecutionPolicy>(__exec), _DifferenceType(0), __n, __n,
        [__first, __mask, &__calc_mask,
         __is_vector](_DifferenceType __i, _DifferenceType __j,
                      _DifferenceType __local_min) -> _DifferenceType {
          __calc_mask(__mask + __i, __mask + __j, __first + __i);

          if (__local_min < __i) {
            return __local_min;
          }

          bool *__result = __internal::__brick_find_if(
              __mask + __i, __mask + __j, [](bool __val) { return !__val; },
              __is_vector);
          if (__result - __mask == __j) {
            return __local_min;
          }
          return std::min(__local_min, _DifferenceType(__result - __mask));
        },
        [](_DifferenceType __local_min1,
           _DifferenceType __local_min2) -> _DifferenceType {
          return std::min(__local_min1, __local_min2);
        });

    if (__min == __n) {
      return __last;
    }
    __n -= __min;
    __first += __min;

    __par_backend::__buffer<_Tp> __buf(__n);
    _Tp *__result = __buf.get();
    __mask += __min;
    _DifferenceType __m{};

    __par_backend::__parallel_strict_scan(
        std::forward<_ExecutionPolicy>(__exec), __n, _DifferenceType(0),
        [__mask, __is_vector](_DifferenceType __i, _DifferenceType __len) {
          return __internal::__brick_count(
              __mask + __i, __mask + __i + __len,
              [](bool __val) { return __val; }, __is_vector);
        },
        std::plus<_DifferenceType>(),
        [=](_DifferenceType __i, _DifferenceType __len,
            _DifferenceType __initial) {
          __internal::__brick_copy_by_mask(
              __first + __i, __first + __i + __len, __result + __initial,
              __mask + __i,
              [](_ForwardIterator __x, _Tp *__z) {
                __internal::__invoke_if_else(
                    std::is_trivial<_Tp>(), [&]() { *__z = std::move(*__x); },
                    [&]() {
                      ::new (std::addressof(*__z)) _Tp(std::move(*__x));
                    });
              },
              __is_vector);
        },
        [&__m](_DifferenceType __total) { __m = __total; });

    __par_backend::__parallel_for(
        std::forward<_ExecutionPolicy>(__exec), __result, __result + __m,
        [__result, __first, __is_vector](_Tp *__i, _Tp *__j) {
          __invoke_if_else(
              std::is_trivial<_Tp>(),
              [&]() {
                __brick_move(__i, __j, __first + (__i - __result), __is_vector);
              },
              [&]() {
                __brick_move_destroy()(__i, __j, __first + (__i - __result),
                                       __is_vector);
              });
        });
    return __first + __m;
  });
}

template <class _ExecutionPolicy, class _ForwardIterator,
          class _BinaryPredicate, class _IsVector>
_ForwardIterator
__pattern_unique(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                 _ForwardIterator __last, _BinaryPredicate __pred,
                 _IsVector __is_vector, std::true_type) noexcept {
  typedef
      typename std::iterator_traits<_ForwardIterator>::reference _ReferenceType;

  if (__first == __last) {
    return __last;
  }
  if (__first + 1 == __last || __first + 2 == __last) {

    return __internal::__brick_unique(__first, __last, __pred, __is_vector);
  }
  return __internal::__remove_elements(
      std::forward<_ExecutionPolicy>(__exec), ++__first, __last,
      [&__pred, __is_vector](bool *__b, bool *__e, _ForwardIterator __it) {
        __internal::__brick_walk3(
            __b, __e, __it - 1, __it,
            [&__pred](bool &__x, _ReferenceType __y, _ReferenceType __z) {
              __x = !__pred(__y, __z);
            },
            __is_vector);
      },
      __is_vector);
}

template <class _ForwardIterator, class _OutputIterator, class _BinaryPredicate>
_OutputIterator
__brick_unique_copy(_ForwardIterator __first, _ForwardIterator __last,
                    _OutputIterator __result, _BinaryPredicate __pred,
                    std::false_type) noexcept {
  return std::unique_copy(__first, __last, __result, __pred);
}

template <class _RandomAccessIterator, class _OutputIterator,
          class _BinaryPredicate>
_OutputIterator
__brick_unique_copy(_RandomAccessIterator __first, _RandomAccessIterator __last,
                    _OutputIterator __result, _BinaryPredicate __pred,
                    std::true_type) noexcept {

  return std::unique_copy(__first, __last, __result, __pred);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator,
          class _BinaryPredicate, class _IsVector>
_OutputIterator
__pattern_unique_copy(_ExecutionPolicy &&, _ForwardIterator __first,
                      _ForwardIterator __last, _OutputIterator __result,
                      _BinaryPredicate __pred, _IsVector __is_vector,
                      std::false_type) noexcept {
  return __internal::__brick_unique_copy(__first, __last, __result, __pred,
                                         __is_vector);
}

template <class _DifferenceType, class _RandomAccessIterator,
          class _BinaryPredicate>
_DifferenceType
__brick_calc_mask_2(_RandomAccessIterator __first, _RandomAccessIterator __last,
                    bool *__restrict __mask, _BinaryPredicate __pred,
                    std::false_type) noexcept {
  _DifferenceType __count = 0;
  for (; __first != __last; ++__first, ++__mask) {
    *__mask = !__pred(*__first, *(__first - 1));
    __count += *__mask;
  }
  return __count;
}

template <class _DifferenceType, class _RandomAccessIterator,
          class _BinaryPredicate>
_DifferenceType
__brick_calc_mask_2(_RandomAccessIterator __first, _RandomAccessIterator __last,
                    bool *__restrict __mask, _BinaryPredicate __pred,
                    std::true_type) noexcept {
  return __unseq_backend::__simd_calc_mask_2(__first, __last - __first, __mask,
                                             __pred);
}

template <class _ExecutionPolicy, class _RandomAccessIterator,
          class _OutputIterator, class _BinaryPredicate, class _IsVector>
_OutputIterator
__pattern_unique_copy(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
                      _RandomAccessIterator __last, _OutputIterator __result,
                      _BinaryPredicate __pred, _IsVector __is_vector,
                      std::true_type) {
  typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type
      _DifferenceType;
  const _DifferenceType __n = __last - __first;
  if (_DifferenceType(2) < __n) {
    __par_backend::__buffer<bool> __mask_buf(__n);
    if (_DifferenceType(2) < __n) {
      return __internal::__except_handler([&__exec, __n, __first, __result,
                                           __pred, __is_vector, &__mask_buf]() {
        bool *__mask = __mask_buf.get();
        _DifferenceType __m{};
        __par_backend::__parallel_strict_scan(
            std::forward<_ExecutionPolicy>(__exec), __n, _DifferenceType(0),
            [=](_DifferenceType __i, _DifferenceType __len) -> _DifferenceType {
              _DifferenceType __extra = 0;
              if (__i == 0) {

                __mask[__i] = true;
                if (--__len == 0)
                  return 1;
                ++__i;
                ++__extra;
              }
              return __internal::__brick_calc_mask_2<_DifferenceType>(
                         __first + __i, __first + (__i + __len), __mask + __i,
                         __pred, __is_vector) +
                     __extra;
            },
            std::plus<_DifferenceType>(),
            [=](_DifferenceType __i, _DifferenceType __len,
                _DifferenceType __initial) {
              __internal::__brick_copy_by_mask(
                  __first + __i, __first + (__i + __len), __result + __initial,
                  __mask + __i,
                  [](_RandomAccessIterator __x, _OutputIterator __z) {
                    *__z = *__x;
                  },
                  __is_vector);
            },
            [&__m](_DifferenceType __total) { __m = __total; });
        return __result + __m;
      });
    }
  }

  return __internal::__brick_unique_copy(__first, __last, __result, __pred,
                                         __is_vector);
}

template <class _BidirectionalIterator>
void __brick_reverse(_BidirectionalIterator __first,
                     _BidirectionalIterator __last, std::false_type) noexcept {
  std::reverse(__first, __last);
}

template <class _BidirectionalIterator>
void __brick_reverse(_BidirectionalIterator __first,
                     _BidirectionalIterator __last, std::true_type) noexcept {
  typedef typename std::iterator_traits<_BidirectionalIterator>::reference
      _ReferenceType;

  const auto __n = (__last - __first) / 2;
  __unseq_backend::__simd_walk_2(
      __first, __n, std::reverse_iterator<_BidirectionalIterator>(__last),
      [](_ReferenceType __x, _ReferenceType __y) {
        using std::swap;
        swap(__x, __y);
      });
}

template <class _BidirectionalIterator>
void __brick_reverse(_BidirectionalIterator __first,
                     _BidirectionalIterator __last,
                     _BidirectionalIterator __d_last,
                     std::false_type) noexcept {
  for (--__d_last; __first != __last; ++__first, --__d_last) {
    using std::iter_swap;
    iter_swap(__first, __d_last);
  }
}

template <class _BidirectionalIterator>
void __brick_reverse(_BidirectionalIterator __first,
                     _BidirectionalIterator __last,
                     _BidirectionalIterator __d_last, std::true_type) noexcept {
  typedef typename std::iterator_traits<_BidirectionalIterator>::reference
      _ReferenceType;

  __unseq_backend::__simd_walk_2(
      __first, __last - __first,
      std::reverse_iterator<_BidirectionalIterator>(__d_last),
      [](_ReferenceType __x, _ReferenceType __y) {
        using std::swap;
        swap(__x, __y);
      });
}

template <class _ExecutionPolicy, class _BidirectionalIterator, class _IsVector>
void __pattern_reverse(_ExecutionPolicy &&, _BidirectionalIterator __first,
                       _BidirectionalIterator __last, _IsVector __is_vector,
                       std::false_type) noexcept {
  __internal::__brick_reverse(__first, __last, __is_vector);
}

template <class _ExecutionPolicy, class _BidirectionalIterator, class _IsVector>
void __pattern_reverse(_ExecutionPolicy &&__exec,
                       _BidirectionalIterator __first,
                       _BidirectionalIterator __last, _IsVector __is_vector,
                       std::true_type) {
  __par_backend::__parallel_for(
      std::forward<_ExecutionPolicy>(__exec), __first,
      __first + (__last - __first) / 2,
      [__is_vector, __first, __last](_BidirectionalIterator __inner_first,
                                     _BidirectionalIterator __inner_last) {
        __internal::__brick_reverse(__inner_first, __inner_last,
                                    __last - (__inner_first - __first),
                                    __is_vector);
      });
}

template <class _BidirectionalIterator, class _OutputIterator>
_OutputIterator __brick_reverse_copy(_BidirectionalIterator __first,
                                     _BidirectionalIterator __last,
                                     _OutputIterator __d_first,
                                     std::false_type) noexcept {
  return std::reverse_copy(__first, __last, __d_first);
}

template <class _BidirectionalIterator, class _OutputIterator>
_OutputIterator __brick_reverse_copy(_BidirectionalIterator __first,
                                     _BidirectionalIterator __last,
                                     _OutputIterator __d_first,
                                     std::true_type) noexcept {
  typedef typename std::iterator_traits<_BidirectionalIterator>::reference
      _ReferenceType1;
  typedef
      typename std::iterator_traits<_OutputIterator>::reference _ReferenceType2;

  return __unseq_backend::__simd_walk_2(
      std::reverse_iterator<_BidirectionalIterator>(__last), __last - __first,
      __d_first, [](_ReferenceType1 __x, _ReferenceType2 __y) { __y = __x; });
}

template <class _ExecutionPolicy, class _BidirectionalIterator,
          class _OutputIterator, class _IsVector>
_OutputIterator
__pattern_reverse_copy(_ExecutionPolicy &&, _BidirectionalIterator __first,
                       _BidirectionalIterator __last, _OutputIterator __d_first,
                       _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_reverse_copy(__first, __last, __d_first,
                                          __is_vector);
}

template <class _ExecutionPolicy, class _BidirectionalIterator,
          class _OutputIterator, class _IsVector>
_OutputIterator __pattern_reverse_copy(_ExecutionPolicy &&__exec,
                                       _BidirectionalIterator __first,
                                       _BidirectionalIterator __last,
                                       _OutputIterator __d_first,
                                       _IsVector __is_vector, std::true_type) {
  auto __len = __last - __first;
  __par_backend::__parallel_for(
      std::forward<_ExecutionPolicy>(__exec), __first, __last,
      [__is_vector, __first, __len,
       __d_first](_BidirectionalIterator __inner_first,
                  _BidirectionalIterator __inner_last) {
        __internal::__brick_reverse_copy(
            __inner_first, __inner_last,
            __d_first + (__len - (__inner_last - __first)), __is_vector);
      });
  return __d_first + __len;
}

template <class _ForwardIterator>
_ForwardIterator
__brick_rotate(_ForwardIterator __first, _ForwardIterator __middle,
               _ForwardIterator __last, std::false_type) noexcept {

  return std::rotate(__first, __middle, __last);
}

template <class _ForwardIterator>
_ForwardIterator
__brick_rotate(_ForwardIterator __first, _ForwardIterator __middle,
               _ForwardIterator __last, std::true_type) noexcept {
  auto __n = __last - __first;
  auto __m = __middle - __first;
  const _ForwardIterator __ret = __first + (__last - __middle);

  bool __is_left = (__m <= __n / 2);
  if (!__is_left)
    __m = __n - __m;

  while (__n > 1 && __m > 0) {
    using std::iter_swap;
    const auto __m_2 = __m * 2;
    if (__is_left) {
      for (; __last - __first >= __m_2; __first += __m) {
        __unseq_backend::__simd_assign(
            __first, __m, __first + __m,
            iter_swap<_ForwardIterator, _ForwardIterator>);
      }
    } else {
      for (; __last - __first >= __m_2; __last -= __m) {
        __unseq_backend::__simd_assign(
            __last - __m, __m, __last - __m_2,
            iter_swap<_ForwardIterator, _ForwardIterator>);
      }
    }
    __is_left = !__is_left;
    __m = __n % __m;
    __n = __last - __first;
  }

  return __ret;
}

template <class _ExecutionPolicy, class _ForwardIterator, class _IsVector>
_ForwardIterator
__pattern_rotate(_ExecutionPolicy &&, _ForwardIterator __first,
                 _ForwardIterator __middle, _ForwardIterator __last,
                 _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_rotate(__first, __middle, __last, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _IsVector>
_ForwardIterator
__pattern_rotate(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                 _ForwardIterator __middle, _ForwardIterator __last,
                 _IsVector __is_vector, std::true_type) {
  typedef typename std::iterator_traits<_ForwardIterator>::value_type _Tp;
  auto __n = __last - __first;
  auto __m = __middle - __first;
  if (__m <= __n / 2) {
    __par_backend::__buffer<_Tp> __buf(__n - __m);
    return __internal::__except_handler(
        [&__exec, __n, __m, __first, __middle, __last, __is_vector, &__buf]() {
          _Tp *__result = __buf.get();
          __par_backend::__parallel_for(
              std::forward<_ExecutionPolicy>(__exec), __middle, __last,
              [__middle, __result, __is_vector](_ForwardIterator __b,
                                                _ForwardIterator __e) {
                __internal::__brick_uninitialized_move(
                    __b, __e, __result + (__b - __middle), __is_vector);
              });

          __par_backend::__parallel_for(
              std::forward<_ExecutionPolicy>(__exec), __first, __middle,
              [__last, __middle, __is_vector](_ForwardIterator __b,
                                              _ForwardIterator __e) {
                __internal::__brick_move(__b, __e, __b + (__last - __middle),
                                         __is_vector);
              });

          __par_backend::__parallel_for(
              std::forward<_ExecutionPolicy>(__exec), __result,
              __result + (__n - __m),
              [__first, __result, __is_vector](_Tp *__b, _Tp *__e) {
                __brick_move_destroy()(__b, __e, __first + (__b - __result),
                                       __is_vector);
              });

          return __first + (__last - __middle);
        });
  } else {
    __par_backend::__buffer<_Tp> __buf(__m);
    return __internal::__except_handler([&__exec, __n, __m, __first, __middle,
                                         __last, __is_vector, &__buf]() {
      _Tp *__result = __buf.get();
      __par_backend::__parallel_for(
          std::forward<_ExecutionPolicy>(__exec), __first, __middle,
          [__first, __result, __is_vector](_ForwardIterator __b,
                                           _ForwardIterator __e) {
            __internal::__brick_uninitialized_move(
                __b, __e, __result + (__b - __first), __is_vector);
          });

      __par_backend::__parallel_for(
          std::forward<_ExecutionPolicy>(__exec), __middle, __last,
          [__first, __middle, __is_vector](_ForwardIterator __b,
                                           _ForwardIterator __e) {
            __internal::__brick_move(__b, __e, __first + (__b - __middle),
                                     __is_vector);
          });

      __par_backend::__parallel_for(
          std::forward<_ExecutionPolicy>(__exec), __result, __result + __m,
          [__n, __m, __first, __result, __is_vector](_Tp *__b, _Tp *__e) {
            __brick_move_destroy()(__b, __e,
                                   __first + ((__n - __m) + (__b - __result)),
                                   __is_vector);
          });

      return __first + (__last - __middle);
    });
  }
}

template <class _ForwardIterator, class _OutputIterator>
_OutputIterator
__brick_rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                    _ForwardIterator __last, _OutputIterator __result,
                    std::false_type) noexcept {
  return std::rotate_copy(__first, __middle, __last, __result);
}

template <class _ForwardIterator, class _OutputIterator>
_OutputIterator
__brick_rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                    _ForwardIterator __last, _OutputIterator __result,
                    std::true_type) noexcept {
  _OutputIterator __res =
      __internal::__brick_copy(__middle, __last, __result, std::true_type());
  return __internal::__brick_copy(__first, __middle, __res, std::true_type());
}

template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator,
          class _IsVector>
_OutputIterator
__pattern_rotate_copy(_ExecutionPolicy &&, _ForwardIterator __first,
                      _ForwardIterator __middle, _ForwardIterator __last,
                      _OutputIterator __result, _IsVector __is_vector,
                      std::false_type) noexcept {
  return __internal::__brick_rotate_copy(__first, __middle, __last, __result,
                                         __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator,
          class _IsVector>
_OutputIterator
__pattern_rotate_copy(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                      _ForwardIterator __middle, _ForwardIterator __last,
                      _OutputIterator __result, _IsVector __is_vector,
                      std::true_type) {
  __par_backend::__parallel_for(
      std::forward<_ExecutionPolicy>(__exec), __first, __last,
      [__first, __last, __middle, __result, __is_vector](_ForwardIterator __b,
                                                         _ForwardIterator __e) {
        if (__b > __middle) {
          __internal::__brick_copy(__b, __e, __result + (__b - __middle),
                                   __is_vector);
        } else {
          _OutputIterator __new_result =
              __result + ((__last - __middle) + (__b - __first));
          if (__e < __middle) {
            __internal::__brick_copy(__b, __e, __new_result, __is_vector);
          } else {
            __internal::__brick_copy(__b, __middle, __new_result, __is_vector);
            __internal::__brick_copy(__middle, __e, __result, __is_vector);
          }
        }
      });
  return __result + (__last - __first);
}

template <class _ForwardIterator, class _UnaryPredicate>
bool __brick_is_partitioned(_ForwardIterator __first, _ForwardIterator __last,
                            _UnaryPredicate __pred, std::false_type) noexcept {
  return std::is_partitioned(__first, __last, __pred);
}

template <class _ForwardIterator, class _UnaryPredicate>
bool __brick_is_partitioned(_ForwardIterator __first, _ForwardIterator __last,
                            _UnaryPredicate __pred, std::true_type) noexcept {
  typedef typename std::iterator_traits<_ForwardIterator>::difference_type
      _SizeType;
  if (__first == __last) {
    return true;
  } else {
    _ForwardIterator __result = __unseq_backend::__simd_first(
        __first, _SizeType(0), __last - __first,
        [&__pred](_ForwardIterator __it, _SizeType __i) {
          return !__pred(__it[__i]);
        });
    if (__result == __last) {
      return true;
    } else {
      ++__result;
      return !__unseq_backend::__simd_or(__result, __last - __result, __pred);
    }
  }
}

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate,
          class _IsVector>
bool __pattern_is_partitioned(_ExecutionPolicy &&, _ForwardIterator __first,
                              _ForwardIterator __last, _UnaryPredicate __pred,
                              _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_is_partitioned(__first, __last, __pred,
                                            __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate,
          class _IsVector>
bool __pattern_is_partitioned(_ExecutionPolicy &&__exec,
                              _ForwardIterator __first, _ForwardIterator __last,
                              _UnaryPredicate __pred, _IsVector __is_vector,
                              std::true_type) {
  if (__first == __last) {
    return true;
  } else {
    return __internal::__except_handler([&]() {
      enum _ReduceType {
        __not_init = -1,
        __broken,
        __all_true,
        __all_false,
        __true_false
      };
      _ReduceType __init = __not_init;

      _ReduceType __table[] = {__broken, __broken,   __broken,     __broken,
                               __broken, __all_true, __true_false, __true_false,
                               __broken, __broken,   __all_false,  __broken,
                               __broken, __broken,   __true_false, __broken};

      __init = __par_backend::__parallel_reduce(
          std::forward<_ExecutionPolicy>(__exec), __first, __last, __init,
          [&__pred, &__table, __is_vector](_ForwardIterator __i,
                                           _ForwardIterator __j,
                                           _ReduceType __value) -> _ReduceType {
            if (__value == __broken) {
              return __broken;
            }
            _ReduceType __res = __not_init;

            if (__pred(*__i)) {

              _ForwardIterator __x = __internal::__brick_find_if(
                  __i + 1, __j, std::not_fn(__pred), __is_vector);
              if (__x != __j) {

                _ForwardIterator __y = __internal::__brick_find_if(
                    __x + 1, __j, __pred, __is_vector);

                if (__y != __j) {
                  return __broken;
                } else {
                  __res = __true_false;
                }
              } else {
                __res = __all_true;
              }
            } else {

              if (__internal::__brick_find_if(__i + 1, __j, __pred,
                                              __is_vector) != __j) {
                return __broken;
              } else {
                __res = __all_false;
              }
            }

            return (__value == -1) ? __res : __table[__value * 4 + __res];
          },

          [&__table](_ReduceType __val1, _ReduceType __val2) -> _ReduceType {
            if (__val1 == __broken || __val2 == __broken) {
              return __broken;
            }

            return __table[__val1 * 4 + __val2];
          });
      return __init != __broken;
    });
  }
}

template <class _ForwardIterator, class _UnaryPredicate>
_ForwardIterator
__brick_partition(_ForwardIterator __first, _ForwardIterator __last,
                  _UnaryPredicate __pred, std::false_type) noexcept {
  return std::partition(__first, __last, __pred);
}

template <class _ForwardIterator, class _UnaryPredicate>
_ForwardIterator
__brick_partition(_ForwardIterator __first, _ForwardIterator __last,
                  _UnaryPredicate __pred, std::true_type) noexcept {
  ;
  return std::partition(__first, __last, __pred);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate,
          class _IsVector>
_ForwardIterator
__pattern_partition(_ExecutionPolicy &&, _ForwardIterator __first,
                    _ForwardIterator __last, _UnaryPredicate __pred,
                    _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_partition(__first, __last, __pred, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate,
          class _IsVector>
_ForwardIterator
__pattern_partition(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                    _ForwardIterator __last, _UnaryPredicate __pred,
                    _IsVector __is_vector, std::true_type) {

  struct _PartitionRange {
    _ForwardIterator __begin;
    _ForwardIterator __pivot;
    _ForwardIterator __end;
  };

  return __internal::__except_handler([&]() {
    _PartitionRange __init{__last, __last, __last};

    auto __reductor = [&__exec,
                       __is_vector](_PartitionRange __val1,
                                    _PartitionRange __val2) -> _PartitionRange {
      auto __size1 = __val1.__end - __val1.__pivot;
      auto __size2 = __val2.__pivot - __val2.__begin;
      auto __new_begin = __val2.__begin - (__val1.__end - __val1.__begin);

      if (__val1.__end == __val1.__pivot) {
        return {__new_begin, __val2.__pivot, __val2.__end};
      }

      else if (__size2 > __size1) {
        __par_backend::__parallel_for(
            std::forward<_ExecutionPolicy>(__exec), __val1.__pivot,
            __val1.__pivot + __size1,
            [__val1, __val2, __size1, __is_vector](_ForwardIterator __i,
                                                   _ForwardIterator __j) {
              __internal::__brick_swap_ranges(
                  __i, __j, (__val2.__pivot - __size1) + (__i - __val1.__pivot),
                  __is_vector);
            });
        return {__new_begin, __val2.__pivot - __size1, __val2.__end};
      }

      else {
        __par_backend::__parallel_for(
            std::forward<_ExecutionPolicy>(__exec), __val1.__pivot,
            __val1.__pivot + __size2,
            [__val1, __val2, __is_vector](_ForwardIterator __i,
                                          _ForwardIterator __j) {
              __internal::__brick_swap_ranges(
                  __i, __j, __val2.__begin + (__i - __val1.__pivot),
                  __is_vector);
            });
        return {__new_begin, __val1.__pivot + __size2, __val2.__end};
      }
    };

    _PartitionRange __result = __par_backend::__parallel_reduce(
        std::forward<_ExecutionPolicy>(__exec), __first, __last, __init,
        [__pred, __is_vector,
         __reductor](_ForwardIterator __i, _ForwardIterator __j,
                     _PartitionRange __value) -> _PartitionRange {
          _ForwardIterator __pivot =
              __internal::__brick_partition(__i, __j, __pred, __is_vector);

          return __reductor(__value, {__i, __pivot, __j});
        },
        __reductor);
    return __result.__pivot;
  });
}

template <class _BidirectionalIterator, class _UnaryPredicate>
_BidirectionalIterator __brick_stable_partition(_BidirectionalIterator __first,
                                                _BidirectionalIterator __last,
                                                _UnaryPredicate __pred,
                                                std::false_type) noexcept {
  return std::stable_partition(__first, __last, __pred);
}

template <class _BidirectionalIterator, class _UnaryPredicate>
_BidirectionalIterator __brick_stable_partition(_BidirectionalIterator __first,
                                                _BidirectionalIterator __last,
                                                _UnaryPredicate __pred,
                                                std::true_type) noexcept {
  ;
  return std::stable_partition(__first, __last, __pred);
}

template <class _ExecutionPolicy, class _BidirectionalIterator,
          class _UnaryPredicate, class _IsVector>
_BidirectionalIterator
__pattern_stable_partition(_ExecutionPolicy &&, _BidirectionalIterator __first,
                           _BidirectionalIterator __last,
                           _UnaryPredicate __pred, _IsVector __is_vector,
                           std::false_type) noexcept {
  return __internal::__brick_stable_partition(__first, __last, __pred,
                                              __is_vector);
}

template <class _ExecutionPolicy, class _BidirectionalIterator,
          class _UnaryPredicate, class _IsVector>
_BidirectionalIterator __pattern_stable_partition(
    _ExecutionPolicy &&__exec, _BidirectionalIterator __first,
    _BidirectionalIterator __last, _UnaryPredicate __pred,
    _IsVector __is_vector, std::true_type) noexcept {

  struct _PartitionRange {
    _BidirectionalIterator __begin;
    _BidirectionalIterator __pivot;
    _BidirectionalIterator __end;
  };

  return __internal::__except_handler([&]() {
    _PartitionRange __init{__last, __last, __last};

    auto __reductor = [__is_vector](_PartitionRange __val1,
                                    _PartitionRange __val2) -> _PartitionRange {
      auto __size1 = __val1.__end - __val1.__pivot;
      auto __new_begin = __val2.__begin - (__val1.__end - __val1.__begin);

      if (__val1.__end == __val1.__pivot) {
        return {__new_begin, __val2.__pivot, __val2.__end};
      }

      else {
        __internal::__brick_rotate(__val1.__pivot, __val2.__begin,
                                   __val2.__pivot, __is_vector);
        return {__new_begin, __val2.__pivot - __size1, __val2.__end};
      }
    };

    _PartitionRange __result = __par_backend::__parallel_reduce(
        std::forward<_ExecutionPolicy>(__exec), __first, __last, __init,
        [&__pred, __is_vector,
         __reductor](_BidirectionalIterator __i, _BidirectionalIterator __j,
                     _PartitionRange __value) -> _PartitionRange {
          _BidirectionalIterator __pivot = __internal::__brick_stable_partition(
              __i, __j, __pred, __is_vector);

          return __reductor(__value, {__i, __pivot, __j});
        },
        __reductor);
    return __result.__pivot;
  });
}

template <class _ForwardIterator, class _OutputIterator1,
          class _OutputIterator2, class _UnaryPredicate>
std::pair<_OutputIterator1, _OutputIterator2>
__brick_partition_copy(_ForwardIterator __first, _ForwardIterator __last,
                       _OutputIterator1 __out_true,
                       _OutputIterator2 __out_false, _UnaryPredicate __pred,
                       std::false_type) noexcept {
  return std::partition_copy(__first, __last, __out_true, __out_false, __pred);
}

template <class _ForwardIterator, class _OutputIterator1,
          class _OutputIterator2, class _UnaryPredicate>
std::pair<_OutputIterator1, _OutputIterator2>
__brick_partition_copy(_ForwardIterator __first, _ForwardIterator __last,
                       _OutputIterator1 __out_true,
                       _OutputIterator2 __out_false, _UnaryPredicate __pred,
                       std::true_type) noexcept {

  return std::partition_copy(__first, __last, __out_true, __out_false, __pred);
}

template <class _ExecutionPolicy, class _ForwardIterator,
          class _OutputIterator1, class _OutputIterator2, class _UnaryPredicate,
          class _IsVector>
std::pair<_OutputIterator1, _OutputIterator2>
__pattern_partition_copy(_ExecutionPolicy &&, _ForwardIterator __first,
                         _ForwardIterator __last, _OutputIterator1 __out_true,
                         _OutputIterator2 __out_false, _UnaryPredicate __pred,
                         _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_partition_copy(__first, __last, __out_true,
                                            __out_false, __pred, __is_vector);
}

template <class _ExecutionPolicy, class _RandomAccessIterator,
          class _OutputIterator1, class _OutputIterator2, class _UnaryPredicate,
          class _IsVector>
std::pair<_OutputIterator1, _OutputIterator2> __pattern_partition_copy(
    _ExecutionPolicy &&__exec, _RandomAccessIterator __first,
    _RandomAccessIterator __last, _OutputIterator1 __out_true,
    _OutputIterator2 __out_false, _UnaryPredicate __pred, _IsVector __is_vector,
    std::true_type) {
  typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type
      _DifferenceType;
  typedef std::pair<_DifferenceType, _DifferenceType> _ReturnType;
  const _DifferenceType __n = __last - __first;
  if (_DifferenceType(1) < __n) {
    __par_backend::__buffer<bool> __mask_buf(__n);
    return __internal::__except_handler([&__exec, __n, __first, __out_true,
                                         __out_false, __is_vector, __pred,
                                         &__mask_buf]() {
      bool *__mask = __mask_buf.get();
      _ReturnType __m{};
      __par_backend::__parallel_strict_scan(
          std::forward<_ExecutionPolicy>(__exec), __n,
          std::make_pair(_DifferenceType(0), _DifferenceType(0)),
          [=](_DifferenceType __i, _DifferenceType __len) {
            return __internal::__brick_calc_mask_1<_DifferenceType>(
                __first + __i, __first + (__i + __len), __mask + __i, __pred,
                __is_vector);
          },
          [](const _ReturnType &__x, const _ReturnType &__y) -> _ReturnType {
            return std::make_pair(__x.first + __y.first,
                                  __x.second + __y.second);
          },
          [=](_DifferenceType __i, _DifferenceType __len,
              _ReturnType __initial) {
            __internal::__brick_partition_by_mask(
                __first + __i, __first + (__i + __len),
                __out_true + __initial.first, __out_false + __initial.second,
                __mask + __i, __is_vector);
          },
          [&__m](_ReturnType __total) { __m = __total; });
      return std::make_pair(__out_true + __m.first, __out_false + __m.second);
    });
  }

  return __internal::__brick_partition_copy(__first, __last, __out_true,
                                            __out_false, __pred, __is_vector);
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector, class _IsMoveConstructible>
void __pattern_sort(_ExecutionPolicy &&, _RandomAccessIterator __first,
                    _RandomAccessIterator __last, _Compare __comp, _IsVector,
                    std::false_type, _IsMoveConstructible) noexcept {
  std::sort(__first, __last, __comp);
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
void __pattern_sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
                    _RandomAccessIterator __last, _Compare __comp, _IsVector,
                    std::true_type, std::true_type) {
  __internal::__except_handler([&]() {
    __par_backend::__parallel_stable_sort(
        std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,
        [](_RandomAccessIterator __first, _RandomAccessIterator __last,
           _Compare __comp) { std::sort(__first, __last, __comp); });
  });
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
void __pattern_stable_sort(_ExecutionPolicy &&, _RandomAccessIterator __first,
                           _RandomAccessIterator __last, _Compare __comp,
                           _IsVector, std::false_type) noexcept {
  std::stable_sort(__first, __last, __comp);
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
void __pattern_stable_sort(_ExecutionPolicy &&__exec,
                           _RandomAccessIterator __first,
                           _RandomAccessIterator __last, _Compare __comp,
                           _IsVector, std::true_type) {
  __internal::__except_handler([&]() {
    __par_backend::__parallel_stable_sort(
        std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,
        [](_RandomAccessIterator __first, _RandomAccessIterator __last,
           _Compare __comp) { std::stable_sort(__first, __last, __comp); });
  });
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
void __pattern_partial_sort(_ExecutionPolicy &&, _RandomAccessIterator __first,
                            _RandomAccessIterator __middle,
                            _RandomAccessIterator __last, _Compare __comp,
                            _IsVector, std::false_type) noexcept {
  std::partial_sort(__first, __middle, __last, __comp);
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
void __pattern_partial_sort(_ExecutionPolicy &&__exec,
                            _RandomAccessIterator __first,
                            _RandomAccessIterator __middle,
                            _RandomAccessIterator __last, _Compare __comp,
                            _IsVector, std::true_type) {
  const auto __n = __middle - __first;
  if (__n == 0)
    return;

  __internal::__except_handler([&]() {
    __par_backend::__parallel_stable_sort(
        std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,
        [__n](_RandomAccessIterator __begin, _RandomAccessIterator __end,
              _Compare __comp) {
          if (__n < __end - __begin)
            std::partial_sort(__begin, __begin + __n, __end, __comp);
          else
            std::sort(__begin, __end, __comp);
        },
        __n);
  });
}

template <class _ExecutionPolicy, class _ForwardIterator,
          class _RandomAccessIterator, class _Compare, class _IsVector>
_RandomAccessIterator __pattern_partial_sort_copy(
    _ExecutionPolicy &&, _ForwardIterator __first, _ForwardIterator __last,
    _RandomAccessIterator __d_first, _RandomAccessIterator __d_last,
    _Compare __comp, _IsVector, std::false_type) noexcept {
  return std::partial_sort_copy(__first, __last, __d_first, __d_last, __comp);
}

template <class _ExecutionPolicy, class _ForwardIterator,
          class _RandomAccessIterator, class _Compare, class _IsVector>
_RandomAccessIterator
__pattern_partial_sort_copy(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                            _ForwardIterator __last,
                            _RandomAccessIterator __d_first,
                            _RandomAccessIterator __d_last, _Compare __comp,
                            _IsVector __is_vector, std::true_type) {
  if (__last == __first || __d_last == __d_first) {
    return __d_first;
  }
  auto __n1 = __last - __first;
  auto __n2 = __d_last - __d_first;
  return __internal::__except_handler([&]() {
    if (__n2 >= __n1) {
      __par_backend::__parallel_stable_sort(
          std::forward<_ExecutionPolicy>(__exec), __d_first, __d_first + __n1,
          __comp,
          [__first, __d_first, __is_vector](_RandomAccessIterator __i,
                                            _RandomAccessIterator __j,
                                            _Compare __comp) {
            _ForwardIterator __i1 = __first + (__i - __d_first);
            _ForwardIterator __j1 = __first + (__j - __d_first);

            __internal::__brick_copy(__i1, __j1, __i, __is_vector);

            std::sort(__i, __j, __comp);
          },
          __n1);
      return __d_first + __n1;
    } else {
      typedef typename std::iterator_traits<_ForwardIterator>::value_type _T1;
      typedef
          typename std::iterator_traits<_RandomAccessIterator>::value_type _T2;
      __par_backend::__buffer<_T1> __buf(__n1);
      _T1 *__r = __buf.get();

      __par_backend::__parallel_stable_sort(
          std::forward<_ExecutionPolicy>(__exec), __r, __r + __n1, __comp,
          [__n2, __first, __r](_T1 *__i, _T1 *__j, _Compare __comp) {
            _ForwardIterator __it = __first + (__i - __r);

            for (_T1 *__k = __i; __k != __j; ++__k, ++__it) {
              ::new (__k) _T2(*__it);
            }

            if (__n2 < __j - __i)
              std::partial_sort(__i, __i + __n2, __j, __comp);
            else
              std::sort(__i, __j, __comp);
          },
          __n2);

      __par_backend::__parallel_for(
          std::forward<_ExecutionPolicy>(__exec), __r, __r + __n2,
          [__r, __d_first, __is_vector](_T1 *__i, _T1 *__j) {
            __brick_move_destroy()(__i, __j, __d_first + (__i - __r),
                                   __is_vector);
          });
      __par_backend::__parallel_for(std::forward<_ExecutionPolicy>(__exec),
                                    __r + __n2, __r + __n1,
                                    [__is_vector](_T1 *__i, _T1 *__j) {
                                      __brick_destroy(__i, __j, __is_vector);
                                    });

      return __d_first + __n2;
    }
  });
}

template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator __brick_adjacent_find(_ForwardIterator __first,
                                       _ForwardIterator __last,
                                       _BinaryPredicate __pred, std::true_type,
                                       bool __or_semantic) noexcept {
  return __unseq_backend::__simd_adjacent_find(__first, __last, __pred,
                                               __or_semantic);
}

template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator
__brick_adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
                      _BinaryPredicate __pred, std::false_type, bool) noexcept {
  return std::adjacent_find(__first, __last, __pred);
}

template <class _ExecutionPolicy, class _ForwardIterator,
          class _BinaryPredicate, class _IsVector>
_ForwardIterator
__pattern_adjacent_find(_ExecutionPolicy &&, _ForwardIterator __first,
                        _ForwardIterator __last, _BinaryPredicate __pred,
                        std::false_type, _IsVector __is_vector,
                        bool __or_semantic) noexcept {
  return __internal::__brick_adjacent_find(__first, __last, __pred, __is_vector,
                                           __or_semantic);
}

template <class _ExecutionPolicy, class _RandomAccessIterator,
          class _BinaryPredicate, class _IsVector>
_RandomAccessIterator __pattern_adjacent_find(
    _ExecutionPolicy &&__exec, _RandomAccessIterator __first,
    _RandomAccessIterator __last, _BinaryPredicate __pred, std::true_type,
    _IsVector __is_vector, bool __or_semantic) {
  if (__last - __first < 2)
    return __last;

  return __internal::__except_handler([&]() {
    return __par_backend::__parallel_reduce(
        std::forward<_ExecutionPolicy>(__exec), __first, __last, __last,
        [__last, __pred, __is_vector, __or_semantic](
            _RandomAccessIterator __begin, _RandomAccessIterator __end,
            _RandomAccessIterator __value) -> _RandomAccessIterator {
          if (__or_semantic && __value < __last) {
            __par_backend::__cancel_execution();
            return __value;
          }

          if (__value > __begin) {

            if (__end != __last)
              ++__end;

            const _RandomAccessIterator __res =
                __internal::__brick_adjacent_find(__begin, __end, __pred,
                                                  __is_vector, __or_semantic);
            if (__res < __end)
              __value = __res;
          }
          return __value;
        },
        [](_RandomAccessIterator __x, _RandomAccessIterator __y)
            -> _RandomAccessIterator { return __x < __y ? __x : __y; });
  });
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
void __pattern_nth_element(_ExecutionPolicy &&, _RandomAccessIterator __first,
                           _RandomAccessIterator __nth,
                           _RandomAccessIterator __last, _Compare __comp,
                           _IsVector, std::false_type) noexcept {
  std::nth_element(__first, __nth, __last, __comp);
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
void __pattern_nth_element(_ExecutionPolicy &&__exec,
                           _RandomAccessIterator __first,
                           _RandomAccessIterator __nth,
                           _RandomAccessIterator __last, _Compare __comp,
                           _IsVector __is_vector, std::true_type) noexcept {
  if (__first == __last || __nth == __last) {
    return;
  }

  using std::iter_swap;
  typedef typename std::iterator_traits<_RandomAccessIterator>::value_type _Tp;
  _RandomAccessIterator __x;
  do {
    __x = __internal::__pattern_partition(
        std::forward<_ExecutionPolicy>(__exec), __first + 1, __last,
        [&__comp, __first](const _Tp &__x) { return __comp(__x, *__first); },
        __is_vector, std::true_type());
    --__x;
    if (__x != __first) {
      iter_swap(__first, __x);
    }

    if (__x - __nth > 0) {
      __last = __x;
    }

    else if (__x - __nth < 0) {

      if (!__comp(*__nth, *__x) && !__comp(*__x, *__nth)) {
        ++__x;
      } else {
        iter_swap(__nth, __x);
      }
      __first = __x;
    }
  } while (__x != __nth);
}

template <class _ForwardIterator, class _Tp>
void __brick_fill(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp &__value, std::true_type) noexcept {
  __unseq_backend::__simd_fill_n(__first, __last - __first, __value);
}

template <class _ForwardIterator, class _Tp>
void __brick_fill(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp &__value, std::false_type) noexcept {
  std::fill(__first, __last, __value);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp,
          class _IsVector>
void __pattern_fill(_ExecutionPolicy &&, _ForwardIterator __first,
                    _ForwardIterator __last, const _Tp &__value,
                    std::false_type, _IsVector __is_vector) noexcept {
  __internal::__brick_fill(__first, __last, __value, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp,
          class _IsVector>
_ForwardIterator __pattern_fill(_ExecutionPolicy &&__exec,
                                _ForwardIterator __first,
                                _ForwardIterator __last, const _Tp &__value,
                                std::true_type, _IsVector __is_vector) {
  return __internal::__except_handler(
      [&__exec, __first, __last, &__value, __is_vector]() {
        __par_backend::__parallel_for(
            std::forward<_ExecutionPolicy>(__exec), __first, __last,
            [&__value, __is_vector](_ForwardIterator __begin,
                                    _ForwardIterator __end) {
              __internal::__brick_fill(__begin, __end, __value, __is_vector);
            });
        return __last;
      });
}

template <class _OutputIterator, class _Size, class _Tp>
_OutputIterator __brick_fill_n(_OutputIterator __first, _Size __count,
                               const _Tp &__value, std::true_type) noexcept {
  return __unseq_backend::__simd_fill_n(__first, __count, __value);
}

template <class _OutputIterator, class _Size, class _Tp>
_OutputIterator __brick_fill_n(_OutputIterator __first, _Size __count,
                               const _Tp &__value, std::false_type) noexcept {
  return std::fill_n(__first, __count, __value);
}

template <class _ExecutionPolicy, class _OutputIterator, class _Size, class _Tp,
          class _IsVector>
_OutputIterator __pattern_fill_n(_ExecutionPolicy &&, _OutputIterator __first,
                                 _Size __count, const _Tp &__value,
                                 std::false_type,
                                 _IsVector __is_vector) noexcept {
  return __internal::__brick_fill_n(__first, __count, __value, __is_vector);
}

template <class _ExecutionPolicy, class _OutputIterator, class _Size, class _Tp,
          class _IsVector>
_OutputIterator __pattern_fill_n(_ExecutionPolicy &&__exec,
                                 _OutputIterator __first, _Size __count,
                                 const _Tp &__value, std::true_type,
                                 _IsVector __is_vector) {
  return __internal::__pattern_fill(std::forward<_ExecutionPolicy>(__exec),
                                    __first, __first + __count, __value,
                                    std::true_type(), __is_vector);
}

template <class _RandomAccessIterator, class _Generator>
void __brick_generate(_RandomAccessIterator __first,
                      _RandomAccessIterator __last, _Generator __g,
                      std::true_type) noexcept {
  __unseq_backend::__simd_generate_n(__first, __last - __first, __g);
}

template <class _ForwardIterator, class _Generator>
void __brick_generate(_ForwardIterator __first, _ForwardIterator __last,
                      _Generator __g, std::false_type) noexcept {
  std::generate(__first, __last, __g);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Generator,
          class _IsVector>
void __pattern_generate(_ExecutionPolicy &&, _ForwardIterator __first,
                        _ForwardIterator __last, _Generator __g,
                        std::false_type, _IsVector __is_vector) noexcept {
  __internal::__brick_generate(__first, __last, __g, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Generator,
          class _IsVector>
_ForwardIterator __pattern_generate(_ExecutionPolicy &&__exec,
                                    _ForwardIterator __first,
                                    _ForwardIterator __last, _Generator __g,
                                    std::true_type, _IsVector __is_vector) {
  return __internal::__except_handler([&]() {
    __par_backend::__parallel_for(
        std::forward<_ExecutionPolicy>(__exec), __first, __last,
        [__g, __is_vector](_ForwardIterator __begin, _ForwardIterator __end) {
          __internal::__brick_generate(__begin, __end, __g, __is_vector);
        });
    return __last;
  });
}

template <class _OutputIterator, class _Size, class _Generator>
_OutputIterator __brick_generate_n(_OutputIterator __first, _Size __count,
                                   _Generator __g, std::true_type) noexcept {
  return __unseq_backend::__simd_generate_n(__first, __count, __g);
}

template <class _OutputIterator, class _Size, class _Generator>
_OutputIterator __brick_generate_n(_OutputIterator __first, _Size __count,
                                   _Generator __g, std::false_type) noexcept {
  return std::generate_n(__first, __count, __g);
}

template <class _ExecutionPolicy, class _OutputIterator, class _Size,
          class _Generator, class _IsVector>
_OutputIterator __pattern_generate_n(_ExecutionPolicy &&,
                                     _OutputIterator __first, _Size __count,
                                     _Generator __g, std::false_type,
                                     _IsVector __is_vector) noexcept {
  return __internal::__brick_generate_n(__first, __count, __g, __is_vector);
}

template <class _ExecutionPolicy, class _OutputIterator, class _Size,
          class _Generator, class _IsVector>
_OutputIterator __pattern_generate_n(_ExecutionPolicy &&__exec,
                                     _OutputIterator __first, _Size __count,
                                     _Generator __g, std::true_type,
                                     _IsVector __is_vector) {
  static_assert(__is_random_access_iterator<_OutputIterator>::value,
                "Pattern-brick error. Should be a random access iterator.");
  return __internal::__pattern_generate(std::forward<_ExecutionPolicy>(__exec),
                                        __first, __first + __count, __g,
                                        std::true_type(), __is_vector);
}

template <class _ForwardIterator, class _UnaryPredicate>
_ForwardIterator
__brick_remove_if(_ForwardIterator __first, _ForwardIterator __last,
                  _UnaryPredicate __pred, std::false_type) noexcept {
  return std::remove_if(__first, __last, __pred);
}

template <class _RandomAccessIterator, class _UnaryPredicate>
_RandomAccessIterator
__brick_remove_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
                  _UnaryPredicate __pred, std::true_type) noexcept {

  return std::remove_if(__first, __last, __pred);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate,
          class _IsVector>
_ForwardIterator
__pattern_remove_if(_ExecutionPolicy &&, _ForwardIterator __first,
                    _ForwardIterator __last, _UnaryPredicate __pred,
                    _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_remove_if(__first, __last, __pred, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate,
          class _IsVector>
_ForwardIterator
__pattern_remove_if(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                    _ForwardIterator __last, _UnaryPredicate __pred,
                    _IsVector __is_vector, std::true_type) noexcept {
  typedef
      typename std::iterator_traits<_ForwardIterator>::reference _ReferenceType;

  if (__first == __last || __first + 1 == __last) {

    return __internal::__brick_remove_if(__first, __last, __pred, __is_vector);
  }

  return __internal::__remove_elements(
      std::forward<_ExecutionPolicy>(__exec), __first, __last,
      [&__pred, __is_vector](bool *__b, bool *__e, _ForwardIterator __it) {
        __internal::__brick_walk2(
            __b, __e, __it,
            [&__pred](bool &__x, _ReferenceType __y) { __x = !__pred(__y); },
            __is_vector);
      },
      __is_vector);
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator
__brick_merge(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2,
              _OutputIterator __d_first, _Compare __comp,
              std::false_type) noexcept {
  return std::merge(__first1, __last1, __first2, __last2, __d_first, __comp);
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator
__brick_merge(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2,
              _OutputIterator __d_first, _Compare __comp,
              std::true_type) noexcept {
  ;
  return std::merge(__first1, __last1, __first2, __last2, __d_first, __comp);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator
__pattern_merge(_ExecutionPolicy &&, _ForwardIterator1 __first1,
                _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                _ForwardIterator2 __last2, _OutputIterator __d_first,
                _Compare __comp, _IsVector __is_vector,
                std::false_type) noexcept {
  return __internal::__brick_merge(__first1, __last1, __first2, __last2,
                                   __d_first, __comp, __is_vector);
}

template <class _ExecutionPolicy, class _RandomAccessIterator1,
          class _RandomAccessIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator
__pattern_merge(_ExecutionPolicy &&__exec, _RandomAccessIterator1 __first1,
                _RandomAccessIterator1 __last1, _RandomAccessIterator2 __first2,
                _RandomAccessIterator2 __last2, _OutputIterator __d_first,
                _Compare __comp, _IsVector __is_vector, std::true_type) {
  __par_backend::__parallel_merge(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      __last2, __d_first, __comp,
      [__is_vector](_RandomAccessIterator1 __f1, _RandomAccessIterator1 __l1,
                    _RandomAccessIterator2 __f2, _RandomAccessIterator2 __l2,
                    _OutputIterator __f3, _Compare __comp) {
        return __internal::__brick_merge(__f1, __l1, __f2, __l2, __f3, __comp,
                                         __is_vector);
      });
  return __d_first + (__last1 - __first1) + (__last2 - __first2);
}

template <class _BidirectionalIterator, class _Compare>
void __brick_inplace_merge(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
                           _BidirectionalIterator __last, _Compare __comp,
                           std::false_type) noexcept {
  std::inplace_merge(__first, __middle, __last, __comp);
}

template <class _BidirectionalIterator, class _Compare>
void __brick_inplace_merge(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
                           _BidirectionalIterator __last, _Compare __comp,
                           std::true_type) noexcept {

  std::inplace_merge(__first, __middle, __last, __comp);
}

template <class _ExecutionPolicy, class _BidirectionalIterator, class _Compare,
          class _IsVector>
void __pattern_inplace_merge(_ExecutionPolicy &&,
                             _BidirectionalIterator __first,
                             _BidirectionalIterator __middle,
                             _BidirectionalIterator __last, _Compare __comp,
                             _IsVector __is_vector, std::false_type) noexcept {
  __internal::__brick_inplace_merge(__first, __middle, __last, __comp,
                                    __is_vector);
}

template <class _ExecutionPolicy, class _BidirectionalIterator, class _Compare,
          class _IsVector>
void __pattern_inplace_merge(_ExecutionPolicy &&__exec,
                             _BidirectionalIterator __first,
                             _BidirectionalIterator __middle,
                             _BidirectionalIterator __last, _Compare __comp,
                             _IsVector __is_vector, std::true_type) {
  if (__first == __last || __first == __middle || __middle == __last) {
    return;
  }
  typedef typename std::iterator_traits<_BidirectionalIterator>::value_type _Tp;
  auto __n = __last - __first;
  __par_backend::__buffer<_Tp> __buf(__n);
  _Tp *__r = __buf.get();
  __internal::__except_handler([&]() {
    auto __move_values = [](_BidirectionalIterator __x, _Tp *__z) {
      __internal::__invoke_if_else(
          std::is_trivial<_Tp>(), [&]() { *__z = std::move(*__x); },
          [&]() { ::new (std::addressof(*__z)) _Tp(std::move(*__x)); });
    };

    auto __move_sequences = [](_BidirectionalIterator __first1,
                               _BidirectionalIterator __last1, _Tp *__first2) {
      return __internal::__brick_uninitialized_move(__first1, __last1, __first2,
                                                    _IsVector());
    };

    __par_backend::__parallel_merge(
        std::forward<_ExecutionPolicy>(__exec), __first, __middle, __middle,
        __last, __r, __comp,
        [__n, __move_values, __move_sequences](
            _BidirectionalIterator __f1, _BidirectionalIterator __l1,
            _BidirectionalIterator __f2, _BidirectionalIterator __l2, _Tp *__f3,
            _Compare __comp) {
          (__utils::__serial_move_merge(__n))(
              __f1, __l1, __f2, __l2, __f3, __comp, __move_values,
              __move_values, __move_sequences, __move_sequences);
          return __f3 + (__l1 - __f1) + (__l2 - __f2);
        });
    __par_backend::__parallel_for(
        std::forward<_ExecutionPolicy>(__exec), __r, __r + __n,
        [__r, __first, __is_vector](_Tp *__i, _Tp *__j) {
          __brick_move_destroy()(__i, __j, __first + (__i - __r), __is_vector);
        });
  });
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Compare, class _IsVector>
bool __pattern_includes(_ExecutionPolicy &&, _ForwardIterator1 __first1,
                        _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                        _ForwardIterator2 __last2, _Compare __comp, _IsVector,
                        std::false_type) noexcept {
  return std::includes(__first1, __last1, __first2, __last2, __comp);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Compare, class _IsVector>
bool __pattern_includes(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                        _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                        _ForwardIterator2 __last2, _Compare __comp, _IsVector,
                        std::true_type) {
  if (__first2 >= __last2)
    return true;

  if (__first1 >= __last1 || __comp(*__first2, *__first1) ||
      __comp(*(__last1 - 1), *(__last2 - 1)))
    return false;

  __first1 = std::lower_bound(__first1, __last1, *__first2, __comp);
  if (__first1 == __last1)
    return false;

  if (__last2 - __first2 == 1)
    return !__comp(*__first1, *__first2) && !__comp(*__first2, *__first1);

  return __internal::__except_handler([&]() {
    return !__internal::__parallel_or(
        std::forward<_ExecutionPolicy>(__exec), __first2, __last2,
        [__first1, __last1, __first2, __last2, &__comp](_ForwardIterator2 __i,
                                                        _ForwardIterator2 __j) {
          do {
            if (std::__is_constant_evaluated() && !bool(__j > __i))
              __builtin_unreachable();
          } while (false);

          auto __is_equal = [&__comp](_ForwardIterator2 __a,
                                      _ForwardIterator2 __b) -> bool {
            return !__comp(*__a, *__b) && !__comp(*__b, *__a);
          };

          if (__i > __first2 && __is_equal(__i, __i - 1)) {

            if (__is_equal(__i, __j - 1))
              return false;

            __i = std::upper_bound(__i, __last2, *__i, __comp);
          }

          if (__j < __last2 && __is_equal(__j - 1, __j))
            __j = std::upper_bound(__j, __last2, *__j, __comp);

          auto __b = std::lower_bound(__first1, __last1, *__i, __comp);

          do {
            if (std::__is_constant_evaluated() &&
                !bool(!__comp(*(__last1 - 1), *__b)))
              __builtin_unreachable();
          } while (false);
          do {
            if (std::__is_constant_evaluated() &&
                !bool(!__comp(*(__j - 1), *__i)))
              __builtin_unreachable();
          } while (false);
          return !std::includes(__b, __last1, __i, __j, __comp);
        });
  });
}

constexpr auto __set_algo_cut_off = 1000;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector, class _SizeFunction, class _SetOP>
_OutputIterator
__parallel_set_op(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                  _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                  _ForwardIterator2 __last2, _OutputIterator __result,
                  _Compare __comp, _SizeFunction __size_func, _SetOP __set_op,
                  _IsVector __is_vector) {
  typedef typename std::iterator_traits<_ForwardIterator1>::difference_type
      _DifferenceType;
  typedef typename std::iterator_traits<_OutputIterator>::value_type _Tp;

  struct _SetRange {
    _DifferenceType __pos, __len, __buf_pos;
    bool empty() const { return __len == 0; }
  };

  const _DifferenceType __n1 = __last1 - __first1;
  const _DifferenceType __n2 = __last2 - __first2;

  __par_backend::__buffer<_Tp> __buf(__size_func(__n1, __n2));

  return __internal::__except_handler([&__exec, __n1, __first1, __last1,
                                       __first2, __last2, __result, __is_vector,
                                       __comp, __size_func, __set_op,
                                       &__buf]() {
    auto __buffer = __buf.get();
    _DifferenceType __m{};
    auto __scan = [=](_DifferenceType, _DifferenceType, const _SetRange &__s) {
      if (!__s.empty())
        __brick_move_destroy()(__buffer + __s.__buf_pos,
                               __buffer + (__s.__buf_pos + __s.__len),
                               __result + __s.__pos, __is_vector);
    };
    __par_backend::__parallel_strict_scan(
        std::forward<_ExecutionPolicy>(__exec), __n1, _SetRange{0, 0, 0},
        [=](_DifferenceType __i, _DifferenceType __len) {
          _ForwardIterator1 __b = __first1 + __i,
                            __e = __first1 + (__i + __len);

          if (__b != __first1)
            __b = std::upper_bound(__b, __last1, *__b, __comp);

          if (__e != __last1)
            __e = std::upper_bound(__e, __last1, *__e, __comp);

          if (__e - __b < 1) {
            _ForwardIterator2 __bb = __last2;
            if (__b != __last1)
              __bb = std::lower_bound(__first2, __last2, *__b, __comp);

            const _DifferenceType __buf_pos =
                __size_func((__b - __first1), (__bb - __first2));
            return _SetRange{0, 0, __buf_pos};
          }

          _ForwardIterator2 __bb = __first2;
          if (__b != __first1)
            __bb = std::lower_bound(__first2, __last2, *__b, __comp);

          _ForwardIterator2 __ee = __last2;
          if (__e != __last1)
            __ee = std::lower_bound(__bb, __last2, *__e, __comp);

          const _DifferenceType __buf_pos =
              __size_func((__b - __first1), (__bb - __first2));
          auto __buffer_b = __buffer + __buf_pos;
          auto __res = __set_op(__b, __e, __bb, __ee, __buffer_b, __comp);

          return _SetRange{0, __res - __buffer_b, __buf_pos};
        },
        [](const _SetRange &__a, const _SetRange &__b) {
          if (__b.__buf_pos > __a.__buf_pos ||
              ((__b.__buf_pos == __a.__buf_pos) && !__b.empty()))
            return _SetRange{__a.__pos + __a.__len + __b.__pos, __b.__len,
                             __b.__buf_pos};
          return _SetRange{__b.__pos + __b.__len + __a.__pos, __a.__len,
                           __a.__buf_pos};
        },
        __scan,
        [&__m, &__scan](const _SetRange &__total) {
          __scan(0, 0, __total);
          __m = __total.__pos + __total.__len;
        });
    return __result + __m;
  });
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _SetUnionOp, class _IsVector>
_OutputIterator
__parallel_set_union_op(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                        _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                        _ForwardIterator2 __last2, _OutputIterator __result,
                        _Compare __comp, _SetUnionOp __set_union_op,
                        _IsVector __is_vector) {
  typedef typename std::iterator_traits<_ForwardIterator1>::difference_type
      _DifferenceType;

  const auto __n1 = __last1 - __first1;
  const auto __n2 = __last2 - __first2;

  auto __copy_range1 = [__is_vector](_ForwardIterator1 __begin,
                                     _ForwardIterator1 __end,
                                     _OutputIterator __res) {
    return __internal::__brick_copy(__begin, __end, __res, __is_vector);
  };
  auto __copy_range2 = [__is_vector](_ForwardIterator2 __begin,
                                     _ForwardIterator2 __end,
                                     _OutputIterator __res) {
    return __internal::__brick_copy(__begin, __end, __res, __is_vector);
  };

  if (__n2 == 0)
    return __internal::__pattern_walk2_brick(
        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __result,
        __copy_range1, std::true_type());

  if (__n1 == 0)
    return __internal::__pattern_walk2_brick(
        std::forward<_ExecutionPolicy>(__exec), __first2, __last2, __result,
        __copy_range2, std::true_type());

  _ForwardIterator1 __left_bound_seq_1 =
      std::lower_bound(__first1, __last1, *__first2, __comp);

  if (__left_bound_seq_1 == __last1) {

    __par_backend::__parallel_invoke(
        std::forward<_ExecutionPolicy>(__exec),
        [=] {
          __internal::__pattern_walk2_brick(
              std::forward<_ExecutionPolicy>(__exec), __first1, __last1,
              __result, __copy_range1, std::true_type());
        },
        [=] {
          __internal::__pattern_walk2_brick(
              std::forward<_ExecutionPolicy>(__exec), __first2, __last2,
              __result + __n1, __copy_range2, std::true_type());
        });
    return __result + __n1 + __n2;
  }

  _ForwardIterator2 __left_bound_seq_2 =
      std::lower_bound(__first2, __last2, *__first1, __comp);

  if (__left_bound_seq_2 == __last2) {

    __par_backend::__parallel_invoke(
        std::forward<_ExecutionPolicy>(__exec),
        [=] {
          __internal::__pattern_walk2_brick(
              std::forward<_ExecutionPolicy>(__exec), __first2, __last2,
              __result, __copy_range2, std::true_type());
        },
        [=] {
          __internal::__pattern_walk2_brick(
              std::forward<_ExecutionPolicy>(__exec), __first1, __last1,
              __result + __n2, __copy_range1, std::true_type());
        });
    return __result + __n1 + __n2;
  }

  const auto __m1 = __left_bound_seq_1 - __first1;
  if (__m1 > __set_algo_cut_off) {
    auto __res_or = __result;
    __result += __m1;
    __par_backend::__parallel_invoke(
        std::forward<_ExecutionPolicy>(__exec),

        [=] {
          __internal::__pattern_walk2_brick(
              std::forward<_ExecutionPolicy>(__exec), __first1,
              __left_bound_seq_1, __res_or, __copy_range1, std::true_type());
        },
        [=, &__result] {
          __result = __internal::__parallel_set_op(
              std::forward<_ExecutionPolicy>(__exec), __left_bound_seq_1,
              __last1, __first2, __last2, __result, __comp,
              [](_DifferenceType __n, _DifferenceType __m) {
                return __n + __m;
              },
              __set_union_op, __is_vector);
        });
    return __result;
  }

  const auto __m2 = __left_bound_seq_2 - __first2;
  do {
    if (std::__is_constant_evaluated() && !bool(__m1 == 0 || __m2 == 0))
      __builtin_unreachable();
  } while (false);
  if (__m2 > __set_algo_cut_off) {
    auto __res_or = __result;
    __result += __m2;
    __par_backend::__parallel_invoke(
        std::forward<_ExecutionPolicy>(__exec),

        [=] {
          __internal::__pattern_walk2_brick(
              std::forward<_ExecutionPolicy>(__exec), __first2,
              __left_bound_seq_2, __res_or, __copy_range2, std::true_type());
        },
        [=, &__result] {
          __result = __internal::__parallel_set_op(
              std::forward<_ExecutionPolicy>(__exec), __first1, __last1,
              __left_bound_seq_2, __last2, __result, __comp,
              [](_DifferenceType __n, _DifferenceType __m) {
                return __n + __m;
              },
              __set_union_op, __is_vector);
        });
    return __result;
  }

  return __internal::__parallel_set_op(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      __last2, __result, __comp,
      [](_DifferenceType __n, _DifferenceType __m) { return __n + __m; },
      __set_union_op, __is_vector);
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator
__brick_set_union(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                  _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                  _OutputIterator __result, _Compare __comp,
                  std::false_type) noexcept {
  return std::set_union(__first1, __last1, __first2, __last2, __result, __comp);
}

template <typename _IsVector> struct __BrickCopyConstruct {
  template <typename _ForwardIterator, typename _OutputIterator>
  _OutputIterator operator()(_ForwardIterator __first, _ForwardIterator __last,
                             _OutputIterator __result) {
    return __brick_uninitialized_copy(__first, __last, __result, _IsVector());
  }
};

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator
__brick_set_union(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                  _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                  _OutputIterator __result, _Compare __comp,
                  std::true_type) noexcept {
  ;
  return std::set_union(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator
__pattern_set_union(_ExecutionPolicy &&, _ForwardIterator1 __first1,
                    _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                    _ForwardIterator2 __last2, _OutputIterator __result,
                    _Compare __comp, _IsVector __is_vector,
                    std::false_type) noexcept {
  return __internal::__brick_set_union(__first1, __last1, __first2, __last2,
                                       __result, __comp, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator
__pattern_set_union(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                    _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                    _ForwardIterator2 __last2, _OutputIterator __result,
                    _Compare __comp, _IsVector __is_vector, std::true_type) {

  const auto __n1 = __last1 - __first1;
  const auto __n2 = __last2 - __first2;

  if (__n1 + __n2 <= __set_algo_cut_off)
    return std::set_union(__first1, __last1, __first2, __last2, __result,
                          __comp);

  typedef typename std::iterator_traits<_OutputIterator>::value_type _Tp;
  return __parallel_set_union_op(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      __last2, __result, __comp,
      [](_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _Tp *__result,
         _Compare __comp) {
        return __pstl::__utils::__set_union_construct(
            __first1, __last1, __first2, __last2, __result, __comp,
            __BrickCopyConstruct<_IsVector>());
      },
      __is_vector);
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator
__brick_set_intersection(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                         _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                         _OutputIterator __result, _Compare __comp,
                         std::false_type) noexcept {
  return std::set_intersection(__first1, __last1, __first2, __last2, __result,
                               __comp);
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator
__brick_set_intersection(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                         _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                         _OutputIterator __result, _Compare __comp,
                         std::true_type) noexcept {
  ;
  return std::set_intersection(__first1, __last1, __first2, __last2, __result,
                               __comp);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator __pattern_set_intersection(
    _ExecutionPolicy &&, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _OutputIterator __result, _Compare __comp, _IsVector __is_vector,
    std::false_type) noexcept {
  return __internal::__brick_set_intersection(
      __first1, __last1, __first2, __last2, __result, __comp, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator __pattern_set_intersection(
    _ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
    _ForwardIterator1 __last1, _ForwardIterator2 __first2,
    _ForwardIterator2 __last2, _OutputIterator __result, _Compare __comp,
    _IsVector __is_vector, std::true_type) {
  typedef typename std::iterator_traits<_OutputIterator>::value_type _Tp;
  typedef typename std::iterator_traits<_ForwardIterator1>::difference_type
      _DifferenceType;

  const auto __n1 = __last1 - __first1;
  const auto __n2 = __last2 - __first2;

  if (__n1 == 0 || __n2 == 0)
    return __result;

  _ForwardIterator1 __left_bound_seq_1 =
      std::lower_bound(__first1, __last1, *__first2, __comp);

  if (__left_bound_seq_1 == __last1)
    return __result;

  _ForwardIterator2 __left_bound_seq_2 =
      std::lower_bound(__first2, __last2, *__first1, __comp);

  if (__left_bound_seq_2 == __last2)
    return __result;

  const auto __m1 = __last1 - __left_bound_seq_1 + __n2;
  if (__m1 > __set_algo_cut_off) {

    return __internal::__parallel_set_op(
        std::forward<_ExecutionPolicy>(__exec), __left_bound_seq_1, __last1,
        __first2, __last2, __result, __comp,
        [](_DifferenceType __n, _DifferenceType __m) {
          return std::min(__n, __m);
        },
        [](_ForwardIterator1 __first1, _ForwardIterator1 __last1,
           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _Tp *__result,
           _Compare __comp) {
          return __pstl::__utils::__set_intersection_construct(
              __first1, __last1, __first2, __last2, __result, __comp);
        },
        __is_vector);
  }

  const auto __m2 = __last2 - __left_bound_seq_2 + __n1;
  if (__m2 > __set_algo_cut_off) {

    __result = __internal::__parallel_set_op(
        std::forward<_ExecutionPolicy>(__exec), __first1, __last1,
        __left_bound_seq_2, __last2, __result, __comp,
        [](_DifferenceType __n, _DifferenceType __m) {
          return std::min(__n, __m);
        },
        [](_ForwardIterator1 __first1, _ForwardIterator1 __last1,
           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _Tp *__result,
           _Compare __comp) {
          return __pstl::__utils::__set_intersection_construct(
              __first2, __last2, __first1, __last1, __result, __comp);
        },
        __is_vector);
    return __result;
  }

  return std::set_intersection(__left_bound_seq_1, __last1, __left_bound_seq_2,
                               __last2, __result, __comp);
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator
__brick_set_difference(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                       _OutputIterator __result, _Compare __comp,
                       std::false_type) noexcept {
  return std::set_difference(__first1, __last1, __first2, __last2, __result,
                             __comp);
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator
__brick_set_difference(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                       _OutputIterator __result, _Compare __comp,
                       std::true_type) noexcept {
  ;
  return std::set_difference(__first1, __last1, __first2, __last2, __result,
                             __comp);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator
__pattern_set_difference(_ExecutionPolicy &&, _ForwardIterator1 __first1,
                         _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                         _ForwardIterator2 __last2, _OutputIterator __result,
                         _Compare __comp, _IsVector __is_vector,
                         std::false_type) noexcept {
  return __internal::__brick_set_difference(
      __first1, __last1, __first2, __last2, __result, __comp, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator
__pattern_set_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                         _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                         _ForwardIterator2 __last2, _OutputIterator __result,
                         _Compare __comp, _IsVector __is_vector,
                         std::true_type) {
  typedef typename std::iterator_traits<_OutputIterator>::value_type _Tp;
  typedef typename std::iterator_traits<_ForwardIterator1>::difference_type
      _DifferenceType;

  const auto __n1 = __last1 - __first1;
  const auto __n2 = __last2 - __first2;

  if (__n1 == 0)
    return __result;

  if (__n2 == 0)
    return __internal::__pattern_walk2_brick(
        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __result,
        [__is_vector](_ForwardIterator1 __begin, _ForwardIterator1 __end,
                      _OutputIterator __res) {
          return __internal::__brick_copy(__begin, __end, __res, __is_vector);
        },
        std::true_type());

  _ForwardIterator1 __left_bound_seq_1 =
      std::lower_bound(__first1, __last1, *__first2, __comp);

  if (__left_bound_seq_1 == __last1)
    return __internal::__pattern_walk2_brick(
        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __result,
        [__is_vector](_ForwardIterator1 __begin, _ForwardIterator1 __end,
                      _OutputIterator __res) {
          return __internal::__brick_copy(__begin, __end, __res, __is_vector);
        },
        std::true_type());

  _ForwardIterator2 __left_bound_seq_2 =
      std::lower_bound(__first2, __last2, *__first1, __comp);

  if (__left_bound_seq_2 == __last2)
    return __internal::__pattern_walk2_brick(
        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __result,
        [__is_vector](_ForwardIterator1 __begin, _ForwardIterator1 __end,
                      _OutputIterator __res) {
          return __internal::__brick_copy(__begin, __end, __res, __is_vector);
        },
        std::true_type());

  if (__n1 + __n2 > __set_algo_cut_off)
    return __parallel_set_op(
        std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
        __last2, __result, __comp,
        [](_DifferenceType __n, _DifferenceType) { return __n; },
        [](_ForwardIterator1 __first1, _ForwardIterator1 __last1,
           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _Tp *__result,
           _Compare __comp) {
          return __pstl::__utils::__set_difference_construct(
              __first1, __last1, __first2, __last2, __result, __comp,
              __BrickCopyConstruct<_IsVector>());
        },
        __is_vector);

  return std::set_difference(__first1, __last1, __first2, __last2, __result,
                             __comp);
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator __brick_set_symmetric_difference(
    _ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _OutputIterator __result, _Compare __comp, std::false_type) noexcept {
  return std::set_symmetric_difference(__first1, __last1, __first2, __last2,
                                       __result, __comp);
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator __brick_set_symmetric_difference(
    _ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _OutputIterator __result, _Compare __comp, std::true_type) noexcept {
  ;
  return std::set_symmetric_difference(__first1, __last1, __first2, __last2,
                                       __result, __comp);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator __pattern_set_symmetric_difference(
    _ExecutionPolicy &&, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _OutputIterator __result, _Compare __comp, _IsVector __is_vector,
    std::false_type) noexcept {
  return __internal::__brick_set_symmetric_difference(
      __first1, __last1, __first2, __last2, __result, __comp, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator __pattern_set_symmetric_difference(
    _ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
    _ForwardIterator1 __last1, _ForwardIterator2 __first2,
    _ForwardIterator2 __last2, _OutputIterator __result, _Compare __comp,
    _IsVector __is_vector, std::true_type) {

  const auto __n1 = __last1 - __first1;
  const auto __n2 = __last2 - __first2;

  if (__n1 + __n2 <= __set_algo_cut_off)
    return std::set_symmetric_difference(__first1, __last1, __first2, __last2,
                                         __result, __comp);

  typedef typename std::iterator_traits<_OutputIterator>::value_type _Tp;
  return __internal::__parallel_set_union_op(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      __last2, __result, __comp,
      [](_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _Tp *__result,
         _Compare __comp) {
        return __pstl::__utils::__set_symmetric_difference_construct(
            __first1, __last1, __first2, __last2, __result, __comp,
            __BrickCopyConstruct<_IsVector>());
      },
      __is_vector);
}

template <class _RandomAccessIterator, class _Compare>
_RandomAccessIterator __brick_is_heap_until(_RandomAccessIterator __first,
                                            _RandomAccessIterator __last,
                                            _Compare __comp,
                                            std::false_type) noexcept {
  return std::is_heap_until(__first, __last, __comp);
}

template <class _RandomAccessIterator, class _Compare>
_RandomAccessIterator __brick_is_heap_until(_RandomAccessIterator __first,
                                            _RandomAccessIterator __last,
                                            _Compare __comp,
                                            std::true_type) noexcept {
  if (__last - __first < 2)
    return __last;
  typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type
      _SizeType;
  return __unseq_backend::__simd_first(
      __first, _SizeType(0), __last - __first,
      [&__comp](_RandomAccessIterator __it, _SizeType __i) {
        return __comp(__it[(__i - 1) / 2], __it[__i]);
      });
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
_RandomAccessIterator
__pattern_is_heap_until(_ExecutionPolicy &&, _RandomAccessIterator __first,
                        _RandomAccessIterator __last, _Compare __comp,
                        _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_is_heap_until(__first, __last, __comp,
                                           __is_vector);
}

template <class _RandomAccessIterator, class _DifferenceType, class _Compare>
_RandomAccessIterator
__is_heap_until_local(_RandomAccessIterator __first, _DifferenceType __begin,
                      _DifferenceType __end, _Compare __comp,
                      std::false_type) noexcept {
  _DifferenceType __i = __begin;
  for (; __i < __end; ++__i) {
    if (__comp(__first[(__i - 1) / 2], __first[__i])) {
      break;
    }
  }
  return __first + __i;
}

template <class _RandomAccessIterator, class _DifferenceType, class _Compare>
_RandomAccessIterator
__is_heap_until_local(_RandomAccessIterator __first, _DifferenceType __begin,
                      _DifferenceType __end, _Compare __comp,
                      std::true_type) noexcept {
  return __unseq_backend::__simd_first(
      __first, __begin, __end,
      [&__comp](_RandomAccessIterator __it, _DifferenceType __i) {
        return __comp(__it[(__i - 1) / 2], __it[__i]);
      });
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
_RandomAccessIterator
__pattern_is_heap_until(_ExecutionPolicy &&__exec,
                        _RandomAccessIterator __first,
                        _RandomAccessIterator __last, _Compare __comp,
                        _IsVector __is_vector, std::true_type) noexcept {
  if (__last - __first < 2)
    return __last;

  return __internal::__except_handler([&]() {
    return __parallel_find(
        std::forward<_ExecutionPolicy>(__exec), __first, __last,
        [__first, __comp, __is_vector](_RandomAccessIterator __i,
                                       _RandomAccessIterator __j) {
          return __internal::__is_heap_until_local(
              __first, __i - __first, __j - __first, __comp, __is_vector);
        },
        std::less<typename std::iterator_traits<
            _RandomAccessIterator>::difference_type>(),
        true);
  });
}

template <typename _ForwardIterator, typename _Compare>
_ForwardIterator __brick_min_element(_ForwardIterator __first,
                                     _ForwardIterator __last, _Compare __comp,
                                     std::false_type) noexcept {
  return std::min_element(__first, __last, __comp);
}

template <typename _ForwardIterator, typename _Compare>
_ForwardIterator __brick_min_element(_ForwardIterator __first,
                                     _ForwardIterator __last, _Compare __comp,
                                     std::true_type) noexcept {

  return std::min_element(__first, __last, __comp);
}

template <typename _ExecutionPolicy, typename _ForwardIterator,
          typename _Compare, typename _IsVector>
_ForwardIterator
__pattern_min_element(_ExecutionPolicy &&, _ForwardIterator __first,
                      _ForwardIterator __last, _Compare __comp,
                      _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_min_element(__first, __last, __comp, __is_vector);
}

template <typename _ExecutionPolicy, typename _RandomAccessIterator,
          typename _Compare, typename _IsVector>
_RandomAccessIterator
__pattern_min_element(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
                      _RandomAccessIterator __last, _Compare __comp,
                      _IsVector __is_vector, std::true_type) {
  if (__first == __last)
    return __last;

  return __internal::__except_handler([&]() {
    return __par_backend::__parallel_reduce(
        std::forward<_ExecutionPolicy>(__exec), __first + 1, __last, __first,
        [=](_RandomAccessIterator __begin, _RandomAccessIterator __end,
            _RandomAccessIterator __init) -> _RandomAccessIterator {
          const _RandomAccessIterator subresult =
              __internal::__brick_min_element(__begin, __end, __comp,
                                              __is_vector);
          return __internal::__cmp_iterators_by_values(__init, subresult,
                                                       __comp);
        },
        [=](_RandomAccessIterator __it1,
            _RandomAccessIterator __it2) -> _RandomAccessIterator {
          return __internal::__cmp_iterators_by_values(__it1, __it2, __comp);
        });
  });
}

template <typename _ForwardIterator, typename _Compare>
std::pair<_ForwardIterator, _ForwardIterator>
__brick_minmax_element(_ForwardIterator __first, _ForwardIterator __last,
                       _Compare __comp, std::false_type) noexcept {
  return std::minmax_element(__first, __last, __comp);
}

template <typename _ForwardIterator, typename _Compare>
std::pair<_ForwardIterator, _ForwardIterator>
__brick_minmax_element(_ForwardIterator __first, _ForwardIterator __last,
                       _Compare __comp, std::true_type) noexcept {

  return std::minmax_element(__first, __last, __comp);
}

template <typename _ExecutionPolicy, typename _ForwardIterator,
          typename _Compare, typename _IsVector>
std::pair<_ForwardIterator, _ForwardIterator>
__pattern_minmax_element(_ExecutionPolicy &&, _ForwardIterator __first,
                         _ForwardIterator __last, _Compare __comp,
                         _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_minmax_element(__first, __last, __comp,
                                            __is_vector);
}

template <typename _ExecutionPolicy, typename _ForwardIterator,
          typename _Compare, typename _IsVector>
std::pair<_ForwardIterator, _ForwardIterator>
__pattern_minmax_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                         _ForwardIterator __last, _Compare __comp,
                         _IsVector __is_vector, std::true_type) {
  if (__first == __last)
    return std::make_pair(__first, __first);

  return __internal::__except_handler([&]() {
    typedef std::pair<_ForwardIterator, _ForwardIterator> _Result;

    return __par_backend::__parallel_reduce(
        std::forward<_ExecutionPolicy>(__exec), __first + 1, __last,
        std::make_pair(__first, __first),
        [=](_ForwardIterator __begin, _ForwardIterator __end,
            _Result __init) -> _Result {
          const _Result __subresult = __internal::__brick_minmax_element(
              __begin, __end, __comp, __is_vector);
          return std::make_pair(
              __internal::__cmp_iterators_by_values(__subresult.first,
                                                    __init.first, __comp),
              __internal::__cmp_iterators_by_values(
                  __init.second, __subresult.second, std::not_fn(__comp)));
        },
        [=](_Result __p1, _Result __p2) -> _Result {
          return std::make_pair(
              __internal::__cmp_iterators_by_values(__p1.first, __p2.first,
                                                    __comp),
              __internal::__cmp_iterators_by_values(__p2.second, __p1.second,
                                                    std::not_fn(__comp)));
        });
  });
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
std::pair<_ForwardIterator1, _ForwardIterator2>
__mismatch_serial(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                  _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                  _BinaryPredicate __pred) {

  return std::mismatch(__first1, __last1, __first2, __last2, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2, class _Predicate>
std::pair<_ForwardIterator1, _ForwardIterator2>
__brick_mismatch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                 _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                 _Predicate __pred, std::false_type) noexcept {
  return __mismatch_serial(__first1, __last1, __first2, __last2, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2, class _Predicate>
std::pair<_ForwardIterator1, _ForwardIterator2>
__brick_mismatch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                 _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                 _Predicate __pred, std::true_type) noexcept {
  auto __n = std::min(__last1 - __first1, __last2 - __first2);
  return __unseq_backend::__simd_first(__first1, __n, __first2,
                                       std::not_fn(__pred));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Predicate, class _IsVector>
std::pair<_ForwardIterator1, _ForwardIterator2>
__pattern_mismatch(_ExecutionPolicy &&, _ForwardIterator1 __first1,
                   _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                   _ForwardIterator2 __last2, _Predicate __pred,
                   _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_mismatch(__first1, __last1, __first2, __last2,
                                      __pred, __is_vector);
}

template <class _ExecutionPolicy, class _RandomAccessIterator1,
          class _RandomAccessIterator2, class _Predicate, class _IsVector>
std::pair<_RandomAccessIterator1, _RandomAccessIterator2>
__pattern_mismatch(_ExecutionPolicy &&__exec, _RandomAccessIterator1 __first1,
                   _RandomAccessIterator1 __last1,
                   _RandomAccessIterator2 __first2,
                   _RandomAccessIterator2 __last2, _Predicate __pred,
                   _IsVector __is_vector, std::true_type) noexcept {
  return __internal::__except_handler([&]() {
    auto __n = std::min(__last1 - __first1, __last2 - __first2);
    auto __result = __internal::__parallel_find(
        std::forward<_ExecutionPolicy>(__exec), __first1, __first1 + __n,
        [__first1, __first2, __pred, __is_vector](_RandomAccessIterator1 __i,
                                                  _RandomAccessIterator1 __j) {
          return __internal::__brick_mismatch(
                     __i, __j, __first2 + (__i - __first1),
                     __first2 + (__j - __first1), __pred, __is_vector)
              .first;
        },
        std::less<typename std::iterator_traits<
            _RandomAccessIterator1>::difference_type>(),
        true);
    return std::make_pair(__result, __first2 + (__result - __first1));
  });
}

template <class _ForwardIterator1, class _ForwardIterator2, class _Compare>
bool __brick_lexicographical_compare(_ForwardIterator1 __first1,
                                     _ForwardIterator1 __last1,
                                     _ForwardIterator2 __first2,
                                     _ForwardIterator2 __last2, _Compare __comp,
                                     std::false_type) noexcept {
  return std::lexicographical_compare(__first1, __last1, __first2, __last2,
                                      __comp);
}

template <class _ForwardIterator1, class _ForwardIterator2, class _Compare>
bool __brick_lexicographical_compare(_ForwardIterator1 __first1,
                                     _ForwardIterator1 __last1,
                                     _ForwardIterator2 __first2,
                                     _ForwardIterator2 __last2, _Compare __comp,
                                     std::true_type) noexcept {
  if (__first2 == __last2) {
    return false;
  } else if (__first1 == __last1) {
    return true;
  } else {
    typedef
        typename std::iterator_traits<_ForwardIterator1>::reference ref_type1;
    typedef
        typename std::iterator_traits<_ForwardIterator2>::reference ref_type2;
    --__last1;
    --__last2;
    auto __n = std::min(__last1 - __first1, __last2 - __first2);
    std::pair<_ForwardIterator1, _ForwardIterator2> __result =
        __unseq_backend::__simd_first(
            __first1, __n, __first2,
            [__comp](const ref_type1 __x, const ref_type2 __y) mutable {
              return __comp(__x, __y) || __comp(__y, __x);
            });

    if (__result.first == __last1 && __result.second != __last2) {
      return !__comp(*__result.second, *__result.first);
    } else {
      return __comp(*__result.first, *__result.second);
    }
  }
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Compare, class _IsVector>
bool __pattern_lexicographical_compare(
    _ExecutionPolicy &&, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2, _Compare __comp,
    _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_lexicographical_compare(
      __first1, __last1, __first2, __last2, __comp, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Compare, class _IsVector>
bool __pattern_lexicographical_compare(_ExecutionPolicy &&__exec,
                                       _ForwardIterator1 __first1,
                                       _ForwardIterator1 __last1,
                                       _ForwardIterator2 __first2,
                                       _ForwardIterator2 __last2,
                                       _Compare __comp, _IsVector __is_vector,
                                       std::true_type) noexcept {
  if (__first2 == __last2) {
    return false;
  } else if (__first1 == __last1) {
    return true;
  } else {
    typedef
        typename std::iterator_traits<_ForwardIterator1>::reference _RefType1;
    typedef
        typename std::iterator_traits<_ForwardIterator2>::reference _RefType2;
    --__last1;
    --__last2;
    auto __n = std::min(__last1 - __first1, __last2 - __first2);
    auto __result = __internal::__parallel_find(
        std::forward<_ExecutionPolicy>(__exec), __first1, __first1 + __n,
        [__first1, __first2, &__comp, __is_vector](_ForwardIterator1 __i,
                                                   _ForwardIterator1 __j) {
          return __internal::__brick_mismatch(
                     __i, __j, __first2 + (__i - __first1),
                     __first2 + (__j - __first1),
                     [&__comp](const _RefType1 __x, const _RefType2 __y) {
                       return !__comp(__x, __y) && !__comp(__y, __x);
                     },
                     __is_vector)
              .first;
        },
        std::less<typename std::iterator_traits<
            _ForwardIterator1>::difference_type>(),
        true);

    if (__result == __last1 && __first2 + (__result - __first1) != __last2) {
      return !__comp(*(__first2 + (__result - __first1)), *__result);
    } else {
      return __comp(*__result, *(__first2 + (__result - __first1)));
    }
  }
}

} // namespace __internal
} // namespace __pstl
# 51 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_execution_defs.h" 2 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/numeric_impl.h" 1 3
# 21 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/numeric_impl.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/algorithm_fwd.h" 1 3
# 16 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/algorithm_fwd.h" 3
namespace __pstl {
namespace __internal {

template <class _ForwardIterator, class _Pred>
bool __brick_any_of(const _ForwardIterator, const _ForwardIterator, _Pred,
                    std::false_type) noexcept;

template <class _ForwardIterator, class _Pred>
bool __brick_any_of(const _ForwardIterator, const _ForwardIterator, _Pred,
                    std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Pred,
          class _IsVector>
bool __pattern_any_of(_ExecutionPolicy &&, _ForwardIterator, _ForwardIterator,
                      _Pred, _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Pred,
          class _IsVector>
bool __pattern_any_of(_ExecutionPolicy &&, _ForwardIterator, _ForwardIterator,
                      _Pred, _IsVector, std::true_type);

template <class _ForwardIterator, class _Function>
void __brick_walk1(_ForwardIterator, _ForwardIterator, _Function,
                   std::false_type) noexcept;

template <class _RandomAccessIterator, class _Function>
void __brick_walk1(_RandomAccessIterator, _RandomAccessIterator, _Function,
                   std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Function,
          class _IsVector>
void __pattern_walk1(_ExecutionPolicy &&, _ForwardIterator, _ForwardIterator,
                     _Function, _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Function,
          class _IsVector>
void __pattern_walk1(_ExecutionPolicy &&, _ForwardIterator, _ForwardIterator,
                     _Function, _IsVector, std::true_type);

template <class _ExecutionPolicy, class _ForwardIterator, class _Brick>
void __pattern_walk_brick(_ExecutionPolicy &&, _ForwardIterator,
                          _ForwardIterator, _Brick, std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Brick>
void __pattern_walk_brick(_ExecutionPolicy &&, _ForwardIterator,
                          _ForwardIterator, _Brick, std::true_type);

template <class _ForwardIterator, class _Size, class _Function>
_ForwardIterator __brick_walk1_n(_ForwardIterator, _Size, _Function,
                                 std::false_type);

template <class _RandomAccessIterator, class _DifferenceType, class _Function>
_RandomAccessIterator __brick_walk1_n(_RandomAccessIterator, _DifferenceType,
                                      _Function, std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Function, class _IsVector>
_ForwardIterator __pattern_walk1_n(_ExecutionPolicy &&, _ForwardIterator, _Size,
                                   _Function, _IsVector,
                                   std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Size,
          class _Function, class _IsVector>
_RandomAccessIterator __pattern_walk1_n(_ExecutionPolicy &&,
                                        _RandomAccessIterator, _Size, _Function,
                                        _IsVector, std::true_type);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Brick>
_ForwardIterator __pattern_walk_brick_n(_ExecutionPolicy &&, _ForwardIterator,
                                        _Size, _Brick,
                                        std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Size,
          class _Brick>
_RandomAccessIterator __pattern_walk_brick_n(_ExecutionPolicy &&,
                                             _RandomAccessIterator, _Size,
                                             _Brick, std::true_type);

template <class _ForwardIterator1, class _ForwardIterator2, class _Function>
_ForwardIterator2 __brick_walk2(_ForwardIterator1, _ForwardIterator1,
                                _ForwardIterator2, _Function,
                                std::false_type) noexcept;

template <class _ForwardIterator1, class _ForwardIterator2, class _Function>
_ForwardIterator2 __brick_walk2(_ForwardIterator1, _ForwardIterator1,
                                _ForwardIterator2, _Function,
                                std::true_type) noexcept;

template <class _ForwardIterator1, class _Size, class _ForwardIterator2,
          class _Function>
_ForwardIterator2 __brick_walk2_n(_ForwardIterator1, _Size, _ForwardIterator2,
                                  _Function, std::false_type) noexcept;

template <class _ForwardIterator1, class _Size, class _ForwardIterator2,
          class _Function>
_ForwardIterator2 __brick_walk2_n(_ForwardIterator1, _Size, _ForwardIterator2,
                                  _Function, std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Function, class _IsVector>
_ForwardIterator2 __pattern_walk2(_ExecutionPolicy &&, _ForwardIterator1,
                                  _ForwardIterator1, _ForwardIterator2,
                                  _Function, _IsVector,
                                  std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Function, class _IsVector>
_ForwardIterator2 __pattern_walk2(_ExecutionPolicy &&, _ForwardIterator1,
                                  _ForwardIterator1, _ForwardIterator2,
                                  _Function, _IsVector, std::true_type);

template <class _ExecutionPolicy, class _ForwardIterator1, class _Size,
          class _ForwardIterator2, class _Function, class _IsVector>
_ForwardIterator2 __pattern_walk2_n(_ExecutionPolicy &&, _ForwardIterator1,
                                    _Size, _ForwardIterator2, _Function,
                                    _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator1, class _Size,
          class _RandomAccessIterator2, class _Function, class _IsVector>
_RandomAccessIterator2
__pattern_walk2_n(_ExecutionPolicy &&, _RandomAccessIterator1, _Size,
                  _RandomAccessIterator2, _Function, _IsVector, std::true_type);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Brick>
_ForwardIterator2 __pattern_walk2_brick(_ExecutionPolicy &&, _ForwardIterator1,
                                        _ForwardIterator1, _ForwardIterator2,
                                        _Brick, std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator1,
          class _RandomAccessIterator2, class _Brick>
_RandomAccessIterator2
__pattern_walk2_brick(_ExecutionPolicy &&, _RandomAccessIterator1,
                      _RandomAccessIterator1, _RandomAccessIterator2, _Brick,
                      std::true_type);

template <class _ExecutionPolicy, class _ForwardIterator1, class _Size,
          class _ForwardIterator2, class _Brick>
_ForwardIterator2
__pattern_walk2_brick_n(_ExecutionPolicy &&, _ForwardIterator1, _Size,
                        _ForwardIterator2, _Brick, std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator1, class _Size,
          class _RandomAccessIterator2, class _Brick>
_RandomAccessIterator2
__pattern_walk2_brick_n(_ExecutionPolicy &&, _RandomAccessIterator1, _Size,
                        _RandomAccessIterator2, _Brick, std::true_type);

template <class _ForwardIterator1, class _ForwardIterator2,
          class _ForwardIterator3, class _Function>
_ForwardIterator3 __brick_walk3(_ForwardIterator1, _ForwardIterator1,
                                _ForwardIterator2, _ForwardIterator3, _Function,
                                std::false_type) noexcept;

template <class _RandomAccessIterator1, class _RandomAccessIterator2,
          class _RandomAccessIterator3, class _Function>
_RandomAccessIterator3
    __brick_walk3(_RandomAccessIterator1, _RandomAccessIterator1,
                  _RandomAccessIterator2, _RandomAccessIterator3, _Function,
                  std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator3, class _Function,
          class _IsVector>
_ForwardIterator3 __pattern_walk3(_ExecutionPolicy &&, _ForwardIterator1,
                                  _ForwardIterator1, _ForwardIterator2,
                                  _ForwardIterator3, _Function, _IsVector,
                                  std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator1,
          class _RandomAccessIterator2, class _RandomAccessIterator3,
          class _Function, class _IsVector>
_RandomAccessIterator3
__pattern_walk3(_ExecutionPolicy &&, _RandomAccessIterator1,
                _RandomAccessIterator1, _RandomAccessIterator2,
                _RandomAccessIterator3, _Function, _IsVector, std::true_type);

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
bool __brick_equal(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2,
                   _BinaryPredicate, std::false_type) noexcept;

template <class _RandomAccessIterator1, class _RandomAccessIterator2,
          class _BinaryPredicate>
bool __brick_equal(_RandomAccessIterator1, _RandomAccessIterator1,
                   _RandomAccessIterator2, _BinaryPredicate,
                   std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate, class _IsVector>
bool __pattern_equal(_ExecutionPolicy &&, _ForwardIterator1, _ForwardIterator1,
                     _ForwardIterator2, _BinaryPredicate, _IsVector,
                     std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator1,
          class _RandomAccessIterator2, class _BinaryPredicate, class _IsVector>
bool __pattern_equal(_ExecutionPolicy &&, _RandomAccessIterator1,
                     _RandomAccessIterator1, _RandomAccessIterator2,
                     _BinaryPredicate, _IsVector, std::true_type);

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
bool __brick_equal(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2,
                   _ForwardIterator2, _BinaryPredicate,
                   std::false_type) noexcept;

template <class _RandomAccessIterator1, class _RandomAccessIterator2,
          class _BinaryPredicate>
bool __brick_equal(_RandomAccessIterator1, _RandomAccessIterator1,
                   _RandomAccessIterator2, _RandomAccessIterator2,
                   _BinaryPredicate, std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate, class _IsVector>
bool __pattern_equal(_ExecutionPolicy &&, _ForwardIterator1, _ForwardIterator1,
                     _ForwardIterator2, _ForwardIterator2, _BinaryPredicate,
                     _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator1,
          class _RandomAccessIterator2, class _BinaryPredicate, class _IsVector>
bool __pattern_equal(_ExecutionPolicy &&, _RandomAccessIterator1,
                     _RandomAccessIterator1, _RandomAccessIterator2,
                     _RandomAccessIterator2, _BinaryPredicate, _IsVector,
                     std::true_type);

template <class _ForwardIterator, class _Predicate>
_ForwardIterator __brick_find_if(_ForwardIterator, _ForwardIterator, _Predicate,
                                 std::false_type) noexcept;

template <class _RandomAccessIterator, class _Predicate>
_RandomAccessIterator __brick_find_if(_RandomAccessIterator,
                                      _RandomAccessIterator, _Predicate,
                                      std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate,
          class _IsVector>
_ForwardIterator __pattern_find_if(_ExecutionPolicy &&, _ForwardIterator,
                                   _ForwardIterator, _Predicate, _IsVector,
                                   std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate,
          class _IsVector>
_ForwardIterator __pattern_find_if(_ExecutionPolicy &&, _ForwardIterator,
                                   _ForwardIterator, _Predicate, _IsVector,
                                   std::true_type);

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
_ForwardIterator1 __brick_find_end(_ForwardIterator1, _ForwardIterator1,
                                   _ForwardIterator2, _ForwardIterator2,
                                   _BinaryPredicate, std::false_type) noexcept;

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
_ForwardIterator1 __brick_find_end(_ForwardIterator1, _ForwardIterator1,
                                   _ForwardIterator2, _ForwardIterator2,
                                   _BinaryPredicate, std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate, class _IsVector>
_ForwardIterator1 __pattern_find_end(_ExecutionPolicy &&, _ForwardIterator1,
                                     _ForwardIterator1, _ForwardIterator2,
                                     _ForwardIterator2, _BinaryPredicate,
                                     _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate, class _IsVector>
_ForwardIterator1 __pattern_find_end(_ExecutionPolicy &&, _ForwardIterator1,
                                     _ForwardIterator1, _ForwardIterator2,
                                     _ForwardIterator2, _BinaryPredicate,
                                     _IsVector, std::true_type) noexcept;

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
_ForwardIterator1 __brick_find_first_of(_ForwardIterator1, _ForwardIterator1,
                                        _ForwardIterator2, _ForwardIterator2,
                                        _BinaryPredicate,
                                        std::false_type) noexcept;

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
_ForwardIterator1 __brick_find_first_of(_ForwardIterator1, _ForwardIterator1,
                                        _ForwardIterator2, _ForwardIterator2,
                                        _BinaryPredicate,
                                        std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate, class _IsVector>
_ForwardIterator1
__pattern_find_first_of(_ExecutionPolicy &&, _ForwardIterator1,
                        _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,
                        _BinaryPredicate, _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate, class _IsVector>
_ForwardIterator1
__pattern_find_first_of(_ExecutionPolicy &&, _ForwardIterator1,
                        _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,
                        _BinaryPredicate, _IsVector, std::true_type) noexcept;

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
_ForwardIterator1 __brick_search(_ForwardIterator1, _ForwardIterator1,
                                 _ForwardIterator2, _ForwardIterator2,
                                 _BinaryPredicate, std::false_type) noexcept;

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
_ForwardIterator1 __brick_search(_ForwardIterator1, _ForwardIterator1,
                                 _ForwardIterator2, _ForwardIterator2,
                                 _BinaryPredicate, std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate, class _IsVector>
_ForwardIterator1 __pattern_search(_ExecutionPolicy &&, _ForwardIterator1,
                                   _ForwardIterator1, _ForwardIterator2,
                                   _ForwardIterator2, _BinaryPredicate,
                                   _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate, class _IsVector>
_ForwardIterator1 __pattern_search(_ExecutionPolicy &&, _ForwardIterator1,
                                   _ForwardIterator1, _ForwardIterator2,
                                   _ForwardIterator2, _BinaryPredicate,
                                   _IsVector, std::true_type) noexcept;

template <class _ForwardIterator, class _Size, class _Tp,
          class _BinaryPredicate>
_ForwardIterator __brick_search_n(_ForwardIterator, _ForwardIterator, _Size,
                                  const _Tp &, _BinaryPredicate,
                                  std::false_type) noexcept;

template <class _ForwardIterator, class _Size, class _Tp,
          class _BinaryPredicate>
_ForwardIterator __brick_search_n(_ForwardIterator, _ForwardIterator, _Size,
                                  const _Tp &, _BinaryPredicate,
                                  std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Tp, class _BinaryPredicate, class _IsVector>
_ForwardIterator __pattern_search_n(_ExecutionPolicy &&, _ForwardIterator,
                                    _ForwardIterator, _Size, const _Tp &,
                                    _BinaryPredicate, _IsVector,
                                    std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Size,
          class _Tp, class _BinaryPredicate, class _IsVector>
_RandomAccessIterator
__pattern_search_n(_ExecutionPolicy &&, _RandomAccessIterator,
                   _RandomAccessIterator, _Size, const _Tp &, _BinaryPredicate,
                   _IsVector, std::true_type) noexcept;

template <class _ForwardIterator, class _Size, class _OutputIterator>
_OutputIterator __brick_copy_n(_ForwardIterator, _Size, _OutputIterator,
                               std::false_type) noexcept;

template <class _ForwardIterator, class _Size, class _OutputIterator>
_OutputIterator __brick_copy_n(_ForwardIterator, _Size, _OutputIterator,
                               std::true_type) noexcept;

template <class _ForwardIterator, class _OutputIterator>
_OutputIterator __brick_copy(_ForwardIterator, _ForwardIterator,
                             _OutputIterator, std::false_type) noexcept;

template <class _RandomAccessIterator, class _OutputIterator>
_OutputIterator __brick_copy(_RandomAccessIterator, _RandomAccessIterator,
                             _OutputIterator, std::true_type) noexcept;

template <class _ForwardIterator, class _OutputIterator>
_OutputIterator __brick_move(_ForwardIterator, _ForwardIterator,
                             _OutputIterator, std::false_type) noexcept;

template <class _RandomAccessIterator, class _OutputIterator>
_OutputIterator __brick_move(_RandomAccessIterator, _RandomAccessIterator,
                             _OutputIterator, std::true_type) noexcept;

template <class _ForwardIterator, class _OutputIterator>
_OutputIterator
__brick_swap_ranges(_ForwardIterator __first, _ForwardIterator __last,
                    _OutputIterator __result, std::false_type) noexcept;

template <class _ForwardIterator, class _OutputIterator>
_OutputIterator
__brick_swap_ranges(_ForwardIterator __first, _ForwardIterator __last,
                    _OutputIterator __result, std::true_type) noexcept;

template <class _ForwardIterator, class _OutputIterator, class _UnaryPredicate>
_OutputIterator __brick_copy_if(_ForwardIterator, _ForwardIterator,
                                _OutputIterator, _UnaryPredicate,
                                std::false_type) noexcept;

template <class _ForwardIterator, class _OutputIterator, class _UnaryPredicate>
_OutputIterator __brick_copy_if(_ForwardIterator, _ForwardIterator,
                                _OutputIterator, _UnaryPredicate,
                                std::true_type) noexcept;

template <class _DifferenceType, class _ForwardIterator, class _UnaryPredicate>
std::pair<_DifferenceType, _DifferenceType>
__brick_calc_mask_1(_ForwardIterator, _ForwardIterator, bool *__restrict,
                    _UnaryPredicate, std::false_type) noexcept;
template <class _DifferenceType, class _RandomAccessIterator,
          class _UnaryPredicate>
std::pair<_DifferenceType, _DifferenceType>
__brick_calc_mask_1(_RandomAccessIterator, _RandomAccessIterator,
                    bool *__restrict, _UnaryPredicate, std::true_type) noexcept;

template <class _ForwardIterator, class _OutputIterator>
void __brick_copy_by_mask(_ForwardIterator, _ForwardIterator, _OutputIterator,
                          bool *, std::false_type) noexcept;

template <class _ForwardIterator, class _OutputIterator>
void __brick_copy_by_mask(_ForwardIterator, _ForwardIterator, _OutputIterator,
                          bool *__restrict, std::true_type) noexcept;

template <class _ForwardIterator, class _OutputIterator1,
          class _OutputIterator2>
void __brick_partition_by_mask(_ForwardIterator, _ForwardIterator,
                               _OutputIterator1, _OutputIterator2, bool *,
                               std::false_type) noexcept;

template <class _RandomAccessIterator, class _OutputIterator1,
          class _OutputIterator2>
void __brick_partition_by_mask(_RandomAccessIterator, _RandomAccessIterator,
                               _OutputIterator1, _OutputIterator2, bool *,
                               std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator,
          class _UnaryPredicate, class _IsVector>
_OutputIterator __pattern_copy_if(_ExecutionPolicy &&, _ForwardIterator,
                                  _ForwardIterator, _OutputIterator,
                                  _UnaryPredicate, _IsVector,
                                  std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator,
          class _OutputIterator, class _UnaryPredicate, class _IsVector>
_OutputIterator __pattern_copy_if(_ExecutionPolicy &&, _RandomAccessIterator,
                                  _RandomAccessIterator, _OutputIterator,
                                  _UnaryPredicate, _IsVector, std::true_type);

template <class _ForwardIterator, class _Predicate>
typename std::iterator_traits<_ForwardIterator>::difference_type
    __brick_count(_ForwardIterator, _ForwardIterator, _Predicate,
                  std::true_type) noexcept;

template <class _ForwardIterator, class _Predicate>
typename std::iterator_traits<_ForwardIterator>::difference_type
    __brick_count(_ForwardIterator, _ForwardIterator, _Predicate,
                  std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate,
          class _IsVector>
typename std::iterator_traits<_ForwardIterator>::difference_type
__pattern_count(_ExecutionPolicy &&, _ForwardIterator, _ForwardIterator,
                _Predicate, std::false_type, _IsVector) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate,
          class _IsVector>
typename std::iterator_traits<_ForwardIterator>::difference_type
__pattern_count(_ExecutionPolicy &&, _ForwardIterator, _ForwardIterator,
                _Predicate, std::true_type, _IsVector);

template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator __brick_unique(_ForwardIterator, _ForwardIterator,
                                _BinaryPredicate, std::false_type) noexcept;

template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator __brick_unique(_ForwardIterator, _ForwardIterator,
                                _BinaryPredicate, std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator,
          class _BinaryPredicate, class _IsVector>
_ForwardIterator __pattern_unique(_ExecutionPolicy &&, _ForwardIterator,
                                  _ForwardIterator, _BinaryPredicate, _IsVector,
                                  std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator,
          class _BinaryPredicate, class _IsVector>
_ForwardIterator __pattern_unique(_ExecutionPolicy &&, _ForwardIterator,
                                  _ForwardIterator, _BinaryPredicate, _IsVector,
                                  std::true_type) noexcept;

template <class _ForwardIterator, class _OutputIterator, class _BinaryPredicate>
_OutputIterator __brick_unique_copy(_ForwardIterator, _ForwardIterator,
                                    _OutputIterator, _BinaryPredicate,
                                    std::false_type) noexcept;

template <class _RandomAccessIterator, class _OutputIterator,
          class _BinaryPredicate>
_OutputIterator __brick_unique_copy(_RandomAccessIterator,
                                    _RandomAccessIterator, _OutputIterator,
                                    _BinaryPredicate, std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator,
          class _BinaryPredicate, class _IsVector>
_OutputIterator __pattern_unique_copy(_ExecutionPolicy &&, _ForwardIterator,
                                      _ForwardIterator, _OutputIterator,
                                      _BinaryPredicate, _IsVector,
                                      std::false_type) noexcept;

template <class _ExecutionPolicy, class _DifferenceType,
          class _RandomAccessIterator, class _BinaryPredicate>
_DifferenceType __brick_calc_mask_2(_RandomAccessIterator,
                                    _RandomAccessIterator, bool *__restrict,
                                    _BinaryPredicate, std::false_type) noexcept;

template <class _DifferenceType, class _RandomAccessIterator,
          class _BinaryPredicate>
_DifferenceType __brick_calc_mask_2(_RandomAccessIterator,
                                    _RandomAccessIterator, bool *__restrict,
                                    _BinaryPredicate, std::true_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator,
          class _OutputIterator, class _BinaryPredicate, class _IsVector>
_OutputIterator
__pattern_unique_copy(_ExecutionPolicy &&, _RandomAccessIterator,
                      _RandomAccessIterator, _OutputIterator, _BinaryPredicate,
                      _IsVector, std::true_type);

template <class _BidirectionalIterator>
void __brick_reverse(_BidirectionalIterator, _BidirectionalIterator,
                     std::false_type) noexcept;

template <class _BidirectionalIterator>
void __brick_reverse(_BidirectionalIterator, _BidirectionalIterator,
                     std::true_type) noexcept;

template <class _BidirectionalIterator>
void __brick_reverse(_BidirectionalIterator, _BidirectionalIterator,
                     _BidirectionalIterator, std::false_type) noexcept;

template <class _BidirectionalIterator>
void __brick_reverse(_BidirectionalIterator, _BidirectionalIterator,
                     _BidirectionalIterator, std::true_type) noexcept;

template <class _ExecutionPolicy, class _BidirectionalIterator, class _IsVector>
void __pattern_reverse(_ExecutionPolicy &&, _BidirectionalIterator,
                       _BidirectionalIterator, _IsVector,
                       std::false_type) noexcept;

template <class _ExecutionPolicy, class _BidirectionalIterator, class _IsVector>
void __pattern_reverse(_ExecutionPolicy &&, _BidirectionalIterator,
                       _BidirectionalIterator, _IsVector, std::true_type);

template <class _BidirectionalIterator, class _OutputIterator>
_OutputIterator __brick_reverse_copy(_BidirectionalIterator,
                                     _BidirectionalIterator, _OutputIterator,
                                     std::false_type) noexcept;

template <class _BidirectionalIterator, class _OutputIterator>
_OutputIterator __brick_reverse_copy(_BidirectionalIterator,
                                     _BidirectionalIterator, _OutputIterator,
                                     std::true_type) noexcept;

template <class _ExecutionPolicy, class _BidirectionalIterator,
          class _OutputIterator, class _IsVector>
_OutputIterator __pattern_reverse_copy(_ExecutionPolicy &&,
                                       _BidirectionalIterator,
                                       _BidirectionalIterator, _OutputIterator,
                                       _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _BidirectionalIterator,
          class _OutputIterator, class _IsVector>
_OutputIterator __pattern_reverse_copy(_ExecutionPolicy &&,
                                       _BidirectionalIterator,
                                       _BidirectionalIterator, _OutputIterator,
                                       _IsVector, std::true_type);

template <class _ForwardIterator>
_ForwardIterator __brick_rotate(_ForwardIterator, _ForwardIterator,
                                _ForwardIterator, std::false_type) noexcept;

template <class _ForwardIterator>
_ForwardIterator __brick_rotate(_ForwardIterator, _ForwardIterator,
                                _ForwardIterator, std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _IsVector>
_ForwardIterator __pattern_rotate(_ExecutionPolicy &&, _ForwardIterator,
                                  _ForwardIterator, _ForwardIterator, _IsVector,
                                  std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _IsVector>
_ForwardIterator __pattern_rotate(_ExecutionPolicy &&, _ForwardIterator,
                                  _ForwardIterator, _ForwardIterator, _IsVector,
                                  std::true_type);

template <class _ForwardIterator, class _OutputIterator>
_OutputIterator __brick_rotate_copy(_ForwardIterator, _ForwardIterator,
                                    _ForwardIterator, _OutputIterator,
                                    std::false_type) noexcept;

template <class _ForwardIterator, class _OutputIterator>
_OutputIterator __brick_rotate_copy(_ForwardIterator, _ForwardIterator,
                                    _ForwardIterator, _OutputIterator,
                                    std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator,
          class _IsVector>
_OutputIterator __pattern_rotate_copy(_ExecutionPolicy &&, _ForwardIterator,
                                      _ForwardIterator, _ForwardIterator,
                                      _OutputIterator, _IsVector,
                                      std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator,
          class _IsVector>
_OutputIterator __pattern_rotate_copy(_ExecutionPolicy &&, _ForwardIterator,
                                      _ForwardIterator, _ForwardIterator,
                                      _OutputIterator, _IsVector,
                                      std::true_type);

template <class _ForwardIterator, class _UnaryPredicate>
bool __brick_is_partitioned(_ForwardIterator, _ForwardIterator, _UnaryPredicate,
                            std::false_type) noexcept;

template <class _ForwardIterator, class _UnaryPredicate>
bool __brick_is_partitioned(_ForwardIterator, _ForwardIterator, _UnaryPredicate,
                            std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate,
          class _IsVector>
bool __pattern_is_partitioned(_ExecutionPolicy &&, _ForwardIterator,
                              _ForwardIterator, _UnaryPredicate, _IsVector,
                              std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate,
          class _IsVector>
bool __pattern_is_partitioned(_ExecutionPolicy &&, _ForwardIterator,
                              _ForwardIterator, _UnaryPredicate, _IsVector,
                              std::true_type);

template <class _ForwardIterator, class _UnaryPredicate>
_ForwardIterator __brick_partition(_ForwardIterator, _ForwardIterator,
                                   _UnaryPredicate, std::false_type) noexcept;

template <class _ForwardIterator, class _UnaryPredicate>
_ForwardIterator __brick_partition(_ForwardIterator, _ForwardIterator,
                                   _UnaryPredicate, std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate,
          class _IsVector>
_ForwardIterator __pattern_partition(_ExecutionPolicy &&, _ForwardIterator,
                                     _ForwardIterator, _UnaryPredicate,
                                     _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate,
          class _IsVector>
_ForwardIterator __pattern_partition(_ExecutionPolicy &&, _ForwardIterator,
                                     _ForwardIterator, _UnaryPredicate,
                                     _IsVector, std::true_type);

template <class _BidirectionalIterator, class _UnaryPredicate>
_BidirectionalIterator
    __brick_stable_partition(_BidirectionalIterator, _BidirectionalIterator,
                             _UnaryPredicate, std::false_type) noexcept;

template <class _BidirectionalIterator, class _UnaryPredicate>
_BidirectionalIterator
    __brick_stable_partition(_BidirectionalIterator, _BidirectionalIterator,
                             _UnaryPredicate, std::true_type) noexcept;

template <class _ExecutionPolicy, class _BidirectionalIterator,
          class _UnaryPredicate, class _IsVector>
_BidirectionalIterator
__pattern_stable_partition(_ExecutionPolicy &&, _BidirectionalIterator,
                           _BidirectionalIterator, _UnaryPredicate, _IsVector,
                           std::false_type) noexcept;

template <class _ExecutionPolicy, class _BidirectionalIterator,
          class _UnaryPredicate, class _IsVector>
_BidirectionalIterator
__pattern_stable_partition(_ExecutionPolicy &&, _BidirectionalIterator,
                           _BidirectionalIterator, _UnaryPredicate, _IsVector,
                           std::true_type) noexcept;

template <class _ForwardIterator, class _OutputIterator1,
          class _OutputIterator2, class _UnaryPredicate>
std::pair<_OutputIterator1, _OutputIterator2>
    __brick_partition_copy(_ForwardIterator, _ForwardIterator, _OutputIterator1,
                           _OutputIterator2, _UnaryPredicate,
                           std::false_type) noexcept;

template <class _ForwardIterator, class _OutputIterator1,
          class _OutputIterator2, class _UnaryPredicate>
std::pair<_OutputIterator1, _OutputIterator2>
    __brick_partition_copy(_ForwardIterator, _ForwardIterator, _OutputIterator1,
                           _OutputIterator2, _UnaryPredicate,
                           std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator,
          class _OutputIterator1, class _OutputIterator2, class _UnaryPredicate,
          class _IsVector>
std::pair<_OutputIterator1, _OutputIterator2>
__pattern_partition_copy(_ExecutionPolicy &&, _ForwardIterator,
                         _ForwardIterator, _OutputIterator1, _OutputIterator2,
                         _UnaryPredicate, _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator,
          class _OutputIterator1, class _OutputIterator2, class _UnaryPredicate,
          class _IsVector>
std::pair<_OutputIterator1, _OutputIterator2>
__pattern_partition_copy(_ExecutionPolicy &&, _RandomAccessIterator,
                         _RandomAccessIterator, _OutputIterator1,
                         _OutputIterator2, _UnaryPredicate, _IsVector,
                         std::true_type);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector, class _IsMoveConstructible>
void __pattern_sort(_ExecutionPolicy &&, _RandomAccessIterator,
                    _RandomAccessIterator, _Compare, _IsVector, std::false_type,
                    _IsMoveConstructible) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
void __pattern_sort(_ExecutionPolicy &&, _RandomAccessIterator,
                    _RandomAccessIterator, _Compare, _IsVector, std::true_type,
                    std::true_type);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
void __pattern_stable_sort(_ExecutionPolicy &&, _RandomAccessIterator,
                           _RandomAccessIterator, _Compare, _IsVector,
                           std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
void __pattern_stable_sort(_ExecutionPolicy &&, _RandomAccessIterator,
                           _RandomAccessIterator, _Compare, _IsVector,
                           std::true_type);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
void __pattern_partial_sort(_ExecutionPolicy &&, _RandomAccessIterator,
                            _RandomAccessIterator, _RandomAccessIterator,
                            _Compare, _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
void __pattern_partial_sort(_ExecutionPolicy &&, _RandomAccessIterator,
                            _RandomAccessIterator, _RandomAccessIterator,
                            _Compare, _IsVector, std::true_type);

template <class _ExecutionPolicy, class _ForwardIterator,
          class _RandomAccessIterator, class _Compare, class _IsVector>
_RandomAccessIterator
__pattern_partial_sort_copy(_ExecutionPolicy &&, _ForwardIterator,
                            _ForwardIterator, _RandomAccessIterator,
                            _RandomAccessIterator, _Compare, _IsVector,
                            std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator,
          class _RandomAccessIterator, class _Compare, class _IsVector>
_RandomAccessIterator
__pattern_partial_sort_copy(_ExecutionPolicy &&, _ForwardIterator,
                            _ForwardIterator, _RandomAccessIterator,
                            _RandomAccessIterator, _Compare, _IsVector,
                            std::true_type);

template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator __brick_adjacent_find(_ForwardIterator, _ForwardIterator,
                                       _BinaryPredicate, std::true_type,
                                       bool) noexcept;

template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator __brick_adjacent_find(_ForwardIterator, _ForwardIterator,
                                       _BinaryPredicate, std::false_type,
                                       bool) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator,
          class _BinaryPredicate, class _IsVector>
_ForwardIterator __pattern_adjacent_find(_ExecutionPolicy &&, _ForwardIterator,
                                         _ForwardIterator, _BinaryPredicate,
                                         std::false_type, _IsVector,
                                         bool) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator,
          class _BinaryPredicate, class _IsVector>
_RandomAccessIterator
__pattern_adjacent_find(_ExecutionPolicy &&, _RandomAccessIterator,
                        _RandomAccessIterator, _BinaryPredicate, std::true_type,
                        _IsVector, bool);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
void __pattern_nth_element(_ExecutionPolicy &&, _RandomAccessIterator,
                           _RandomAccessIterator, _RandomAccessIterator,
                           _Compare, _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
void __pattern_nth_element(_ExecutionPolicy &&, _RandomAccessIterator,
                           _RandomAccessIterator, _RandomAccessIterator,
                           _Compare, _IsVector, std::true_type) noexcept;

template <class _ForwardIterator, class _Tp>
void __brick_fill(_ForwardIterator, _ForwardIterator, const _Tp &,
                  std::true_type) noexcept;

template <class _ForwardIterator, class _Tp>
void __brick_fill(_ForwardIterator, _ForwardIterator, const _Tp &,
                  std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp,
          class _IsVector>
void __pattern_fill(_ExecutionPolicy &&, _ForwardIterator, _ForwardIterator,
                    const _Tp &, std::false_type, _IsVector) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp,
          class _IsVector>
_ForwardIterator __pattern_fill(_ExecutionPolicy &&, _ForwardIterator,
                                _ForwardIterator, const _Tp &, std::true_type,
                                _IsVector);

template <class _OutputIterator, class _Size, class _Tp>
_OutputIterator __brick_fill_n(_OutputIterator, _Size, const _Tp &,
                               std::true_type) noexcept;

template <class _OutputIterator, class _Size, class _Tp>
_OutputIterator __brick_fill_n(_OutputIterator, _Size, const _Tp &,
                               std::false_type) noexcept;

template <class _ExecutionPolicy, class _OutputIterator, class _Size, class _Tp,
          class _IsVector>
_OutputIterator __pattern_fill_n(_ExecutionPolicy &&, _OutputIterator, _Size,
                                 const _Tp &, std::false_type,
                                 _IsVector) noexcept;

template <class _ExecutionPolicy, class _OutputIterator, class _Size, class _Tp,
          class _IsVector>
_OutputIterator __pattern_fill_n(_ExecutionPolicy &&, _OutputIterator, _Size,
                                 const _Tp &, std::true_type, _IsVector);

template <class _RandomAccessIterator, class _Generator>
void __brick_generate(_RandomAccessIterator, _RandomAccessIterator, _Generator,
                      std::true_type) noexcept;

template <class _ForwardIterator, class _Generator>
void __brick_generate(_ForwardIterator, _ForwardIterator, _Generator,
                      std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Generator,
          class _IsVector>
void __pattern_generate(_ExecutionPolicy &&, _ForwardIterator, _ForwardIterator,
                        _Generator, std::false_type, _IsVector) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Generator,
          class _IsVector>
_ForwardIterator __pattern_generate(_ExecutionPolicy &&, _ForwardIterator,
                                    _ForwardIterator, _Generator,
                                    std::true_type, _IsVector);

template <class _OutputIterator, class _Size, class _Generator>
_OutputIterator __brick_generate_n(_OutputIterator, _Size, _Generator,
                                   std::true_type) noexcept;

template <class _OutputIterator, class _Size, class _Generator>
_OutputIterator __brick_generate_n(_OutputIterator, _Size, _Generator,
                                   std::false_type) noexcept;

template <class _ExecutionPolicy, class _OutputIterator, class _Size,
          class _Generator, class _IsVector>
_OutputIterator __pattern_generate_n(_ExecutionPolicy &&, _OutputIterator,
                                     _Size, _Generator, std::false_type,
                                     _IsVector) noexcept;

template <class _ExecutionPolicy, class _OutputIterator, class _Size,
          class _Generator, class _IsVector>
_OutputIterator __pattern_generate_n(_ExecutionPolicy &&, _OutputIterator,
                                     _Size, _Generator, std::true_type,
                                     _IsVector);

template <class _ForwardIterator, class _UnaryPredicate>
_ForwardIterator __brick_remove_if(_ForwardIterator, _ForwardIterator,
                                   _UnaryPredicate, std::false_type) noexcept;

template <class _RandomAccessIterator, class _UnaryPredicate>
_RandomAccessIterator __brick_remove_if(_RandomAccessIterator,
                                        _RandomAccessIterator, _UnaryPredicate,
                                        std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate,
          class _IsVector>
_ForwardIterator __pattern_remove_if(_ExecutionPolicy &&, _ForwardIterator,
                                     _ForwardIterator, _UnaryPredicate,
                                     _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate,
          class _IsVector>
_ForwardIterator __pattern_remove_if(_ExecutionPolicy &&, _ForwardIterator,
                                     _ForwardIterator, _UnaryPredicate,
                                     _IsVector, std::true_type) noexcept;

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator __brick_merge(_ForwardIterator1, _ForwardIterator1,
                              _ForwardIterator2, _ForwardIterator2,
                              _OutputIterator, _Compare,
                              std::false_type) noexcept;

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator __brick_merge(_ForwardIterator1, _ForwardIterator1,
                              _ForwardIterator2, _ForwardIterator2,
                              _OutputIterator, _Compare,
                              std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator __pattern_merge(_ExecutionPolicy &&, _ForwardIterator1,
                                _ForwardIterator1, _ForwardIterator2,
                                _ForwardIterator2, _OutputIterator, _Compare,
                                _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator1,
          class _RandomAccessIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator __pattern_merge(_ExecutionPolicy &&, _RandomAccessIterator1,
                                _RandomAccessIterator1, _RandomAccessIterator2,
                                _RandomAccessIterator2, _OutputIterator,
                                _Compare, _IsVector, std::true_type);

template <class _BidirectionalIterator, class _Compare>
void __brick_inplace_merge(_BidirectionalIterator, _BidirectionalIterator,
                           _BidirectionalIterator, _Compare,
                           std::false_type) noexcept;

template <class _BidirectionalIterator, class _Compare>
void __brick_inplace_merge(_BidirectionalIterator, _BidirectionalIterator,
                           _BidirectionalIterator, _Compare,
                           std::true_type) noexcept;

template <class _ExecutionPolicy, class _BidirectionalIterator, class _Compare,
          class _IsVector>
void __pattern_inplace_merge(_ExecutionPolicy &&, _BidirectionalIterator,
                             _BidirectionalIterator, _BidirectionalIterator,
                             _Compare, _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _BidirectionalIterator, class _Compare,
          class _IsVector>
void __pattern_inplace_merge(_ExecutionPolicy &&, _BidirectionalIterator,
                             _BidirectionalIterator, _BidirectionalIterator,
                             _Compare, _IsVector, std::true_type);

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Compare, class _IsVector>
bool __pattern_includes(_ExecutionPolicy &&, _ForwardIterator1,
                        _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,
                        _Compare, _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Compare, class _IsVector>
bool __pattern_includes(_ExecutionPolicy &&, _ForwardIterator1,
                        _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,
                        _Compare, _IsVector, std::true_type);

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator __brick_set_union(_ForwardIterator1, _ForwardIterator1,
                                  _ForwardIterator2, _ForwardIterator2,
                                  _OutputIterator, _Compare,
                                  std::false_type) noexcept;

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator __brick_set_union(_ForwardIterator1, _ForwardIterator1,
                                  _ForwardIterator2, _ForwardIterator2,
                                  _OutputIterator, _Compare,
                                  std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator
__pattern_set_union(_ExecutionPolicy &&, _ForwardIterator1, _ForwardIterator1,
                    _ForwardIterator2, _ForwardIterator2, _OutputIterator,
                    _Compare, _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator __pattern_set_union(_ExecutionPolicy &&, _ForwardIterator1,
                                    _ForwardIterator1, _ForwardIterator2,
                                    _ForwardIterator2, _OutputIterator,
                                    _Compare, _IsVector, std::true_type);

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator __brick_set_intersection(_ForwardIterator1, _ForwardIterator1,
                                         _ForwardIterator2, _ForwardIterator2,
                                         _OutputIterator, _Compare,
                                         std::false_type) noexcept;

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator __brick_set_intersection(_ForwardIterator1, _ForwardIterator1,
                                         _ForwardIterator2, _ForwardIterator2,
                                         _OutputIterator, _Compare,
                                         std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator __pattern_set_intersection(_ExecutionPolicy &&,
                                           _ForwardIterator1, _ForwardIterator1,
                                           _ForwardIterator2, _ForwardIterator2,
                                           _OutputIterator, _Compare, _IsVector,
                                           std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator __pattern_set_intersection(_ExecutionPolicy &&,
                                           _ForwardIterator1, _ForwardIterator1,
                                           _ForwardIterator2, _ForwardIterator2,
                                           _OutputIterator, _Compare, _IsVector,
                                           std::true_type);

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator __brick_set_difference(_ForwardIterator1, _ForwardIterator1,
                                       _ForwardIterator2, _ForwardIterator2,
                                       _OutputIterator, _Compare,
                                       std::false_type) noexcept;

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator __brick_set_difference(_ForwardIterator1, _ForwardIterator1,
                                       _ForwardIterator2, _ForwardIterator2,
                                       _OutputIterator, _Compare,
                                       std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator __pattern_set_difference(_ExecutionPolicy &&, _ForwardIterator1,
                                         _ForwardIterator1, _ForwardIterator2,
                                         _ForwardIterator2, _OutputIterator,
                                         _Compare, _IsVector,
                                         std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator __pattern_set_difference(_ExecutionPolicy &&, _ForwardIterator1,
                                         _ForwardIterator1, _ForwardIterator2,
                                         _ForwardIterator2, _OutputIterator,
                                         _Compare, _IsVector, std::true_type);

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator __brick_set_symmetric_difference(
    _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,
    _OutputIterator, _Compare, std::false_type) noexcept;

template <class _ForwardIterator1, class _ForwardIterator2,
          class _OutputIterator, class _Compare>
_OutputIterator __brick_set_symmetric_difference(
    _ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2,
    _OutputIterator, _Compare, std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator
__pattern_set_symmetric_difference(_ExecutionPolicy &&, _ForwardIterator1,
                                   _ForwardIterator1, _ForwardIterator2,
                                   _ForwardIterator2, _OutputIterator, _Compare,
                                   _IsVector, std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _OutputIterator, class _Compare,
          class _IsVector>
_OutputIterator
__pattern_set_symmetric_difference(_ExecutionPolicy &&, _ForwardIterator1,
                                   _ForwardIterator1, _ForwardIterator2,
                                   _ForwardIterator2, _OutputIterator, _Compare,
                                   _IsVector, std::true_type);

template <class _RandomAccessIterator, class _Compare>
_RandomAccessIterator __brick_is_heap_until(_RandomAccessIterator,
                                            _RandomAccessIterator, _Compare,
                                            std::false_type) noexcept;

template <class _RandomAccessIterator, class _Compare>
_RandomAccessIterator __brick_is_heap_until(_RandomAccessIterator,
                                            _RandomAccessIterator, _Compare,
                                            std::true_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
_RandomAccessIterator
__pattern_is_heap_until(_ExecutionPolicy &&, _RandomAccessIterator,
                        _RandomAccessIterator, _Compare, _IsVector,
                        std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare,
          class _IsVector>
_RandomAccessIterator
__pattern_is_heap_until(_ExecutionPolicy &&, _RandomAccessIterator,
                        _RandomAccessIterator, _Compare, _IsVector,
                        std::true_type) noexcept;

template <typename _ForwardIterator, typename _Compare>
_ForwardIterator __brick_min_element(_ForwardIterator, _ForwardIterator,
                                     _Compare, std::false_type) noexcept;

template <typename _ForwardIterator, typename _Compare>
_ForwardIterator __brick_min_element(_ForwardIterator, _ForwardIterator,
                                     _Compare, std::true_type) noexcept;

template <typename _ExecutionPolicy, typename _ForwardIterator,
          typename _Compare, typename _IsVector>
_ForwardIterator __pattern_min_element(_ExecutionPolicy &&, _ForwardIterator,
                                       _ForwardIterator, _Compare, _IsVector,
                                       std::false_type) noexcept;

template <typename _ExecutionPolicy, typename _RandomAccessIterator,
          typename _Compare, typename _IsVector>
_RandomAccessIterator __pattern_min_element(_ExecutionPolicy &&,
                                            _RandomAccessIterator,
                                            _RandomAccessIterator, _Compare,
                                            _IsVector, std::true_type);

template <typename _ForwardIterator, typename _Compare>
std::pair<_ForwardIterator, _ForwardIterator>
    __brick_minmax_element(_ForwardIterator, _ForwardIterator, _Compare,
                           std::false_type) noexcept;

template <typename _ForwardIterator, typename _Compare>
std::pair<_ForwardIterator, _ForwardIterator>
    __brick_minmax_element(_ForwardIterator, _ForwardIterator, _Compare,
                           std::true_type) noexcept;

template <typename _ExecutionPolicy, typename _ForwardIterator,
          typename _Compare, typename _IsVector>
std::pair<_ForwardIterator, _ForwardIterator>
__pattern_minmax_element(_ExecutionPolicy &&, _ForwardIterator,
                         _ForwardIterator, _Compare, _IsVector,
                         std::false_type) noexcept;

template <typename _ExecutionPolicy, typename _ForwardIterator,
          typename _Compare, typename _IsVector>
std::pair<_ForwardIterator, _ForwardIterator>
__pattern_minmax_element(_ExecutionPolicy &&, _ForwardIterator,
                         _ForwardIterator, _Compare, _IsVector, std::true_type);

template <class _ForwardIterator1, class _ForwardIterator2, class _Predicate>
std::pair<_ForwardIterator1, _ForwardIterator2>
    __brick_mismatch(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2,
                     _ForwardIterator2, _Predicate, std::false_type) noexcept;

template <class _ForwardIterator1, class _ForwardIterator2, class _Predicate>
std::pair<_ForwardIterator1, _ForwardIterator2>
    __brick_mismatch(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2,
                     _ForwardIterator2, _Predicate, std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Predicate, class _IsVector>
std::pair<_ForwardIterator1, _ForwardIterator2>
__pattern_mismatch(_ExecutionPolicy &&, _ForwardIterator1, _ForwardIterator1,
                   _ForwardIterator2, _ForwardIterator2, _Predicate, _IsVector,
                   std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator1,
          class _RandomAccessIterator2, class _Predicate, class _IsVector>
std::pair<_RandomAccessIterator1, _RandomAccessIterator2>
__pattern_mismatch(_ExecutionPolicy &&, _RandomAccessIterator1,
                   _RandomAccessIterator1, _RandomAccessIterator2,
                   _RandomAccessIterator2, _Predicate, _IsVector,
                   std::true_type) noexcept;

template <class _ForwardIterator1, class _ForwardIterator2, class _Compare>
bool __brick_lexicographical_compare(_ForwardIterator1, _ForwardIterator1,
                                     _ForwardIterator2, _ForwardIterator2,
                                     _Compare, std::false_type) noexcept;

template <class _ForwardIterator1, class _ForwardIterator2, class _Compare>
bool __brick_lexicographical_compare(_ForwardIterator1, _ForwardIterator1,
                                     _ForwardIterator2, _ForwardIterator2,
                                     _Compare, std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Compare, class _IsVector>
bool __pattern_lexicographical_compare(_ExecutionPolicy &&, _ForwardIterator1,
                                       _ForwardIterator1, _ForwardIterator2,
                                       _ForwardIterator2, _Compare, _IsVector,
                                       std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Compare, class _IsVector>
bool __pattern_lexicographical_compare(_ExecutionPolicy &&, _ForwardIterator1,
                                       _ForwardIterator1, _ForwardIterator2,
                                       _ForwardIterator2, _Compare, _IsVector,
                                       std::true_type) noexcept;

} // namespace __internal
} // namespace __pstl
# 22 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/numeric_impl.h" 2 3

namespace __pstl {
namespace __internal {

template <class _ForwardIterator1, class _ForwardIterator2, class _Tp,
          class _BinaryOperation1, class _BinaryOperation2>
_Tp __brick_transform_reduce(_ForwardIterator1 __first1,
                             _ForwardIterator1 __last1,
                             _ForwardIterator2 __first2, _Tp __init,
                             _BinaryOperation1 __binary_op1,
                             _BinaryOperation2 __binary_op2,
                             std::false_type) noexcept {
  return std::inner_product(__first1, __last1, __first2, __init, __binary_op1,
                            __binary_op2);
}

template <class _ForwardIterator1, class _ForwardIterator2, class _Tp,
          class _BinaryOperation1, class _BinaryOperation2>
_Tp __brick_transform_reduce(_ForwardIterator1 __first1,
                             _ForwardIterator1 __last1,
                             _ForwardIterator2 __first2, _Tp __init,
                             _BinaryOperation1 __binary_op1,
                             _BinaryOperation2 __binary_op2,
                             std::true_type) noexcept {
  typedef typename std::iterator_traits<_ForwardIterator1>::difference_type
      _DifferenceType;
  return __unseq_backend::__simd_transform_reduce(
      __last1 - __first1, __init, __binary_op1,
      [=, &__binary_op2](_DifferenceType __i) {
        return __binary_op2(__first1[__i], __first2[__i]);
      });
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp, class _BinaryOperation1,
          class _BinaryOperation2, class _IsVector>
_Tp __pattern_transform_reduce(_ExecutionPolicy &&, _ForwardIterator1 __first1,
                               _ForwardIterator1 __last1,
                               _ForwardIterator2 __first2, _Tp __init,
                               _BinaryOperation1 __binary_op1,
                               _BinaryOperation2 __binary_op2,
                               _IsVector __is_vector,
                               std::false_type) noexcept {
  return __brick_transform_reduce(__first1, __last1, __first2, __init,
                                  __binary_op1, __binary_op2, __is_vector);
}

template <class _ExecutionPolicy, class _RandomAccessIterator1,
          class _RandomAccessIterator2, class _Tp, class _BinaryOperation1,
          class _BinaryOperation2, class _IsVector>
_Tp __pattern_transform_reduce(_ExecutionPolicy &&__exec,
                               _RandomAccessIterator1 __first1,
                               _RandomAccessIterator1 __last1,
                               _RandomAccessIterator2 __first2, _Tp __init,
                               _BinaryOperation1 __binary_op1,
                               _BinaryOperation2 __binary_op2,
                               _IsVector __is_vector, std::true_type) {
  return __internal::__except_handler([&]() {
    return __par_backend::__parallel_transform_reduce(
        std::forward<_ExecutionPolicy>(__exec), __first1, __last1,
        [__first1, __first2, __binary_op2](_RandomAccessIterator1 __i) mutable {
          return __binary_op2(*__i, *(__first2 + (__i - __first1)));
        },
        __init, __binary_op1,
        [__first1, __first2, __binary_op1, __binary_op2,
         __is_vector](_RandomAccessIterator1 __i, _RandomAccessIterator1 __j,
                      _Tp __init) -> _Tp {
          return __internal::__brick_transform_reduce(
              __i, __j, __first2 + (__i - __first1), __init, __binary_op1,
              __binary_op2, __is_vector);
        });
  });
}

template <class _ForwardIterator, class _Tp, class _BinaryOperation,
          class _UnaryOperation>
_Tp __brick_transform_reduce(_ForwardIterator __first, _ForwardIterator __last,
                             _Tp __init, _BinaryOperation __binary_op,
                             _UnaryOperation __unary_op,
                             std::false_type) noexcept {
  return std::transform_reduce(__first, __last, __init, __binary_op,
                               __unary_op);
}

template <class _ForwardIterator, class _Tp, class _UnaryOperation,
          class _BinaryOperation>
_Tp __brick_transform_reduce(_ForwardIterator __first, _ForwardIterator __last,
                             _Tp __init, _BinaryOperation __binary_op,
                             _UnaryOperation __unary_op,
                             std::true_type) noexcept {
  typedef typename std::iterator_traits<_ForwardIterator>::difference_type
      _DifferenceType;
  return __unseq_backend::__simd_transform_reduce(
      __last - __first, __init, __binary_op,
      [=, &__unary_op](_DifferenceType __i) {
        return __unary_op(__first[__i]);
      });
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp,
          class _BinaryOperation, class _UnaryOperation, class _IsVector>
_Tp __pattern_transform_reduce(_ExecutionPolicy &&, _ForwardIterator __first,
                               _ForwardIterator __last, _Tp __init,
                               _BinaryOperation __binary_op,
                               _UnaryOperation __unary_op,
                               _IsVector __is_vector,
                               std::false_type) noexcept {
  return __internal::__brick_transform_reduce(
      __first, __last, __init, __binary_op, __unary_op, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp,
          class _BinaryOperation, class _UnaryOperation, class _IsVector>
_Tp __pattern_transform_reduce(_ExecutionPolicy &&__exec,
                               _ForwardIterator __first,
                               _ForwardIterator __last, _Tp __init,
                               _BinaryOperation __binary_op,
                               _UnaryOperation __unary_op,
                               _IsVector __is_vector, std::true_type) {
  return __internal::__except_handler([&]() {
    return __par_backend::__parallel_transform_reduce(
        std::forward<_ExecutionPolicy>(__exec), __first, __last,
        [__unary_op](_ForwardIterator __i) mutable { return __unary_op(*__i); },
        __init, __binary_op,
        [__unary_op, __binary_op,
         __is_vector](_ForwardIterator __i, _ForwardIterator __j, _Tp __init) {
          return __internal::__brick_transform_reduce(
              __i, __j, __init, __binary_op, __unary_op, __is_vector);
        });
  });
}
# 144 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/numeric_impl.h" 3
template <class _ForwardIterator, class _OutputIterator, class _UnaryOperation,
          class _Tp, class _BinaryOperation>
std::pair<_OutputIterator, _Tp>
__brick_transform_scan(_ForwardIterator __first, _ForwardIterator __last,
                       _OutputIterator __result, _UnaryOperation __unary_op,
                       _Tp __init, _BinaryOperation __binary_op,
                       std::false_type, std::false_type) noexcept {
  for (; __first != __last; ++__first, ++__result) {
    *__result = __init;

    __init = __binary_op(__init, __unary_op(*__first));
  }
  return std::make_pair(__result, __init);
}

template <class _ForwardIterator, class _OutputIterator, class _UnaryOperation,
          class _Tp, class _BinaryOperation>
std::pair<_OutputIterator, _Tp>
__brick_transform_scan(_ForwardIterator __first, _ForwardIterator __last,
                       _OutputIterator __result, _UnaryOperation __unary_op,
                       _Tp __init, _BinaryOperation __binary_op, std::true_type,
                       std::false_type) noexcept {
  for (; __first != __last; ++__first, ++__result) {

    __init = __binary_op(__init, __unary_op(*__first));
    *__result = __init;
  }
  return std::make_pair(__result, __init);
}

template <typename _Tp, typename _BinaryOperation>
using is_arithmetic_udop = std::integral_constant<
    bool, std::is_arithmetic<_Tp>::value &&
              !std::is_same<_BinaryOperation, std::plus<_Tp>>::value>;

template <class _ForwardIterator, class _OutputIterator, class _UnaryOperation,
          class _Tp, class _BinaryOperation, class _Inclusive>
typename std::enable_if<!is_arithmetic_udop<_Tp, _BinaryOperation>::value,
                        std::pair<_OutputIterator, _Tp>>::type
__brick_transform_scan(_ForwardIterator __first, _ForwardIterator __last,
                       _OutputIterator __result, _UnaryOperation __unary_op,
                       _Tp __init, _BinaryOperation __binary_op, _Inclusive,
                       std::true_type) noexcept {

  return __internal::__brick_transform_scan(__first, __last, __result,
                                            __unary_op, __init, __binary_op,
                                            _Inclusive(), std::false_type());
}

template <class _ForwardIterator, class _OutputIterator, class _UnaryOperation,
          class _Tp, class _BinaryOperation, class _Inclusive>
typename std::enable_if<is_arithmetic_udop<_Tp, _BinaryOperation>::value,
                        std::pair<_OutputIterator, _Tp>>::type
__brick_transform_scan(_ForwardIterator __first, _ForwardIterator __last,
                       _OutputIterator __result, _UnaryOperation __unary_op,
                       _Tp __init, _BinaryOperation __binary_op, _Inclusive,
                       std::true_type) noexcept {
  return __internal::__brick_transform_scan(__first, __last, __result,
                                            __unary_op, __init, __binary_op,
                                            _Inclusive(), std::false_type());
}

template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator,
          class _UnaryOperation, class _Tp, class _BinaryOperation,
          class _Inclusive, class _IsVector>
_OutputIterator
__pattern_transform_scan(_ExecutionPolicy &&, _ForwardIterator __first,
                         _ForwardIterator __last, _OutputIterator __result,
                         _UnaryOperation __unary_op, _Tp __init,
                         _BinaryOperation __binary_op, _Inclusive,
                         _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_transform_scan(__first, __last, __result,
                                            __unary_op, __init, __binary_op,
                                            _Inclusive(), __is_vector)
      .first;
}

template <class _ExecutionPolicy, class _RandomAccessIterator,
          class _OutputIterator, class _UnaryOperation, class _Tp,
          class _BinaryOperation, class _Inclusive, class _IsVector>
typename std::enable_if<!std::is_floating_point<_Tp>::value,
                        _OutputIterator>::type
__pattern_transform_scan(_ExecutionPolicy &&__exec,
                         _RandomAccessIterator __first,
                         _RandomAccessIterator __last, _OutputIterator __result,
                         _UnaryOperation __unary_op, _Tp __init,
                         _BinaryOperation __binary_op, _Inclusive,
                         _IsVector __is_vector, std::true_type) {
  typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type
      _DifferenceType;

  return __internal::__except_handler([&]() {
    __par_backend::__parallel_transform_scan(
        std::forward<_ExecutionPolicy>(__exec), __last - __first,
        [__first, __unary_op](_DifferenceType __i) mutable {
          return __unary_op(__first[__i]);
        },
        __init, __binary_op,
        [__first, __unary_op, __binary_op](_DifferenceType __i,
                                           _DifferenceType __j, _Tp __init) {
          return __internal::__brick_transform_reduce(
              __first + __i, __first + __j, __init, __binary_op, __unary_op,
              std::false_type());
        },
        [__first, __unary_op, __binary_op, __result,
         __is_vector](_DifferenceType __i, _DifferenceType __j, _Tp __init) {
          return __internal::__brick_transform_scan(
                     __first + __i, __first + __j, __result + __i, __unary_op,
                     __init, __binary_op, _Inclusive(), __is_vector)
              .second;
        });
    return __result + (__last - __first);
  });
}

template <class _ExecutionPolicy, class _RandomAccessIterator,
          class _OutputIterator, class _UnaryOperation, class _Tp,
          class _BinaryOperation, class _Inclusive, class _IsVector>
typename std::enable_if<std::is_floating_point<_Tp>::value,
                        _OutputIterator>::type
__pattern_transform_scan(_ExecutionPolicy &&__exec,
                         _RandomAccessIterator __first,
                         _RandomAccessIterator __last, _OutputIterator __result,
                         _UnaryOperation __unary_op, _Tp __init,
                         _BinaryOperation __binary_op, _Inclusive,
                         _IsVector __is_vector, std::true_type) {
  typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type
      _DifferenceType;
  _DifferenceType __n = __last - __first;

  if (__n <= 0) {
    return __result;
  }
  return __internal::__except_handler([&]() {
    __par_backend::__parallel_strict_scan(
        std::forward<_ExecutionPolicy>(__exec), __n, __init,
        [__first, __unary_op, __binary_op, __result,
         __is_vector](_DifferenceType __i, _DifferenceType __len) {
          return __internal::__brick_transform_scan(
                     __first + __i, __first + (__i + __len), __result + __i,
                     __unary_op, _Tp{}, __binary_op, _Inclusive(), __is_vector)
              .second;
        },
        __binary_op,
        [__result, &__binary_op](_DifferenceType __i, _DifferenceType __len,
                                 _Tp __initial) {
          return *(std::transform(__result + __i, __result + __i + __len,
                                  __result + __i,
                                  [&__initial, &__binary_op](const _Tp &__x) {
                                    return __binary_op(__initial, __x);
                                  }) -
                   1);
        },
        [](_Tp) {});
    return __result + (__last - __first);
  });
}

template <class _ForwardIterator, class _OutputIterator, class _BinaryOperation>
_OutputIterator
__brick_adjacent_difference(_ForwardIterator __first, _ForwardIterator __last,
                            _OutputIterator __d_first, _BinaryOperation __op,
                            std::false_type) noexcept {
  return std::adjacent_difference(__first, __last, __d_first, __op);
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryOperation>
_ForwardIterator2
__brick_adjacent_difference(_ForwardIterator1 __first, _ForwardIterator1 __last,
                            _ForwardIterator2 __d_first, _BinaryOperation __op,
                            std::true_type) noexcept {
  do {
    if (std::__is_constant_evaluated() && !bool(__first != __last))
      __builtin_unreachable();
  } while (false);

  typedef typename std::iterator_traits<_ForwardIterator1>::reference
      _ReferenceType1;
  typedef typename std::iterator_traits<_ForwardIterator2>::reference
      _ReferenceType2;

  auto __n = __last - __first;
  *__d_first = *__first;
  return __unseq_backend::__simd_walk_3(
      __first + 1, __n - 1, __first, __d_first + 1,
      [&__op](_ReferenceType1 __x, _ReferenceType1 __y, _ReferenceType2 __z) {
        __z = __op(__x, __y);
      });
}

template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator,
          class _BinaryOperation, class _IsVector>
_OutputIterator
__pattern_adjacent_difference(_ExecutionPolicy &&, _ForwardIterator __first,
                              _ForwardIterator __last,
                              _OutputIterator __d_first, _BinaryOperation __op,
                              _IsVector __is_vector, std::false_type) noexcept {
  return __internal::__brick_adjacent_difference(__first, __last, __d_first,
                                                 __op, __is_vector);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryOperation, class _IsVector>
_ForwardIterator2 __pattern_adjacent_difference(
    _ExecutionPolicy &&__exec, _ForwardIterator1 __first,
    _ForwardIterator1 __last, _ForwardIterator2 __d_first,
    _BinaryOperation __op, _IsVector __is_vector, std::true_type) {
  do {
    if (std::__is_constant_evaluated() && !bool(__first != __last))
      __builtin_unreachable();
  } while (false);
  typedef typename std::iterator_traits<_ForwardIterator1>::reference
      _ReferenceType1;
  typedef typename std::iterator_traits<_ForwardIterator2>::reference
      _ReferenceType2;

  *__d_first = *__first;
  __par_backend::__parallel_for(
      std::forward<_ExecutionPolicy>(__exec), __first, __last - 1,
      [&__op, __is_vector, __d_first, __first](_ForwardIterator1 __b,
                                               _ForwardIterator1 __e) {
        _ForwardIterator2 __d_b = __d_first + (__b - __first);
        __internal::__brick_walk3(
            __b, __e, __b + 1, __d_b + 1,
            [&__op](_ReferenceType1 __x, _ReferenceType1 __y,
                    _ReferenceType2 __z) { __z = __op(__y, __x); },
            __is_vector);
      });
  return __d_first + (__last - __first);
}

} // namespace __internal
} // namespace __pstl
# 52 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_execution_defs.h" 2 3
# 35 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/execution" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_algorithm_impl.h" 1 3
# 18 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_algorithm_impl.h" 3
# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/numeric_fwd.h" 1 3
# 16 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/numeric_fwd.h" 3
namespace __pstl {
namespace __internal {

template <class _ForwardIterator1, class _ForwardIterator2, class _Tp,
          class _BinaryOperation1, class _BinaryOperation2>
_Tp __brick_transform_reduce(_ForwardIterator1, _ForwardIterator1,
                             _ForwardIterator2, _Tp, _BinaryOperation1,
                             _BinaryOperation2, std::true_type) noexcept;

template <class _ForwardIterator1, class _ForwardIterator2, class _Tp,
          class _BinaryOperation1, class _BinaryOperation2>
_Tp __brick_transform_reduce(_ForwardIterator1, _ForwardIterator1,
                             _ForwardIterator2, _Tp, _BinaryOperation1,
                             _BinaryOperation2, std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp, class _BinaryOperation1,
          class _BinaryOperation2, class _IsVector>
_Tp __pattern_transform_reduce(_ExecutionPolicy &&, _ForwardIterator1,
                               _ForwardIterator1, _ForwardIterator2, _Tp,
                               _BinaryOperation1, _BinaryOperation2, _IsVector,
                               std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator1,
          class _RandomAccessIterator2, class _Tp, class _BinaryOperation1,
          class _BinaryOperation2, class _IsVector>
_Tp __pattern_transform_reduce(_ExecutionPolicy &&, _RandomAccessIterator1,
                               _RandomAccessIterator1, _RandomAccessIterator2,
                               _Tp, _BinaryOperation1, _BinaryOperation2,
                               _IsVector __is_vector, std::true_type);

template <class _ForwardIterator, class _Tp, class _UnaryOperation,
          class _BinaryOperation>
_Tp __brick_transform_reduce(_ForwardIterator, _ForwardIterator, _Tp,
                             _BinaryOperation, _UnaryOperation,
                             std::true_type) noexcept;

template <class _ForwardIterator, class _Tp, class _BinaryOperation,
          class _UnaryOperation>
_Tp __brick_transform_reduce(_ForwardIterator, _ForwardIterator, _Tp,
                             _BinaryOperation, _UnaryOperation,
                             std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp,
          class _BinaryOperation, class _UnaryOperation, class _IsVector>
_Tp __pattern_transform_reduce(_ExecutionPolicy &&, _ForwardIterator,
                               _ForwardIterator, _Tp, _BinaryOperation,
                               _UnaryOperation, _IsVector,
                               std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp,
          class _BinaryOperation, class _UnaryOperation, class _IsVector>
_Tp __pattern_transform_reduce(_ExecutionPolicy &&, _ForwardIterator,
                               _ForwardIterator, _Tp, _BinaryOperation,
                               _UnaryOperation, _IsVector, std::true_type);

template <class _ForwardIterator, class _OutputIterator, class _UnaryOperation,
          class _Tp, class _BinaryOperation>
std::pair<_OutputIterator, _Tp>
    __brick_transform_scan(_ForwardIterator, _ForwardIterator, _OutputIterator,
                           _UnaryOperation, _Tp, _BinaryOperation,
                           std::false_type) noexcept;

template <class _ForwardIterator, class _OutputIterator, class _UnaryOperation,
          class _Tp, class _BinaryOperation>
std::pair<_OutputIterator, _Tp>
    __brick_transform_scan(_ForwardIterator, _ForwardIterator, _OutputIterator,
                           _UnaryOperation, _Tp, _BinaryOperation,
                           std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator,
          class _UnaryOperation, class _Tp, class _BinaryOperation,
          class _Inclusive, class _IsVector>
_OutputIterator __pattern_transform_scan(_ExecutionPolicy &&, _ForwardIterator,
                                         _ForwardIterator, _OutputIterator,
                                         _UnaryOperation, _Tp, _BinaryOperation,
                                         _Inclusive, _IsVector,
                                         std::false_type) noexcept;

template <class _ExecutionPolicy, class _RandomAccessIterator,
          class _OutputIterator, class _UnaryOperation, class _Tp,
          class _BinaryOperation, class _Inclusive, class _IsVector>
typename std::enable_if<!std::is_floating_point<_Tp>::value,
                        _OutputIterator>::type
__pattern_transform_scan(_ExecutionPolicy &&, _RandomAccessIterator,
                         _RandomAccessIterator, _OutputIterator,
                         _UnaryOperation, _Tp, _BinaryOperation, _Inclusive,
                         _IsVector, std::true_type);

template <class _ExecutionPolicy, class _RandomAccessIterator,
          class _OutputIterator, class _UnaryOperation, class _Tp,
          class _BinaryOperation, class _Inclusive, class _IsVector>
typename std::enable_if<std::is_floating_point<_Tp>::value,
                        _OutputIterator>::type
__pattern_transform_scan(_ExecutionPolicy &&, _RandomAccessIterator,
                         _RandomAccessIterator, _OutputIterator,
                         _UnaryOperation, _Tp, _BinaryOperation, _Inclusive,
                         _IsVector, std::true_type);

template <class _ForwardIterator, class _OutputIterator, class _BinaryOperation>
_OutputIterator __brick_adjacent_difference(_ForwardIterator, _ForwardIterator,
                                            _OutputIterator, _BinaryOperation,
                                            std::false_type) noexcept;

template <class _ForwardIterator, class _OutputIterator, class _BinaryOperation>
_OutputIterator __brick_adjacent_difference(_ForwardIterator, _ForwardIterator,
                                            _OutputIterator, _BinaryOperation,
                                            std::true_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator,
          class _BinaryOperation, class _IsVector>
_OutputIterator __pattern_adjacent_difference(_ExecutionPolicy &&,
                                              _ForwardIterator,
                                              _ForwardIterator, _OutputIterator,
                                              _BinaryOperation, _IsVector,
                                              std::false_type) noexcept;

template <class _ExecutionPolicy, class _ForwardIterator, class _OutputIterator,
          class _BinaryOperation, class _IsVector>
_OutputIterator
__pattern_adjacent_difference(_ExecutionPolicy &&, _ForwardIterator,
                              _ForwardIterator, _OutputIterator,
                              _BinaryOperation, _IsVector, std::true_type);

} // namespace __internal
} // namespace __pstl
# 19 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_algorithm_impl.h" 2 3

namespace std {

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
any_of(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __last, _Predicate __pred) {
  return __pstl::__internal::__pattern_any_of(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Pred>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
all_of(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __last, _Pred __pred) {
  return !std::any_of(std::forward<_ExecutionPolicy>(__exec), __first, __last,
                      std::not_fn(__pred));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
none_of(_ExecutionPolicy &&__exec, _ForwardIterator __first,
        _ForwardIterator __last, _Predicate __pred) {
  return !std::any_of(std::forward<_ExecutionPolicy>(__exec), __first, __last,
                      __pred);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Function>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
for_each(_ExecutionPolicy &&__exec, _ForwardIterator __first,
         _ForwardIterator __last, _Function __f) {
  __pstl::__internal::__pattern_walk1(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __f,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Function>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
for_each_n(_ExecutionPolicy &&__exec, _ForwardIterator __first, _Size __n,
           _Function __f) {
  return __pstl::__internal::__pattern_walk1_n(
      std::forward<_ExecutionPolicy>(__exec), __first, __n, __f,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
find_if(_ExecutionPolicy &&__exec, _ForwardIterator __first,
        _ForwardIterator __last, _Predicate __pred) {
  return __pstl::__internal::__pattern_find_if(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
find_if_not(_ExecutionPolicy &&__exec, _ForwardIterator __first,
            _ForwardIterator __last, _Predicate __pred) {
  return std::find_if(std::forward<_ExecutionPolicy>(__exec), __first, __last,
                      std::not_fn(__pred));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
find(_ExecutionPolicy &&__exec, _ForwardIterator __first,
     _ForwardIterator __last, const _Tp &__value) {
  return std::find_if(std::forward<_ExecutionPolicy>(__exec), __first, __last,
                      __pstl::__internal::__equal_value<_Tp>(__value));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator1>
find_end(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
         _ForwardIterator1 __last, _ForwardIterator2 __s_first,
         _ForwardIterator2 __s_last, _BinaryPredicate __pred) {
  return __pstl::__internal::__pattern_find_end(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first,
      __s_last, __pred,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator1>
find_end(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
         _ForwardIterator1 __last, _ForwardIterator2 __s_first,
         _ForwardIterator2 __s_last) {
  return std::find_end(std::forward<_ExecutionPolicy>(__exec), __first, __last,
                       __s_first, __s_last, std::equal_to<>());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator1>
find_first_of(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
              _ForwardIterator1 __last, _ForwardIterator2 __s_first,
              _ForwardIterator2 __s_last, _BinaryPredicate __pred) {
  return __pstl::__internal::__pattern_find_first_of(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first,
      __s_last, __pred,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator1>
find_first_of(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
              _ForwardIterator1 __last, _ForwardIterator2 __s_first,
              _ForwardIterator2 __s_last) {
  return std::find_first_of(std::forward<_ExecutionPolicy>(__exec), __first,
                            __last, __s_first, __s_last, std::equal_to<>());
}

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
adjacent_find(_ExecutionPolicy &&__exec, _ForwardIterator __first,
              _ForwardIterator __last) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  return __pstl::__internal::__pattern_adjacent_find(
      std::forward<_ExecutionPolicy>(__exec), __first, __last,
      std::equal_to<_ValueType>(),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      false);
}

template <class _ExecutionPolicy, class _ForwardIterator,
          class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
adjacent_find(_ExecutionPolicy &&__exec, _ForwardIterator __first,
              _ForwardIterator __last, _BinaryPredicate __pred) {
  return __pstl::__internal::__pattern_adjacent_find(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      false);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy,
    typename iterator_traits<_ForwardIterator>::difference_type>
count(_ExecutionPolicy &&__exec, _ForwardIterator __first,
      _ForwardIterator __last, const _Tp &__value) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  return __pstl::__internal::__pattern_count(
      std::forward<_ExecutionPolicy>(__exec), __first, __last,
      [&__value](const _ValueType &__x) { return __value == __x; },
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy,
    typename iterator_traits<_ForwardIterator>::difference_type>
count_if(_ExecutionPolicy &&__exec, _ForwardIterator __first,
         _ForwardIterator __last, _Predicate __pred) {
  return __pstl::__internal::__pattern_count(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator1>
search(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
       _ForwardIterator1 __last, _ForwardIterator2 __s_first,
       _ForwardIterator2 __s_last, _BinaryPredicate __pred) {
  return __pstl::__internal::__pattern_search(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __s_first,
      __s_last, __pred,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator1>
search(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
       _ForwardIterator1 __last, _ForwardIterator2 __s_first,
       _ForwardIterator2 __s_last) {
  return std::search(std::forward<_ExecutionPolicy>(__exec), __first, __last,
                     __s_first, __s_last, std::equal_to<>());
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Tp, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
search_n(_ExecutionPolicy &&__exec, _ForwardIterator __first,
         _ForwardIterator __last, _Size __count, const _Tp &__value,
         _BinaryPredicate __pred) {
  return __pstl::__internal::__pattern_search_n(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __count, __value,
      __pred,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
search_n(_ExecutionPolicy &&__exec, _ForwardIterator __first,
         _ForwardIterator __last, _Size __count, const _Tp &__value) {
  return std::search_n(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __count, __value,
      std::equal_to<typename iterator_traits<_ForwardIterator>::value_type>());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
     _ForwardIterator1 __last, _ForwardIterator2 __result) {
  const auto __is_vector = __pstl::__internal::__is_vectorization_preferred<
      _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec);

  return __pstl::__internal::__pattern_walk2_brick(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,
      [__is_vector](_ForwardIterator1 __begin, _ForwardIterator1 __end,
                    _ForwardIterator2 __res) {
        return __pstl::__internal::__brick_copy(__begin, __end, __res,
                                                __is_vector);
      },
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1, class _Size,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
copy_n(_ExecutionPolicy &&__exec, _ForwardIterator1 __first, _Size __n,
       _ForwardIterator2 __result) {
  const auto __is_vector = __pstl::__internal::__is_vectorization_preferred<
      _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec);

  return __pstl::__internal::__pattern_walk2_brick_n(
      std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,
      [__is_vector](_ForwardIterator1 __begin, _Size __sz,
                    _ForwardIterator2 __res) {
        return __pstl::__internal::__brick_copy_n(__begin, __sz, __res,
                                                  __is_vector);
      },
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
copy_if(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
        _ForwardIterator1 __last, _ForwardIterator2 __result,
        _Predicate __pred) {
  return __pstl::__internal::__pattern_copy_if(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __pred,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
swap_ranges(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
            _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
  typedef
      typename iterator_traits<_ForwardIterator1>::reference _ReferenceType1;
  typedef
      typename iterator_traits<_ForwardIterator2>::reference _ReferenceType2;
  return __pstl::__internal::__pattern_walk2(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      [](_ReferenceType1 __x, _ReferenceType2 __y) {
        using std::swap;
        swap(__x, __y);
      },
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _UnaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
transform(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
          _ForwardIterator1 __last, _ForwardIterator2 __result,
          _UnaryOperation __op) {
  typedef typename iterator_traits<_ForwardIterator1>::reference _InputType;
  typedef typename iterator_traits<_ForwardIterator2>::reference _OutputType;
  return __pstl::__internal::__pattern_walk2(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,
      [__op](_InputType __x, _OutputType __y) mutable { __y = __op(__x); },
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator,
          class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
transform(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
          _ForwardIterator1 __last1, _ForwardIterator2 __first2,
          _ForwardIterator __result, _BinaryOperation __op) {
  typedef typename iterator_traits<_ForwardIterator1>::reference _Input1Type;
  typedef typename iterator_traits<_ForwardIterator2>::reference _Input2Type;
  typedef typename iterator_traits<_ForwardIterator>::reference _OutputType;
  return __pstl::__internal::__pattern_walk3(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      __result,
      [__op](_Input1Type __x, _Input2Type __y, _OutputType __z) mutable {
        __z = __op(__x, __y);
      },
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,
          _ForwardIterator>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,
          _ForwardIterator>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate,
          class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
replace_if(_ExecutionPolicy &&__exec, _ForwardIterator __first,
           _ForwardIterator __last, _UnaryPredicate __pred,
           const _Tp &__new_value) {
  typedef typename iterator_traits<_ForwardIterator>::reference _ElementType;
  __pstl::__internal::__pattern_walk1(
      std::forward<_ExecutionPolicy>(__exec), __first, __last,
      [&__pred, &__new_value](_ElementType __elem) {
        if (__pred(__elem)) {
          __elem = __new_value;
        }
      },
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
replace(_ExecutionPolicy &&__exec, _ForwardIterator __first,
        _ForwardIterator __last, const _Tp &__old_value,
        const _Tp &__new_value) {
  std::replace_if(std::forward<_ExecutionPolicy>(__exec), __first, __last,
                  __pstl::__internal::__equal_value<_Tp>(__old_value),
                  __new_value);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _UnaryPredicate, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
replace_copy_if(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
                _ForwardIterator1 __last, _ForwardIterator2 __result,
                _UnaryPredicate __pred, const _Tp &__new_value) {
  typedef typename iterator_traits<_ForwardIterator1>::reference _InputType;
  typedef typename iterator_traits<_ForwardIterator2>::reference _OutputType;
  return __pstl::__internal::__pattern_walk2(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,
      [__pred, &__new_value](_InputType __x, _OutputType __y) mutable {
        __y = __pred(__x) ? __new_value : __x;
      },
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
replace_copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
             _ForwardIterator1 __last, _ForwardIterator2 __result,
             const _Tp &__old_value, const _Tp &__new_value) {
  return std::replace_copy_if(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,
      __pstl::__internal::__equal_value<_Tp>(__old_value), __new_value);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
fill(_ExecutionPolicy &&__exec, _ForwardIterator __first,
     _ForwardIterator __last, const _Tp &__value) {
  __pstl::__internal::__pattern_fill(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __value,
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
fill_n(_ExecutionPolicy &&__exec, _ForwardIterator __first, _Size __count,
       const _Tp &__value) {
  if (__count <= 0)
    return __first;

  return __pstl::__internal::__pattern_fill_n(
      std::forward<_ExecutionPolicy>(__exec), __first, __count, __value,
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Generator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
generate(_ExecutionPolicy &&__exec, _ForwardIterator __first,
         _ForwardIterator __last, _Generator __g) {
  __pstl::__internal::__pattern_generate(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __g,
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Generator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
generate_n(_ExecutionPolicy &&__exec, _ForwardIterator __first, _Size __count,
           _Generator __g) {
  if (__count <= 0)
    return __first;

  return __pstl::__internal::__pattern_generate_n(
      std::forward<_ExecutionPolicy>(__exec), __first, __count, __g,
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
remove_copy_if(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
               _ForwardIterator1 __last, _ForwardIterator2 __result,
               _Predicate __pred) {
  return std::copy_if(std::forward<_ExecutionPolicy>(__exec), __first, __last,
                      __result, std::not_fn(__pred));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
remove_copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
            _ForwardIterator1 __last, _ForwardIterator2 __result,
            const _Tp &__value) {
  return std::copy_if(std::forward<_ExecutionPolicy>(__exec), __first, __last,
                      __result,
                      __pstl::__internal::__not_equal_value<_Tp>(__value));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
remove_if(_ExecutionPolicy &&__exec, _ForwardIterator __first,
          _ForwardIterator __last, _UnaryPredicate __pred) {
  return __pstl::__internal::__pattern_remove_if(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
remove(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __last, const _Tp &__value) {
  return std::remove_if(std::forward<_ExecutionPolicy>(__exec), __first, __last,
                        __pstl::__internal::__equal_value<_Tp>(__value));
}

template <class _ExecutionPolicy, class _ForwardIterator,
          class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
unique(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __last, _BinaryPredicate __pred) {
  return __pstl::__internal::__pattern_unique(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
unique(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __last) {
  return std::unique(std::forward<_ExecutionPolicy>(__exec), __first, __last,
                     std::equal_to<>());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
unique_copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
            _ForwardIterator1 __last, _ForwardIterator2 __result,
            _BinaryPredicate __pred) {
  return __pstl::__internal::__pattern_unique_copy(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __result, __pred,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
unique_copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
            _ForwardIterator1 __last, _ForwardIterator2 __result) {
  return std::unique_copy(__exec, __first, __last, __result, std::equal_to<>());
}

template <class _ExecutionPolicy, class _BidirectionalIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
reverse(_ExecutionPolicy &&__exec, _BidirectionalIterator __first,
        _BidirectionalIterator __last) {
  __pstl::__internal::__pattern_reverse(
      std::forward<_ExecutionPolicy>(__exec), __first, __last,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _BidirectionalIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _BidirectionalIterator>(__exec));
}

template <class _ExecutionPolicy, class _BidirectionalIterator,
          class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
reverse_copy(_ExecutionPolicy &&__exec, _BidirectionalIterator __first,
             _BidirectionalIterator __last, _ForwardIterator __d_first) {
  return __pstl::__internal::__pattern_reverse_copy(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __d_first,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _BidirectionalIterator, _ForwardIterator>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _BidirectionalIterator, _ForwardIterator>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
rotate(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __middle, _ForwardIterator __last) {
  return __pstl::__internal::__pattern_rotate(
      std::forward<_ExecutionPolicy>(__exec), __first, __middle, __last,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
rotate_copy(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
            _ForwardIterator1 __middle, _ForwardIterator1 __last,
            _ForwardIterator2 __result) {
  return __pstl::__internal::__pattern_rotate_copy(
      std::forward<_ExecutionPolicy>(__exec), __first, __middle, __last,
      __result,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_partitioned(_ExecutionPolicy &&__exec, _ForwardIterator __first,
               _ForwardIterator __last, _UnaryPredicate __pred) {
  return __pstl::__internal::__pattern_is_partitioned(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
partition(_ExecutionPolicy &&__exec, _ForwardIterator __first,
          _ForwardIterator __last, _UnaryPredicate __pred) {
  return __pstl::__internal::__pattern_partition(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _BidirectionalIterator,
          class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _BidirectionalIterator>
stable_partition(_ExecutionPolicy &&__exec, _BidirectionalIterator __first,
                 _BidirectionalIterator __last, _UnaryPredicate __pred) {
  return __pstl::__internal::__pattern_stable_partition(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __pred,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _BidirectionalIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _BidirectionalIterator>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator,
          class _ForwardIterator1, class _ForwardIterator2,
          class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
partition_copy(_ExecutionPolicy &&__exec, _ForwardIterator __first,
               _ForwardIterator __last, _ForwardIterator1 __out_true,
               _ForwardIterator2 __out_false, _UnaryPredicate __pred) {
  return __pstl::__internal::__pattern_partition_copy(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __out_true,
      __out_false, __pred,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator, _ForwardIterator1,
          _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator, _ForwardIterator1,
          _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp) {
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type _InputType;
  return __pstl::__internal::__pattern_sort(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _RandomAccessIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _RandomAccessIterator>(
          __exec),
      typename std::is_move_constructible<_InputType>::type());
}

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
     _RandomAccessIterator __last) {
  typedef typename std::iterator_traits<_RandomAccessIterator>::value_type
      _InputType;
  std::sort(std::forward<_ExecutionPolicy>(__exec), __first, __last,
            std::less<_InputType>());
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
stable_sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
            _RandomAccessIterator __last, _Compare __comp) {
  return __pstl::__internal::__pattern_stable_sort(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _RandomAccessIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _RandomAccessIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
stable_sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
            _RandomAccessIterator __last) {
  typedef typename std::iterator_traits<_RandomAccessIterator>::value_type
      _InputType;
  std::stable_sort(__exec, __first, __last, std::less<_InputType>());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
         _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _ForwardIterator2 __last2, _BinaryPredicate __pred) {
  return __pstl::__internal::__pattern_mismatch(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      __last2, __pred,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
         _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _BinaryPredicate __pred) {
  return std::mismatch(__exec, __first1, __last1, __first2,
                       std::next(__first2, std::distance(__first1, __last1)),
                       __pred);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
         _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _ForwardIterator2 __last2) {
  return std::mismatch(std::forward<_ExecutionPolicy>(__exec), __first1,
                       __last1, __first2, __last2, std::equal_to<>());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
         _ForwardIterator1 __last1, _ForwardIterator2 __first2) {

  return std::mismatch(std::forward<_ExecutionPolicy>(__exec), __first1,
                       __last1, __first2,
                       std::next(__first2, std::distance(__first1, __last1)));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
      _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _BinaryPredicate __p) {
  return __pstl::__internal::__pattern_equal(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2, __p,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator1>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator1>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
      _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
  return std::equal(std::forward<_ExecutionPolicy>(__exec), __first1, __last1,
                    __first2, std::equal_to<>());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
      _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _ForwardIterator2 __last2, _BinaryPredicate __p) {
  return __pstl::__internal::__pattern_equal(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      __last2, __p,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator1>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator1>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
      _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _ForwardIterator2 __last2) {
  return equal(std::forward<_ExecutionPolicy>(__exec), __first1, __last1,
               __first2, __last2, std::equal_to<>());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
move(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
     _ForwardIterator1 __last, _ForwardIterator2 __d_first) {
  const auto __is_vector = __pstl::__internal::__is_vectorization_preferred<
      _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec);

  return __pstl::__internal::__pattern_walk2_brick(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __d_first,
      [__is_vector](_ForwardIterator1 __begin, _ForwardIterator1 __end,
                    _ForwardIterator2 __res) {
        return __pstl::__internal::__brick_move(__begin, __end, __res,
                                                __is_vector);
      },
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
partial_sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
             _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp) {
  __pstl::__internal::__pattern_partial_sort(
      std::forward<_ExecutionPolicy>(__exec), __first, __middle, __last, __comp,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _RandomAccessIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _RandomAccessIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
partial_sort(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
             _RandomAccessIterator __middle, _RandomAccessIterator __last) {
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type _InputType;
  std::partial_sort(__exec, __first, __middle, __last, std::less<_InputType>());
}

template <class _ExecutionPolicy, class _ForwardIterator,
          class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _RandomAccessIterator>
partial_sort_copy(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                  _ForwardIterator __last, _RandomAccessIterator __d_first,
                  _RandomAccessIterator __d_last, _Compare __comp) {
  return __pstl::__internal::__pattern_partial_sort_copy(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __d_first,
      __d_last, __comp,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator, _RandomAccessIterator>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator, _RandomAccessIterator>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator,
          class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _RandomAccessIterator>
partial_sort_copy(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                  _ForwardIterator __last, _RandomAccessIterator __d_first,
                  _RandomAccessIterator __d_last) {
  return std::partial_sort_copy(std::forward<_ExecutionPolicy>(__exec), __first,
                                __last, __d_first, __d_last, std::less<>());
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
is_sorted_until(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                _ForwardIterator __last, _Compare __comp) {
  const _ForwardIterator __res = __pstl::__internal::__pattern_adjacent_find(
      std::forward<_ExecutionPolicy>(__exec), __first, __last,
      __pstl::__internal::__reorder_pred<_Compare>(__comp),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      false);
  return __res == __last ? __last : std::next(__res);
}

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
is_sorted_until(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                _ForwardIterator __last) {
  typedef
      typename std::iterator_traits<_ForwardIterator>::value_type _InputType;
  return is_sorted_until(std::forward<_ExecutionPolicy>(__exec), __first,
                         __last, std::less<_InputType>());
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_sorted(_ExecutionPolicy &&__exec, _ForwardIterator __first,
          _ForwardIterator __last, _Compare __comp) {
  return __pstl::__internal::__pattern_adjacent_find(
             std::forward<_ExecutionPolicy>(__exec), __first, __last,
             __pstl::__internal::__reorder_pred<_Compare>(__comp),
             __pstl::__internal::__is_parallelization_preferred<
                 _ExecutionPolicy, _ForwardIterator>(__exec),
             __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                              _ForwardIterator>(
                 __exec),
             true) == __last;
}

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_sorted(_ExecutionPolicy &&__exec, _ForwardIterator __first,
          _ForwardIterator __last) {
  typedef
      typename std::iterator_traits<_ForwardIterator>::value_type _InputType;
  return std::is_sorted(std::forward<_ExecutionPolicy>(__exec), __first, __last,
                        std::less<_InputType>());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
merge(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
      _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _ForwardIterator2 __last2, _ForwardIterator __d_first, _Compare __comp) {
  return __pstl::__internal::__pattern_merge(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      __last2, __d_first, __comp,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,
          _ForwardIterator>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,
          _ForwardIterator>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
merge(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
      _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _ForwardIterator2 __last2, _ForwardIterator __d_first) {
  return std::merge(std::forward<_ExecutionPolicy>(__exec), __first1, __last1,
                    __first2, __last2, __d_first, std::less<>());
}

template <class _ExecutionPolicy, class _BidirectionalIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
inplace_merge(_ExecutionPolicy &&__exec, _BidirectionalIterator __first,
              _BidirectionalIterator __middle, _BidirectionalIterator __last,
              _Compare __comp) {
  __pstl::__internal::__pattern_inplace_merge(
      std::forward<_ExecutionPolicy>(__exec), __first, __middle, __last, __comp,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _BidirectionalIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _BidirectionalIterator>(__exec));
}

template <class _ExecutionPolicy, class _BidirectionalIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
inplace_merge(_ExecutionPolicy &&__exec, _BidirectionalIterator __first,
              _BidirectionalIterator __middle, _BidirectionalIterator __last) {
  typedef typename std::iterator_traits<_BidirectionalIterator>::value_type
      _InputType;
  std::inplace_merge(__exec, __first, __middle, __last,
                     std::less<_InputType>());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
includes(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
         _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _ForwardIterator2 __last2, _Compare __comp) {
  return __pstl::__internal::__pattern_includes(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      __last2, __comp,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
includes(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
         _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _ForwardIterator2 __last2) {
  return std::includes(std::forward<_ExecutionPolicy>(__exec), __first1,
                       __last1, __first2, __last2, std::less<>());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
set_union(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
          _ForwardIterator1 __last1, _ForwardIterator2 __first2,
          _ForwardIterator2 __last2, _ForwardIterator __result,
          _Compare __comp) {
  return __pstl::__internal::__pattern_set_union(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      __last2, __result, __comp,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,
          _ForwardIterator>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,
          _ForwardIterator>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
set_union(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
          _ForwardIterator1 __last1, _ForwardIterator2 __first2,
          _ForwardIterator2 __last2, _ForwardIterator __result) {
  return std::set_union(std::forward<_ExecutionPolicy>(__exec), __first1,
                        __last1, __first2, __last2, __result, std::less<>());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
set_intersection(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                 _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                 _ForwardIterator2 __last2, _ForwardIterator __result,
                 _Compare __comp) {
  return __pstl::__internal::__pattern_set_intersection(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      __last2, __result, __comp,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,
          _ForwardIterator>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,
          _ForwardIterator>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
set_intersection(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                 _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                 _ForwardIterator2 __last2, _ForwardIterator __result) {
  return std::set_intersection(std::forward<_ExecutionPolicy>(__exec), __first1,
                               __last1, __first2, __last2, __result,
                               std::less<>());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
set_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
               _ForwardIterator1 __last1, _ForwardIterator2 __first2,
               _ForwardIterator2 __last2, _ForwardIterator __result,
               _Compare __comp) {
  return __pstl::__internal::__pattern_set_difference(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      __last2, __result, __comp,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,
          _ForwardIterator>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,
          _ForwardIterator>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
set_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
               _ForwardIterator1 __last1, _ForwardIterator2 __first2,
               _ForwardIterator2 __last2, _ForwardIterator __result) {
  return std::set_difference(std::forward<_ExecutionPolicy>(__exec), __first1,
                             __last1, __first2, __last2, __result,
                             std::less<>());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
set_symmetric_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                         _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                         _ForwardIterator2 __last2, _ForwardIterator __result,
                         _Compare __comp) {
  return __pstl::__internal::__pattern_set_symmetric_difference(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      __last2, __result, __comp,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,
          _ForwardIterator>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2,
          _ForwardIterator>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
set_symmetric_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                         _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                         _ForwardIterator2 __last2, _ForwardIterator __result) {
  return std::set_symmetric_difference(std::forward<_ExecutionPolicy>(__exec),
                                       __first1, __last1, __first2, __last2,
                                       __result, std::less<>());
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _RandomAccessIterator>
is_heap_until(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
              _RandomAccessIterator __last, _Compare __comp) {
  return __pstl::__internal::__pattern_is_heap_until(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _RandomAccessIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _RandomAccessIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _RandomAccessIterator>
is_heap_until(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
              _RandomAccessIterator __last) {
  typedef typename std::iterator_traits<_RandomAccessIterator>::value_type
      _InputType;
  return std::is_heap_until(std::forward<_ExecutionPolicy>(__exec), __first,
                            __last, std::less<_InputType>());
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_heap(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
        _RandomAccessIterator __last, _Compare __comp) {
  return std::is_heap_until(std::forward<_ExecutionPolicy>(__exec), __first,
                            __last, __comp) == __last;
}

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_heap(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
        _RandomAccessIterator __last) {
  typedef typename std::iterator_traits<_RandomAccessIterator>::value_type
      _InputType;
  return std::is_heap(std::forward<_ExecutionPolicy>(__exec), __first, __last,
                      std::less<_InputType>());
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
min_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
            _ForwardIterator __last, _Compare __comp) {
  return __pstl::__internal::__pattern_min_element(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
min_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
            _ForwardIterator __last) {
  typedef
      typename std::iterator_traits<_ForwardIterator>::value_type _InputType;
  return std::min_element(std::forward<_ExecutionPolicy>(__exec), __first,
                          __last, std::less<_InputType>());
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
max_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
            _ForwardIterator __last, _Compare __comp) {
  return min_element(std::forward<_ExecutionPolicy>(__exec), __first, __last,
                     __pstl::__internal::__reorder_pred<_Compare>(__comp));
}

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
max_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
            _ForwardIterator __last) {
  typedef
      typename std::iterator_traits<_ForwardIterator>::value_type _InputType;
  return std::min_element(
      std::forward<_ExecutionPolicy>(__exec), __first, __last,
      __pstl::__internal::__reorder_pred<std::less<_InputType>>(
          std::less<_InputType>()));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy, std::pair<_ForwardIterator, _ForwardIterator>>
minmax_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
               _ForwardIterator __last, _Compare __comp) {
  return __pstl::__internal::__pattern_minmax_element(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __comp,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy, std::pair<_ForwardIterator, _ForwardIterator>>
minmax_element(_ExecutionPolicy &&__exec, _ForwardIterator __first,
               _ForwardIterator __last) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  return std::minmax_element(std::forward<_ExecutionPolicy>(__exec), __first,
                             __last, std::less<_ValueType>());
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
nth_element(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
            _RandomAccessIterator __nth, _RandomAccessIterator __last,
            _Compare __comp) {
  __pstl::__internal::__pattern_nth_element(
      std::forward<_ExecutionPolicy>(__exec), __first, __nth, __last, __comp,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _RandomAccessIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _RandomAccessIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
nth_element(_ExecutionPolicy &&__exec, _RandomAccessIterator __first,
            _RandomAccessIterator __nth, _RandomAccessIterator __last) {
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type _InputType;
  std::nth_element(std::forward<_ExecutionPolicy>(__exec), __first, __nth,
                   __last, std::less<_InputType>());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
lexicographical_compare(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                        _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                        _ForwardIterator2 __last2, _Compare __comp) {
  return __pstl::__internal::__pattern_lexicographical_compare(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      __last2, __comp,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
lexicographical_compare(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                        _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                        _ForwardIterator2 __last2) {
  return std::lexicographical_compare(std::forward<_ExecutionPolicy>(__exec),
                                      __first1, __last1, __first2, __last2,
                                      std::less<>());
}

} // namespace std
# 41 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/execution" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_numeric_impl.h" 1 3
# 18 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_numeric_impl.h" 3
namespace std {

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp,
          class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>
reduce(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __last, _Tp __init, _BinaryOperation __binary_op) {
  return transform_reduce(std::forward<_ExecutionPolicy>(__exec), __first,
                          __last, __init, __binary_op,
                          __pstl::__internal::__no_op());
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>
reduce(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __last, _Tp __init) {
  return transform_reduce(std::forward<_ExecutionPolicy>(__exec), __first,
                          __last, __init, std::plus<_Tp>(),
                          __pstl::__internal::__no_op());
}

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<
    _ExecutionPolicy, typename iterator_traits<_ForwardIterator>::value_type>
reduce(_ExecutionPolicy &&__exec, _ForwardIterator __first,
       _ForwardIterator __last) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  return transform_reduce(std::forward<_ExecutionPolicy>(__exec), __first,
                          __last, _ValueType{}, std::plus<_ValueType>(),
                          __pstl::__internal::__no_op());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>
transform_reduce(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                 _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                 _Tp __init) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type _InputType;
  return __pstl::__internal::__pattern_transform_reduce(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      __init, std::plus<_InputType>(), std::multiplies<_InputType>(),
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp, class _BinaryOperation1,
          class _BinaryOperation2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>
transform_reduce(_ExecutionPolicy &&__exec, _ForwardIterator1 __first1,
                 _ForwardIterator1 __last1, _ForwardIterator2 __first2,
                 _Tp __init, _BinaryOperation1 __binary_op1,
                 _BinaryOperation2 __binary_op2) {
  return __pstl::__internal::__pattern_transform_reduce(
      std::forward<_ExecutionPolicy>(__exec), __first1, __last1, __first2,
      __init, __binary_op1, __binary_op2,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp,
          class _BinaryOperation, class _UnaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _Tp>
transform_reduce(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                 _ForwardIterator __last, _Tp __init,
                 _BinaryOperation __binary_op, _UnaryOperation __unary_op) {
  return __pstl::__internal::__pattern_transform_reduce(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __init,
      __binary_op, __unary_op,
      __pstl::__internal::__is_vectorization_preferred<_ExecutionPolicy,
                                                       _ForwardIterator>(
          __exec),
      __pstl::__internal::__is_parallelization_preferred<_ExecutionPolicy,
                                                         _ForwardIterator>(
          __exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
exclusive_scan(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
               _ForwardIterator1 __last, _ForwardIterator2 __result,
               _Tp __init) {
  using namespace __pstl;
  return __internal::__pattern_transform_scan(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,
      __pstl::__internal::__no_op(), __init, std::plus<_Tp>(),
      std::false_type(),
      __internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp, class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
exclusive_scan(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
               _ForwardIterator1 __last, _ForwardIterator2 __result, _Tp __init,
               _BinaryOperation __binary_op) {
  using namespace __pstl;
  return __internal::__pattern_transform_scan(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,
      __pstl::__internal::__no_op(), __init, __binary_op, std::false_type(),
      __internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
inclusive_scan(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
               _ForwardIterator1 __last, _ForwardIterator2 __result) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type _InputType;
  return transform_inclusive_scan(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,
      std::plus<_InputType>(), __pstl::__internal::__no_op());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
inclusive_scan(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
               _ForwardIterator1 __last, _ForwardIterator2 __result,
               _BinaryOperation __binary_op) {
  return transform_inclusive_scan(std::forward<_ExecutionPolicy>(__exec),
                                  __first, __last, __result, __binary_op,
                                  __pstl::__internal::__no_op());
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp, class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
inclusive_scan(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
               _ForwardIterator1 __last, _ForwardIterator2 __result,
               _BinaryOperation __binary_op, _Tp __init) {
  return transform_inclusive_scan(std::forward<_ExecutionPolicy>(__exec),
                                  __first, __last, __result, __binary_op,
                                  __pstl::__internal::__no_op(), __init);
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _Tp, class _BinaryOperation,
          class _UnaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
transform_exclusive_scan(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
                         _ForwardIterator1 __last, _ForwardIterator2 __result,
                         _Tp __init, _BinaryOperation __binary_op,
                         _UnaryOperation __unary_op) {
  return __pstl::__internal::__pattern_transform_scan(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,
      __unary_op, __init, __binary_op, std::false_type(),
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryOperation,
          class _UnaryOperation, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
transform_inclusive_scan(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
                         _ForwardIterator1 __last, _ForwardIterator2 __result,
                         _BinaryOperation __binary_op,
                         _UnaryOperation __unary_op, _Tp __init) {
  return __pstl::__internal::__pattern_transform_scan(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,
      __unary_op, __init, __binary_op, std::true_type(),
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _UnaryOperation,
          class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
transform_inclusive_scan(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
                         _ForwardIterator1 __last, _ForwardIterator2 __result,
                         _BinaryOperation __binary_op,
                         _UnaryOperation __unary_op) {
  if (__first != __last) {
    auto __tmp = __unary_op(*__first);
    *__result = __tmp;
    return transform_inclusive_scan(std::forward<_ExecutionPolicy>(__exec),
                                    ++__first, __last, ++__result, __binary_op,
                                    __unary_op, __tmp);
  } else {
    return __result;
  }
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2, class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
adjacent_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
                    _ForwardIterator1 __last, _ForwardIterator2 __d_first,
                    _BinaryOperation __op) {

  if (__first == __last)
    return __d_first;

  return __pstl::__internal::__pattern_adjacent_difference(
      std::forward<_ExecutionPolicy>(__exec), __first, __last, __d_first, __op,
      __pstl::__internal::__is_vectorization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec),
      __pstl::__internal::__is_parallelization_preferred<
          _ExecutionPolicy, _ForwardIterator1, _ForwardIterator2>(__exec));
}

template <class _ExecutionPolicy, class _ForwardIterator1,
          class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator2>
adjacent_difference(_ExecutionPolicy &&__exec, _ForwardIterator1 __first,
                    _ForwardIterator1 __last, _ForwardIterator2 __d_first) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type _ValueType;
  return adjacent_difference(std::forward<_ExecutionPolicy>(__exec), __first,
                             __last, __d_first, std::minus<_ValueType>());
}

} // namespace std
# 46 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/execution" 2 3

# 1 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_memory_impl.h" 1 3
# 16 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/pstl/glue_memory_impl.h" 3
namespace std {

template <class _ExecutionPolicy, class _InputIterator, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
uninitialized_copy(_ExecutionPolicy &&__exec, _InputIterator __first,
                   _InputIterator __last, _ForwardIterator __result) {
  typedef typename iterator_traits<_InputIterator>::value_type _ValueType1;
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;
  typedef typename iterator_traits<_InputIterator>::reference _ReferenceType1;
  typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType2;

  const auto __is_parallel = __pstl::__internal::__is_parallelization_preferred<
      _ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);
  const auto __is_vector = __pstl::__internal::__is_vectorization_preferred<
      _ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);

  return __pstl::__internal::__invoke_if_else(
      std::integral_constant < bool,
      std::is_trivial<_ValueType1>::value
              &&std::is_trivial<_ValueType2>::value > (),
      [&]() {
        return __pstl::__internal::__pattern_walk2_brick(
            std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,
            [__is_vector](_InputIterator __begin, _InputIterator __end,
                          _ForwardIterator __res) {
              return __pstl::__internal::__brick_copy(__begin, __end, __res,
                                                      __is_vector);
            },
            __is_parallel);
      },
      [&]() {
        return __pstl::__internal::__pattern_walk2(
            std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,
            [](_ReferenceType1 __val1, _ReferenceType2 __val2) {
              ::new (std::addressof(__val2)) _ValueType2(__val1);
            },
            __is_vector, __is_parallel);
      });
}

template <class _ExecutionPolicy, class _InputIterator, class _Size,
          class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
uninitialized_copy_n(_ExecutionPolicy &&__exec, _InputIterator __first,
                     _Size __n, _ForwardIterator __result) {
  typedef typename iterator_traits<_InputIterator>::value_type _ValueType1;
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;
  typedef typename iterator_traits<_InputIterator>::reference _ReferenceType1;
  typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType2;

  const auto __is_parallel = __pstl::__internal::__is_parallelization_preferred<
      _ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);
  const auto __is_vector = __pstl::__internal::__is_vectorization_preferred<
      _ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);

  return __pstl::__internal::__invoke_if_else(
      std::integral_constant < bool,
      std::is_trivial<_ValueType1>::value
              &&std::is_trivial<_ValueType2>::value > (),
      [&]() {
        return __pstl::__internal::__pattern_walk2_brick_n(
            std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,
            [__is_vector](_InputIterator __begin, _Size __sz,
                          _ForwardIterator __res) {
              return __pstl::__internal::__brick_copy_n(__begin, __sz, __res,
                                                        __is_vector);
            },
            __is_parallel);
      },
      [&]() {
        return __pstl::__internal::__pattern_walk2_n(
            std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,
            [](_ReferenceType1 __val1, _ReferenceType2 __val2) {
              ::new (std::addressof(__val2)) _ValueType2(__val1);
            },
            __is_vector, __is_parallel);
      });
}

template <class _ExecutionPolicy, class _InputIterator, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
uninitialized_move(_ExecutionPolicy &&__exec, _InputIterator __first,
                   _InputIterator __last, _ForwardIterator __result) {
  typedef typename iterator_traits<_InputIterator>::value_type _ValueType1;
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;
  typedef typename iterator_traits<_InputIterator>::reference _ReferenceType1;
  typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType2;

  const auto __is_parallel = __pstl::__internal::__is_parallelization_preferred<
      _ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);
  const auto __is_vector = __pstl::__internal::__is_vectorization_preferred<
      _ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);

  return __pstl::__internal::__invoke_if_else(
      std::integral_constant < bool,
      std::is_trivial<_ValueType1>::value
              &&std::is_trivial<_ValueType2>::value > (),
      [&]() {
        return __pstl::__internal::__pattern_walk2_brick(
            std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,
            [__is_vector](_InputIterator __begin, _InputIterator __end,
                          _ForwardIterator __res) {
              return __pstl::__internal::__brick_copy(__begin, __end, __res,
                                                      __is_vector);
            },
            __is_parallel);
      },
      [&]() {
        return __pstl::__internal::__pattern_walk2(
            std::forward<_ExecutionPolicy>(__exec), __first, __last, __result,
            [](_ReferenceType1 __val1, _ReferenceType2 __val2) {
              ::new (std::addressof(__val2)) _ValueType2(std::move(__val1));
            },
            __is_vector, __is_parallel);
      });
}

template <class _ExecutionPolicy, class _InputIterator, class _Size,
          class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
uninitialized_move_n(_ExecutionPolicy &&__exec, _InputIterator __first,
                     _Size __n, _ForwardIterator __result) {
  typedef typename iterator_traits<_InputIterator>::value_type _ValueType1;
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType2;
  typedef typename iterator_traits<_InputIterator>::reference _ReferenceType1;
  typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType2;

  const auto __is_parallel = __pstl::__internal::__is_parallelization_preferred<
      _ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);
  const auto __is_vector = __pstl::__internal::__is_vectorization_preferred<
      _ExecutionPolicy, _InputIterator, _ForwardIterator>(__exec);

  return __pstl::__internal::__invoke_if_else(
      std::integral_constant < bool,
      std::is_trivial<_ValueType1>::value
              &&std::is_trivial<_ValueType2>::value > (),
      [&]() {
        return __pstl::__internal::__pattern_walk2_brick_n(
            std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,
            [__is_vector](_InputIterator __begin, _Size __sz,
                          _ForwardIterator __res) {
              return __pstl::__internal::__brick_copy_n(__begin, __sz, __res,
                                                        __is_vector);
            },
            __is_parallel);
      },
      [&]() {
        return __pstl::__internal::__pattern_walk2_n(
            std::forward<_ExecutionPolicy>(__exec), __first, __n, __result,
            [](_ReferenceType1 __val1, _ReferenceType2 __val2) {
              ::new (std::addressof(__val2)) _ValueType2(std::move(__val1));
            },
            __is_vector, __is_parallel);
      });
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
uninitialized_fill(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                   _ForwardIterator __last, const _Tp &__value) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;

  const auto __is_parallel = __pstl::__internal::__is_parallelization_preferred<
      _ExecutionPolicy, _ForwardIterator>(__exec);
  const auto __is_vector = __pstl::__internal::__is_vectorization_preferred<
      _ExecutionPolicy, _ForwardIterator>(__exec);

  __pstl::__internal::__invoke_if_else(
      std::is_arithmetic<_ValueType>(),
      [&]() {
        __pstl::__internal::__pattern_walk_brick(
            std::forward<_ExecutionPolicy>(__exec), __first, __last,
            [&__value, &__is_vector](_ForwardIterator __begin,
                                     _ForwardIterator __end) {
              __pstl::__internal::__brick_fill(
                  __begin, __end, _ValueType(__value), __is_vector);
            },
            __is_parallel);
      },
      [&]() {
        __pstl::__internal::__pattern_walk1(
            std::forward<_ExecutionPolicy>(__exec), __first, __last,
            [&__value](_ReferenceType __val) {
              ::new (std::addressof(__val)) _ValueType(__value);
            },
            __is_vector, __is_parallel);
      });
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Size,
          class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
uninitialized_fill_n(_ExecutionPolicy &&__exec, _ForwardIterator __first,
                     _Size __n, const _Tp &__value) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;

  const auto __is_parallel = __pstl::__internal::__is_parallelization_preferred<
      _ExecutionPolicy, _ForwardIterator>(__exec);
  const auto __is_vector = __pstl::__internal::__is_vectorization_preferred<
      _ExecutionPolicy, _ForwardIterator>(__exec);

  return __pstl::__internal::__invoke_if_else(
      std::is_arithmetic<_ValueType>(),
      [&]() {
        return __pstl::__internal::__pattern_walk_brick_n(
            std::forward<_ExecutionPolicy>(__exec), __first, __n,
            [&__value, &__is_vector](_ForwardIterator __begin, _Size __count) {
              return __pstl::__internal::__brick_fill_n(
                  __begin, __count, _ValueType(__value), __is_vector);
            },
            __is_parallel);
      },
      [&]() {
        return __pstl::__internal::__pattern_walk1_n(
            std::forward<_ExecutionPolicy>(__exec), __first, __n,
            [&__value](_ReferenceType __val) {
              ::new (std::addressof(__val)) _ValueType(__value);
            },
            __is_vector, __is_parallel);
      });
}

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
destroy(_ExecutionPolicy &&__exec, _ForwardIterator __first,
        _ForwardIterator __last) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;

  const auto __is_parallel = __pstl::__internal::__is_parallelization_preferred<
      _ExecutionPolicy, _ForwardIterator>(__exec);
  const auto __is_vector = __pstl::__internal::__is_vectorization_preferred<
      _ExecutionPolicy, _ForwardIterator>(__exec);

  __pstl::__internal::__invoke_if_not(
      std::is_trivially_destructible<_ValueType>(), [&]() {
        __pstl::__internal::__pattern_walk1(
            std::forward<_ExecutionPolicy>(__exec), __first, __last,
            [](_ReferenceType __val) { __val.~_ValueType(); }, __is_vector,
            __is_parallel);
      });
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Size>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
destroy_n(_ExecutionPolicy &&__exec, _ForwardIterator __first, _Size __n) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;

  const auto __is_parallel = __pstl::__internal::__is_parallelization_preferred<
      _ExecutionPolicy, _ForwardIterator>(__exec);
  const auto __is_vector = __pstl::__internal::__is_vectorization_preferred<
      _ExecutionPolicy, _ForwardIterator>(__exec);

  return __pstl::__internal::__invoke_if_else(
      std::is_trivially_destructible<_ValueType>(),
      [&]() { return std::next(__first, __n); },
      [&]() {
        return __pstl::__internal::__pattern_walk1_n(
            std::forward<_ExecutionPolicy>(__exec), __first, __n,
            [](_ReferenceType __val) { __val.~_ValueType(); }, __is_vector,
            __is_parallel);
      });
}

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
uninitialized_default_construct(_ExecutionPolicy &&__exec,
                                _ForwardIterator __first,
                                _ForwardIterator __last) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;

  const auto __is_parallel = __pstl::__internal::__is_parallelization_preferred<
      _ExecutionPolicy, _ForwardIterator>(__exec);
  const auto __is_vector = __pstl::__internal::__is_vectorization_preferred<
      _ExecutionPolicy, _ForwardIterator>(__exec);

  __pstl::__internal::__invoke_if_not(std::is_trivial<_ValueType>(), [&]() {
    __pstl::__internal::__pattern_walk1(
        std::forward<_ExecutionPolicy>(__exec), __first, __last,
        [](_ReferenceType __val) { ::new (std::addressof(__val)) _ValueType; },
        __is_vector, __is_parallel);
  });
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Size>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
uninitialized_default_construct_n(_ExecutionPolicy &&__exec,
                                  _ForwardIterator __first, _Size __n) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;

  const auto __is_parallel = __pstl::__internal::__is_parallelization_preferred<
      _ExecutionPolicy, _ForwardIterator>(__exec);
  const auto __is_vector = __pstl::__internal::__is_vectorization_preferred<
      _ExecutionPolicy, _ForwardIterator>(__exec);

  return __pstl::__internal::__invoke_if_else(
      std::is_trivial<_ValueType>(), [&]() { return std::next(__first, __n); },
      [&]() {
        return __pstl::__internal::__pattern_walk1_n(
            std::forward<_ExecutionPolicy>(__exec), __first, __n,
            [](_ReferenceType __val) {
              ::new (std::addressof(__val)) _ValueType;
            },
            __is_vector, __is_parallel);
      });
}

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
uninitialized_value_construct(_ExecutionPolicy &&__exec,
                              _ForwardIterator __first,
                              _ForwardIterator __last) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;

  const auto __is_parallel = __pstl::__internal::__is_parallelization_preferred<
      _ExecutionPolicy, _ForwardIterator>(__exec);
  const auto __is_vector = __pstl::__internal::__is_vectorization_preferred<
      _ExecutionPolicy, _ForwardIterator>(__exec);

  __pstl::__internal::__invoke_if_else(
      std::is_trivial<_ValueType>(),
      [&]() {
        __pstl::__internal::__pattern_walk_brick(
            std::forward<_ExecutionPolicy>(__exec), __first, __last,
            [__is_vector](_ForwardIterator __begin, _ForwardIterator __end) {
              __pstl::__internal::__brick_fill(__begin, __end, _ValueType(),
                                               __is_vector);
            },
            __is_parallel);
      },
      [&]() {
        __pstl::__internal::__pattern_walk1(
            std::forward<_ExecutionPolicy>(__exec), __first, __last,
            [](_ReferenceType __val) {
              ::new (std::addressof(__val)) _ValueType();
            },
            __is_vector, __is_parallel);
      });
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Size>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 _ForwardIterator>
uninitialized_value_construct_n(_ExecutionPolicy &&__exec,
                                _ForwardIterator __first, _Size __n) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  typedef typename iterator_traits<_ForwardIterator>::reference _ReferenceType;

  const auto __is_parallel = __pstl::__internal::__is_parallelization_preferred<
      _ExecutionPolicy, _ForwardIterator>(__exec);
  const auto __is_vector = __pstl::__internal::__is_vectorization_preferred<
      _ExecutionPolicy, _ForwardIterator>(__exec);

  return __pstl::__internal::__invoke_if_else(
      std::is_trivial<_ValueType>(),
      [&]() {
        return __pstl::__internal::__pattern_walk_brick_n(
            std::forward<_ExecutionPolicy>(__exec), __first, __n,
            [__is_vector](_ForwardIterator __begin, _Size __count) {
              return __pstl::__internal::__brick_fill_n(
                  __begin, __count, _ValueType(), __is_vector);
            },
            __is_parallel);
      },
      [&]() {
        return __pstl::__internal::__pattern_walk1_n(
            std::forward<_ExecutionPolicy>(__exec), __first, __n,
            [](_ReferenceType __val) {
              ::new (std::addressof(__val)) _ValueType();
            },
            __is_vector, __is_parallel);
      });
}

} // namespace std
# 51 "/usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/execution" 2 3
# 25 "./ComputeRestriction_stdexec.hpp" 2

auto ComputeRestriction_stdexec(double *time, const SparseMatrix &A,
                                const Vector &rf) {

  return stdexec::then([&, time]() {
           if (time != __null)
             *time -= mytimer();
         }) |
         stdexec::bulk(stdexec::par, A.mgData->rc->localLength,
                       [&](int i) {
                         double *Axfv = A.mgData->Axf->values;
                         double *rfv = rf.values;
                         double *rcv = A.mgData->rc->values;
                         local_int_t *f2c = A.mgData->f2cOperator;
                         rcv[i] = rfv[f2c[i]] - Axfv[f2c[i]];
                       }) |
         stdexec::then([&, time]() {
           if (time != __null)
             *time += mytimer();
         });
# 65 "./ComputeRestriction_stdexec.hpp"
}
# 9 "./ComputeMG_stdexec.hpp" 2
# 1 "./ComputeProlongation_stdexec.hpp" 1
# 26 "./ComputeProlongation_stdexec.hpp"
auto ComputeProlongation_stdexec(double *time, const SparseMatrix &Af,
                                 Vector &xf) {

  return stdexec::then([&, time]() {
           if (time != __null)
             *time -= mytimer();
         }) |
         stdexec::bulk(stdexec::par, Af.mgData->rc->localLength,
                       [&](int i) {
                         double *xfv = xf.values;
                         double *xcv = Af.mgData->xc->values;
                         local_int_t *f2c = Af.mgData->f2cOperator;
                         xfv[f2c[i]] += xcv[i];
                       }) |
         stdexec::then([&, time]() {
           if (time != __null)
             *time += mytimer();
         });
# 62 "./ComputeProlongation_stdexec.hpp"
}
# 10 "./ComputeMG_stdexec.hpp" 2

auto preRecursionMG(const SparseMatrix &A, const Vector &r, Vector &x) {

  return ComputeSYMGS_stdexec(__null, A, r, x) |
         ComputeSYMGS_stdexec(__null, A, r, x) |
         ComputeSYMGS_stdexec(__null, A, r, x) |
         ComputeSPMV_stdexec(__null, A, x, *A.mgData->Axf) |
         ComputeRestriction_stdexec(__null, A, r);
}

auto postRecursionMG(const SparseMatrix &A, const Vector &r, Vector &x) {
  return ComputeProlongation_stdexec(__null, A, x)

         | ComputeSYMGS_stdexec(__null, A, r, x) |
         ComputeSYMGS_stdexec(__null, A, r, x) |
         ComputeSYMGS_stdexec(__null, A, r, x);
}

auto terminalMG(const SparseMatrix &A, const Vector &r, Vector &x) {
  return ComputeSYMGS_stdexec(__null, A, r, x);
}

auto ComputeMG_stdexec(double *time, const SparseMatrix &A, const Vector &r,
                       Vector &x) {

  static std::vector<const SparseMatrix *> matrix_ptrs(4);
  static std::vector<const Vector *> res_ptrs(4);
  static std::vector<Vector *> xval_ptrs(4);

  matrix_ptrs[0] = &A;
  res_ptrs[0] = &r;
  xval_ptrs[0] = &x;
  for (int cnt = 1; cnt < 4; cnt++) {
    matrix_ptrs[cnt] = matrix_ptrs[cnt - 1]->Ac;
    res_ptrs[cnt] = matrix_ptrs[cnt - 1]->mgData->rc;
    xval_ptrs[cnt] = matrix_ptrs[cnt - 1]->mgData->xc;
  }

  return stdexec::then([&, time]() {
           if (time != __null)
             *time -= mytimer();

           (static_cast<bool>(x.localLength == A.localNumberOfColumns)
                ? void(0)
                : __assert_fail("x.localLength == A.localNumberOfColumns",
                                __builtin_FILE(), __builtin_LINE(),
                                __extension__ __PRETTY_FUNCTION__));
           ZeroVector(x);
         })

         | preRecursionMG(*matrix_ptrs[0], *res_ptrs[0], *xval_ptrs[0]) |
         preRecursionMG(*matrix_ptrs[1], *res_ptrs[1], *xval_ptrs[1]) |
         preRecursionMG(*matrix_ptrs[2], *res_ptrs[2], *xval_ptrs[2]) |
         terminalMG(*matrix_ptrs[3], *res_ptrs[3], *xval_ptrs[3]) |
         postRecursionMG(*matrix_ptrs[2], *res_ptrs[2], *xval_ptrs[2]) |
         postRecursionMG(*matrix_ptrs[1], *res_ptrs[1], *xval_ptrs[1]) |
         postRecursionMG(*matrix_ptrs[0], *res_ptrs[0], *xval_ptrs[0])

         | stdexec::then([&, time]() {
             if (time != __null)
               *time += mytimer();
           });
}
# 7 "CG_stdexec.hpp" 2
# 1 "./ComputeDotProduct_stdexec.hpp" 1
# 26 "./ComputeDotProduct_stdexec.hpp"
# 1 "./ComputeDotProduct_ref.hpp" 1
# 18 "./ComputeDotProduct_ref.hpp"
int ComputeDotProduct_ref(const local_int_t n, const Vector &x, const Vector &y,
                          double &result, double &time_allreduce);
# 27 "./ComputeDotProduct_stdexec.hpp" 2

auto ComputeDotProduct_stdexec(double *time, const local_int_t n,
                               const Vector &x, const Vector &y, double &result,
                               double &time_allreduce) {

  return stdexec::then([&, time, n]() {
    if (time != __null)
      *time -= mytimer();
    ComputeDotProduct_ref(n, x, y, result, time_allreduce);
# 66 "./ComputeDotProduct_stdexec.hpp"
    if (time != __null)
      *time += mytimer();
  });
}
# 8 "CG_stdexec.hpp" 2
# 1 "./ComputeWAXPBY_stdexec.hpp" 1
# 22 "./ComputeWAXPBY_stdexec.hpp"
# 1 "./ComputeWAXPBY_ref.hpp" 1
# 18 "./ComputeWAXPBY_ref.hpp"
int ComputeWAXPBY_ref(const local_int_t n, const double alpha, const Vector &x,
                      const double beta, const Vector &y, Vector &w);
# 23 "./ComputeWAXPBY_stdexec.hpp" 2

auto ComputeWAXPBY_stdexec(double *time, const local_int_t n,
                           const double alpha, const Vector &x,
                           const double beta, const Vector &y, Vector &w) {

  (static_cast<bool>(x.localLength >= n)
       ? void(0)
       : __assert_fail("x.localLength >= n", __builtin_FILE(), __builtin_LINE(),
                       __extension__ __PRETTY_FUNCTION__));
  (static_cast<bool>(y.localLength >= n)
       ? void(0)
       : __assert_fail("y.localLength >= n", __builtin_FILE(), __builtin_LINE(),
                       __extension__ __PRETTY_FUNCTION__));
  const double *const xv = x.values;
  const double *const yv = y.values;
  double *const wv = w.values;

  return stdexec::then([&, time, n, alpha, beta]() {
    if (time != __null)
      *time -= mytimer();
    ComputeWAXPBY_ref(n, alpha, x, beta, y, w);
    if (time != __null)
      *time += mytimer();
  });
}
# 9 "CG_stdexec.hpp" 2

using stdexec::bulk;
using stdexec::schedule;
using stdexec::sender;
using stdexec::sync_wait;
using stdexec::then;
# 143 "CG_stdexec.hpp"
auto CG_stdexec(auto scheduler, const SparseMatrix &A, CGData &data,
                const Vector &b, Vector &x, const int max_iter,
                const double tolerance, int &niters, double &normr,
                double &normr0, double *times, bool doPreconditioning) {

  double t_begin = mytimer();
  normr = 0.0;
  double rtz = 0.0, oldrtz = 0.0, alpha = 0.0, beta = 0.0, pAp = 0.0;
  double t0 = 0.0, t1 = 0.0, t2 = 0.0, t3 = 0.0, t4 = 0.0, t5 = 0.0;
  local_int_t nrow = A.localNumberOfRows;
  Vector &r = data.r;
  Vector &z = data.z;
  Vector &p = data.p;
  Vector &Ap = data.Ap;
  std::atomic<double> dot_local_result(0.0);
  double dot_local_copy;

  std::vector<const SparseMatrix *> matrix_ptrs(4);
  std::vector<const Vector *> res_ptrs(4);
  std::vector<Vector *> zval_ptrs(4);
  matrix_ptrs[0] = &A;
  res_ptrs[0] = &r;
  zval_ptrs[0] = &z;
  for (int cnt = 1; cnt < 4; cnt++) {
    matrix_ptrs[cnt] = matrix_ptrs[cnt - 1]->Ac;
    res_ptrs[cnt] = matrix_ptrs[cnt - 1]->mgData->rc;
    zval_ptrs[cnt] = matrix_ptrs[cnt - 1]->mgData->xc;
  }

  double **matrixDiagonal;
  double *rv;
  double *xv;

  if (!doPreconditioning && A.geom->rank == 0)
    HPCG_fout << "WARNING: PERFORMING UNPRECONDITIONED ITERATIONS" << std::endl;

  sender auto pre_loop_work =
      schedule(scheduler) | then([&]() { CopyVector(x, p); })

      | stdexec::bulk(stdexec::par, (A).localNumberOfRows,
                      [&](local_int_t i) {
                        double sum = 0.0;
                        double *cur_vals = (A).matrixValues[i];
                        local_int_t *cur_inds = (A).mtxIndL[i];
                        int cur_nnz = (A).nonzerosInRow[i];
                        double *xv = (p).values;
                        for (int j = 0; j < cur_nnz; j++)
                          sum += cur_vals[j] * xv[cur_inds[j]];
                        (Ap).values[i] = sum;
                      })

      | bulk(stdexec::par, nrow,
             [&](local_int_t i) {
               (r).values[i] = (1) * (b).values[i] + (-1) * (Ap).values[i];
             }) |
      then([&]() { dot_local_result = 0.0; }) |
      bulk(stdexec::par, nrow,
           [&](local_int_t i) {
             dot_local_result.fetch_add((r).values[i] * (r).values[i],
                                        std::memory_order_relaxed);
           }) |
      then([&]() { (normr) = dot_local_result.load(); }) | then([&]() {
        normr = sqrt(normr);

        normr0 = normr;
      });

  sync_wait(std::move(pre_loop_work));
  int k = 1;

  sender auto first_loop =
      schedule(scheduler) | then([&]() { t0 = mytimer(); })

      | then([&]() {
          matrixDiagonal = ((*matrix_ptrs[0])).matrixDiagonal;
          rv = ((*res_ptrs[0])).values;
          xv = ((*zval_ptrs[0])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[0])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[0])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[0])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[0])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[0])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[0])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          matrixDiagonal = ((*matrix_ptrs[0])).matrixDiagonal;
          rv = ((*res_ptrs[0])).values;
          xv = ((*zval_ptrs[0])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[0])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[0])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[0])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[0])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[0])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[0])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          matrixDiagonal = ((*matrix_ptrs[0])).matrixDiagonal;
          rv = ((*res_ptrs[0])).values;
          xv = ((*zval_ptrs[0])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[0])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[0])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[0])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[0])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[0])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[0])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
        }) |
      stdexec::bulk(stdexec::par, ((*matrix_ptrs[0])).localNumberOfRows,
                    [&](local_int_t i) {
                      double sum = 0.0;
                      double *cur_vals = ((*matrix_ptrs[0])).matrixValues[i];
                      local_int_t *cur_inds = ((*matrix_ptrs[0])).mtxIndL[i];
                      int cur_nnz = ((*matrix_ptrs[0])).nonzerosInRow[i];
                      double *xv = ((*zval_ptrs[0])).values;
                      for (int j = 0; j < cur_nnz; j++)
                        sum += cur_vals[j] * xv[cur_inds[j]];
                      (*((*matrix_ptrs[0]).mgData->Axf)).values[i] = sum;
                    }) |
      stdexec::bulk(stdexec::par, ((*matrix_ptrs[0])).mgData->rc->localLength,
                    [&](int i) {
                      double *Axfv = ((*matrix_ptrs[0])).mgData->Axf->values;
                      double *rfv = ((*res_ptrs[0])).values;
                      double *rcv = ((*matrix_ptrs[0])).mgData->rc->values;
                      local_int_t *f2c =
                          ((*matrix_ptrs[0])).mgData->f2cOperator;
                      rcv[i] = rfv[f2c[i]] - Axfv[f2c[i]];
                    }) |
      then([&]() {
        matrixDiagonal = ((*matrix_ptrs[1])).matrixDiagonal;
        rv = ((*res_ptrs[1])).values;
        xv = ((*zval_ptrs[1])).values;
        for (local_int_t i = 0; i < nrow; i++) {
          const double *const currentValues =
              ((*matrix_ptrs[1])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[1])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[1])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        for (local_int_t i = nrow - 1; i >= 0; i--) {
          const double *const currentValues =
              ((*matrix_ptrs[1])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[1])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[1])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        matrixDiagonal = ((*matrix_ptrs[1])).matrixDiagonal;
        rv = ((*res_ptrs[1])).values;
        xv = ((*zval_ptrs[1])).values;
        for (local_int_t i = 0; i < nrow; i++) {
          const double *const currentValues =
              ((*matrix_ptrs[1])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[1])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[1])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        for (local_int_t i = nrow - 1; i >= 0; i--) {
          const double *const currentValues =
              ((*matrix_ptrs[1])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[1])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[1])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        matrixDiagonal = ((*matrix_ptrs[1])).matrixDiagonal;
        rv = ((*res_ptrs[1])).values;
        xv = ((*zval_ptrs[1])).values;
        for (local_int_t i = 0; i < nrow; i++) {
          const double *const currentValues =
              ((*matrix_ptrs[1])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[1])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[1])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        for (local_int_t i = nrow - 1; i >= 0; i--) {
          const double *const currentValues =
              ((*matrix_ptrs[1])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[1])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[1])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
      }) |
      stdexec::bulk(stdexec::par, ((*matrix_ptrs[1])).localNumberOfRows,
                    [&](local_int_t i) {
                      double sum = 0.0;
                      double *cur_vals = ((*matrix_ptrs[1])).matrixValues[i];
                      local_int_t *cur_inds = ((*matrix_ptrs[1])).mtxIndL[i];
                      int cur_nnz = ((*matrix_ptrs[1])).nonzerosInRow[i];
                      double *xv = ((*zval_ptrs[1])).values;
                      for (int j = 0; j < cur_nnz; j++)
                        sum += cur_vals[j] * xv[cur_inds[j]];
                      (*((*matrix_ptrs[1]).mgData->Axf)).values[i] = sum;
                    }) |
      stdexec::bulk(stdexec::par, ((*matrix_ptrs[1])).mgData->rc->localLength,
                    [&](int i) {
                      double *Axfv = ((*matrix_ptrs[1])).mgData->Axf->values;
                      double *rfv = ((*res_ptrs[1])).values;
                      double *rcv = ((*matrix_ptrs[1])).mgData->rc->values;
                      local_int_t *f2c =
                          ((*matrix_ptrs[1])).mgData->f2cOperator;
                      rcv[i] = rfv[f2c[i]] - Axfv[f2c[i]];
                    }) |
      then([&]() {
        matrixDiagonal = ((*matrix_ptrs[2])).matrixDiagonal;
        rv = ((*res_ptrs[2])).values;
        xv = ((*zval_ptrs[2])).values;
        for (local_int_t i = 0; i < nrow; i++) {
          const double *const currentValues =
              ((*matrix_ptrs[2])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[2])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[2])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        for (local_int_t i = nrow - 1; i >= 0; i--) {
          const double *const currentValues =
              ((*matrix_ptrs[2])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[2])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[2])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        matrixDiagonal = ((*matrix_ptrs[2])).matrixDiagonal;
        rv = ((*res_ptrs[2])).values;
        xv = ((*zval_ptrs[2])).values;
        for (local_int_t i = 0; i < nrow; i++) {
          const double *const currentValues =
              ((*matrix_ptrs[2])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[2])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[2])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        for (local_int_t i = nrow - 1; i >= 0; i--) {
          const double *const currentValues =
              ((*matrix_ptrs[2])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[2])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[2])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        matrixDiagonal = ((*matrix_ptrs[2])).matrixDiagonal;
        rv = ((*res_ptrs[2])).values;
        xv = ((*zval_ptrs[2])).values;
        for (local_int_t i = 0; i < nrow; i++) {
          const double *const currentValues =
              ((*matrix_ptrs[2])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[2])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[2])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        for (local_int_t i = nrow - 1; i >= 0; i--) {
          const double *const currentValues =
              ((*matrix_ptrs[2])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[2])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[2])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
      }) |
      stdexec::bulk(stdexec::par, ((*matrix_ptrs[2])).localNumberOfRows,
                    [&](local_int_t i) {
                      double sum = 0.0;
                      double *cur_vals = ((*matrix_ptrs[2])).matrixValues[i];
                      local_int_t *cur_inds = ((*matrix_ptrs[2])).mtxIndL[i];
                      int cur_nnz = ((*matrix_ptrs[2])).nonzerosInRow[i];
                      double *xv = ((*zval_ptrs[2])).values;
                      for (int j = 0; j < cur_nnz; j++)
                        sum += cur_vals[j] * xv[cur_inds[j]];
                      (*((*matrix_ptrs[2]).mgData->Axf)).values[i] = sum;
                    }) |
      stdexec::bulk(stdexec::par, ((*matrix_ptrs[2])).mgData->rc->localLength,
                    [&](int i) {
                      double *Axfv = ((*matrix_ptrs[2])).mgData->Axf->values;
                      double *rfv = ((*res_ptrs[2])).values;
                      double *rcv = ((*matrix_ptrs[2])).mgData->rc->values;
                      local_int_t *f2c =
                          ((*matrix_ptrs[2])).mgData->f2cOperator;
                      rcv[i] = rfv[f2c[i]] - Axfv[f2c[i]];
                    }) |
      stdexec::bulk(stdexec::par, (*matrix_ptrs[3]).localNumberOfRows,
                    [&](local_int_t i) {
                      double sum = 0.0;
                      double *cur_vals = (*matrix_ptrs[3]).matrixValues[i];
                      local_int_t *cur_inds = (*matrix_ptrs[3]).mtxIndL[i];
                      int cur_nnz = (*matrix_ptrs[3]).nonzerosInRow[i];
                      double *xv = (*res_ptrs[3]).values;
                      for (int j = 0; j < cur_nnz; j++)
                        sum += cur_vals[j] * xv[cur_inds[j]];
                      (*zval_ptrs[3]).values[i] = sum;
                    }) |
      stdexec::bulk(stdexec::par, ((*matrix_ptrs[2])).mgData->rc->localLength,
                    [&](int i) {
                      double *xfv = ((*zval_ptrs[2])).values;
                      double *xcv = ((*matrix_ptrs[2])).mgData->xc->values;
                      local_int_t *f2c =
                          ((*matrix_ptrs[2])).mgData->f2cOperator;
                      xfv[f2c[i]] += xcv[i];
                    }) |
      then([&]() {
        matrixDiagonal = ((*matrix_ptrs[2])).matrixDiagonal;
        rv = ((*res_ptrs[2])).values;
        xv = ((*zval_ptrs[2])).values;
        for (local_int_t i = 0; i < nrow; i++) {
          const double *const currentValues =
              ((*matrix_ptrs[2])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[2])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[2])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        for (local_int_t i = nrow - 1; i >= 0; i--) {
          const double *const currentValues =
              ((*matrix_ptrs[2])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[2])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[2])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        matrixDiagonal = ((*matrix_ptrs[2])).matrixDiagonal;
        rv = ((*res_ptrs[2])).values;
        xv = ((*zval_ptrs[2])).values;
        for (local_int_t i = 0; i < nrow; i++) {
          const double *const currentValues =
              ((*matrix_ptrs[2])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[2])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[2])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        for (local_int_t i = nrow - 1; i >= 0; i--) {
          const double *const currentValues =
              ((*matrix_ptrs[2])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[2])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[2])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        matrixDiagonal = ((*matrix_ptrs[2])).matrixDiagonal;
        rv = ((*res_ptrs[2])).values;
        xv = ((*zval_ptrs[2])).values;
        for (local_int_t i = 0; i < nrow; i++) {
          const double *const currentValues =
              ((*matrix_ptrs[2])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[2])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[2])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        for (local_int_t i = nrow - 1; i >= 0; i--) {
          const double *const currentValues =
              ((*matrix_ptrs[2])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[2])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[2])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
      }) |
      stdexec::bulk(stdexec::par, ((*matrix_ptrs[1])).mgData->rc->localLength,
                    [&](int i) {
                      double *xfv = ((*zval_ptrs[1])).values;
                      double *xcv = ((*matrix_ptrs[1])).mgData->xc->values;
                      local_int_t *f2c =
                          ((*matrix_ptrs[1])).mgData->f2cOperator;
                      xfv[f2c[i]] += xcv[i];
                    }) |
      then([&]() {
        matrixDiagonal = ((*matrix_ptrs[1])).matrixDiagonal;
        rv = ((*res_ptrs[1])).values;
        xv = ((*zval_ptrs[1])).values;
        for (local_int_t i = 0; i < nrow; i++) {
          const double *const currentValues =
              ((*matrix_ptrs[1])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[1])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[1])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        for (local_int_t i = nrow - 1; i >= 0; i--) {
          const double *const currentValues =
              ((*matrix_ptrs[1])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[1])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[1])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        matrixDiagonal = ((*matrix_ptrs[1])).matrixDiagonal;
        rv = ((*res_ptrs[1])).values;
        xv = ((*zval_ptrs[1])).values;
        for (local_int_t i = 0; i < nrow; i++) {
          const double *const currentValues =
              ((*matrix_ptrs[1])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[1])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[1])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        for (local_int_t i = nrow - 1; i >= 0; i--) {
          const double *const currentValues =
              ((*matrix_ptrs[1])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[1])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[1])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        matrixDiagonal = ((*matrix_ptrs[1])).matrixDiagonal;
        rv = ((*res_ptrs[1])).values;
        xv = ((*zval_ptrs[1])).values;
        for (local_int_t i = 0; i < nrow; i++) {
          const double *const currentValues =
              ((*matrix_ptrs[1])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[1])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[1])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        for (local_int_t i = nrow - 1; i >= 0; i--) {
          const double *const currentValues =
              ((*matrix_ptrs[1])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[1])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[1])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
      }) |
      stdexec::bulk(stdexec::par, ((*matrix_ptrs[0])).mgData->rc->localLength,
                    [&](int i) {
                      double *xfv = ((*zval_ptrs[0])).values;
                      double *xcv = ((*matrix_ptrs[0])).mgData->xc->values;
                      local_int_t *f2c =
                          ((*matrix_ptrs[0])).mgData->f2cOperator;
                      xfv[f2c[i]] += xcv[i];
                    }) |
      then([&]() {
        matrixDiagonal = ((*matrix_ptrs[0])).matrixDiagonal;
        rv = ((*res_ptrs[0])).values;
        xv = ((*zval_ptrs[0])).values;
        for (local_int_t i = 0; i < nrow; i++) {
          const double *const currentValues =
              ((*matrix_ptrs[0])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[0])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[0])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        for (local_int_t i = nrow - 1; i >= 0; i--) {
          const double *const currentValues =
              ((*matrix_ptrs[0])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[0])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[0])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        matrixDiagonal = ((*matrix_ptrs[0])).matrixDiagonal;
        rv = ((*res_ptrs[0])).values;
        xv = ((*zval_ptrs[0])).values;
        for (local_int_t i = 0; i < nrow; i++) {
          const double *const currentValues =
              ((*matrix_ptrs[0])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[0])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[0])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        for (local_int_t i = nrow - 1; i >= 0; i--) {
          const double *const currentValues =
              ((*matrix_ptrs[0])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[0])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[0])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        matrixDiagonal = ((*matrix_ptrs[0])).matrixDiagonal;
        rv = ((*res_ptrs[0])).values;
        xv = ((*zval_ptrs[0])).values;
        for (local_int_t i = 0; i < nrow; i++) {
          const double *const currentValues =
              ((*matrix_ptrs[0])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[0])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[0])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
        for (local_int_t i = nrow - 1; i >= 0; i--) {
          const double *const currentValues =
              ((*matrix_ptrs[0])).matrixValues[i];
          const local_int_t *const currentColIndices =
              ((*matrix_ptrs[0])).mtxIndL[i];
          const int currentNumberOfNonzeros =
              ((*matrix_ptrs[0])).nonzerosInRow[i];
          const double currentDiagonal = matrixDiagonal[i][0];
          double sum = rv[i];
          for (int j = 0; j < currentNumberOfNonzeros; j++) {
            local_int_t curCol = currentColIndices[j];
            sum -= currentValues[j] * xv[curCol];
          }
          sum += xv[i] * currentDiagonal;
          xv[i] = sum / currentDiagonal;
        }
      }) |
      then([&]() {
        t5 += mytimer() - t0;
        CopyVector(z, p);
      }) |
      then([&]() { dot_local_result = 0.0; }) |
      bulk(stdexec::par, nrow,
           [&](local_int_t i) {
             dot_local_result.fetch_add((r).values[i] * (z).values[i],
                                        std::memory_order_relaxed);
           }) |
      then([&]() { (rtz) = dot_local_result.load(); })

      | stdexec::bulk(stdexec::par, (A).localNumberOfRows,
                      [&](local_int_t i) {
                        double sum = 0.0;
                        double *cur_vals = (A).matrixValues[i];
                        local_int_t *cur_inds = (A).mtxIndL[i];
                        int cur_nnz = (A).nonzerosInRow[i];
                        double *xv = (p).values;
                        for (int j = 0; j < cur_nnz; j++)
                          sum += cur_vals[j] * xv[cur_inds[j]];
                        (Ap).values[i] = sum;
                      }) |
      then([&]() { dot_local_result = 0.0; }) |
      bulk(stdexec::par, nrow,
           [&](local_int_t i) {
             dot_local_result.fetch_add((p).values[i] * (Ap).values[i],
                                        std::memory_order_relaxed);
           }) |
      then([&]() { (pAp) = dot_local_result.load(); }) |
      then([&]() { alpha = rtz / pAp; })

      | bulk(stdexec::par, nrow,
             [&](local_int_t i) {
               (x).values[i] = (1) * (x).values[i] + (alpha) * (p).values[i];
             })

      | bulk(stdexec::par, nrow,
             [&](local_int_t i) {
               (r).values[i] = (1) * (r).values[i] + (-alpha) * (Ap).values[i];
             }) |
      then([&]() { dot_local_result = 0.0; }) |
      bulk(stdexec::par, nrow,
           [&](local_int_t i) {
             dot_local_result.fetch_add((r).values[i] * (r).values[i],
                                        std::memory_order_relaxed);
           }) |
      then([&]() { (normr) = dot_local_result.load(); }) |
      then([&]() { normr = sqrt(normr); }) | then([&]() { niters = 1; });

  stdexec::sync_wait(std::move(first_loop));

  for (int k = 2; k <= max_iter && normr / normr0 > tolerance; k++) {

    sender auto subsequent_loop =
        schedule(scheduler) | then([&]() { t0 = mytimer(); })

        | then([&]() {
            matrixDiagonal = ((*matrix_ptrs[0])).matrixDiagonal;
            rv = ((*res_ptrs[0])).values;
            xv = ((*zval_ptrs[0])).values;
            for (local_int_t i = 0; i < nrow; i++) {
              const double *const currentValues =
                  ((*matrix_ptrs[0])).matrixValues[i];
              const local_int_t *const currentColIndices =
                  ((*matrix_ptrs[0])).mtxIndL[i];
              const int currentNumberOfNonzeros =
                  ((*matrix_ptrs[0])).nonzerosInRow[i];
              const double currentDiagonal = matrixDiagonal[i][0];
              double sum = rv[i];
              for (int j = 0; j < currentNumberOfNonzeros; j++) {
                local_int_t curCol = currentColIndices[j];
                sum -= currentValues[j] * xv[curCol];
              }
              sum += xv[i] * currentDiagonal;
              xv[i] = sum / currentDiagonal;
            }
            for (local_int_t i = nrow - 1; i >= 0; i--) {
              const double *const currentValues =
                  ((*matrix_ptrs[0])).matrixValues[i];
              const local_int_t *const currentColIndices =
                  ((*matrix_ptrs[0])).mtxIndL[i];
              const int currentNumberOfNonzeros =
                  ((*matrix_ptrs[0])).nonzerosInRow[i];
              const double currentDiagonal = matrixDiagonal[i][0];
              double sum = rv[i];
              for (int j = 0; j < currentNumberOfNonzeros; j++) {
                local_int_t curCol = currentColIndices[j];
                sum -= currentValues[j] * xv[curCol];
              }
              sum += xv[i] * currentDiagonal;
              xv[i] = sum / currentDiagonal;
            }
            matrixDiagonal = ((*matrix_ptrs[0])).matrixDiagonal;
            rv = ((*res_ptrs[0])).values;
            xv = ((*zval_ptrs[0])).values;
            for (local_int_t i = 0; i < nrow; i++) {
              const double *const currentValues =
                  ((*matrix_ptrs[0])).matrixValues[i];
              const local_int_t *const currentColIndices =
                  ((*matrix_ptrs[0])).mtxIndL[i];
              const int currentNumberOfNonzeros =
                  ((*matrix_ptrs[0])).nonzerosInRow[i];
              const double currentDiagonal = matrixDiagonal[i][0];
              double sum = rv[i];
              for (int j = 0; j < currentNumberOfNonzeros; j++) {
                local_int_t curCol = currentColIndices[j];
                sum -= currentValues[j] * xv[curCol];
              }
              sum += xv[i] * currentDiagonal;
              xv[i] = sum / currentDiagonal;
            }
            for (local_int_t i = nrow - 1; i >= 0; i--) {
              const double *const currentValues =
                  ((*matrix_ptrs[0])).matrixValues[i];
              const local_int_t *const currentColIndices =
                  ((*matrix_ptrs[0])).mtxIndL[i];
              const int currentNumberOfNonzeros =
                  ((*matrix_ptrs[0])).nonzerosInRow[i];
              const double currentDiagonal = matrixDiagonal[i][0];
              double sum = rv[i];
              for (int j = 0; j < currentNumberOfNonzeros; j++) {
                local_int_t curCol = currentColIndices[j];
                sum -= currentValues[j] * xv[curCol];
              }
              sum += xv[i] * currentDiagonal;
              xv[i] = sum / currentDiagonal;
            }
            matrixDiagonal = ((*matrix_ptrs[0])).matrixDiagonal;
            rv = ((*res_ptrs[0])).values;
            xv = ((*zval_ptrs[0])).values;
            for (local_int_t i = 0; i < nrow; i++) {
              const double *const currentValues =
                  ((*matrix_ptrs[0])).matrixValues[i];
              const local_int_t *const currentColIndices =
                  ((*matrix_ptrs[0])).mtxIndL[i];
              const int currentNumberOfNonzeros =
                  ((*matrix_ptrs[0])).nonzerosInRow[i];
              const double currentDiagonal = matrixDiagonal[i][0];
              double sum = rv[i];
              for (int j = 0; j < currentNumberOfNonzeros; j++) {
                local_int_t curCol = currentColIndices[j];
                sum -= currentValues[j] * xv[curCol];
              }
              sum += xv[i] * currentDiagonal;
              xv[i] = sum / currentDiagonal;
            }
            for (local_int_t i = nrow - 1; i >= 0; i--) {
              const double *const currentValues =
                  ((*matrix_ptrs[0])).matrixValues[i];
              const local_int_t *const currentColIndices =
                  ((*matrix_ptrs[0])).mtxIndL[i];
              const int currentNumberOfNonzeros =
                  ((*matrix_ptrs[0])).nonzerosInRow[i];
              const double currentDiagonal = matrixDiagonal[i][0];
              double sum = rv[i];
              for (int j = 0; j < currentNumberOfNonzeros; j++) {
                local_int_t curCol = currentColIndices[j];
                sum -= currentValues[j] * xv[curCol];
              }
              sum += xv[i] * currentDiagonal;
              xv[i] = sum / currentDiagonal;
            }
          }) |
        stdexec::bulk(stdexec::par, ((*matrix_ptrs[0])).localNumberOfRows,
                      [&](local_int_t i) {
                        double sum = 0.0;
                        double *cur_vals = ((*matrix_ptrs[0])).matrixValues[i];
                        local_int_t *cur_inds = ((*matrix_ptrs[0])).mtxIndL[i];
                        int cur_nnz = ((*matrix_ptrs[0])).nonzerosInRow[i];
                        double *xv = ((*zval_ptrs[0])).values;
                        for (int j = 0; j < cur_nnz; j++)
                          sum += cur_vals[j] * xv[cur_inds[j]];
                        (*((*matrix_ptrs[0]).mgData->Axf)).values[i] = sum;
                      }) |
        stdexec::bulk(stdexec::par, ((*matrix_ptrs[0])).mgData->rc->localLength,
                      [&](int i) {
                        double *Axfv = ((*matrix_ptrs[0])).mgData->Axf->values;
                        double *rfv = ((*res_ptrs[0])).values;
                        double *rcv = ((*matrix_ptrs[0])).mgData->rc->values;
                        local_int_t *f2c =
                            ((*matrix_ptrs[0])).mgData->f2cOperator;
                        rcv[i] = rfv[f2c[i]] - Axfv[f2c[i]];
                      }) |
        then([&]() {
          matrixDiagonal = ((*matrix_ptrs[1])).matrixDiagonal;
          rv = ((*res_ptrs[1])).values;
          xv = ((*zval_ptrs[1])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[1])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[1])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[1])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[1])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[1])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[1])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          matrixDiagonal = ((*matrix_ptrs[1])).matrixDiagonal;
          rv = ((*res_ptrs[1])).values;
          xv = ((*zval_ptrs[1])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[1])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[1])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[1])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[1])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[1])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[1])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          matrixDiagonal = ((*matrix_ptrs[1])).matrixDiagonal;
          rv = ((*res_ptrs[1])).values;
          xv = ((*zval_ptrs[1])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[1])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[1])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[1])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[1])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[1])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[1])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
        }) |
        stdexec::bulk(stdexec::par, ((*matrix_ptrs[1])).localNumberOfRows,
                      [&](local_int_t i) {
                        double sum = 0.0;
                        double *cur_vals = ((*matrix_ptrs[1])).matrixValues[i];
                        local_int_t *cur_inds = ((*matrix_ptrs[1])).mtxIndL[i];
                        int cur_nnz = ((*matrix_ptrs[1])).nonzerosInRow[i];
                        double *xv = ((*zval_ptrs[1])).values;
                        for (int j = 0; j < cur_nnz; j++)
                          sum += cur_vals[j] * xv[cur_inds[j]];
                        (*((*matrix_ptrs[1]).mgData->Axf)).values[i] = sum;
                      }) |
        stdexec::bulk(stdexec::par, ((*matrix_ptrs[1])).mgData->rc->localLength,
                      [&](int i) {
                        double *Axfv = ((*matrix_ptrs[1])).mgData->Axf->values;
                        double *rfv = ((*res_ptrs[1])).values;
                        double *rcv = ((*matrix_ptrs[1])).mgData->rc->values;
                        local_int_t *f2c =
                            ((*matrix_ptrs[1])).mgData->f2cOperator;
                        rcv[i] = rfv[f2c[i]] - Axfv[f2c[i]];
                      }) |
        then([&]() {
          matrixDiagonal = ((*matrix_ptrs[2])).matrixDiagonal;
          rv = ((*res_ptrs[2])).values;
          xv = ((*zval_ptrs[2])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[2])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[2])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[2])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[2])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[2])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[2])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          matrixDiagonal = ((*matrix_ptrs[2])).matrixDiagonal;
          rv = ((*res_ptrs[2])).values;
          xv = ((*zval_ptrs[2])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[2])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[2])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[2])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[2])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[2])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[2])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          matrixDiagonal = ((*matrix_ptrs[2])).matrixDiagonal;
          rv = ((*res_ptrs[2])).values;
          xv = ((*zval_ptrs[2])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[2])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[2])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[2])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[2])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[2])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[2])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
        }) |
        stdexec::bulk(stdexec::par, ((*matrix_ptrs[2])).localNumberOfRows,
                      [&](local_int_t i) {
                        double sum = 0.0;
                        double *cur_vals = ((*matrix_ptrs[2])).matrixValues[i];
                        local_int_t *cur_inds = ((*matrix_ptrs[2])).mtxIndL[i];
                        int cur_nnz = ((*matrix_ptrs[2])).nonzerosInRow[i];
                        double *xv = ((*zval_ptrs[2])).values;
                        for (int j = 0; j < cur_nnz; j++)
                          sum += cur_vals[j] * xv[cur_inds[j]];
                        (*((*matrix_ptrs[2]).mgData->Axf)).values[i] = sum;
                      }) |
        stdexec::bulk(stdexec::par, ((*matrix_ptrs[2])).mgData->rc->localLength,
                      [&](int i) {
                        double *Axfv = ((*matrix_ptrs[2])).mgData->Axf->values;
                        double *rfv = ((*res_ptrs[2])).values;
                        double *rcv = ((*matrix_ptrs[2])).mgData->rc->values;
                        local_int_t *f2c =
                            ((*matrix_ptrs[2])).mgData->f2cOperator;
                        rcv[i] = rfv[f2c[i]] - Axfv[f2c[i]];
                      }) |
        stdexec::bulk(stdexec::par, (*matrix_ptrs[3]).localNumberOfRows,
                      [&](local_int_t i) {
                        double sum = 0.0;
                        double *cur_vals = (*matrix_ptrs[3]).matrixValues[i];
                        local_int_t *cur_inds = (*matrix_ptrs[3]).mtxIndL[i];
                        int cur_nnz = (*matrix_ptrs[3]).nonzerosInRow[i];
                        double *xv = (*res_ptrs[3]).values;
                        for (int j = 0; j < cur_nnz; j++)
                          sum += cur_vals[j] * xv[cur_inds[j]];
                        (*zval_ptrs[3]).values[i] = sum;
                      }) |
        stdexec::bulk(stdexec::par, ((*matrix_ptrs[2])).mgData->rc->localLength,
                      [&](int i) {
                        double *xfv = ((*zval_ptrs[2])).values;
                        double *xcv = ((*matrix_ptrs[2])).mgData->xc->values;
                        local_int_t *f2c =
                            ((*matrix_ptrs[2])).mgData->f2cOperator;
                        xfv[f2c[i]] += xcv[i];
                      }) |
        then([&]() {
          matrixDiagonal = ((*matrix_ptrs[2])).matrixDiagonal;
          rv = ((*res_ptrs[2])).values;
          xv = ((*zval_ptrs[2])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[2])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[2])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[2])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[2])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[2])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[2])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          matrixDiagonal = ((*matrix_ptrs[2])).matrixDiagonal;
          rv = ((*res_ptrs[2])).values;
          xv = ((*zval_ptrs[2])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[2])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[2])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[2])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[2])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[2])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[2])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          matrixDiagonal = ((*matrix_ptrs[2])).matrixDiagonal;
          rv = ((*res_ptrs[2])).values;
          xv = ((*zval_ptrs[2])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[2])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[2])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[2])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[2])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[2])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[2])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
        }) |
        stdexec::bulk(stdexec::par, ((*matrix_ptrs[1])).mgData->rc->localLength,
                      [&](int i) {
                        double *xfv = ((*zval_ptrs[1])).values;
                        double *xcv = ((*matrix_ptrs[1])).mgData->xc->values;
                        local_int_t *f2c =
                            ((*matrix_ptrs[1])).mgData->f2cOperator;
                        xfv[f2c[i]] += xcv[i];
                      }) |
        then([&]() {
          matrixDiagonal = ((*matrix_ptrs[1])).matrixDiagonal;
          rv = ((*res_ptrs[1])).values;
          xv = ((*zval_ptrs[1])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[1])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[1])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[1])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[1])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[1])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[1])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          matrixDiagonal = ((*matrix_ptrs[1])).matrixDiagonal;
          rv = ((*res_ptrs[1])).values;
          xv = ((*zval_ptrs[1])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[1])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[1])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[1])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[1])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[1])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[1])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          matrixDiagonal = ((*matrix_ptrs[1])).matrixDiagonal;
          rv = ((*res_ptrs[1])).values;
          xv = ((*zval_ptrs[1])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[1])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[1])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[1])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[1])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[1])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[1])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
        }) |
        stdexec::bulk(stdexec::par, ((*matrix_ptrs[0])).mgData->rc->localLength,
                      [&](int i) {
                        double *xfv = ((*zval_ptrs[0])).values;
                        double *xcv = ((*matrix_ptrs[0])).mgData->xc->values;
                        local_int_t *f2c =
                            ((*matrix_ptrs[0])).mgData->f2cOperator;
                        xfv[f2c[i]] += xcv[i];
                      }) |
        then([&]() {
          matrixDiagonal = ((*matrix_ptrs[0])).matrixDiagonal;
          rv = ((*res_ptrs[0])).values;
          xv = ((*zval_ptrs[0])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[0])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[0])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[0])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[0])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[0])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[0])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          matrixDiagonal = ((*matrix_ptrs[0])).matrixDiagonal;
          rv = ((*res_ptrs[0])).values;
          xv = ((*zval_ptrs[0])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[0])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[0])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[0])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[0])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[0])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[0])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          matrixDiagonal = ((*matrix_ptrs[0])).matrixDiagonal;
          rv = ((*res_ptrs[0])).values;
          xv = ((*zval_ptrs[0])).values;
          for (local_int_t i = 0; i < nrow; i++) {
            const double *const currentValues =
                ((*matrix_ptrs[0])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[0])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[0])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
          for (local_int_t i = nrow - 1; i >= 0; i--) {
            const double *const currentValues =
                ((*matrix_ptrs[0])).matrixValues[i];
            const local_int_t *const currentColIndices =
                ((*matrix_ptrs[0])).mtxIndL[i];
            const int currentNumberOfNonzeros =
                ((*matrix_ptrs[0])).nonzerosInRow[i];
            const double currentDiagonal = matrixDiagonal[i][0];
            double sum = rv[i];
            for (int j = 0; j < currentNumberOfNonzeros; j++) {
              local_int_t curCol = currentColIndices[j];
              sum -= currentValues[j] * xv[curCol];
            }
            sum += xv[i] * currentDiagonal;
            xv[i] = sum / currentDiagonal;
          }
        }) |
        then([&]() { t5 += mytimer() - t0; }) | then([&]() { oldrtz = rtz; }) |
        then([&]() { dot_local_result = 0.0; }) |
        bulk(stdexec::par, nrow,
             [&](local_int_t i) {
               dot_local_result.fetch_add((r).values[i] * (z).values[i],
                                          std::memory_order_relaxed);
             }) |
        then([&]() { (rtz) = dot_local_result.load(); }) |
        then([&]() { beta = rtz / oldrtz; })

        | bulk(stdexec::par, nrow,
               [&](local_int_t i) {
                 (p).values[i] = (1) * (z).values[i] + (beta) * (p).values[i];
               })

        | stdexec::bulk(stdexec::par, (A).localNumberOfRows,
                        [&](local_int_t i) {
                          double sum = 0.0;
                          double *cur_vals = (A).matrixValues[i];
                          local_int_t *cur_inds = (A).mtxIndL[i];
                          int cur_nnz = (A).nonzerosInRow[i];
                          double *xv = (p).values;
                          for (int j = 0; j < cur_nnz; j++)
                            sum += cur_vals[j] * xv[cur_inds[j]];
                          (Ap).values[i] = sum;
                        }) |
        then([&]() { dot_local_result = 0.0; }) |
        bulk(stdexec::par, nrow,
             [&](local_int_t i) {
               dot_local_result.fetch_add((p).values[i] * (Ap).values[i],
                                          std::memory_order_relaxed);
             }) |
        then([&]() { (pAp) = dot_local_result.load(); }) |
        then([&]() { alpha = rtz / pAp; })

        | bulk(stdexec::par, nrow,
               [&](local_int_t i) {
                 (x).values[i] = (1) * (x).values[i] + (alpha) * (p).values[i];
               })

        |
        bulk(stdexec::par, nrow,
             [&](local_int_t i) {
               (r).values[i] = (1) * (r).values[i] + (-alpha) * (Ap).values[i];
             }) |
        then([&]() { dot_local_result = 0.0; }) |
        bulk(stdexec::par, nrow,
             [&](local_int_t i) {
               dot_local_result.fetch_add((r).values[i] * (r).values[i],
                                          std::memory_order_relaxed);
             }) |
        then([&]() { (normr) = dot_local_result.load(); }) |
        then([&]() { normr = sqrt(normr); }) | then([&]() { niters = k; });

    stdexec::sync_wait(std::move(subsequent_loop));
  }

  sender auto store_times = schedule(scheduler) | then([&]() {
                              times[1] += t1;
                              times[2] += t2;
                              times[3] += t3;
                              times[4] += t4;
                              times[5] += t5;

                              times[0] += mytimer() - t_begin;
                            });

  stdexec::sync_wait(std::move(store_times));

  return 0;
}
